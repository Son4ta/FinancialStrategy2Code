[
    {
        "text": "# 阿尔法 (Alpha / α)\n\n## 定义\n阿尔法是衡量投资组合相对于其基准（如 S&P 500 指数）表现的指标。它表示了投资策略产生超额回报的能力。\n\n## 解释\n- **正 Alpha (α > 0)**: 表示投资组合的表现优于其基准回报率。例如，如果基准指数上涨了10%，而您的投资组合上涨了15%，那么多出来的5%就是正 Alpha，代表了基金经理或交易策略的附加价值。\n- **零 Alpha (α = 0)**: 表示投资组合的表现与基准相符。\n- **负 Alpha (α < 0)**: 表示投资组合的表现不及基准。\n\n## 计算公式\n$$ \\alpha = R_p - [R_f + \\beta \\times (R_m - R_f)] $$\n\n其中：\n- $R_p$ = 投资组合的实际回报率\n- $R_m$ = 市场基准回报率\n- $R_f$ = 无风险利率\n- $\\beta$ = 投资组合的贝塔系数\n\n简单来说，Alpha 就是投资的实际回报率与预期回报率之间的差额。它是主动投资策略追求的核心目标。\n\n# 贝塔 (Beta / β)\n\n## 定义\n贝塔衡量的是一项资产或投资组合相对于整个",
        "source": "knowledge.txt"
    },
    {
        "text": "核心目标。\n\n# 贝塔 (Beta / β)\n\n## 定义\n贝塔衡量的是一项资产或投资组合相对于整个市场的系统性风险（波动性）。它表示当市场整体上涨或下跌1%时，该资产预期会上涨或下跌的百分比。\n\n## 解释\n- **Beta = 1**: 表示资产的波动性与市场完全相同。如果市场上涨10%，该资产也倾向于上涨10%。\n- **Beta > 1**: 表示资产的波动性大于市场。例如，Beta 为 1.2 的股票，当市场上涨10%时，它倾向于上涨12%。这类资产通常风险和潜在回报都更高。\n- **Beta < 1**: 表示资产的波动性小于市场。例如，Beta 为 0.8 的公用事业股票，当市场上涨10%时，它可能只上涨8%。这类资产通常被认为是防御性的。\n- **Beta = 0**: 表示资产的波动与市场无关，例如现金或国库券。\n- **Beta < 0**: 表示资产与市场呈负相关。当市场下跌时，它反而倾向于上涨，常用于对冲策略（如黄金）。\n\n## 应用\nBeta 是资本资产定价模型 (CAPM) 的核心组成部分，用于计算投资的预期回报率和评估风险。\n\n# 夏普比率 (Sharpe Ratio)\n\n## ",
        "source": "knowledge.txt"
    },
    {
        "text": "成部分，用于计算投资的预期回报率和评估风险。\n\n# 夏普比率 (Sharpe Ratio)\n\n## 定义\n夏普比率是由诺贝尔奖得主威廉·夏普提出的，是衡量风险调整后回报的核心指标。它表示投资者每多承担一单位的总风险（以标准差衡量），可以获得多少超额回报。\n\n## 解释\n夏普比率越高，说明投资组合在承担相同风险的情况下，回报率越高，或者在获得相同回报的情况下，风险越低。因此，它是评估投资策略优劣的黄金标准之一。\n\n## 计算公式\n$$ \\text{Sharpe Ratio} = \\frac{R_p - R_f}{\\sigma_p} $$\n\n其中：\n- $R_p$ = 投资组合的年化回报率\n- $R_f$ = 年化无风险利率（通常使用国库券利率）\n- $\\sigma_p$ = 投资组合回报率的年化标准差（衡量总风险/波动性）\n\n## 应用\n当比较多个交易策略或基金时，夏普比率提供了一个统一的平台。一个高回报但波动性极大的策略，其夏普比率可能低于一个回报中等但非常稳健的策略。\n\n# 移动平均线 (Moving Average, MA)\n\n## 定义\n移动平均线是一种技术分析工具，通过计算特定时间周期内（如20天、5",
        "source": "knowledge.txt"
    },
    {
        "text": "rage, MA)\n\n## 定义\n移动平均线是一种技术分析工具，通过计算特定时间周期内（如20天、50天、200天）的平均价格，来平滑价格波动，展示价格趋势。\n\n## 类型\n- **简单移动平均线 (Simple Moving Average, SMA)**: 对周期内所有价格取算术平均值。\n- **指数移动平均线 (Exponential Moving Average, EMA)**: 对近期的价格赋予更高的权重，因此对价格变化的反应比 SMA 更快。\n\n## 实现逻辑与应用\n1.  **趋势判断**:\n    - 价格在移动平均线之上，通常被视为上升趋势。\n    - 价格在移动平均线之下，通常被视为下降趋势。\n2.  **交叉信号 (Crossover Signals)**:\n    - **黄金交叉 (Golden Cross)**: 短期均线（如50日线）从下方穿越长期均线（如200日线），被视为强烈的买入信号。\n    - **死亡交叉 (Death Cross)**: 短期均线从上方穿越长期均线，被视为强烈的卖出信号。\n3.  **支撑与阻力**:\n    - 在上升趋势中，移动平均线可以作为动",
        "source": "knowledge.txt"
    },
    {
        "text": "被视为强烈的卖出信号。\n3.  **支撑与阻力**:\n    - 在上升趋势中，移动平均线可以作为动态的支撑位。\n    - 在下降趋势中，移动平均线可以作为动态的阻力位。\n\n# 布林带 (Bollinger Bands)\n\n## 定义\n布林带是由约翰·布林格发明的一种技术分析工具，它由三条线组成：\n1.  **中轨 (Middle Band)**: 通常是一条20期的简单移动平均线 (SMA)。\n2.  **上轨 (Upper Band)**: 中轨 + 两倍标准差。\n3.  **下轨 (Lower Band)**: 中轨 - 两倍标准差。\n\n## 理论基础\n布林带基于统计学原理，价格的波动通常会发生在这两条标准差构成的通道内。它动态地衡量市场的波动性——当市场波动剧烈时，带子会变宽；当市场平静时，带子会收窄。\n\n## 实现逻辑与应用\n1.  **超买超卖信号**:\n    - 价格触及或突破上轨，可能表示市场超买，有回调风险。\n    - 价格触及或跌破下轨，可能表示市场超卖，有反弹机会。\n2.  **波动性判断 (The Squeeze)**:\n    - 当布林带变得非常狭窄时（称为“挤压”），预示着",
        "source": "knowledge.txt"
    },
    {
        "text": "性判断 (The Squeeze)**:\n    - 当布林带变得非常狭窄时（称为“挤压”），预示着市场即将发生剧烈的单向波动。交易者会为即将到来的突破做准备。\n3.  **趋势跟踪**:\n    - 在强劲的上升趋势中，价格会持续沿着上轨运行。\n    - 在强劲的下降趋势中，价格会持续沿着下轨运行。\n\n# 交易策略理论：趋势跟随 (Trend Following)\n\n## 核心理念\n趋势跟随策略的核心假设是“趋势会持续”。它不预测市场的顶部或底部，而是识别已经形成的趋势并顺势而为。“截断亏损，让利润奔跑”（Cut losses, let profits run）是其座右铭。\n\n## 实现逻辑\n1.  **趋势识别**:\n    - 使用技术指标来确定趋势方向。常用指标包括：\n        - **移动平均线 (MA)**: 价格是否持续在长期均线（如200日MA）之上或之下。\n        - **ADX (Average Directional Index)**: 衡量趋势的强度，ADX值高于25通常表示存在明显趋势。\n        - **价格突破**: 价格是否突破了过去N天的高点（做多）或低",
        "source": "knowledge.txt"
    },
    {
        "text": "表示存在明显趋势。\n        - **价格突破**: 价格是否突破了过去N天的高点（做多）或低点（做空），例如著名的“海龟交易法则”。\n2.  **入场信号**:\n    - 当识别到上升趋势时，买入。例如，发生“黄金交叉”。\n    - 当识别到下降趋势时，卖出（做空）。例如，发生“死亡交叉”。\n3.  **退出逻辑**:\n    - **止损**: 严格的止损是关键。通常设置在趋势反转的信号点，例如价格跌破了某个关键的移动平均线，或者使用ATR（平均真实波幅）来设置动态止损位。\n    - **止盈**: 通常不设固定的止盈目标，而是采用“追踪止损”（Trailing Stop），让利润随趋势发展而不断扩大，直到趋势结束的信号出现。\n\n## 优缺点\n- **优点**: 在大的单边行情（牛市或熊市）中能获得巨大利润。逻辑简单，纪律性强。\n- **缺点**: 在震荡行情中会频繁止损，产生连续的小额亏损。胜率通常不高（低于50%），但依靠少数几次大的盈利来覆盖所有亏损。\n\n# 交易策略理论：均值回归 (Mean Reversion)\n\n## 核心理念\n均值回归策略的核心假设是，资产价格或市场指标无论偏离其",
        "source": "knowledge.txt"
    },
    {
        "text": "an Reversion)\n\n## 核心理念\n均值回归策略的核心假设是，资产价格或市场指标无论偏离其长期均值多远，最终都会回归到这个均值。它是一种“反向操作”策略，即“涨多了就卖，跌多了就买”。\n\n## 实现逻辑\n1.  **识别偏离**:\n    - 使用统计工具来衡量价格相对于其历史均值的偏离程度。常用指标包括：\n        - **布林带 (Bollinger Bands)**: 价格触及上轨被视为高估，触及下轨被视为低估。\n        - **相对强弱指数 (RSI)**: RSI > 70 被视为超买（高估），RSI < 30 被视为超卖（低估）。\n        - **统计套利 (Pairs Trading)**: 寻找两支价格走势高度相关的股票，当它们的价差（spread）偏离历史均值时进行交易。\n2.  **入场信号**:\n    - 当资产价格被认定为严重低估时，买入。例如，价格跌破布林带下轨或RSI低于30。\n    - 当资产价格被认定为严重高估时，卖出（做空）。\n3.  **退出逻辑**:\n    - **止盈**: 当价格回归到其均值时平仓。例如，价格回到布林带中轨。\n  ",
        "source": "knowledge.txt"
    },
    {
        "text": "出逻辑**:\n    - **止盈**: 当价格回归到其均值时平仓。例如，价格回到布林带中轨。\n    - **止损**: 如果价格没有回归，反而继续向偏离方向发展，必须设置止损位以控制风险。\n\n## 优缺点\n- **优点**: 在震荡行情或盘整市场中表现优异，交易机会多，胜率通常较高。\n- **缺点**: 在强劲的单边趋势行情中是致命的，可能会因为过早地“抄底”或“摸顶”而导致巨大亏损。所谓的“趋势是你的朋友”，但却是均值回归的天敌。",
        "source": "knowledge.txt"
    },
    {
        "text": "[\n\n    \"strategy_1\",\n    \"python\\n\\nfrom web3 import Web3\\nimport json\\nimport time\\nimport urllib.request\\n\\ndef transaction(my_address, to_address, contract_address, private_key, send, gas):\\n    Log(\\\"start trans \\\" + contract_coin)\\n    bsc = \\\"https://bsc-dataseed.binance.org/\\\"\\n    web3 = Web3(Web3.HTTPProvider(bsc))\\n\\n    Log(web3.isConnected())\\n\\n    balance = web3.eth.get_balance(my_address)\\n    humanReadalbe = web3.fromWei(balance, 'ether')\\n    Log(humanReadalbe)\\n\\n    abi = json.loads('[{\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  Log(humanReadalbe)\\n\\n    abi = json.loads('[{\\\"constant\\\":true,\\\"inputs\\\":[],\\\"name\\\":\\\"name\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"string\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":false,\\\"inputs\\\":[{\\\"name\\\":\\\"spender\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"tokens\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"approve\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"success\\\",\\\"type\\\":\\\"bool\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "le\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[],\\\"name\\\":\\\"totalSupply\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":false,\\\"inputs\\\":[{\\\"name\\\":\\\"from\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"to\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"tokens\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"transferFrom\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"success\\\",\\\"type\\\":\\\"bool\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"func",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[],\\\"name\\\":\\\"decimals\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint8\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[],\\\"name\\\":\\\"_totalSupply\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"tokenOwner\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"balanceOf\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ner\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"balanceOf\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"balance\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[],\\\"name\\\":\\\"symbol\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"string\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"safeSub\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"c\\\",\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"name\\\":\\\"safeSub\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"c\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"pure\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":false,\\\"inputs\\\":[{\\\"name\\\":\\\"to\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"tokens\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"transfer\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"success\\\",\\\"type\\\":\\\"bool\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"uint25",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"safeDiv\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"c\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"pure\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"safeMul\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"c\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"pure\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"tokenOwner\\\",\\\"type",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"tokenOwner\\\",\\\"type\\\":\\\"address\\\"},{\\\"name\\\":\\\"spender\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"allowance\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"remaining\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"constant\\\":true,\\\"inputs\\\":[{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"safeAdd\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"c\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"pure\\\",\\\"type\\\":\\\"function\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",\\\"stateMutability\\\":\\\"pure\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"constructor\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":true,\\\"name\\\":\\\"from\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":true,\\\"name\\\":\\\"to\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"name\\\":\\\"tokens\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"Transfer\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":true,\\\"name\\\":\\\"tokenOwner\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":true",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "kenOwner\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":true,\\\"name\\\":\\\"spender\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"name\\\":\\\"tokens\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"Approval\\\",\\\"type\\\":\\\"event\\\"}]')\\n\\n    nonce = web3.eth.getTransactionCount(my_address)\\n\\n    contract_address = web3.toChecksumAddress(contract_address)\\n    contract = web3.eth.contract(address=contract_address, abi=abi)\\n\\n    amount = web3.toWei(send, 'ether')\\n    Log(amount)\\n\\n    token_tx = contract.functions.transfer(to_address, am",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "en_tx = contract.functions.transfer(to_address, amount).buildTransaction({\\n        'chainId':56, 'gas': 150000,'gasPrice': web3.toWei(gas,'gwei'), 'nonce':nonce\\n    })\\n    sign_txn = web3.eth.account.signTransaction(token_tx, private_key=private_key)\\n    web3.eth.sendRawTransaction(sign_txn.rawTransaction)\\n    Log(\\\"Transaction has been sent to \\\" + to_address)\\n\\ndef transaction_bnb(my_address, to_address, private_key, send, gas):\\n    Log(\\\"start trans \\\" + contract_coin)\\n    bsc = \\\"https://bsc-dat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s \\\" + contract_coin)\\n    bsc = \\\"https://bsc-dataseed.binance.org/\\\"\\n    web3 = Web3(Web3.HTTPProvider(bsc))\\n\\n    Log(web3.isConnected())\\n\\n    balance = web3.eth.get_balance(my_address)\\n    humanReadalbe = web3.fromWei(balance, 'ether')\\n    Log(humanReadalbe)\\n\\n    nonce = web3.eth.getTransactionCount(my_address)\\n\\n    tx = {\\n        'nonce': nonce,\\n        'to': to_address,\\n        'value': web3.toWei(send, 'ether'),\\n        'gas': 150000,\\n        'gasPrice': web3.toWei(gas, 'gwei')\\n    }\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       'gasPrice': web3.toWei(gas, 'gwei')\\n    }\\n\\n    try:\\n        signed_tx = web3.eth.account.signTransaction(tx, private_key)\\n        tx_hash = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\\n        trans = web3.toHex(tx_hash)\\n        Log(trans)\\n        transaction = web3.eth.get_transaction(trans)\\n        Log(\\\"get \\\" + trans + \\\" status!!\\\")\\n    except IOError:\\n        Sleep(100)\\n        signed_tx = web3.eth.account.signTransaction(tx, private_key)\\n        tx_hash = web3.eth.sendRaw",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", private_key)\\n        tx_hash = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\\n        trans = web3.toHex(tx_hash)\\n        Log(\\\"get hash error retry!!\\\")\\n        transaction = web3.eth.get_transaction(trans)\\n        Log(\\\"get \\\" + trans + \\\" status!!\\\")\\n    else:\\n        trans_reslut = web3.eth.waitForTransactionReceipt(tx_hash, timeout=30, poll_latency=0.1)\\n        trans_reslut = web3.toJSON(trans_reslut)\\n        Log(trans_reslut)\\n        trans_reslut_status = json.loads(trans_reslut)['s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " trans_reslut_status = json.loads(trans_reslut)['status']\\n        Log(trans_reslut_status)\\n        if trans_reslut_status == 0:\\n            Log(\\\"trans failed retry!!\\\")\\n            transaction_bnb(my_address, to_address, private_key, send, gas)\\n\\n\\ndef doAction():\\n    Log(\\\"Start trasaction!!!\\\")\\n    if contract_coin != 'BNB':\\n        transaction(my_address, to_address, contract_address, private_key, send, gas)\\n    else:\\n        transaction_bnb(my_address, to_address, private_key, send, gas)\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_address, to_address, private_key, send, gas)\\n    pass\\n    Log(\\\"trasaction Done!!!\\\")\\n\\ndef main():\\n    LogReset()\\n    while 1:\\n        if time.time() > transaction_time:\\n            Log(\\\"Is time to gogogo !!!\\\")\\n            Log(_D(time.time()))\\n            doAction()\\n            exit(\\\"End!!!\\\")\\n        pass\",\n    \"策略名称: BSC-Transaction\\n\\n未找到描述\"\n \n\n    \"strategy_2\",\n    \"python\\n# encoding: utf-8\\n\\nimport os\\nfrom time import time, sleep\\nfrom threading import Thread\\nfrom socket import sock",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "m threading import Thread\\nfrom socket import socket, AF_INET, SOCK_DGRAM, gethostname, timeout, error\\n\\nprct = 0.1\\npassword = 'test888'\\nreq = {}\\npos = {}\\nrecv = True\\ndata = ''\\nn=60 #减数触发器，减到零触发\\n\\ndef trade(req):\\n    \\\"\\\"\\\"测试交易\\\"\\\"\\\"\\n    for symbol, mpos in req.items():\\n        if symbol not in pos.keys():\\n            pos[symbol] = 0.0\\n        targetPos=round(mpos*prct, 4)\\n        Log('targetPos =', targetPos)\\n        if targetPos == pos[symbol]:\\n            #Log(\\\"No Trade Operation! client",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l]:\\n            #Log(\\\"No Trade Operation! client Pos %s is %.3f\\\" % (symbol, pos[symbol]))\\n            continue\\n        tick = exchange.GetTicker();\\n        if targetPos > pos[symbol]:\\n            vol = round(targetPos-pos[symbol], 4)\\n            type = 'buy-market'\\n            #Log(' Buy btcusdt', vol)\\n            id = exchange.Buy(tick.Sell+10, vol)\\n            #Log(' Buy btcusdt at %s = %s' %(tick.Sell, vol))\\n            Log(\\\"Order id:\\\", id);\\n        elif targetPos < pos[symbol]:\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        elif targetPos < pos[symbol]:\\n            vol = round(pos[symbol]-targetPos, 4)\\n            type = 'sell-market'\\n            #Log(' Sell btcusdt', vol)\\n            id = exchange.Sell(-1, vol)\\n            #Log(' Sell btcusdt at %s = %s' %(tick.Buy, vol))\\n            Log(\\\"Order id:\\\", id);\\n        \\n        account = exchange.GetAccount()\\n        Log(\\\"账户信息，Balance:\\\", account.Balance, \\\"FrozenBalance:\\\", account.FrozenBalance, \\\"Stocks:\\\",\\n        account.Stocks, \\\"FrozenStocks:\\\", accoun",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        account.Stocks, \\\"FrozenStocks:\\\", account.FrozenStocks)\\n        pos[symbol] = round(account.Stocks, 4)\\n        Log('Now Client %s POS = %s' % (symbol, pos[symbol]))\\n        \\nclass recServer(object):\\n    \\\"\\\"\\\"recServer is receving Signal from SigServer\\\"\\\"\\\"\\n    def __init__(self, c):\\n        self.rcv = True\\n        self.t = Thread(target = self.recSig, args = (c,))\\n        self.t.start()\\n        \\n    def recSig(self, c):\\n        while self.rcv:\\n            try:\\n                data,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "self.rcv:\\n            try:\\n                data, addr = c.recvfrom(1024)\\n                #Log('n=',n)\\n            except timeout:\\n                continue\\n            except error:\\n                msg = traceback.format_exc()\\n                Log(msg)\\n                continue\\n            if data == 'ok':        \\n                #Log('SigServer is alive! Receving \\\"ok\\\" from', addr)\\n                pass\\n            elif 'send password' in data:\\n                Log('The client not login, press an",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               Log('The client not login, press any key to exit and restart!')\\n                self.rcv = False\\n            elif not data:\\n                Log(\\\"SigServer is stopped, press any Key to exit SigClient!\\\")\\n                self.rcv = False\\n            else:\\n                try:\\n                    c.sendto('ack', addr)\\n                    Log('send ack to ', addr)\\n                except error:\\n                    Log('Send ack error!')\\n                    \\n                req = eval(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                    \\n                req = eval(data)\\n                Log(req, 'from', addr)\\n                trade(req)\\n        else:\\n            Log('RecSig Thread is Exiting...')\\n        return None\\n            \\n    def heart(self, c, ADDR):      \\n        try:\\n            c.sendto('live', ADDR)\\n        except error:\\n            Log('Send keepAlive error!')\\n            return None\\n                    \\n    def close(self):\\n        self.rcv = False\\n        self.t.join()   \\n\\ndef main():\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " False\\n        self.t.join()   \\n\\ndef main():\\n    account = exchange.GetAccount()\\n    Log(\\\"账户信息，Balance:\\\", account.Balance, \\\"FrozenBalance:\\\", account.FrozenBalance, \\\"Stocks:\\\",\\n        account.Stocks, \\\"FrozenStocks:\\\", account.FrozenStocks)\\n    pos['btcusdt'] = round(account.Stocks, 4)\\n    Log(pos)\\n    # 启动UDP客户端\\n    c = socket(AF_INET, SOCK_DGRAM)\\n    host = '47.98.130.139'\\n    port = 1234\\n    ADDR = (host, port)\\n    c.settimeout(5)\\n    try:\\n        c.sendto(password, ADDR)\\n        da",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "try:\\n        c.sendto(password, ADDR)\\n        data, addr = c.recvfrom(256)\\n        Log(data+' from ', addr)\\n    except timeout, error:\\n        Log('SigServer is not active, client is aborting!')\\n        c.close()\\n        return None         \\n    if 'invalid' in data:\\n        Log('\\\\nYou failed to Login! SigClient is Exiting...')\\n        c.close()\\n        return None\\n\\n    # 如果密码正确，开启接收信号模式\\n    rc = recServer(c)       \\n    sleep(1)\\n    global n\\n    while recv:\\n        n -= 1\\n        if not ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    while recv:\\n        n -= 1\\n        if not n:\\n            rc.heart(c, ADDR)\\n            account = exchange.GetAccount()\\n            pos['btcusdt'] = round(account.Stocks, 4)\\n            #Log(pos)\\n            n = 60\\n        sleep(1)\\n    else:\\n        rc.close()\\n        Log('Program is End!')\",\n    \"策略名称: BTC-V反策略\\n\\nimport os\\nfrom time import time, sleep\\nfrom threading import Thread\\nfrom socket import socket, AF_INET, SOCK_DGRAM, gethostname, timeout, error\\n\\nprct = 0.1\\npassword = 'test8",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e, timeout, error\\n\\nprct = 0.1\\npassword = 'test888'\\nreq = {}\\npos = {}\\nrecv = True\\ndata = ''\\nn=60 #减数触发器，减到零触发\\n\\ndef trade(req):\\n    \\\"\\\"\\\"测试交易\\\"\\\"\\\"\\n    for symbol, mpos in req.items():\\n        if symbol not in pos.keys():\\n            pos[symbol] = 0.0\\n        targetPos=round(mpos*prct, 4)\\n        Log('targetPos =', targetPos)\\n        if targetPos == pos[symbol]:\\n            #Log(\\\"No Trade Operation! client Pos %s is %.3f\\\" % (symbol, pos[symbol]))\\n            continue\\n        tick = exch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mbol]))\\n            continue\\n        tick = exchange.GetTicker();\\n        if targetPos > pos[symbol]:\\n            vol = round(targetPos-pos[symbol], 4)\\n            type = 'buy-market'\\n            #Log(' Buy btcusdt', vol)\\n            id = exchange.Buy(tick.Sell+10, vol)\\n            #Log(' Buy btcusdt at %s = %s' %(tick.Sell, vol))\\n            Log(\\\"Order id:\\\", id);\\n        elif targetPos < pos[symbol]:\\n            vol = round(pos[symbol]-targetPos, 4)\\n            type = 'sell-market'\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s, 4)\\n            type = 'sell-market'\\n            #Log(' Sell btcusdt', vol)\\n            id = exchange.Sell(-1, vol)\\n            #Log(' Sell btcusdt at %s = %s' %(tick.Buy, vol))\\n            Log(\\\"Order id:\\\", id);\\n        \\n        account = exchange.GetAccount()\\n        Log(\\\"账户信息，Balance:\\\", account.Balance, \\\"FrozenBalance:\\\", account.FrozenBalance, \\\"Stocks:\\\",\\n        account.Stocks, \\\"FrozenStocks:\\\", account.FrozenStocks)\\n        pos[symbol] = round(account.Stocks, 4)\\n        Log('Now Cli",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "] = round(account.Stocks, 4)\\n        Log('Now Client %s POS = %s' % (symbol, pos[symbol]))\\n        \\nclass recServer(object):\\n    \\\"\\\"\\\"recServer is receving Signal from SigServer\\\"\\\"\\\"\\n    def __init__(self, c):\\n        self.rcv = True\\n        self.t = Thread(target = self.recSig, args = (c,))\\n        self.t.start()\\n        \\n    def recSig(self, c):\\n        while self.rcv:\\n            try:\\n                data, addr = c.recvfrom(1024)\\n                #Log('n=',n)\\n            except timeout:\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       #Log('n=',n)\\n            except timeout:\\n                continue\\n            except error:\\n                msg = traceback.format_exc()\\n                Log(msg)\\n                continue\\n            if data == 'ok':        \\n                #Log('SigServer is alive! Receving \\\"ok\\\" from', addr)\\n                pass\\n            elif 'send password' in data:\\n                Log('The client not login, press any key to exit and restart!')\\n                self.rcv = False\\n            elif not ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           self.rcv = False\\n            elif not data:\\n                Log(\\\"SigServer is stopped, press any Key to exit SigClient!\\\")\\n                self.rcv = False\\n            else:\\n                try:\\n                    c.sendto('ack', addr)\\n                    Log('send ack to ', addr)\\n                except error:\\n                    Log('Send ack error!')\\n                    \\n                req = eval(data)\\n                Log(req, 'from', addr)\\n                trade(req)\\n        el",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "om', addr)\\n                trade(req)\\n        else:\\n            Log('RecSig Thread is Exiting...')\\n        return None\\n            \\n    def heart(self, c, ADDR):      \\n        try:\\n            c.sendto('live', ADDR)\\n        except error:\\n            Log('Send keepAlive error!')\\n            return None\\n                    \\n    def close(self):\\n        self.rcv = False\\n        self.t.join()   \\n\\ndef main():\\n    account = exchange.GetAccount()\\n    Log(\\\"账户信息，Balance:\\\", account.Balance, \\\"Fro",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    Log(\\\"账户信息，Balance:\\\", account.Balance, \\\"FrozenBalance:\\\", account.FrozenBalance, \\\"Stocks:\\\",\\n        account.Stocks, \\\"FrozenStocks:\\\", account.FrozenStocks)\\n    pos['btcusdt'] = round(account.Stocks, 4)\\n    Log(pos)\\n    # 启动UDP客户端\\n    c = socket(AF_INET, SOCK_DGRAM)\\n    host = '47.98.130.139'\\n    port = 1234\\n    ADDR = (host, port)\\n    c.settimeout(5)\\n    try:\\n        c.sendto(password, ADDR)\\n        data, addr = c.recvfrom(256)\\n        Log(data+' from ', addr)\\n    except timeout, err",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " Log(data+' from ', addr)\\n    except timeout, error:\\n        Log('SigServer is not active, client is aborting!')\\n        c.close()\\n        return None         \\n    if 'invalid' in data:\\n        Log('\\\\nYou failed to Login! SigClient is Exiting...')\\n        c.close()\\n        return None\\n\\n    # 如果密码正确，开启接收信号模式\\n    rc = recServer(c)       \\n    sleep(1)\\n    global n\\n    while recv:\\n        n -= 1\\n        if not n:\\n            rc.heart(c, ADDR)\\n            account = exchange.GetAccount()\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            account = exchange.GetAccount()\\n            pos['btcusdt'] = round(account.Stocks, 4)\\n            #Log(pos)\\n            n = 60\\n        sleep(1)\\n    else:\\n        rc.close()\\n        Log('Program is End!')\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/117202\\n\\n> Last Modified\\n\\n2018-09-27 21:45:01\"\n \n\n    \"strategy_3\",\n    \"python\\nfrom okex.trade import trade,pos_info,acc_info,select_last\\nimport okex.api as api\\nimport okex.Trade_api as Trade\\nimport time\\nimport json\\nfrom okex.log ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "as Trade\\nimport time\\nimport json\\nfrom okex.log import log\\n\\n# 策略源码完整版下载地址 https://github.com/Find-Dream/BTCUSDT\\n\\ndef main():\\n    nowtime = time.time()\\n    st = time.localtime(nowtime)\\n    update = time.strftime('%Y-%m-%d',st)\\n    filenamedate = time.strftime('%Y%m%d',st)\\n    logfilename = 'mark_'+ str(filenamedate)\\n\\n    log(logfilename,'========================【获取基础信息开始】========================')\\n\\n    btcusdt_api_data = api.btcusdt_api()\\n\\n    log(logfilename,'btcusdt_api_data：'+str(btcusdt_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  log(logfilename,'btcusdt_api_data：'+str(btcusdt_api_data))\\n\\n    btcusdt_api = btcusdt_api_data['rule']\\n    log(logfilename,'btcusdt_api'+str(btcusdt_api))\\n\\n    pos_api = btcusdt_api_data['pos']\\n    log(logfilename,'pos_api'+str(pos_api))\\n\\n    pos_okex = {}\\n    acc_okex = {}\\n    try:\\n        acc_api = api.select_acc()\\n        log(logfilename,'读取本地保存的账户信息'+str(acc_api))\\n    except:\\n        acc_okex['lever'] = 1\\n\\n\\n    acc_info_data = acc_info()[0]['details']\\n\\n\\n    for i in acc_info_data:\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "()[0]['details']\\n\\n\\n    for i in acc_info_data:\\n        if i['ccy'] == 'USDT':\\n            acc_okex['ccy'] = i['cashBal']\\n            log(logfilename,'读取接口账户余额'+str(i['cashBal']))\\n\\n    for i in pos_info():\\n        if i['mgnMode'] == 'cross' and i['posSide'] == 'long':\\n            pos_okex['long'] = i['pos']\\n            if i['pos'] != '0':\\n                acc_okex['lever'] = i['lever']\\n                log(logfilename,'读取接口long账户杠杆倍数：'+str(i['lever']))\\n            else:\\n                acc_okex[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "']))\\n            else:\\n                acc_okex['lever'] = acc_api['lever']\\n                log(logfilename,'读取本地long账户杠杆倍数：'+str(acc_api['lever']))\\n        elif i['mgnMode'] == 'cross' and i['posSide'] == 'short':\\n            pos_okex['short'] = i['pos']\\n            if i['pos'] != '0':\\n                acc_okex['lever'] = i['lever']\\n                log(logfilename,'读取接口short账户杠杆倍数：'+str(i['lever']))\\n            \\n\\n    api.set_acc(json.dumps(acc_okex))\\n    log(logfilename,'写入本地账户信息：'+str(acc_okex)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "x))\\n    log(logfilename,'写入本地账户信息：'+str(acc_okex))\\n    last = float(select_last())\\n    log(logfilename,'读取当前价格：'+str(last))\\n\\n    max_sz = int(float(acc_okex['ccy']) * float(acc_okex['lever']) / last * 100)\\n    log(logfilename,'最大交易量：'+str(max_sz))\\n\\n    sz_r = max_sz / 20\\n    log(logfilename,'交易量系数：'+str(sz_r))\\n\\n    pos_api_id = int(btcusdt_api['id'])\\n    pos_api_posSide = btcusdt_api['posside']\\n    pos_api_side = btcusdt_api['side']\\n    pos_api_sz = int(int(btcusdt_api['sz']) * sz_r)\\n    pos_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_sz = int(int(btcusdt_api['sz']) * sz_r)\\n    pos_api_uptime = int(btcusdt_api['uptime'])\\n    pos_api_long = int(int(pos_api['long']) * sz_r)\\n    pos_api_short = int(int(pos_api['short']) * sz_r)\\n\\n    log(logfilename,'pos_api_long：'+str(pos_api_long)+',pos_api_short:'+str(pos_api_short)+',pos_api_sz:'+str(pos_api_sz))\\n    log(logfilename,'本地仓位信息pos_okex：'+str(pos_okex))\\n\\n\\n    try:\\n        pos_log_done = int(api.pos_log_done())\\n    except:\\n        pos_log_done = api.pos_log_done()\\n    \\n    log(l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pos_log_done = api.pos_log_done()\\n    \\n    log(logfilename,'pos_log_done:'+str(pos_log_done))\\n\\n    log(logfilename,'========================【获取基础信息结束】========================')\\n    log(logfilename,'========================【mark任务开始】========================')\\n    log(logfilename,'判断pos_log_done_id是否为int型:'+str(type(pos_log_done)))\\n    if isinstance(pos_log_done,int):\\n        log(logfilename,'pos_log_done_id为int型，判断pos_log_done_id与pos_log_id,pos_api_id:'+str(pos_api_id)+',pos_log_done:'+str(pos_log_do",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":'+str(pos_api_id)+',pos_log_done:'+str(pos_log_done))\\n        if pos_api_id > pos_log_done:\\n            log(logfilename,'API的pos_log_id大于pos_log_done_id，判断API更新时间是否在10秒以内,nowtime:'+str(nowtime)+',pos_api_uptime:'+str(pos_api_uptime))\\n            if nowtime < (pos_api_uptime + 13):\\n                log(logfilename,'api更新时间在10秒内，判断api交易方向,pos_api_posSide'+str(pos_api_posSide)+',pos_api_side:'+str(pos_api_side))\\n                if pos_api_posSide == 'long' and pos_api_side == 'buy':\\n                    l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " and pos_api_side == 'buy':\\n                    log(logfilename,'api交易方向：long-buy，判断当前持仓信息与api是否一致')\\n                    if int(pos_okex['long']) + int(pos_api_sz) == int(pos_api_long):\\n                        log(logfilename,'当前持仓信息与api一致，执行交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\\n                        log(logfilename,'执行结果：'+str(trade_ok))\\n                   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lename,'执行结果：'+str(trade_ok))\\n                    elif int(pos_okex['long']) + int(pos_api_sz) < int(pos_api_long):\\n                        log(logfilename,'当前持仓信息与api一致，执行交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\\n                        log(logfilename,'执行结果：'+str(trade_ok))\\n                    else:\\n                        log(logfilename,'long仓信息不一致，请将long仓手动平仓",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           log(logfilename,'long仓信息不一致，请将long仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_long)+',API交易数量：'+str(pos_api_sz))\\n\\n                elif pos_api_posSide == 'long' and pos_api_side == 'sell':\\n                    log(logfilename,'api交易方向：long-sell，判断是否符合平仓条件')\\n                    if int(pos_okex['long']) > 0:\\n                        log(logfilename,'符合平仓条件，当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n                        trade_ok",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "str(pos_api_sz))\\n                        trade_ok = trade(pos_api_side,pos_api_posSide,int(pos_okex['long']),pos_api_id)\\n                        log(logfilename,'执行结果：'+str(trade_ok))\\n                    else:\\n                        log(logfilename,'long仓信息不一致，请将long仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['long'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n\\n                elif pos_api_posSide == 'short' and pos_api_side == 'sell':\\n                    log(logfilename,'api交易方向：short-sell，判断当",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           log(logfilename,'api交易方向：short-sell，判断当前持仓信息与api是否一致')\\n                    if int(pos_okex['short']) + int(pos_api_sz) == int(pos_api_short):\\n                        log(logfilename,'符合开仓条件，执行交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\\n                        log(logfilename,'执行结果：'+str(trade_ok))\\n                    elif int(pos_okex['short']) + int(pos",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             elif int(pos_okex['short']) + int(pos_api_sz) < int(pos_api_short):\\n                        log(logfilename,'符合开仓条件，执行交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n                        trade_ok = trade(pos_api_side,pos_api_posSide,pos_api_sz,pos_api_id)\\n                        log(logfilename,'执行结果：'+str(trade_ok))\\n                    else:\\n                        log(logfilename,'short仓信息不一致，请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n\\n                elif pos_api_posSide == 'short' and pos_api_side == 'buy':\\n                    log(logfilename,'api交易方向：short-buy，判断是否符合平仓条件')\\n                    if int(pos_okex['short']) > 0:\\n                        log(logfilename,'符合平仓条件，当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n                        trade_ok = trade(pos_api_side,pos_api_posS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        trade_ok = trade(pos_api_side,pos_api_posSide,pos_okex['short'],pos_api_id)\\n                        log(logfilename,'执行结果：'+str(trade_ok))\\n                    else:\\n                        log(logfilename,'short仓信息不一致，请将short仓手动平仓后再进行自动交易,当前持仓：'+str(pos_okex['short'])+',API持仓：'+str(pos_api_short)+',API交易数量：'+str(pos_api_sz))\\n            else:\\n                log(logfilename,'api更新时间超过10秒内，已错过最佳交易时间,nowtime:'+str(nowtime)+',pos_api_uptime:'+str(pos_api_uptime))\\n        else:\\n            log(lo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "os_api_uptime))\\n        else:\\n            log(logfilename,'API的pos_log_id不大于pos_log_done_id，api无新数据，继续执行监控,pos_api_id:'+str(pos_api_id)+',pos_log_done:'+str(pos_log_done))\\n    else:\\n        log(logfilename,'pos_log_done_id不为int型')\\n        api.set_pos_log_done(pos_api_id)\\n    log(logfilename,'========================【mark任务结束】========================')\",\n    \"策略名称: BTCUSDT量化交易执行体\\n\\n- 如果你不是运行在固定IP的云主机上的话，请不要设置绑定IP，否则无法使用；\\n- 为了你的账号安全申请API时，请勾选只读和交易权限，请勿勾选提现权限；\\n- `okex_api.json`中的flag为交易盘选项，0为真实盘，1为模拟盘",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "勾选提现权限；\\n- `okex_api.json`中的flag为交易盘选项，0为真实盘，1为模拟盘；\"\n \n\n    \"strategy_4\",\n    \"python\\n\\n\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n#\\n# BitMEX Advanced API Interface for FMZ.com.\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# GNU General Public License v3.0\\n#\\n\\nimport json\\nimport math\\nimport decimal\\n\\ndef toNearest(num, tickSize):\\n    tickDec = decimal.Decimal(str(tickSize))\\n    return float((decimal.Decimal(round(num / tickSize, 0)) * t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "oat((decimal.Decimal(round(num / tickSize, 0)) * tickDec))\\n\\nQUOTES = {}\\nQUOTES['ZH'] = {\\n    'GREET' : '[BitMEX 接口已初始化]  合约: %s. %s',\\n    'INITF' : '使用的交易所不正确，当前交易所: %s',\\n    'PARAMERR' : '***传的参数不对 检查你的代码*** %s',\\n    'NEWORDER' : '[添加订单]  合约: %s 方向: %s 价格: %.8f 数量: %d 张. %s',\\n    'MODORDER' : '[修改订单]  orderID/clOrdID: %s 新价格: %.8f 新数量: %d. %s',\\n    'MODORDERP' : '[修改订单]  orderID/clOrdID: %s 新价格: %.8f. %s',\\n    'MODORDERA' : '[修改订单]  orderID/clOrdID: %s 新数量: %d. %s',\\n    'ORDCOUNT' : '[本次批量发送订单] ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "D: %s 新数量: %d. %s',\\n    'ORDCOUNT' : '[本次批量发送订单]  总计: %d 条. %s',\\n    'THISBATCH' : '[信息]  正在处理 合约: %s 条数: %d. %s',\\n    'CLEARALL' : '[信息]  已清除所有本地订单. %s',\\n    'CLEAR' : '[信息]  已清除所有 %s 本地订单. %s',\\n    'CA' : '[订单计划取消]  所有订单都将在 %d 毫秒 后取消. %s'\\n}\\n\\nCOLORS = {\\n    'DEEPBLUE' : '#1F618D',\\n    'BLUE' : '#0000FF',\\n    'LIGHTBLUE' : '#5DADE2',\\n    'DEEPGREEN' : '#27AE60',\\n    'GREEN' : '#00FF00',\\n    'LIGHTGREEN' : '#58D68D',\\n    'LAPIS' : '#26619C',\\n    'DEEPRED' : '#CB4335',\\n    'RED' : '#FF0000',\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   'DEEPRED' : '#CB4335',\\n    'RED' : '#FF0000',\\n    'LIGHTRED' : '#EC7063'\\n}\\n\\n\\nclass BitMEX:\\n\\n    def __init__(self, exchange, silent=False):\\n        self.silent = silent\\n        exchange.GetCurrency()\\n        if isinstance(exchange.GetCurrency(), bytes):\\n            self.symbol = str(exchange.GetCurrency(), \\\"utf-8\\\").lower()\\n            name = str(exchange.GetName(), \\\"utf-8\\\")\\n        else:\\n            self.symbol = exchange.GetCurrency()\\n            name = exchange.GetName()\\n        se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            name = exchange.GetName()\\n        self.IO = exchange.IO\\n        self.bulks = []\\n        self.amends = []\\n        if 'BitMEX' in str(name):\\n            self.Log(QUOTES[LANG]['GREET'] % (self.symbol.upper(),COLORS['LAPIS']))\\n        else:\\n            Log(QUOTES[LANG]['INITF'] % (name))\\n            \\n    def Log(self, *args):\\n        if self.silent:\\n            return \\n        Log(*args)\\n\\n    def BulkAdd(self, side=None, price=None, amount=None, symbol=None, ordType='Limit', displayQt",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ount=None, symbol=None, ordType='Limit', displayQty=None, clOrdID=None, execInst=None):\\n        if type is None or price is None or amount is None:\\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\\n            return False\\n        side = side.lower()\\n        if 'sell' in side:\\n            side = 'Sell'\\n            cl = COLORS['DEEPRED']\\n        else:\\n            side = 'Buy'\\n            cl = COLORS['DEEPGREEN']\\n        if symbol is None:\\n            symbol = self.symbol\\n\\n        # Or",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            symbol = self.symbol\\n\\n        # Order structure\\n        order = {}\\n        order['symbol'] = symbol.upper()            # Symbol\\n        order['price'] = price                      # Price\\n        order['side'] = side                        # Buy/Sell\\n        order['orderQty'] = int(amount)             # Amount\\n\\n        # Valid order types\\n        # Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged\\n        # Limit: The default order ty",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mit, Pegged\\n        # Limit: The default order type. Specify an orderQty and price.\\n        # Market: A traditional Market order. A Market order will execute until filled or your bankruptcy price is reached, at which point it will cancel.\\n        # MarketWithLeftOverAsLimit: A market order that, after eating through the order book as far as permitted by available margin, will become a limit order. The difference between this type and Market only affects the behavior in thin books. Upon reaching the deepe",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "he behavior in thin books. Upon reaching the deepest possible price, if there is quantity left over, a Market order will cancel the remaining quantity. MarketWithLeftOverAsLimit will keep the remaining quantity in the books as a Limit.\\n        # Stop: A Stop Market order. Specify an orderQty and stopPx. When the stopPx is reached, the order will be entered into the book.\\n        ## On sell orders, the order will trigger if the triggering price is lower than the stopPx. On buys, higher.\\n        ## Note: S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n the stopPx. On buys, higher.\\n        ## Note: Stop orders do not consume margin until triggered. Be sure that the required margin is available in your account so that it may trigger fully.\\n        ## Close Stops don't require an orderQty. See Execution Instructions below.\\n        # StopLimit: Like a Stop Market, but enters a Limit order instead of a Market order. Specify an orderQty, stopPx, and price.\\n        # MarketIfTouched: Similar to a Stop, but triggers are done in the opposite direction. Usefu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "triggers are done in the opposite direction. Useful for Take Profit orders.\\n        # LimitIfTouched: As above; use for Take Profit Limit orders.\\n        order['ordType'] = ordType\\n        # If you want to keep track of order IDs yourself, set a unique clOrdID per order. This clOrdID will come back as a property on the order and any related executions (including on the WebSocket), and can be used to get or cancel the order. Max length is 36 characters.\\n        if clOrdID is not None:\\n            order[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       if clOrdID is not None:\\n            order['clOrdID'] = clOrdID\\n        # The following execInsts are supported. If using multiple, separate with a comma (e.g. LastPrice,Close).\\n        # ParticipateDoNotInitiate, MarkPrice, LastPrice, IndexPrice, ReduceOnly, Close\\n        # ParticipateDoNotInitiate: Also known as a Post-Only order. If this order would have executed on placement, it will cancel instead.\\n        # MarkPrice, LastPrice, IndexPrice: Used by stop and if-touched orders to determine th",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Used by stop and if-touched orders to determine the triggering price. Use only one. By default, 'MarkPrice' is used. Also used for Pegged orders to define the value of 'LastPeg'.\\n        # ReduceOnly: A 'ReduceOnly' order can only reduce your position, not increase it. If you have a 'ReduceOnly' limit order that rests in the order book while the position is reduced by other orders, then its order quantity will be amended down or canceled. If there are multiple 'ReduceOnly' orders the least aggressive will ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ple 'ReduceOnly' orders the least aggressive will be amended first.\\n        # Close: 'Close' implies 'ReduceOnly'. A 'Close' order will cancel other active limit orders with the same side and symbol if the open quantity exceeds the current position. This is useful for stops: by canceling these orders, a 'Close' Stop is ensured to have the margin required to execute, and can only execute up to the full size of your position. If orderQty is not specified, a 'Close' order has an orderQty equal to your current",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Close' order has an orderQty equal to your current position's size.\\n        ## Note that a Close order without an orderQty requires a side, so that BitMEX knows if it should trigger above or below the stopPx.\\n        if execInst is not None:\\n            order['execInst'] = execInst\\n            if 'Close' in execInst:\\n                del order['orderQty']\\n        # Optional quantity to display in the book. Use 0 for a fully hidden order. (Iceberg Order)\\n        if displayQty is not None:\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        if displayQty is not None:\\n            order['displayQty'] = displayQty\\n\\n        self.bulks.append(order)\\n\\n        self.Log(QUOTES[LANG]['NEWORDER'] % (symbol.upper(),side.upper(),price,amount,cl))\\n\\n        return True\\n\\n    def BulkClear(self, symbol=None, notify=True):\\n        ret = []\\n        if symbol is None:\\n            ret = self.bulks\\n            self.bulks = []\\n            if notify:\\n                self.Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\\n        else:\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ARALL'] % (COLORS['RED']))\\n        else:\\n            new = []\\n            for i in self.bulks:\\n                if i['symbol'] != symbol:\\n                    new.append(i)\\n                else:\\n                    ret.append(i)\\n            self.bulks = new\\n            self.Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), COLORS['RED']))\\n\\n        return ret\\n\\n    def BulkPost(self, symbol=None):\\n        orders = []\\n        if symbol is None:\\n            orders = self.BulkClear(notify=False",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            orders = self.BulkClear(notify=False)\\n        else:\\n            orders = self.BulkClear(symbol=symbol, notify=False)\\n            \\n        if len(orders) == 0:\\n            return True\\n\\n        ret = self.IO(\\\"api\\\", \\\"POST\\\", \\\"/api/v1/order/bulk\\\", 'orders=%s' % json.dumps(orders))\\n\\n        self.Log(QUOTES[LANG]['ORDCOUNT'] % (len(orders),COLORS['LAPIS']))\\n        return ret\\n\\n    def BulkOrders(self):\\n        return self.bulks\\n\\n    def Amend(self, symbol=None, orderID=None, clOr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   def Amend(self, symbol=None, orderID=None, clOrdID=None, price=None, amount=None):\\n        if symbol is None:\\n            symbol = self.symbol\\n\\n        order = {}\\n        order['symbol'] = symbol\\n        if orderID is None:\\n            if clOrdID is None:\\n                Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\\n                return False\\n            else:\\n                order['clOrdID'] = clOrdID\\n        else:\\n            order['orderID'] = orderID\\n\\n        if price is not None:\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "erID'] = orderID\\n\\n        if price is not None:\\n            order['price'] = price\\n        if amount is not None:\\n            order['orderQty'] = amount\\n\\n        if price is None and amount is None:\\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\\n            return False\\n\\n        ret = self.IO(\\\"api\\\", \\\"PUT\\\", \\\"/api/v1/order/bulk\\\", 'orders=%s' % json.dumps([order]))\\n        if ret == False:\\n            return False\\n\\n        try:\\n            id = order['orderID']\\n        excep",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            id = order['orderID']\\n        except:\\n            id = order['clOrdID']\\n\\n        if price is None:\\n            self.Log(QUOTES[LANG]['MODORDERA'] % (id, amount, COLORS['LAPIS']))\\n            return ret\\n        elif amount is None:\\n            self.Log(QUOTES[LANG]['MODORDERP'] % (id, price, COLORS['LAPIS']))\\n            return ret\\n        else:\\n            self.Log(QUOTES[LANG]['MODORDER'] % (id, price, amount, COLORS['LAPIS']))\\n            return ret\\n\\n    def AmendAdd(self, symb",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         return ret\\n\\n    def AmendAdd(self, symbol=None, orderID=None, clOrdID=None, price=None, amount=None):\\n        if symbol is None:\\n            symbol = self.symbol\\n\\n        order = {}\\n        order['symbol'] = symbol\\n        if orderID is None:\\n            if clOrdID is None:\\n                Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\\n                return False\\n            else:\\n                order['clOrdID'] = clOrdID\\n        else:\\n            order['orderID'] = orderID\\n\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "se:\\n            order['orderID'] = orderID\\n\\n        if price is not None:\\n            order['price'] = price\\n        if amount is not None:\\n            order['orderQty'] = amount\\n\\n        if price is None and amount is None:\\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\\n            return False\\n\\n        self.amends.append(order)\\n\\n        try:\\n            id = order['orderID']\\n        except:\\n            id = order['clOrdID']\\n\\n        if price is None:\\n            self.Log(Q",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        if price is None:\\n            self.Log(QUOTES[LANG]['MODORDERA'] % (id, amount, COLORS['LAPIS']))\\n            return True\\n        elif amount is None:\\n            self.Log(QUOTES[LANG]['MODORDERP'] % (id, price, COLORS['LAPIS']))\\n            return True\\n        else:\\n            self.Log(QUOTES[LANG]['MODORDER'] % (id, price, amount, COLORS['LAPIS']))\\n            return True\\n\\n    def AmendClear(self, symbol=None, notify=True):\\n        ret = []\\n        if symbol is None:\\n            ret",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = []\\n        if symbol is None:\\n            ret = self.amends\\n            self.amends = []\\n            if notify:\\n                self.Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\\n        else:\\n            new = []\\n            for i in self.amends:\\n                if i['symbol'] != symbol:\\n                    new.append(i)\\n                else:\\n                    ret.append(i)\\n            self.self.amends = new\\n            self.Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), COLORS[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "LANG]['CLEAR'] % (symbol.encode().upper(), COLORS['RED']))\\n\\n        return ret\\n\\n    def AmendPost(self, symbol=None):\\n        if symbol is None:\\n            symbol = self.symbol\\n        orders = self.AmendClear(symbol=symbol, notify=False)\\n        if len(orders) == 0:\\n            return True\\n        param = \\\"orders=\\\" + json.dumps(orders)\\n        self.Log(QUOTES[LANG]['ORDCOUNT'] % (len(orders),COLORS['LAPIS']))\\n        return self.IO(\\\"api\\\", \\\"PUT\\\", \\\"/api/v1/order/bulk\\\", param)\\n\\n    def ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"PUT\\\", \\\"/api/v1/order/bulk\\\", param)\\n\\n    def AmendOrders(self):\\n        return self.amends\\n\\n    def CancelAllOrders(self, symbol=None, filters=None):\\n        param = ''\\n        if symbol is not None:\\n            param = param + 'symbol=' + symbol\\n        if filters is not None:\\n            param = param + 'filters=' + json.dumps(filters)\\n        return self.IO(\\\"api\\\",\\\"DELETE\\\",\\\"/api/v1/order/all\\\", param)\\n\\n    def CancelAllAfter(self, timeout=0, notify=True):\\n        param = 'timeout=' +",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "out=0, notify=True):\\n        param = 'timeout=' + str(timeout)\\n        if notify:\\n            self.Log(QUOTES[LANG]['CA'] % (timeout,COLORS['LAPIS']))\\n        return self.IO(\\\"api\\\",\\\"POST\\\",\\\"/api/v1/order/cancelAllAfter\\\", param)\\n\\n    def GetInstrument(self, symbol='XBTUSD'):\\n        try:\\n            import requests\\n        except ModuleNotFoundError:\\n            Log('pip安装requests以使用GetInstrument()函数.')\\n            return {}\\n        return requests.get('https://www.bitmex.com/api/v1/instrumen",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "uests.get('https://www.bitmex.com/api/v1/instrument?symbol=%s&count=1&reverse=false' % symbol).json()[0]\\n\\next.BitMEXPlus = BitMEX # 导出BitMEX Class, 主策略可以通过BitMEXPlus = ext.BitMEXPlus(exchange)调用\\next.toNearest = toNearest\\n\\n# 模块功能测试\\ndef main():\\n    LogReset()\\n    Log(exchange.GetAccount())\\n    BitMEXPlus = ext.BitMEXPlus(exchange)\\n    exchange.SetContractType(exchange.GetCurrency())\\n    base_price = exchange.GetTicker()['Last']\\n    _toNearest = ext.toNearest\\n    BitMEXPlus.BulkAdd('sell', _toNear",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".toNearest\\n    BitMEXPlus.BulkAdd('sell', _toNearest(base_price*1.4, 0.5), 30)\\n    BitMEXPlus.BulkAdd('buy', _toNearest(base_price*0.7, 0.5), 30)\\n    Log(BitMEXPlus.BulkOrders())\\n    Log(BitMEXPlus.BulkPost())\\n    Log(exchange.GetOrders())\\n    Log(BitMEXPlus.CancelAllAfter(5000))\\n    Sleep(8000)\\n    Log(exchange.GetOrders())\\n    Log(BitMEXPlus.BulkOrders())\",\n    \"策略名称: BitMEX-高级API功能-V110-期货批量下单编辑订单冰山订单一键撤单定时撤单-Python2-3\\n\\n### 初始化\\n这个库整合了一些高级的 BitMEX API 功能，使用前需要进行初始化。\\n```\"\n \n\n    \"strategy_5\",\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "MEX API 功能，使用前需要进行初始化。\\n```\"\n \n\n    \"strategy_5\",\n    \"python\\n#!Python3\\n\\n\\\"\\\"\\\"\\n《策略代写》 与 （此程序帮助），致信QQ：35787501\\n\\n币安合约，可用于解决开单 因精度而产生异常 的问题，获取最小变动单位，用于稳定交易系统的运行\\n\\\"\\\"\\\"\\n\\nimport requests\\n\\n\\ndef get_min_size(symbol: str, host=\\\"https://www.binancezh.jp\\\"):\\n    \\n    \\\"\\\"\\\"\\n    获取最小变动单位\\n    Args:\\n        symbol: 交易对(str)\\n                例如: ETHUSDT 等\\n        host: 域名将影响访问超时\\n              国外地址: https://fapi.binance.com\\n              国内地址（变动后需要替换）: https://www.binancezh.jp\\n    Returns:\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": https://www.binancezh.jp\\n    Returns:\\n        最小变动价格(str)，最小变动数量(str)\\n    \\\"\\\"\\\"\\n    \\n    tick_size, step_size = None, None\\n    symbols_info = requests.get(f\\\"{host}/fapi/v1/exchangeInfo\\\", timeout=5).json()[\\\"symbols\\\"]\\n    \\n    for info in symbols_info:\\n        if symbol == info[\\\"symbol\\\"]:\\n            tick_size, step_size = info[\\\"filters\\\"][0][\\\"tickSize\\\"], info[\\\"filters\\\"][1][\\\"stepSize\\\"]\\n            break\\n            \\n    return tick_size, step_size\\n\\n\\ndef main():\\n    tick_size, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_size, step_size\\n\\n\\ndef main():\\n    tick_size, step_size = get_min_size(\\\"ETHUSDT\\\")\\n    Log(tick_size, step_size)\",\n    \"策略名称: Bn-获取精度最小变动单位-稳定交易系统必备\\n\\n未找到描述\"\n \n\n    \"strategy_6\",\n    \"python\\n#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n'''\\nCoinPark通用协议,使用Python2.7\\n运行地址：http://127.0.0.1:6667，端口可指定\\n由于账户没资产，未作详细测试，欢迎反馈Bug\\nQQ:1051804485\\n反馈地址：https://www.botvs.com/bbs-topic/1963\\n2018.6.26 15:57 更新，修改了Bug\\n可以把通用协议当成普通机器人，运行在BotVs模拟盘即可，不收取费用\\n为了使用IO函数，需要重载exchange里的rpc方法，js的例子如下：\\nexchange.rpc = f",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "O函数，需要重载exchange里的rpc方法，js的例子如下：\\nexchange.rpc = function(path, obj) {\\n    return exchange.IO(\\\"api\\\",\\\"POST\\\", path, \\\"obj=\\\"+escape(JSON.stringify(obj)));\\n}\\nfunction main() {\\n\\tLog(exchange.rpc(\\\"/transfer\\\", {cmd: \\\"transfer/assets\\\", body: {select:1}}));\\n}\\n'''\\nfrom BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\\nimport json\\nimport urllib\\nimport urllib2\\nimport time\\nimport hmac\\nimport hashlib\\nimport random\\nimport ssl\\nssl._create_default_https_context = ssl._create_unverified_conte",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "fault_https_context = ssl._create_unverified_context\\n\\ndef httpGet(url):\\n    headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'}\\n    req = urllib2.Request(url,headers=headers)\\n    response = urllib2.urlopen(req)\\n    return json.loads(response.read())\\n\\ndef getsign(data,secret):\\n    result = hmac.new(secret.encode(\\\"utf-8\\\"), data.encode(\\\"utf-8\\\"), hashlib.md5).hexdigest()\\n    return result\\n\\ndef httpPostWithSign(url, cmds, api_key, ap",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ult\\n\\ndef httpPostWithSign(url, cmds, api_key, api_secret):\\n    headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'}\\n    s_cmds = json.dumps(cmds)\\n    sign = getsign(s_cmds,api_secret)\\n    req = urllib2.Request(url, urllib.urlencode({'cmds': s_cmds, 'apikey': api_key,'sign':sign}), headers=headers)\\n    response = urllib2.urlopen(req)\\n    return json.loads(response.read())\\n\\nclass MyExchange:\\n\\n    market_url = \\\"https://api.coinpark.cc/",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ge:\\n\\n    market_url = \\\"https://api.coinpark.cc/v1/mdata\\\"\\n    trade_url = \\\"https://api.coinpark.cc/v1\\\"\\n    kline_period = {1:'1min', 3:'3min', 5:'5min', 15:'15min', 30:'30min',\\\\\\n                    60:'1hour', 120:'2hour', 240:'4hour', 360:'6hour', \\\\\\n                    60*12:'12hour', 60*24:'day', 60*24*7:'week'}\\n    @staticmethod\\n    def GetTicker(symbol):\\n        url = MyExchange.market_url + \\\"?cmd=ticker&pair=\\\" + symbol\\n        raw_data = httpGet(url)\\n        if 'error' in raw_data.key",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= httpGet(url)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\": {\\\"time\\\": raw_data['result']['timestamp'], \\\"buy\\\": raw_data['result']['buy'],\\\\\\n                    \\\"sell\\\": raw_data['result']['sell'], \\\"last\\\": raw_data['result']['last'],\\\\\\n                    \\\"high\\\": raw_data['result']['high'], \\\"low\\\": raw_data['result']['low'],\\\\\\n                    \\\"vol\\\": raw_data['result']['",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                    \\\"vol\\\": raw_data['result']['vol']}}\\n        return ret_data\\n    @staticmethod\\n    def GetDepth(symbol):\\n        url = MyExchange.market_url + \\\"?cmd=depth&size=10&pair=\\\" + symbol\\n        raw_data = httpGet(url)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\" : {\\\"time\\\" : raw_data['result']['update_time'], \\\"asks\\\" : [], \\\"bids\\\" : []}}\\n        for bid in raw_d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\" : [], \\\"bids\\\" : []}}\\n        for bid in raw_data['result']['bids']:\\n            ret_data['data']['bids'].append([bid['price'],bid['volume']])\\n        for ask in raw_data['result']['asks']:\\n            ret_data['data']['asks'].append([ask['price'],ask['volume']])\\n        return ret_data\\n    @staticmethod\\n    def GetRecords(symbol, period):\\n        url = MyExchange.market_url + \\\"?cmd=kline&size=200&period=%s&pair=\\\"%MyExchange.kline_period[period] + symbol\\n        raw_data = httpGet(url)\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " + symbol\\n        raw_data = httpGet(url)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\": []}\\n        for kline in raw_data['result']:\\n            ret_data['data'].append([kline['time'], kline['open'], kline['high'],\\\\\\n            kline['low'], kline['close'], kline['vol']])\\n        return ret_data\\n    @staticmethod\\n    def GetTrades(symbol):\\n        url = MyExchange.market_url + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s(symbol):\\n        url = MyExchange.market_url + \\\"?cmd=deals&size=50&pair=\\\" + symbol\\n        raw_data = httpGet(url)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\":[]}\\n        for trade in raw_data[\\\"result\\\"]:\\n            ret_data[\\\"data\\\"].append({\\\"id\\\":trade[\\\"id\\\"], \\\"time\\\":trade[\\\"time\\\"], \\\\\\n            \\\"price\\\":trade[\\\"price\\\"], \\\"amount\\\":trade[\\\"amount\\\"],\\\"type\\\":\\\"buy",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ce\\\"], \\\"amount\\\":trade[\\\"amount\\\"],\\\"type\\\":\\\"buy\\\" if int(trade[\\\"side\\\"])==1 else \\\"sell\\\"})\\n        return ret_data\\n    @staticmethod\\n    def GetAccount(api_key, api_secret):\\n        url = MyExchange.trade_url + \\\"/transfer\\\"\\n        cmds = [{\\\"cmd\\\": \\\"transfer/assets\\\", \\\"body\\\": {\\\"select\\\":1}}]\\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=Fals",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\": []}\\n        if \\\"assets_list\\\" in raw_data[\\\"result\\\"][0][\\\"result\\\"].keys():\\n            for asset in raw_data[\\\"result\\\"][0][\\\"result\\\"][\\\"assets_list\\\"]:\\n                ret_data[\\\"data\\\"].append({\\\"currency\\\":asset[\\\"coin_symbol\\\"], \\\\\\n                \\\"free\\\":asset[\\\"balance\\\"], \\\"frozen\\\":asset[\\\"freeze\\\"]})\\n        ret_data[\\\"raw\\\"] = raw_data[\\\"result\\\"]\\n        return ret_data\\n    @staticmethod\\n    def Trad",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  return ret_data\\n    @staticmethod\\n    def Trade(api_key, api_secret, pair, order_type, order_side, price, amount):\\n        url = MyExchange.trade_url + \\\"/orderpending\\\"\\n        cmds = [{\\n                'cmd':\\\"orderpending/trade\\\",\\n                'index': random.randint(0,2000), \\n                'body':{\\n                    'pair':pair,\\n                    'account_type':0,\\n                    'order_type':order_type,\\n                    'order_side':order_side,\\n                    'price':",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "er_side':order_side,\\n                    'price':price,\\n                    'amount':amount,\\n                    }\\n                }]\\n        if order_type==1:\\n            cmds['money'] = amount\\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\": {'id':raw_data['result'][0]['result']}}\\n        return ret_data\\n    @st",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "][0]['result']}}\\n        return ret_data\\n    @staticmethod\\n    def CancelOrder(api_key, api_secret, orders_id):\\n        url = MyExchange.trade_url + \\\"/orderpending\\\"\\n        cmds = [{\\n                'cmd':\\\"orderpending/cancelTrade\\\",\\n                'index': random.randint(0,2000), \\n                'body':{'orders_id':orders_id}\\n                }]\\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\":True}\\n        try:\\n            result = raw_data['result'].encode('utf8')\\n        except:\\n            ret_data = {\\\"data\\\":False}\\n        ret_data['raw'] = raw_data\\n        return ret_data\\n    @staticmethod\\n    def GetOrder(api_key, api_secret, orders_id):\\n        url = MyExchange.trade_url + \\\"/orderpending\\\"\\n        cmds = [{\\n                'cmd':\\\"orderpendi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     cmds = [{\\n                'cmd':\\\"orderpending/order\\\",\\n                'index': random.randint(0,2000), \\n                'body':{'id':orders_id}\\n                }]\\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        status = 'open'\\n        if not raw_data['result'][0]['result']:\\n            return {\\\"error\\\":'Id not found'}\\n        i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      return {\\\"error\\\":'Id not found'}\\n        if int(raw_data['result'][0]['result']['status'])==3:\\n            status = 'closed'\\n        if int(raw_data['result'][0]['result']['status'])==5:\\n            status = 'canceled'\\n        ret_data = { \\n                    \\\"data\\\": {\\n                        \\\"id\\\": raw_data['result'][0]['result']['id'],\\n                        \\\"amount\\\": raw_data['result'][0]['result']['amount'],\\n                        \\\"price\\\": raw_data['result'][0]['result']['price",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\\"price\\\": raw_data['result'][0]['result']['price'],\\n                        \\\"status\\\": status,\\n                        \\\"deal_amount\\\": raw_data['result'][0]['result']['deal_amount'],\\n                        \\\"type\\\": \\\"buy\\\" if raw_data['result'][0]['result']['order_side']==1 else \\\"sell\\\", \\n                        \\\"avg_price\\\": 0,\\n                    }\\n                }\\n        ret_data['raw'] = raw_data\\n        return ret_data\\n    @staticmethod\\n    def GetOrders(api_key, api_secret, pair):\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "od\\n    def GetOrders(api_key, api_secret, pair):\\n        url = MyExchange.trade_url + \\\"/orderpending\\\"\\n        cmds = [{\\n                'cmd':\\\"orderpending/orderPendingList\\\",\\n                'body':{\\n                    'pair':pair, \\n                    'page':1, \\n                    'size':50\\n                    }\\n                }]\\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['err",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        ret_data = {\\\"data\\\":[]}\\n        for order in raw_data[\\\"result\\\"][0][\\\"result\\\"][\\\"items\\\"]:\\n            status = 'open'\\n            if int(order['status'])==3:\\n                status = 'closed'\\n            if int(order['status'])==5:\\n                status = 'canceled'\\n            ret_data[\\\"data\\\"].append(\\n              \\n                    \\\"id\\\": order['id'],\\n                    \\\"amount\\\":",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d\\\": order['id'],\\n                    \\\"amount\\\": order['amount'],\\n                    \\\"price\\\": order['price'],\\n                    \\\"status\\\": status,\\n                    \\\"deal_amount\\\": order['deal_amount'],\\n                    \\\"type\\\": \\\"buy\\\" if order['order_side']==1 else \\\"sell\\\", \\n                }\\n            )\\n        ret_data['raw'] = raw_data\\n        return ret_data\\n    @staticmethod\\n    def IO(api_key, api_secret, path, params):\\n        url = MyExchange.trade_url + path\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       url = MyExchange.trade_url + path\\n        cmds = [json.loads(str(urllib.unquote(params['obj'])))]\\n        raw_data = httpPostWithSign(url, cmds, api_key, api_secret)\\n        if 'error' in raw_data.keys():\\n            return {'error':json.dumps(raw_data['error'],encoding=\\\"utf8\\\", ensure_ascii=False)}\\n        return {\\\"data\\\":raw_data}\\n\\nclass Server(BaseHTTPRequestHandler):\\n\\n    def do_HEAD(self):\\n        self.send_response(200)\\n        self.send_header('Content-type', 'application/json')\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".send_header('Content-type', 'application/json')\\n        self.end_headers()\\n        \\n    def do_POST(self):\\n\\n        self.data_string = self.rfile.read(int(self.headers['Content-Length']))\\n        data =json.loads(self.data_string.replace(\\\"'\\\", '\\\"'))\\n        sent_data = {}\\n        if data['method'] == \\\"ticker\\\":\\n            symbol = data['params']['symbol'].upper()\\n            sent_data = MyExchange.GetTicker(symbol)\\n        elif data['method'] == \\\"depth\\\":\\n            symbol = data['params'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == \\\"depth\\\":\\n            symbol = data['params']['symbol'].upper()\\n            sent_data = MyExchange.GetDepth(symbol)\\n        elif data['method'] == \\\"records\\\":\\n            symbol = data['params']['symbol'].upper()\\n            period = data['params']['period']\\n            sent_data = MyExchange.GetRecords(symbol, int(period))\\n        elif data['method'] == \\\"trades\\\":\\n            symbol = data['params']['symbol'].upper()\\n            sent_data = MyExchange.GetTrades(symbol)\\n        elif data['m",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "MyExchange.GetTrades(symbol)\\n        elif data['method'] == \\\"accounts\\\":\\n            access_key = data[\\\"access_key\\\"]\\n            secret_key = data[\\\"secret_key\\\"]\\n            sent_data = MyExchange.GetAccount(access_key, secret_key)\\n        elif data['method'] == \\\"trade\\\":\\n            access_key = data[\\\"access_key\\\"]\\n            secret_key = data[\\\"secret_key\\\"]\\n            pair = data['params']['symbol'].upper()\\n            order_side = 1 if data['params']['type'] == 'buy' else 2\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ata['params']['type'] == 'buy' else 2\\n            price = data['params']['price']\\n            order_type = 2 if price > 0 else 1\\n            amount = data['params']['amount']\\n            sent_data = MyExchange.Trade(access_key, secret_key, pair, order_type, order_side, price, amount)\\n        elif data['method'] == \\\"cancel\\\":\\n            access_key = data[\\\"access_key\\\"]\\n            secret_key = data[\\\"secret_key\\\"]\\n            orders_id = int(data['params']['id'])\\n            sent_data = MyExchang",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "params']['id'])\\n            sent_data = MyExchange.CancelOrder(access_key, secret_key, orders_id)\\n        elif data['method'] == \\\"order\\\":\\n            access_key = data[\\\"access_key\\\"]\\n            secret_key = data[\\\"secret_key\\\"]\\n            orders_id = int(data['params']['id'])\\n            sent_data = MyExchange.GetOrder(access_key, secret_key, orders_id)\\n        elif data['method'] == \\\"orders\\\":\\n            access_key = data[\\\"access_key\\\"]\\n            secret_key = data[\\\"secret_key\\\"]\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         secret_key = data[\\\"secret_key\\\"]\\n            pair = data['params']['symbol'].upper()\\n            sent_data = MyExchange.GetOrders(access_key, secret_key, pair)\\n        elif data['method'][:2] == \\\"__\\\":\\n            access_key = data[\\\"access_key\\\"]\\n            secret_key = data[\\\"secret_key\\\"]\\n            path = data[\\\"method\\\"].split('_')[-1]\\n            params = data[\\\"params\\\"]\\n            sent_data = MyExchange.IO(access_key, secret_key, path, params)\\n\\n        self.do_HEAD()\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", path, params)\\n\\n        self.do_HEAD()\\n        self.wfile.write(json.dumps(sent_data))\\n        \\ndef run(server_class=HTTPServer, handler_class=Server, port=6667):\\n    server_address = ('', port)\\n    httpd = server_class(server_address, handler_class)\\n    print 'Starting http server...'\\n    httpd.serve_forever()\\n\\nif __name__ == \\\"__main__\\\":\\n    from sys import argv\\n    if len(argv) == 2:\\n        run(port=int(argv[1]))\\n    else:\\n        run()\",\n    \"策略名称: CoinPark交易所通用协议-627-1600-更新-关闭了SSL验证",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\",\n    \"策略名称: CoinPark交易所通用协议-627-1600-更新-关闭了SSL验证\\n\\n用途：可以使BotVs支持coinpark.cc交易所\\n代码公开地址：https://www.fmz.com/strategy/101399\\n运行地址 \\n\\n    http://127.0.0.1:6667\"\n \n\n    \"strategy_7\",\n    \"python\\n'''\\n代码可以直接放到本地运行，\\n不过需要一直开启电脑，也可以放到自己的服务器上运行\\n'''\\n\\nimport time\\nimport json\\nimport ssl\\nimport requests\\nssl._create_default_https_context = ssl._create_unverified_context\\n\\ntry:\\n    import md5\\n    import urllib2\\n    from urllib import urlencode\\nexcept:\\n    import hashlib as md5\\n    import urllib.reques",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   import hashlib as md5\\n    import urllib.request as urllib2\\n    from urllib.parse import urlencode\\n\\naccessKey = '48xxxxxxxxxxxxxxxxxxxxxxxxxxxxde'\\nsecretKey = '91xxxxxxxxxxxxxxxxxxxxxxxxxxxx84'\\n\\ndef api(method, *args):\\n    d = {\\n        'version': '1.0',\\n        'access_key': accessKey,\\n        'method': method,\\n        'args': json.dumps(list(args)),\\n        'nonce': int(time.time() * 1000),\\n        }\\n\\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\\n    # 注意： urllib2.urlopen 函数，超时问题，可以设置超时时间，urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8'), timeout=10) 设置超时 10秒\\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\\n\\ndef send_wechat(msg):\\n    token = '93xxxxxxxxxxxxxxxxxxxxxxxxxxxx57'  # 前边复制到那个token\\n    title = '【Waring】 策略信息'\\n    content = msg\\n    templat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = '【Waring】 策略信息'\\n    content = msg\\n    template = 'html'\\n    url = f\\\"https://www.pushplus.plus/send?token={token}&title={title}&content={content}&template={template}\\\"\\n    #print(url)\\n    r = requests.get(url=url)\\n    print(json.loads(r.text)['msg'])\\n\\nrobotId = [xxx,xxx,xxx]    #需要监视的机器人代码\\n\\n\\nwhile True:\\n    for j in range(len(robotId)):\\n        detail = api('GetRobotDetail', robotId[j])\\n        if detail['data']['result']['robot']['status'] == 1 and detail['data']['result']['robot']['wd'] =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "== 1 and detail['data']['result']['robot']['wd'] == 1:\\n            print(f\\\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视已打开 wd = {detail['data']['result']['robot']['wd']}\\\")\\n            pass\\n        elif detail['data']['result']['robot']['status'] == 1 :\\n            print(f\\\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视未打开 wd = {detail['data']['result']['robot']['wd']}\\\")\\n            pass\\n        else:\\n            print(f\\\"实盘{robotId[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s\\n        else:\\n            print(f\\\"实盘{robotId[j]}状态异常 status = {detail['data']['result']['robot']['status']}\\\")\\n            #尝试重启实盘   尝试次数 = 4    每5s 尝试一次\\n            status = False\\n            for i in range(4):\\n                api('RestartRobot', robotId[j])\\n                robotDetail = api('GetRobotDetail', robotId[j])\\n                print(f\\\"尝试重启实盘{robotId[j]}第 {i+1} 次\\\")\\n                if robotDetail['data']['result']['robot']['status'] == 1 :\\n                    mess = api('GetRobotLogs",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 1 :\\n                    mess = api('GetRobotLogs',robotId[j],0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\\n                    print(f\\\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\\\n\\\"\\n                          f\\\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\\\n\\\"\\n                          f\\\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\\\n\\\")\\n                    send_wechat(f\\\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetai",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f\\\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\\\n\\\"\\n                                f\\\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\\\n\\\"\\n                                f\\\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\\\n\\\")\\n                    status = True\\n                    break\\n                else:\\n                    print(f\\\"第 {i+1} 次 重启失败!!\\\")\\n                time.sleep(5)\\n            if status == False :\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".sleep(5)\\n            if status == False :\\n                print(f\\\"尝试 4 次重启实盘{robotId[j]}失败，发送警告信息！！\\\")\\n                send_wechat(f\\\"尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\\\n\\\")\\n    time.sleep(60*10)\",\n    \"策略名称: FMZ实盘机器人自动检测重启程序微信推送\\n\\nreturn json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\\n\\ndef send_wechat(msg):\\n    token = '93xxxxxxxxxxxxxxxxxxxxxxxxxxxx57'  # 前边复制到那个tok",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= '93xxxxxxxxxxxxxxxxxxxxxxxxxxxx57'  # 前边复制到那个token\\n    title = '【Waring】 策略信息'\\n    content = msg\\n    template = 'html'\\n    url = f\\\"https://www.pushplus.plus/send?token={token}&title={title}&content={content}&template={template}\\\"\\n    #print(url)\\n    r = requests.get(url=url)\\n    print(json.loads(r.text)['msg'])\\n\\nrobotId = [xxx,xxx,xxx]    #需要监视的机器人代码\\n\\n\\nwhile True:\\n    for j in range(len(robotId)):\\n        detail = api('GetRobotDetail', robotId[j])\\n        if detail['data']['result']['robot",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Id[j])\\n        if detail['data']['result']['robot']['status'] == 1 and detail['data']['result']['robot']['wd'] == 1:\\n            print(f\\\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视已打开 wd = {detail['data']['result']['robot']['wd']}\\\")\\n            pass\\n        elif detail['data']['result']['robot']['status'] == 1 :\\n            print(f\\\"实盘{robotId[j]}状态正常 status = {detail['data']['result']['robot']['status']}，实盘监视未打开 wd = {detail['data']['result']['robot']['wd']}\\\")\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= {detail['data']['result']['robot']['wd']}\\\")\\n            pass\\n        else:\\n            print(f\\\"实盘{robotId[j]}状态异常 status = {detail['data']['result']['robot']['status']}\\\")\\n            #尝试重启实盘   尝试次数 = 4    每5s 尝试一次\\n            status = False\\n            for i in range(4):\\n                api('RestartRobot', robotId[j])\\n                robotDetail = api('GetRobotDetail', robotId[j])\\n                print(f\\\"尝试重启实盘{robotId[j]}第 {i+1} 次\\\")\\n                if robotDetail['data']['result']['robot']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         if robotDetail['data']['result']['robot']['status'] == 1 :\\n                    mess = api('GetRobotLogs',robotId[j],0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\\n                    print(f\\\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\\\n\\\"\\n                          f\\\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\\\n\\\"\\n                          f\\\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\\\n\\\")\\n                   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "logs'][0]['Arr'][1][6]}\\\\n\\\")\\n                    send_wechat(f\\\"实盘{robotId[j]}重启完成 status = {api('GetRobotDetail', robotId[j])['data']['result']['robot']['status']}\\\\n\\\"\\n                                f\\\"返回错误信息1：{mess['data']['result']['logs'][0]['Arr'][0][6]}\\\\n\\\"\\n                                f\\\"返回错误信息2：{mess['data']['result']['logs'][0]['Arr'][1][6]}\\\\n\\\")\\n                    status = True\\n                    break\\n                else:\\n                    print(f\\\"第 {i+1} 次 重启失败!!\\\")\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             print(f\\\"第 {i+1} 次 重启失败!!\\\")\\n                time.sleep(5)\\n            if status == False :\\n                print(f\\\"尝试 4 次重启实盘{robotId[j]}失败，发送警告信息！！\\\")\\n                send_wechat(f\\\"尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\\\n尝试 4 次重启实盘{robotId[j]}失败，请及时查看！！\\\\n\\\")\\n    time.sleep(60*10)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/383695\\n\\n> Last Modified\\n\\n2022-09-22 18:27:23\"\n \n\n    \"strategy_8\",\n    \"python\\n# 单行注释\\n\\\"\\\"\\\" 多行字符串可以用\\n    三个引号包裹，不过这也可以被",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ython\\n# 单行注释\\n\\\"\\\"\\\" 多行字符串可以用\\n    三个引号包裹，不过这也可以被当做\\n    多行注释\\n\\\"\\\"\\\"\\n\\n####################################################\\n## 1. 原始数据类型和操作符\\n####################################################\\n\\n# 数字类型\\n3  # => 3\\n\\n# 简单的算数\\n1 + 1  # => 2\\n8 - 1  # => 7\\n10 * 2  # => 20\\n35 / 5  # => 7\\n\\n# 整数的除法会自动取整\\n5 / 2  # => 2\\n\\n# 要做精确的除法，我们需要引入浮点数\\n2.0     # 浮点数\\n11.0 / 4.0  # => 2.75 精确多了\\n\\n# 括号具有最高优先级\\n(1 + 3) * 2  # => 8\\n\\n# 布尔值也是基本的数据类型\\nTrue\\nFalse\\n\\n# 用 not 来取非\\nnot True  # => False\\nnot False  # => ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 用 not 来取非\\nnot True  # => False\\nnot False  # => True\\n\\n# 相等\\n1 == 1  # => True\\n2 == 1  # => False\\n\\n# 不等\\n1 != 1  # => False\\n2 != 1  # => True\\n\\n# 更多的比较操作符\\n1 < 10  # => True\\n1 > 10  # => False\\n2 <= 2  # => True\\n2 >= 2  # => True\\n\\n# 比较运算可以连起来写！\\n1 < 2 < 3  # => True\\n2 < 3 < 2  # => False\\n\\n# 字符串通过 \\\" 或 ' 括起来\\n\\\"This is a string.\\\"\\n'This is also a string.'\\n\\n# 字符串通过加号拼接\\n\\\"Hello \\\" + \\\"world!\\\"  # => \\\"Hello world!\\\"\\n\\n# 字符串可以被视为字符的列表\\n\\\"This is a string\\\"[0]  # => 'T'\\n\\n# % 可以用来格式化字符串\\n\\\"%",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " is a string\\\"[0]  # => 'T'\\n\\n# % 可以用来格式化字符串\\n\\\"%s can be %s\\\" % (\\\"strings\\\", \\\"interpolated\\\")\\n\\n# 也可以用 format 方法来格式化字符串\\n# 推荐使用这个方法\\n\\\"{0} can be {1}\\\".format(\\\"strings\\\", \\\"formatted\\\")\\n# 也可以用变量名代替数字\\n\\\"{name} wants to eat {food}\\\".format(name=\\\"Bob\\\", food=\\\"lasagna\\\")\\n\\n# None 是对象\\nNone  # => None\\n\\n# 不要用相等 `==` 符号来和None进行比较\\n# 要用 `is`\\n\\\"etc\\\" is None  # => False\\nNone is None  # => True\\n\\n# 'is' 可以用来比较对象的相等性\\n# 这个操作符在比较原始数据时没多少用，但是比较对象时必不可少\\n\\n# None, 0, 和空字符串都被算作 False\\n# 其他的均为 True\\n0 == Fal",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "# None, 0, 和空字符串都被算作 False\\n# 其他的均为 True\\n0 == False  # => True\\n\\\"\\\" == False  # => True\\n\\n\\n####################################################\\n## 2. 变量和集合\\n####################################################\\n\\n# 很方便的输出\\nprint \\\"I'm Python. Nice to meet you!\\\"\\n\\n\\n# 给变量赋值前不需要事先声明\\nsome_var = 5    # 一般建议使用小写字母和下划线组合来做为变量名\\nsome_var  # => 5\\n\\n# 访问未赋值的变量会抛出异常\\n# 可以查看控制流程一节来了解如何异常处理\\nsome_other_var  # 抛出 NameError\\n\\n# if 语句可以作为表达式来使用\\n\\\"yahoo!\\\" if 3 > 2 else 2  # => \\\"yahoo!\\\"\\n\\n# 列表用来保存序列\\nli = []\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 2 else 2  # => \\\"yahoo!\\\"\\n\\n# 列表用来保存序列\\nli = []\\n# 可以直接初始化列表\\nother_li = [4, 5, 6]\\n\\n# 在列表末尾添加元素\\nli.append(1)    # li 现在是 [1]\\nli.append(2)    # li 现在是 [1, 2]\\nli.append(4)    # li 现在是 [1, 2, 4]\\nli.append(3)    # li 现在是 [1, 2, 4, 3]\\n# 移除列表末尾元素\\nli.pop()        # => 3 li 现在是 [1, 2, 4]\\n# 重新加进去\\nli.append(3)    # li is now [1, 2, 4, 3] again.\\n\\n# 像其他语言访问数组一样访问列表\\nli[0]  # => 1\\n# 访问最后一个元素\\nli[-1]  # => 3\\n\\n# 越界会抛出异常\\nli[4]  # 抛出越界异常\\n\\n# 切片语法需要用到列表的索引访问\\n# 可以看做数学之中左闭右开区间\\nli[1:3]  # => [2, 4]\\n# 省略开头的",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "问\\n# 可以看做数学之中左闭右开区间\\nli[1:3]  # => [2, 4]\\n# 省略开头的元素\\nli[2:]  # => [4, 3]\\n# 省略末尾的元素\\nli[:3]  # => [1, 2, 4]\\n\\n# 删除特定元素\\ndel li[2]  # li 现在是 [1, 2, 3]\\n\\n# 合并列表\\nli + other_li  # => [1, 2, 3, 4, 5, 6] - 并不会不改变这两个列表\\n\\n# 通过拼接来合并列表\\nli.extend(other_li)  # li 是 [1, 2, 3, 4, 5, 6]\\n\\n# 用 in 来返回元素是否在列表中\\n1 in li  # => True\\n\\n# 返回列表长度\\nlen(li)  # => 6\\n\\n\\n# 元组类似于列表，但它是不可改变的\\ntup = (1, 2, 3)\\ntup[0]  # => 1\\ntup[0] = 3  # 类型错误\\n\\n# 对于大多数的列表操作，也适用于元组\\nlen(tup)  # => 3\\ntup + (4, 5, 6)  # => (1, 2, 3, 4, 5, 6)\\nt",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " => 3\\ntup + (4, 5, 6)  # => (1, 2, 3, 4, 5, 6)\\ntup[:2]  # => (1, 2)\\n2 in tup  # => True\\n\\n# 你可以将元组解包赋给多个变量\\na, b, c = (1, 2, 3)     # a 是 1，b 是 2，c 是 3\\n# 如果不加括号，将会被自动视为元组\\nd, e, f = 4, 5, 6\\n# 现在我们可以看看交换两个数字是多么容易的事\\ne, d = d, e     # d 是 5，e 是 4\\n\\n\\n# 字典用来储存映射关系\\nempty_dict = {}\\n# 字典初始化\\nfilled_dict = {\\\"one\\\": 1, \\\"two\\\": 2, \\\"three\\\": 3}\\n\\n# 字典也用中括号访问元素\\nfilled_dict[\\\"one\\\"]  # => 1\\n\\n# 把所有的键保存在列表中\\nfilled_dict.keys()  # => [\\\"three\\\", \\\"two\\\", \\\"one\\\"]\\n# 键的顺序并不是唯一的，得到的不一定是这个顺序\\n\\n# 把所有的值保存在列表中\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "one\\\"]\\n# 键的顺序并不是唯一的，得到的不一定是这个顺序\\n\\n# 把所有的值保存在列表中\\nfilled_dict.values()  # => [3, 2, 1]\\n# 和键的顺序相同\\n\\n# 判断一个键是否存在\\n\\\"one\\\" in filled_dict  # => True\\n1 in filled_dict  # => False\\n\\n# 查询一个不存在的键会抛出 KeyError\\nfilled_dict[\\\"four\\\"]  # KeyError\\n\\n# 用 get 方法来避免 KeyError\\nfilled_dict.get(\\\"one\\\")  # => 1\\nfilled_dict.get(\\\"four\\\")  # => None\\n# get 方法支持在不存在的时候返回一个默认值\\nfilled_dict.get(\\\"one\\\", 4)  # => 1\\nfilled_dict.get(\\\"four\\\", 4)  # => 4\\n\\n# setdefault 是一个更安全的添加字典元素的方法\\nfilled_dict.setdefault(\\\"five\\\", 5)  #",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "的添加字典元素的方法\\nfilled_dict.setdefault(\\\"five\\\", 5)  # filled_dict[\\\"five\\\"] 的值为 5\\nfilled_dict.setdefault(\\\"five\\\", 6)  # filled_dict[\\\"five\\\"] 的值仍然是 5\\n\\n\\n# 集合储存无顺序的元素\\nempty_set = set()\\n# 初始化一个集合\\nsome_set = set([1, 2, 2, 3, 4])  # some_set 现在是 set([1, 2, 3, 4])\\n\\n# Python 2.7 之后，大括号可以用来表示集合\\nfilled_set = {1, 2, 2, 3, 4}  # => {1 2 3 4}\\n\\n# 向集合添加元素\\nfilled_set.add(5)  # filled_set 现在是 {1, 2, 3, 4, 5}\\n\\n# 用 & 来计算集合的交\\nother_set = {3, 4, 5, 6}\\nfilled_set & other_set  # => {3, 4, 5}\\n\\n# 用 | 来计算集合的并\\nfill",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "& other_set  # => {3, 4, 5}\\n\\n# 用 | 来计算集合的并\\nfilled_set | other_set  # => {1, 2, 3, 4, 5, 6}\\n\\n# 用 - 来计算集合的差\\n{1, 2, 3, 4} - {2, 3, 5}  # => {1, 4}\\n\\n# 用 in 来判断元素是否存在于集合中\\n2 in filled_set  # => True\\n10 in filled_set  # => False\\n\\n\\n####################################################\\n## 3. 控制流程\\n####################################################\\n\\n# 新建一个变量\\nsome_var = 5\\n\\n# 这是个 if 语句，在 python 中缩进是很重要的。\\n# 下面的代码片段将会输出 \\\"some var is smaller than 10\\\"\\nif some_var > 10:\\n    print \\\"some_var is total",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\nif some_var > 10:\\n    print \\\"some_var is totally bigger than 10.\\\"\\nelif some_var < 10:    # 这个 elif 语句是不必须的\\n    print \\\"some_var is smaller than 10.\\\"\\nelse:           # 这个 else 也不是必须的\\n    print \\\"some_var is indeed 10.\\\"\\n\\n\\n\\\"\\\"\\\"\\n用for循环遍历列表\\n输出:\\n    dog is a mammal\\n    cat is a mammal\\n    mouse is a mammal\\n\\\"\\\"\\\"\\nfor animal in [\\\"dog\\\", \\\"cat\\\", \\\"mouse\\\"]:\\n    # 你可以用 % 来格式化字符串\\n    print \\\"%s is a mammal\\\" % animal\\n\\n\\\"\\\"\\\"\\n`range(number)` 返回从0到给定数字的列表\\n输出:\\n    0\\n    1\\n    2\\n    3\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")` 返回从0到给定数字的列表\\n输出:\\n    0\\n    1\\n    2\\n    3\\n\\\"\\\"\\\"\\nfor i in range(4):\\n    print i\\n\\n\\\"\\\"\\\"\\nwhile 循环\\n输出:\\n    0\\n    1\\n    2\\n    3\\n\\\"\\\"\\\"\\nx = 0\\nwhile x < 4:\\n    print x\\n    x += 1  #  x = x + 1 的简写\\n\\n# 用 try/except 块来处理异常\\n\\n# Python 2.6 及以上适用:\\ntry:\\n    # 用 raise 来抛出异常\\n    raise IndexError(\\\"This is an index error\\\")\\nexcept IndexError as e:\\n    pass    # pass 就是什么都不做，不过通常这里会做一些恢复工作\\n\\n\\n####################################################\\n## 4. 函数\\n###################################",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "###\\n## 4. 函数\\n####################################################\\n\\n# 用 def 来新建函数\\ndef add(x, y):\\n    print \\\"x is %s and y is %s\\\" % (x, y)\\n    return x + y    # 通过 return 来返回值\\n\\n# 调用带参数的函数\\nadd(5, 6)  # => 输出 \\\"x is 5 and y is 6\\\" 返回 11\\n\\n# 通过关键字赋值来调用函数\\nadd(y=6, x=5)   # 顺序是无所谓的\\n\\n# 我们也可以定义接受多个变量的函数，这些变量是按照顺序排列的\\ndef varargs(*args):\\n    return args\\n\\nvarargs(1, 2, 3)  # => (1,2,3)\\n\\n\\n# 我们也可以定义接受多个变量的函数，这些变量是按照关键字排列的\\ndef keyword_args(**kwargs):\\n    return kwargs\\n\\n# 实际效果：\\nkeyword_args(big=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n    return kwargs\\n\\n# 实际效果：\\nkeyword_args(big=\\\"foot\\\", loch=\\\"ness\\\")  # => {\\\"big\\\": \\\"foot\\\", \\\"loch\\\": \\\"ness\\\"}\\n\\n# 你也可以同时将一个函数定义成两种形式\\ndef all_the_args(*args, **kwargs):\\n    print args\\n    print kwargs\\n\\\"\\\"\\\"\\nall_the_args(1, 2, a=3, b=4) prints:\\n    (1, 2)\\n  \\\"a\\\": 3, \\\"b\\\": 4}\\n\\\"\\\"\\\"\\n\\n# 当调用函数的时候，我们也可以进行相反的操作，把元组和字典展开为参数\\nargs = (1, 2, 3, 4)\\nkwargs = {\\\"a\\\": 3, \\\"b\\\": 4}\\nall_the_args(*args)  # 等价于 foo(1, 2, 3, 4)\\nall_the_args(**kwargs)  # 等价于 foo(a=3, b=4)\\nall_the_args(*args, **kwarg",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  # 等价于 foo(a=3, b=4)\\nall_the_args(*args, **kwargs)  # 等价于 foo(1, 2, 3, 4, a=3, b=4)\\n\\n# 函数在 python 中是一等公民\\ndef create_adder(x):\\n    def adder(y):\\n        return x + y\\n    return adder\\n\\nadd_10 = create_adder(10)\\nadd_10(3)  # => 13\\n\\n# 匿名函数\\n(lambda x: x > 2)(3)  # => True\\n\\n# 内置高阶函数\\nmap(add_10, [1, 2, 3])  # => [11, 12, 13]\\nfilter(lambda x: x > 5, [3, 4, 5, 6, 7])  # => [6, 7]\\n\\n# 可以用列表方法来对高阶函数进行更巧妙的引用\\n[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]\\n[x for x in [3, 4, 5, 6, 7] if x > 5]  # ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "12, 13]\\n[x for x in [3, 4, 5, 6, 7] if x > 5]  # => [6, 7]\\n\\n####################################################\\n## 5. 类\\n####################################################\\n\\n# 我们新建的类是从 object 类中继承的\\nclass Human(object):\\n\\n     # 类属性，由所有类的对象共享\\n    species = \\\"H. sapiens\\\"\\n\\n    # 基本构造函数\\n    def __init__(self, name):\\n        # 将参数赋给对象成员属性\\n        self.name = name\\n\\n    # 成员方法，参数要有 self\\n    def say(self, msg):\\n        return \\\"%s: %s\\\" % (self.name, msg)\\n\\n    # 类方法由所有类的对象共享\\n    # 这类方法在调用时，会",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "name, msg)\\n\\n    # 类方法由所有类的对象共享\\n    # 这类方法在调用时，会把类本身传给第一个参数\\n    @classmethod\\n    def get_species(cls):\\n        return cls.species\\n\\n    # 静态方法是不需要类和对象的引用就可以调用的方法\\n    @staticmethod\\n    def grunt():\\n        return \\\"*grunt*\\\"\\n\\n\\n# 实例化一个类\\ni = Human(name=\\\"Ian\\\")\\nprint i.say(\\\"hi\\\")     # 输出 \\\"Ian: hi\\\"\\n\\nj = Human(\\\"Joel\\\")\\nprint j.say(\\\"hello\\\")  # 输出 \\\"Joel: hello\\\"\\n\\n# 访问类的方法\\ni.get_species()  # => \\\"H. sapiens\\\"\\n\\n# 改变共享属性\\nHuman.species = \\\"H. neanderthalensis\\\"\\ni.get_species()  # => \\\"H",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"H. neanderthalensis\\\"\\ni.get_species()  # => \\\"H. neanderthalensis\\\"\\nj.get_species()  # => \\\"H. neanderthalensis\\\"\\n\\n# 访问静态变量\\nHuman.grunt()  # => \\\"*grunt*\\\"\\n\\n\\n####################################################\\n## 6. 模块\\n####################################################\\n\\n# 我们可以导入其他模块\\nimport math\\nprint math.sqrt(16)  # => 4\\n\\n# 我们也可以从一个模块中导入特定的函数\\nfrom math import ceil, floor\\nprint ceil(3.7)   # => 4.0\\nprint floor(3.7)  # => 3.0\\n\\n# 从模块中导入所有的函数\\n# 警告：不推荐使用\\nfrom math import *\\n\\n# 简写模块名",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "导入所有的函数\\n# 警告：不推荐使用\\nfrom math import *\\n\\n# 简写模块名\\nimport math as m\\nmath.sqrt(16) == m.sqrt(16)  # => True\\n\\n# Python的模块其实只是普通的python文件\\n# 你也可以创建自己的模块，并且导入它们\\n# 模块的名字就和文件的名字相同\\n\\n# 也可以通过下面的方法查看模块中有什么属性和方法\\nimport math\\ndir(math)\",\n    \"策略名称: FMZ教程-Python速成手册\\n\\n\\\"\\\"\\\" 多行字符串可以用\\n    三个引号包裹，不过这也可以被当做\\n    多行注释\\n\\\"\\\"\\\"\"\n \n\n    \"strategy_9\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n# \\n# Fomo3D Smart Contract Monitoring\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@faw",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# Do What the Fuck You Want To Public License\\n#\\n\\nimport requests\\nimport re\\nimport json\\nimport time\\nimport datetime\\n\\nLogReset()\\n\\nif TG == 1:\\n    TG_ENABLE = True \\nelse:\\n    TG_ENABLE = False\\nif WECHAT == 1:\\n    WC_ENABLE = True \\nelse:\\n    WC_ENABLE = False\\n    \\nTG_BOT_KEY = TGKEY\\n\\nTGURL = 'https://api.telegram.org/bot%s/sendMessage' % TG_BOT_KEY\\nTGPARAM = {}\\nTGPARAM['chat_id'] = TGID\\n\\ndef Send(message)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "{}\\nTGPARAM['chat_id'] = TGID\\n\\ndef Send(message):\\n    if TG_ENABLE == False:\\n        return\\n    try:\\n        TGPARAM['text'] = message\\n        res = requests.post(TGURL, data = TGPARAM)\\n        return\\n    except IOError as e:\\n        print(e)\\n        return\\n\\n\\ndef Refresh():\\n    URL = 'https://mainnet.infura.io/%s' % INFURAKEY\\n    HEADER = {'Content-Type': 'application/json'}\\n    PARAM = '{\\\"jsonrpc\\\": \\\"2.0\\\", \\\"id\\\": 1, \\\"method\\\": \\\"eth_call\\\", \\\"params\\\": [{\\\"data\\\":\\\"0x747dff42\\\",\\\"to\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ll\\\", \\\"params\\\": [{\\\"data\\\":\\\"0x747dff42\\\",\\\"to\\\":\\\"%s\\\"},\\\"latest\\\"]}' % CONTRACT\\n    data = requests.post(URL,data=PARAM,headers=HEADER).json()\\n    HEX = re.sub('(0{2,})','X',data['result']).split('X')[3]\\n    print(HEX)\\n    INT = int(HEX, 16)\\n    NOW = int(time.time())\\n    LEFT = INT - NOW\\n    return LEFT\\n\\ndef main():\\n    Log('Started!')\\n    Log('ContractAddress: ' + CONTRACT)\\n    Log('Telegram Enabled: ' + str(TG_ENABLE))\\n    Log('WeChat Enabled: ' + str(WC_ENABLE))\\n    while True:\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bled: ' + str(WC_ENABLE))\\n    while True:\\n        try:\\n            DATE = datetime.datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n            TIMELEFT = Refresh()\\n            message = 'Time before FOMO ENDING : %d' % TIMELEFT\\n            if TIMELEFT < 0:\\n                TIMELEFT = THRESHOLD + 10\\n            if TIMELEFT <= THRESHOLD:\\n                Send(message)\\n                if WC_ENABLE == True:\\n                    message = message + ' !@'\\n                    \\n                Log(message)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                    \\n                Log(message)\\n            else:\\n                Log(message)\\n\\n        except IOError as e:\\n            print(e)\\n            time.sleep(REFRESH_DELAY)\\n            pass\\n\\n        time.sleep(REFRESH_DELAY)\",\n    \"策略名称: Fomo3D-智能合约监控-Fomo3D-Smart-Contract-Monitoring\\n\\n# encoding: utf-8\"\n \n\n    \"strategy_10\",\n    \"python\\n'''\\nstart: 2020-01-01 00:00:00\\nend: 2020-04-24 00:00:00\\nperiod: 1h\\nexchanges: [{\\\"eid\\\":\\\"huobi\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":0,\\\"meta",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bi\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":0,\\\"meta\\\":{\\\"AccessKey\\\":\\\"7yngd7gh5g-a7ed9b1a-c05064c3-bab33\\\",\\\"SecretKey\\\":\\\"553c2cd1-e229e1d2-25a536cb-db7d3\\\"}}]\\n'''\\n\\nimport talib as ta\\nimport pandas as pd\\nfrom datetime import datetime\\nfrom datetime import timedelta\\nimport math\\n#coding:utf8\\nimport sys\\n\\neid = -1\\nlast_price = -1\\n\\ndef main():\\n    global eid\\n    global last_price\\n    global ma\\n\\n    while True:\\n\\n        records = exchange.GetRecords(1*60*60)\\n        e = exchange\\n        kli",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ecords(1*60*60)\\n        e = exchange\\n        kline1 = pd.DataFrame(records)\\n        kline1['Time'] = kline1['Time'].map(lambda x: datetime.utcfromtimestamp(x/1000)+timedelta(hours=8))\\n        kline1.columns = ['time','open','high','low','close','volume','oi']\\n       \\n        r = kline1\\n        #Log('最新k线时间',r.iloc[-1].time, ' 最新价格收盘价', r.iloc[-1].close)\\n    \\n        leadLine1 = ta.EMA(r.close, 30)\\n        leadLine2 = ta.SMA(r.close, 30)\\n        UT=leadLine2 < leadLine1\\n        DT=leadLine2 > lea",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=leadLine2 < leadLine1\\n        DT=leadLine2 > leadLine1\\n    \\n        # keltner channel\\n        ma  = ta.EMA(kline1.close, 80)\\n        # 真实的范围函数\\n        range1 = ta.TRANGE(kline1.high, kline1.low, kline1.close)\\n        rangema = ta.EMA(range1, 80)\\n        upper = ma + 3*rangema\\n        lower = ma - 3*rangema\\n       \\n        # minus and plus of adx/dmi\\n        minus = ta.MINUS_DI(kline1.high,kline1.low, kline1.close,14) \\n        plus = ta.PLUS_DI(kline1.high, kline1.low, kline1.close ,14)\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "kline1.high, kline1.low, kline1.close ,14)\\n                   \\n        volume0 = r.iloc[-1].volume\\n        volume1 = r.iloc[-2].volume\\n        rn = r.iloc[-1]\\n       \\n        entry_long = rn.close > upper.iloc[-1] and (r.iloc[-1].volume+ r.iloc[-2].volume) >1.5 *(r.iloc[-4].volume+ r.iloc[-5].volume)\\n        long = entry_long\\n        exit_long = (rn.close < ma.iloc[-1] )\\n        account = exchange.GetAccount()\\n        amount = account.Stocks\\n        #Log('Balance is ', account['Balance'], ' Btc a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   #Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n        # 如果处于空仓状态\\n        if (account['Balance'] >= 600 and amount < 0.001):\\n            if long==True and account['Balance'] < 400 and amount<0.01:\\n                Log('balance is ', account['Balance'], ' 余额不足400，退出！')\\n                return\\n            elif long== True  and account['Balance'] >= 600: #第一次开多仓\\n                Log('balance is ', account['Balance'])\\n                Log('多仓位时间: ', rn.time, ' open is ', rn.open , ' c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Log('多仓位时间: ', rn.time, ' open is ', rn.open , ' close is ', rn.close, ' upper is ', upper.iloc[-1], ' volume 0\\\\1 is', volume0 , 'volume 1 is ', volume1 , \\n                ' plus is ',plus.iloc[-1], ' minus is ', minus.iloc[-1], '@')\\n                exchange.Buy(-1,600)\\n                last_price = rn.close + 10\\n                Sleep(1000*60*15)\\n        # 如果处于持仓状态\\n        if  amount>0.001 :\\n            if  amount > 0.0001 and rn.close <= last_price*0.94: \\n                Log('止损平仓事件: ','balance is ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".94: \\n                Log('止损平仓事件: ','balance is ', account['Balance'], rn.time, ' rn.close is ', rn.close, ' @')\\n                id = exchange.Sell(-1, amount);\\n                account = exchange.GetAccount()\\n                amount = account.Stocks\\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n                eid = -1\\n       #如果处于一直持仓又大跌状态，才卖出\\n            elif  amount > 0.0001 and rn.close >= last_price * 1.1 and rn.close <= r.iloc[-24].close*0.9:\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rn.close <= r.iloc[-24].close*0.9:\\n                Log('持仓周期内的大跌止损平仓事件: ', rn.time, ' rn.close is ', rn.close, ' @')\\n                id = exchange.Sell(-1, amount);\\n                eid = -1\\n                account = exchange.GetAccount()\\n                amount = account.Stocks\\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n            elif amount > 0.0001 and exit_long == True :\\n                if rn.close <= last_price:\\n                    Log('位置下滑平仓位事件,亏损:  amo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rice:\\n                    Log('位置下滑平仓位事件,亏损:  amount is ',amount ,' time is ', rn.time, ' 价格是：',rn.close,' ma is ', ma.iloc[-1], ' 开仓价格',last_price,' 亏损幅度：',100*(last_price -rn.close)/last_price ,'% @')\\n                    eid = exchange.Sell(-1, amount)\\n#                print(r.tail(10))\\n#                print('ma is ' ,ma)\\n                    account = exchange.GetAccount()\\n                    amount = account.Stocks\\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amou",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " is ', account['Balance'], ' Btc amount is ', amount)\\n                elif rn.close > last_price*1.1 :\\n                    Log('超出10%盈利继续持仓')\\n                    account = exchange.GetAccount()\\n                    amount = account.Stocks\\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n                    return \\n                elif rn.close > last_price  and rn.close <=last_price*1.1:\\n                    eid = exchange.Sell(-1, amount);\\n                    acc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchange.Sell(-1, amount);\\n                    account = exchange.GetAccount()\\n                    amount = account.Stocks\\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n                    Log('位置下滑平仓位事件,赚钱啦: amount is ',amount, ' time is ', rn.time, ' 价格是： ',rn.close,' ma is ', ma.iloc[-1],' 开仓价格',last_price,' 盈利幅度：',100*(rn.close-last_price )/last_price ,'% @' )\\n                else:\\n                    id = exchange.Sell(-1, amount);\\n                    Log('",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hange.Sell(-1, amount);\\n                    Log('最终位置下滑平仓位事件,赚钱啦: amount is ',amount, ' time is ', rn.time, ' 价格是： ',rn.close,' ma is ', ma.iloc[-1],' 开仓价格',last_price,' 盈利幅度：',100*(rn.close-last_price )/last_price ,'% @' )\\n                    eid = -1\\n                    account = exchange.GetAccount()\\n                    amount = account.Stocks\\n                    Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n            Sleep(1000*60*15)\",\n    \"策略名称: Keltner通道突破止损加盈利10即长期持有策略-v2",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "0*60*15)\",\n    \"策略名称: Keltner通道突破止损加盈利10即长期持有策略-v23-dev-多周期\\n\\nma  = ta.EMA(kline1.close, 80)\\n        # 真实的范围函数\\n        range1 = ta.TRANGE(kline1.high, kline1.low, kline1.close)\\n        rangema = ta.EMA(range1, 80)\\n        upper = ma + 3*rangema\\n        lower = ma - 3*rangema\\n       \\n        # minus and plus of adx/dmi\\n        minus = ta.MINUS_DI(kline1.high,kline1.low, kline1.close,14) \\n        plus = ta.PLUS_DI(kline1.high, kline1.low, kline1.close ,14)\\n                   \\n        volume0 = r.i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e ,14)\\n                   \\n        volume0 = r.iloc[-1].volume\\n        volume1 = r.iloc[-2].volume\\n        rn = r.iloc[-1]\\n       \\n        entry_long = rn.close > upper.iloc[-1] and (r.iloc[-1].volume+ r.iloc[-2].volume) >1.5 *(r.iloc[-4].volume+ r.iloc[-5].volume)\\n        long = entry_long\\n        exit_long = (rn.close < ma.iloc[-1] )\\n        account = exchange.GetAccount()\\n        amount = account.Stocks\\n        #Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n        # 如果处于空",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nce'], ' Btc amount is ', amount)\\n        # 如果处于空仓状态\\n        if (account['Balance'] >= 600 and amount < 0.001):\\n            if long==True and account['Balance'] < 400 and amount<0.01:\\n                Log('balance is ', account['Balance'], ' 余额不足400，退出！')\\n                return\\n            elif long== True  and account['Balance'] >= 600: #第一次开多仓\\n                Log('balance is ', account['Balance'])\\n                Log('多仓位时间: ', rn.time, ' open is ', rn.open , ' close is ', rn.close, ' upper is ', u",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " rn.open , ' close is ', rn.close, ' upper is ', upper.iloc[-1], ' volume 0\\\\1 is', volume0 , 'volume 1 is ', volume1 , \\n                ' plus is ',plus.iloc[-1], ' minus is ', minus.iloc[-1], '@')\\n                exchange.Buy(-1,600)\\n                last_price = rn.close + 10\\n                Sleep(1000*60*15)\\n        # 如果处于持仓状态\\n        if  amount>0.001 :\\n            if  amount > 0.0001 and rn.close <= last_price*0.94: \\n                Log('止损平仓事件: ','balance is ', account['Balance'], rn.time, ' rn",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "','balance is ', account['Balance'], rn.time, ' rn.close is ', rn.close, ' @')\\n                id = exchange.Sell(-1, amount);\\n                account = exchange.GetAccount()\\n                amount = account.Stocks\\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n                eid = -1\\n       #如果处于一直持仓又大跌状态，才卖出\\n            elif  amount > 0.0001 and rn.close >= last_price * 1.1 and rn.close <= r.iloc[-24].close*0.9:\\n                Log('持仓周期内的大跌止损平仓事件: ', rn.time, '",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                Log('持仓周期内的大跌止损平仓事件: ', rn.time, ' rn.close is ', rn.close, ' @')\\n                id = exchange.Sell(-1, amount);\\n                eid = -1\\n                account = exchange.GetAccount()\\n                amount = account.Stocks\\n                Log('Balance is ', account['Balance'], ' Btc amount is ', amount)\\n            elif amount > 0.0001 and exit_long == True :\\n                if rn.close <= last_price:\\n                    Log('位置下滑平仓位事件,亏损:  amount is ',amount ,' time is ', rn.tim",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "平仓位事件,亏损:  amount is ',amount ,' time is ', rn.time, ' 价格是：',rn.close,' ma is ', ma.iloc[-1], ' 开仓价格',last_price,' 亏损幅度：',100*(last_price -rn.close)/last_price ,'% @')\\n                    eid = exchange.Sell(-1, amount)\"\n \n\n    \"strategy_11\",\n    \"python\\n'''backtest\\nstart: 2020-05-31 00:00:00\\nend: 2020-08-28 00:00:00\\nperiod: 1day\\nexchanges: [{\\\"eid\\\":\\\"huobi\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\n\\nratio = 0.01\\nacc = 0\\nminStock = 0.01\\n\\ndef main():\\n    global ratio,acc,minStock\\n    exchanges[0].SetP",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  global ratio,acc,minStock\\n    exchanges[0].SetPrecision(2, 3)\\n    Log('hello sltrain@')\\n    #Log(exchanges[0].GetAccount())\\n    tickers = _C(exchanges[0].GetTicker)\\n    #Log(tickers)   \\n    while(True):\\n        tickers_new = _C(exchanges[0].GetTicker)\\n        if tickers_new.Last > tickers.Last * (1 + ratio):\\n            acc = _C(exchanges[0].GetAccount)\\n            id = exchanges[0].Sell(tickers_new.Last, acc.Stocks * ratio)\\n            Log(\\\"id:\\\", id)\\n        elif tickers_new.Last < tickers.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\\", id)\\n        elif tickers_new.Last < tickers.Last * (1 + ratio):\\n            acc = _C(exchanges[0].GetAccount)\\n            id = exchanges[0].Buy(tickers_new.Last, (acc.Balance * ratio)/tickers_new.Last)\\n            Log(\\\"id:\\\", id)\\n        if tickers_new.Last == tickers.Last:\\n            continue\\n        tickers = tickers_new \\n        Sleep(20*60*1000)\",\n    \"策略名称: Lbuy_Hsell-低买高卖\\n\\n未找到描述\"\n \n\n    \"strategy_12\",\n    \"python\\n'''backtest\\nstart: 2023-01-01 00:00:00\\nend: 2023-05-12 00:00:00\\nperi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "023-01-01 00:00:00\\nend: 2023-05-12 00:00:00\\nperiod: 1d\\nbasePeriod: 1h\\nexchanges: [{\\\"eid\\\":\\\"Bitfinex\\\",\\\"currency\\\":\\\"BTC_USD\\\",\\\"stocks\\\":10}]\\n'''\\n\\n\\n# from matplotlib import pyplot as plt\\n# plt.figure()\\n\\nclass ExitTop(object):\\n    def __init__(self,index):\\n        self.index = index \\n        self.totestlist = [] # MACD数据\\n        self.klist = [] # k线数据\\n        self.toplus = []\\n        self.tocpn = []\\n        self.Sell = False\\n    \\n    # 获取k线及MACD数据\\n    def GetRecord(self) -> bool:\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "获取k线及MACD数据\\n    def GetRecord(self) -> bool:\\n        self.totestlist = []\\n        self.klist = []\\n        self.toplus = []\\n        self.tocpn = []\\n        records = exchanges[self.index].GetRecords()\\n        macd = TA.MACD(records, 12, 26, 9)\\n        # 判断DIF是否大于DEA\\n        if not macd[0][-2] > macd[1][-2] and macd[0][-3] < macd[1][-3] or not macd[0][-2] > macd[1][-2] and macd[0][-4] < macd[1][-4]:\\n            return False\\n        self.totestlist = macd[0][len(macd[0])-80:]\\n        # 封装k线数据\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " macd[0][len(macd[0])-80:]\\n        # 封装k线数据\\n        for get in range(len(records)):\\n            self.klist.append(records[get][\\\"Close\\\"])\\n        self.klist = self.klist[len(self.klist)-80:]\\n        return True\\n    \\n    def mepath(self):\\n        if not self.GetRecord():\\n            return False\\n        # 向前遍历发现最大值\\n        maxsign = -1000000000000\\n        for i in range(len(self.totestlist)-1,-1,-1):\\n            if self.totestlist[i] > maxsign:\\n                maxsign = self.totestlist[i]\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                maxsign = self.totestlist[i]\\n                self.tocpn.append([1,i])\\n            else:\\n                if len(self.tocpn) > 0:\\n                    self.tocpn[-1][0] = self.tocpn[-1][0]+1\\n            self.toplus.insert(0,maxsign)\\n        sign = False\\n        shorttime = [0,0] # 步长 , 索引\\n        for i in range(len(self.tocpn)):\\n            if self.tocpn[i][0] > 15 and sign == False:\\n                shorttime = [self.tocpn[i][0],self.tocpn[i][1]]\\n                sign = True\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tocpn[i][1]]\\n                sign = True\\n        # 如果最大索引不是自己\\n        if shorttime[1] < len(self.klist)-4:\\n            # 锁定区域内最高价格\\n            are = max(self.klist[shorttime[1]:-4])\\n            # 判断是否存在大于当前macd值,如果当前价格大于区域内最高价格\\n            if self.totestlist[-2]+300 < self.totestlist[shorttime[1]] and self.klist[-2] >= are:\\n                return True\\n            return False\\n        return False\\n    \\n    def main(self):\\n        result = self.mepath()\\n        if result == True and self.Sell ==",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "path()\\n        if result == True and self.Sell == False:\\n            exchanges[self.index].Sell(-1, num)\\n            self.Sell = True\\n        elif result == False:\\n            if self.Sell == True:\\n                self.Sell = False\\n        # plt.plot(self.totestlist)\\n        # plt.plot(self.toplus)\\n        # LogStatus(plt)\\n\\n\\ndef main():\\n    transaction = []\\n    for index in range(len(exchanges)):\\n        transaction.append(ExitTop(index))\\n    while True:\\n        for tran in range(len(transa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " while True:\\n        for tran in range(len(transaction)):\\n            transaction[tran].main()\\n            Sleep(1000*60)\",\n    \"策略名称: MACD逃顶策略\\n\\n# plt.figure()\\n\\nclass ExitTop(object):\\n    def __init__(self,index):\\n        self.index = index \\n        self.totestlist = [] # MACD数据\\n        self.klist = [] # k线数据\\n        self.toplus = []\\n        self.tocpn = []\\n        self.Sell = False\\n    \\n    # 获取k线及MACD数据\\n    def GetRecord(self) -> bool:\\n        self.totestlist = []\\n        self.klist = [",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      self.totestlist = []\\n        self.klist = []\\n        self.toplus = []\\n        self.tocpn = []\\n        records = exchanges[self.index].GetRecords()\\n        macd = TA.MACD(records, 12, 26, 9)\\n        # 判断DIF是否大于DEA\\n        if not macd[0][-2] > macd[1][-2] and macd[0][-3] < macd[1][-3] or not macd[0][-2] > macd[1][-2] and macd[0][-4] < macd[1][-4]:\\n            return False\\n        self.totestlist = macd[0][len(macd[0])-80:]\\n        # 封装k线数据\\n        for get in range(len(records)):\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     for get in range(len(records)):\\n            self.klist.append(records[get][\\\"Close\\\"])\\n        self.klist = self.klist[len(self.klist)-80:]\\n        return True\\n    \\n    def mepath(self):\\n        if not self.GetRecord():\\n            return False\\n        # 向前遍历发现最大值\\n        maxsign = -1000000000000\\n        for i in range(len(self.totestlist)-1,-1,-1):\\n            if self.totestlist[i] > maxsign:\\n                maxsign = self.totestlist[i]\\n                self.tocpn.append([1,i])\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "              self.tocpn.append([1,i])\\n            else:\\n                if len(self.tocpn) > 0:\\n                    self.tocpn[-1][0] = self.tocpn[-1][0]+1\\n            self.toplus.insert(0,maxsign)\\n        sign = False\\n        shorttime = [0,0] # 步长 , 索引\\n        for i in range(len(self.tocpn)):\\n            if self.tocpn[i][0] > 15 and sign == False:\\n                shorttime = [self.tocpn[i][0],self.tocpn[i][1]]\\n                sign = True\\n        # 如果最大索引不是自己\\n        if shorttime[1] < len(self",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  # 如果最大索引不是自己\\n        if shorttime[1] < len(self.klist)-4:\\n            # 锁定区域内最高价格\\n            are = max(self.klist[shorttime[1]:-4])\\n            # 判断是否存在大于当前macd值,如果当前价格大于区域内最高价格\\n            if self.totestlist[-2]+300 < self.totestlist[shorttime[1]] and self.klist[-2] >= are:\\n                return True\\n            return False\\n        return False\\n    \\n    def main(self):\\n        result = self.mepath()\\n        if result == True and self.Sell == False:\\n            exchanges[self.index].Sell(-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= False:\\n            exchanges[self.index].Sell(-1, num)\\n            self.Sell = True\\n        elif result == False:\\n            if self.Sell == True:\\n                self.Sell = False\\n        # plt.plot(self.totestlist)\\n        # plt.plot(self.toplus)\\n        # LogStatus(plt)\\n\\n\\ndef main():\\n    transaction = []\\n    for index in range(len(exchanges)):\\n        transaction.append(ExitTop(index))\\n    while True:\\n        for tran in range(len(transaction)):\\n            transaction[tran].main()\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "action)):\\n            transaction[tran].main()\\n            Sleep(1000*60)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/356399\\n\\n> Last Modified\\n\\n2023-05-13 21:21:01\"\n \n\n    \"strategy_13\",\n    \"js\\nfunction main() {\\n    // 访问接口获取数据\\n    var r = GetRecords(\\\"ETH-USDT-SWAP\\\", \\\"1H\\\")   // 例如获取ETH U本位永续合约的1小时K线数据\\n\\n    // 输出数据\\n    Log(\\\"K线数据：\\\", r)\\n    Log(\\\"K线数据数量：\\\", r.length)\\n\\n    // 画图输出\\n    $.PlotRecords(r, \\\"K\\\")\\n\\n    // 简单验证\\n    for (var i = 0 ; i < r.length - 1 ; i++) {\\n        if (r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r i = 0 ; i < r.length - 1 ; i++) {\\n        if (r[i + 1].Time - r[i].Time != 1000 * 60 * 60) {\\n            Log(_D(r[i + 1].Time), _D(r[i].Time), r[i + 1].Time - r[i].Time)\\n        }\\n    }\\n}\\n\\n# ==========================================\\n\\npython\\nimport json\\nimport urllib.request\\n\\ndef encodeParams(params):\\n    ret = \\\"\\\"\\n    index = 0 \\n    for key in params:\\n        if index == 0:\\n            ret += key + \\\"=\\\" + str(params[key])\\n        else :\\n            ret += \\\"&\\\" + key + \\\"=\\\" + str(p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " :\\n            ret += \\\"&\\\" + key + \\\"=\\\" + str(params[key])\\n        index += 1\\n    return ret \\n\\ndef GetRecords(symbol, period):\\n    arr = []\\n    after = 0\\n    while True:\\n        params = {\\n            \\\"instId\\\": symbol,\\n            \\\"bar\\\": period,\\n            \\\"limit\\\": 100,\\n        }\\n        if after != 0 :\\n            params[\\\"after\\\"] = after\\n        query = encodeParams(params)        \\n        try :\\n            headers = {\\n                'Accept':'text/html,application/xhtml+xml,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3',\\n                'Accept-Language':'zh-CN,zh;q=0.9',\\n                'Connection':'keep-alive',\\n                'Cookie':'uuid_tt_dd=10_35489889920-1563497330616-876822; ...... ',\\n                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'\\n            }           \\n\\n            url = \\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            }           \\n\\n            url = \\\"https://www.okex.com/api/v5/market/candles?\\\" + query\\n            req = urllib.request.Request(url=url,headers=headers)\\n            r = json.loads(urllib.request.urlopen(req).read().decode('utf-8'))[\\\"data\\\"]\\n            for i in range(len(r)):\\n                record = {}\\n                record[\\\"Time\\\"] = int(r[i][0])\\n                record[\\\"High\\\"] = float(r[i][2])\\n                record[\\\"Open\\\"] = float(r[i][1])\\n                record[\\\"Low\\\"] =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " float(r[i][1])\\n                record[\\\"Low\\\"] = float(r[i][3])\\n                record[\\\"Close\\\"] = float(r[i][4])\\n                record[\\\"Volume\\\"] = float(r[i][5])\\n                arr.append(record)\\n                after = record[\\\"Time\\\"]\\n            if len(arr) >= 1440 or len(r) == 0:\\n                break\\n        except Exception as e:\\n            Log(e)\\n            return \\n        Sleep(1000)\\n    arr.reverse()    \\n    return arr \\n    \\ndef main():\\n    r = GetRecords(\\\"ETH-USDT-SWAP\\\",",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "def main():\\n    r = GetRecords(\\\"ETH-USDT-SWAP\\\", \\\"1H\\\")\\n    \\n    Log(\\\"K线数据：\\\", r)\\n    Log(\\\"K线数据数量：\\\", len(r))\\n    \\n    ext.PlotRecords(r, \\\"K\\\")\\n    \\n    for i in range(len(r) - 1):\\n        if r[i + 1][\\\"Time\\\"] - r[i][\\\"Time\\\"] != 1000 * 60 * 60:\\n            Log(_D(r[i + 1][\\\"Time\\\"] / 1000), _D(r[i][\\\"Time\\\"] / 1000), r[i + 1][\\\"Time\\\"] - r[i][\\\"Time\\\"])\",\n    \"策略名称: OKEX-V5-K线数据分页查询例子-Python版\\n\\n由于OKEX V5接口一次调用最多只有100根，需要分页查询。所以封装了一个例子，如何分页查询K线接口，获取1440根K线数据。\\n\\n```js\\nfunction main() {\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "询K线接口，获取1440根K线数据。\\n\\n```js\\nfunction main() {\\n    // 访问接口获取数据\\n    var r = GetRecords(\\\"ETH-USDT-SWAP\\\", \\\"1H\\\")   // 例如获取ETH U本位永续合约的1小时K线数据\\n\\n    // 输出数据\\n    Log(\\\"K线数据：\\\", r)\\n    Log(\\\"K线数据数量：\\\", r.length)\\n\\n    // 画图输出\\n    $.PlotRecords(r, \\\"K\\\")\\n\\n    // 简单验证\\n    for (var i = 0 ; i < r.length - 1 ; i++) {\\n        if (r[i + 1].Time - r[i].Time != 1000 * 60 * 60) {\\n            Log(_D(r[i + 1].Time), _D(r[i].Time), r[i + 1].Time - r[i].Time)\\n        }\\n    }\\n}\\n```\\n\\n![IMG](https://www.fmz.c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      }\\n    }\\n}\\n```\\n\\n![IMG](https://www.fmz.com/upload/asset/16d33bb293b09726b5dc.png) \\n\\n```main```函数是使用例子，其它函数可以摘出来直接使用。\\n\\n\\n\\n> Source (python)\\n\\n``` python\\nimport json\\nimport urllib.request\\n\\ndef encodeParams(params):\\n    ret = \\\"\\\"\\n    index = 0 \\n    for key in params:\\n        if index == 0:\\n            ret += key + \\\"=\\\" + str(params[key])\\n        else :\\n            ret += \\\"&\\\" + key + \\\"=\\\" + str(params[key])\\n        index += 1\\n    return ret \\n\\ndef GetRecords(symbol, period):\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  return ret \\n\\ndef GetRecords(symbol, period):\\n    arr = []\\n    after = 0\\n    while True:\\n        params = {\\n            \\\"instId\\\": symbol,\\n            \\\"bar\\\": period,\\n            \\\"limit\\\": 100,\\n        }\\n        if after != 0 :\\n            params[\\\"after\\\"] = after\\n        query = encodeParams(params)        \\n        try :\\n            headers = {\\n                'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "age/apng,*/*;q=0.8,application/signed-exchange;v=b3',\\n                'Accept-Language':'zh-CN,zh;q=0.9',\\n                'Connection':'keep-alive',\\n                'Cookie':'uuid_tt_dd=10_35489889920-1563497330616-876822; ...... ',\\n                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'\\n            }           \\n\\n            url = \\\"https://www.okex.com/api/v5/market/candles?\\\" + query\\n            req = urllib.reque",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "candles?\\\" + query\\n            req = urllib.request.Request(url=url,headers=headers)\\n            r = json.loads(urllib.request.urlopen(req).read().decode('utf-8'))[\\\"data\\\"]\\n            for i in range(len(r)):\\n                record = {}\\n                record[\\\"Time\\\"] = int(r[i][0])\\n                record[\\\"High\\\"] = float(r[i][2])\\n                record[\\\"Open\\\"] = float(r[i][1])\\n                record[\\\"Low\\\"] = float(r[i][3])\\n                record[\\\"Close\\\"] = float(r[i][4])\\n                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cord[\\\"Close\\\"] = float(r[i][4])\\n                record[\\\"Volume\\\"] = float(r[i][5])\\n                arr.append(record)\\n                after = record[\\\"Time\\\"]\\n            if len(arr) >= 1440 or len(r) == 0:\\n                break\\n        except Exception as e:\\n            Log(e)\\n            return \\n        Sleep(1000)\\n    arr.reverse()    \\n    return arr \\n    \\ndef main():\\n    r = GetRecords(\\\"ETH-USDT-SWAP\\\", \\\"1H\\\")\\n    \\n    Log(\\\"K线数据：\\\", r)\\n    Log(\\\"K线数据数量：\\\", len(r))\\n    \\n    ext.Pl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r)\\n    Log(\\\"K线数据数量：\\\", len(r))\\n    \\n    ext.PlotRecords(r, \\\"K\\\")\\n    \\n    for i in range(len(r) - 1):\\n        if r[i + 1][\\\"Time\\\"] - r[i][\\\"Time\\\"] != 1000 * 60 * 60:\\n            Log(_D(r[i + 1][\\\"Time\\\"] / 1000), _D(r[i][\\\"Time\\\"] / 1000), r[i + 1][\\\"Time\\\"] - r[i][\\\"Time\\\"])\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/316746\\n\\n> Last Modified\\n\\n2021-09-16 11:35:10\"\n \n\n    \"strategy_14\",\n    \"python\\n#!/usr/bin/python\\n# coding=UTF-8\\n\\nimport hmac\\nimport base64\\nimport urllib\\nfrom has",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mport hmac\\nimport base64\\nimport urllib\\nfrom hashlib import sha256\\nimport datetime\\nimport json\\nimport requests\\nfrom logger import logger\\n\\n\\nclass Okex(object):\\n\\n    def __init__(self, api_key, secret_key, passphrase):\\n        self.api_key = api_key\\n        self.secret_key = secret_key\\n        self.passphrase = passphrase\\n        self.host = 'https://www.okex.com'\\n        self.timestamp = ''\\n        self.method = ''\\n        self.request_path = ''\\n\\n    # 下单\\n    def trade_order(self, symbol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= ''\\n\\n    # 下单\\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\\\"market\\\", px=None):\\n        self.request_path = '/api/v5/trade/order'\\n        self.method = 'POST'\\n        inst_id = symbol.upper() + '-USDT-SWAP'\\n        post_data = {\\n            'instId': inst_id,\\n            'tdMode': 'cross',\\n            'side': trade_side,\\n            'ordType': ord_type,\\n            'posSide': pos_side,\\n            'sz': str(sz),\\n            'tag': 'BrokerCode',\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "z),\\n            'tag': 'BrokerCode',\\n            'clOrdId': '4dc650bdb59cBCDE' + str(client_id)\\n        }\\n        if ord_type == 'limit':\\n            post_data['px'] = str(px)\\n        try:\\n            # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\\n            order = self.send(post_data)\\n            # print(order)\\n            if len(order['data']) == 0:\\n                return {\\\"code\\\": 2, \\\"msg\\\": 'OKEX下单接口返回数据错误', \\\"data\\\": {}}\\n            order_info = order['data'][0]\\n            if order['code'] == '0' and ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ata'][0]\\n            if order['code'] == '0' and order_info['sCode'] == '0':\\n                return {\\\"code\\\": 0, \\\"msg\\\": 'success', \\\"data\\\": order_info}\\n\\n            if order_info['sCode'] == '50004' or order_info['sCode'] == '51029' or order_info['sCode'] == '51030':\\n                #  失败, 稍后可重试\\n                return {\\\"code\\\": 1, \\\"msg\\\": order_info['sMsg'], \\\"data\\\": {}}\\n            if order_info['sCode'] == '51008':\\n                # 失败, 暂停买入\\n                return {\\\"code\\\": 3, \\\"msg\\\": or",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                return {\\\"code\\\": 3, \\\"msg\\\": order_info['sMsg'], \\\"data\\\": {}}\\n        except Exception as e:\\n            return {\\\"code\\\": 2, \\\"msg\\\": str(e), \\\"data\\\": {}}\\n        # 失败, 暂停运行\\n        return {\\\"code\\\": 2, \\\"msg\\\": order_info['sMsg'], \\\"data\\\": {}}\\n\\n    # 撤单\\n    def cancel_order(self, data):\\n        self.request_path = '/api/v5/trade/cancel-batch-orders'\\n        self.method = 'POST'\\n        try:\\n            order = self.send(data)\\n            if len(order['data']) == 0:\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "a)\\n            if len(order['data']) == 0:\\n                return {\\\"code\\\": 3, \\\"msg\\\": 'OKEX撤单接口返回数据错误', \\\"data\\\": {}}\\n            if order['code'] == '0':\\n                return {\\\"code\\\": 0, \\\"msg\\\": 'success', \\\"data\\\": order}\\n\\n        except Exception as e:\\n            # logger.error(e)\\n            return {\\\"code\\\": 3, \\\"msg\\\": str(e), \\\"data\\\": {}}\\n        # 失败, 暂停运行\\n        return {\\\"code\\\": 3, \\\"msg\\\": order['msg'], \\\"data\\\": {}}\\n\\n    # 获取挂单列表\\n    def get_open_order(self):\\n        sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "获取挂单列表\\n    def get_open_order(self):\\n        self.request_path = '/api/v5/trade/orders-pending'\\n        self.method = 'GET'\\n        post_data = {\\n            'instType': 'SWAP',\\n        }\\n        order = self.send(post_data)\\n        if order['code'] != '0':\\n            raise ValueError(order['msg'])\\n        return order['data']\\n\\n    # 获取持仓列表\\n    def get_positions(self, symbol=None):\\n        self.request_path = '/api/v5/account/positions'\\n        self.method = 'GET'\\n        post_data = {\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   self.method = 'GET'\\n        post_data = {\\n            'instType': 'SWAP',\\n        }\\n        if symbol:\\n            post_data['instId'] = symbol.upper() + '-USDT-SWAP'\\n\\n        order = self.send(post_data)\\n        if order['code'] != '0':\\n            raise ValueError(order['msg'])\\n        return order['data']\\n\\n    # 获取k线\\n    def get_kline(self, symbol, limit, interval, after=None):\\n        self.request_path = '/api/v5/market/history-candles'\\n        self.method = 'GET'\\n\\n        post_data ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        self.method = 'GET'\\n\\n        post_data = {\\n            'instId': symbol.upper() + '-USDT-SWAP',\\n            'bar': interval,\\n            'limit': limit,\\n        }\\n        if after:\\n            post_data['after'] = after\\n        order = self.send(post_data)\\n        if order['code'] != '0':\\n            raise ValueError(order['msg'])\\n        return order['data']\\n\\n    # 签名\\n    def generate_sign(self, data):\\n        if self.method == 'GET':\\n            self.request_path = self.request_p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "':\\n            self.request_path = self.request_path + '?' + urllib.parse.urlencode(data)\\n        req_str = self.timestamp + self.method + self.request_path\\n\\n        if self.method == 'POST':\\n            req_str = (req_str + json.dumps(data))\\n\\n        req_strs = req_str.encode('utf-8')\\n        signature = base64.b64encode(hmac.new(self.secret_key.encode('utf-8'), req_strs, digestmod=sha256).digest())\\n        return signature\\n\\n    # 时间戳\\n    def set_timestamp(self):\\n        utc_t = datetime.datet",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t_timestamp(self):\\n        utc_t = datetime.datetime.utcnow().isoformat()\\n        self.timestamp = utc_t[:-3] + 'Z'\\n\\n    # 请求\\n    def send(self, data):\\n        self.set_timestamp()\\n        headers = {\\n            'Accept': 'application/json',\\n            'Content-Type': 'application/json',\\n            'OK-ACCESS-KEY': self.api_key,\\n            'OK-ACCESS-SIGN': self.generate_sign(data),\\n            'OK-ACCESS-TIMESTAMP': self.timestamp,\\n            'OK-ACCESS-PASSPHRASE': self.passphrase,\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    'OK-ACCESS-PASSPHRASE': self.passphrase,\\n        }\\n        if self.method == 'GET':\\n            response = requests.get(self.host + self.request_path, headers=headers, timeout=30)\\n        else:\\n            post_data = json.dumps(data)\\n            response = requests.post(self.host + self.request_path, headers=headers, data=post_data, timeout=30)\\n        # logger.info('okex请求信息')\\n        # logger.info(data)\\n        # logger.info(response.text)\\n        return json.loads(response.text)\",\n    \"策略名",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       return json.loads(response.text)\",\n    \"策略名称: OKX部分交易封装示例\\n\\nimport hmac\\nimport base64\\nimport urllib\\nfrom hashlib import sha256\\nimport datetime\\nimport json\\nimport requests\\nfrom logger import logger\\n\\n\\nclass Okex(object):\\n\\n    def __init__(self, api_key, secret_key, passphrase):\\n        self.api_key = api_key\\n        self.secret_key = secret_key\\n        self.passphrase = passphrase\\n        self.host = 'https://www.okex.com'\\n        self.timestamp = ''\\n        self.method = ''\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".timestamp = ''\\n        self.method = ''\\n        self.request_path = ''\\n\\n    # 下单\\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\\\"market\\\", px=None):\\n        self.request_path = '/api/v5/trade/order'\\n        self.method = 'POST'\\n        inst_id = symbol.upper() + '-USDT-SWAP'\\n        post_data = {\\n            'instId': inst_id,\\n            'tdMode': 'cross',\\n            'side': trade_side,\\n            'ordType': ord_type,\\n            'posSide': pos_side,\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " ord_type,\\n            'posSide': pos_side,\\n            'sz': str(sz),\\n            'tag': 'BrokerCode',\\n            'clOrdId': '4dc650bdb59cBCDE' + str(client_id)\\n        }\\n        if ord_type == 'limit':\\n            post_data['px'] = str(px)\\n        try:\\n            # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\\n            order = self.send(post_data)\\n            # print(order)\\n            if len(order['data']) == 0:\\n                return {\\\"code\\\": 2, \\\"msg\\\": 'OKEX下单接口返回数据错误', \\\"data\\\": {}}\\n            or",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\": 'OKEX下单接口返回数据错误', \\\"data\\\": {}}\\n            order_info = order['data'][0]\\n            if order['code'] == '0' and order_info['sCode'] == '0':\\n                return {\\\"code\\\": 0, \\\"msg\\\": 'success', \\\"data\\\": order_info}\\n\\n            if order_info['sCode'] == '50004' or order_info['sCode'] == '51029' or order_info['sCode'] == '51030':\\n                #  失败, 稍后可重试\\n                return {\\\"code\\\": 1, \\\"msg\\\": order_info['sMsg'], \\\"data\\\": {}}\\n            if order_info['sCode'] == '51008':\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       if order_info['sCode'] == '51008':\\n                # 失败, 暂停买入\\n                return {\\\"code\\\": 3, \\\"msg\\\": order_info['sMsg'], \\\"data\\\": {}}\\n        except Exception as e:\\n            return {\\\"code\\\": 2, \\\"msg\\\": str(e), \\\"data\\\": {}}\\n        # 失败, 暂停运行\\n        return {\\\"code\\\": 2, \\\"msg\\\": order_info['sMsg'], \\\"data\\\": {}}\\n\\n    # 撤单\\n    def cancel_order(self, data):\\n        self.request_path = '/api/v5/trade/cancel-batch-orders'\\n        self.method = 'POST'\\n        try:\\n            or",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "self.method = 'POST'\\n        try:\\n            order = self.send(data)\\n            if len(order['data']) == 0:\\n                return {\\\"code\\\": 3, \\\"msg\\\": 'OKEX撤单接口返回数据错误', \\\"data\\\": {}}\\n            if order['code'] == '0':\\n                return {\\\"code\\\": 0, \\\"msg\\\": 'success', \\\"data\\\": order}\\n\\n        except Exception as e:\\n            # logger.error(e)\\n            return {\\\"code\\\": 3, \\\"msg\\\": str(e), \\\"data\\\": {}}\\n        # 失败, 暂停运行\\n        return {\\\"code\\\": 3, \\\"msg\\\": order['msg'], \\\"da",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  return {\\\"code\\\": 3, \\\"msg\\\": order['msg'], \\\"data\\\": {}}\\n\\n    # 获取挂单列表\\n    def get_open_order(self):\\n        self.request_path = '/api/v5/trade/orders-pending'\\n        self.method = 'GET'\\n        post_data = {\\n            'instType': 'SWAP',\\n        }\\n        order = self.send(post_data)\\n        if order['code'] != '0':\\n            raise ValueError(order['msg'])\\n        return order['data']\\n\\n    # 获取持仓列表\\n    def get_positions(self, symbol=None):\\n        self.request_path = '/api/v5/accoun",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "one):\\n        self.request_path = '/api/v5/account/positions'\\n        self.method = 'GET'\\n        post_data = {\\n            'instType': 'SWAP',\\n        }\\n        if symbol:\\n            post_data['instId'] = symbol.upper() + '-USDT-SWAP'\\n\\n        order = self.send(post_data)\\n        if order['code'] != '0':\\n            raise ValueError(order['msg'])\\n        return order['data']\\n\\n    # 获取k线\\n    def get_kline(self, symbol, limit, interval, after=None):\\n        self.request_path = '/api/v5/marke",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "None):\\n        self.request_path = '/api/v5/market/history-candles'\\n        self.method = 'GET'\\n\\n        post_data = {\\n            'instId': symbol.upper() + '-USDT-SWAP',\\n            'bar': interval,\\n            'limit': limit,\\n        }\\n        if after:\\n            post_data['after'] = after\\n        order = self.send(post_data)\\n        if order['code'] != '0':\\n            raise ValueError(order['msg'])\\n        return order['data']\\n\\n    # 签名\\n    def generate_sign(self, data):\\n        if ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "名\\n    def generate_sign(self, data):\\n        if self.method == 'GET':\\n            self.request_path = self.request_path + '?' + urllib.parse.urlencode(data)\\n        req_str = self.timestamp + self.method + self.request_path\\n\\n        if self.method == 'POST':\\n            req_str = (req_str + json.dumps(data))\\n\\n        req_strs = req_str.encode('utf-8')\\n        signature = base64.b64encode(hmac.new(self.secret_key.encode('utf-8'), req_strs, digestmod=sha256).digest())\\n        return signature\\n\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=sha256).digest())\\n        return signature\\n\\n    # 时间戳\\n    def set_timestamp(self):\\n        utc_t = datetime.datetime.utcnow().isoformat()\\n        self.timestamp = utc_t[:-3] + 'Z'\\n\\n    # 请求\\n    def send(self, data):\\n        self.set_timestamp()\\n        headers = {\\n            'Accept': 'application/json',\\n            'Content-Type': 'application/json',\\n            'OK-ACCESS-KEY': self.api_key,\\n            'OK-ACCESS-SIGN': self.generate_sign(data),\\n            'OK-ACCESS-TIMESTAMP': self.t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(data),\\n            'OK-ACCESS-TIMESTAMP': self.timestamp,\\n            'OK-ACCESS-PASSPHRASE': self.passphrase,\\n        }\\n        if self.method == 'GET':\\n            response = requests.get(self.host + self.request_path, headers=headers, timeout=30)\\n        else:\\n            post_data = json.dumps(data)\\n            response = requests.post(self.host + self.request_path, headers=headers, data=post_data, timeout=30)\\n        # logger.info('okex请求信息')\\n        # logger.info(data)\\n        # logger.inf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        # logger.info(data)\\n        # logger.info(response.text)\\n        return json.loads(response.text)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/417576\\n\\n> Last Modified\\n\\n2023-06-14 17:57:16\"\n \n\n    \"strategy_15\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n# \\n# Market Real-time Subscription v3\\n#\\n# Copyright 2019 FawkesPan\\n#\\n# Do What the Fuck You Want To Public License\\n#\\n\\n\\nimport time\\nimport ssl\\nimport sys\\nimport code\\nimport json\\nimport has",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\nimport sys\\nimport code\\nimport json\\nimport hashlib\\nimport hmac\\nimport urllib\\nimport threading\\nimport websocket\\nimport zlib\\nimport string\\n\\ntry:\\n    import readline\\nexcept ImportError:\\n    pass\\n\\npong = time.time()\\n\\nclass WSSubscription:\\n\\n    def __init__(self, instrument_id='BTC-USD-190517', market='futures', on_message=None):\\n        self.__iid = instrument_id\\n        self.__market = market\\n        self.__Depth = {}\\n        \\n        if on_message is not None:\\n            self.__cal",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if on_message is not None:\\n            self.__callbackEnabled = True\\n            self.__callback = on_message\\n        else:\\n            self.__callbackEnabled = False\\n\\n        thread = threading.Thread(target=self.sub, args=())\\n        thread.daemon = True\\n        thread.start()\\n\\n    def GetDepth(self):\\n        return self.__Depth\\n\\n    def subscribe(self, ws):\\n        \\n        def operator(op, args):\\n            message = {\\n                'op': op,\\n                'args': args\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "op': op,\\n                'args': args\\n            }\\n            ws.send(json.dumps(message))\\n\\n        def run(*args):\\n            operator('subscribe', ['%s/depth5:%s' % (self.__market, self.__iid)])\\n            operator('subscribe', ['%s/trade:%s' % (self.__market, self.__iid)])\\n\\n            while True:\\n                ws.send(\\\"ping\\\")\\n                time.sleep(30)\\n\\n        threading.Thread(target=run).start()\\n\\n    def sub(self):\\n\\n        websocket.enableTrace(False)\\n        URL = \\\"wss",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " websocket.enableTrace(False)\\n        URL = \\\"wss://real.okex.com:10442/ws/v3\\\"\\n        ws = websocket.WebSocketApp(URL,\\n                                    on_message=self.incoming,\\n                                    on_error=self.error_handling,\\n                                    on_close=self.closing)\\n\\n        ws.on_open = self.subscribe\\n\\n        while True:\\n            try:\\n                ws.run_forever()\\n            except:\\n                pass\\n\\n        pass\\n\\n    def incoming(self,w",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   pass\\n\\n        pass\\n\\n    def incoming(self,ws,message):\\n        message = zlib.decompress(message, -zlib.MAX_WBITS)\\n        message = message.decode('utf-8')\\n        global pong\\n        if 'pong' in message:\\n            pong = time.time()\\n        if 'asks' in message and 'bids' in message:\\n            d = json.loads(message)\\n            self.__Depth = d['data'][0]\\n            \\n        if self.__callbackEnabled:\\n            self.__callback(message)\\n    \\n\\n    def error_handling(self,ws,err",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ssage)\\n    \\n\\n    def error_handling(self,ws,error):\\n        print(str(error))\\n\\n    def closing(self,ws):\\n        print(\\\"WebSocket Closing...\\\")\\n        \\next.OkEXWS = WSSubscription\\n\\n# 模块测试\\ndef main():\\n    OkEX = ext.OkEXWS('BTC-USD-190517', 'futures')\\n    while (True):\\n        Log(OkEX.GetDepth())\\n        time.sleep(1)\",\n    \"策略名称: OkEX-Websocket-Realtime-v3\\n\\n因为 `websocket-client` 新版的各种大脑降级设计 很多功能无法使用\\n需要安装老版本websocket-client的包才能正常使用 `pip3 install websocket-client==0.46.0`\\n\\n\\n\\n> Source",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " install websocket-client==0.46.0`\\n\\n\\n\\n> Source (python)\\n\\n``` python\"\n \n\n    \"strategy_16\",\n    \"python\\n\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n#\\n# OkEX Advanced API Interface for FMZ.com.\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# GNU General Public License v3.0\\n#\\n\\nimport json\\nimport time\\n\\nQUOTES = {}\\nQUOTES['ZH'] = {\\n    'GREET' : '[OkEX 接口已初始化]  币种: %s 合约: %s. %s',\\n    'INITF' : '使用的交易所不正确，当前交易所: %s',\\n    'PARAMERR' : ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "INITF' : '使用的交易所不正确，当前交易所: %s',\\n    'PARAMERR' : '***传的参数不对 检查你的代码*** %s',\\n    'NEWORDER' : '[添加订单]  币种: %s 合约: %s 方向: %s 价格: %.4f 数量: %d 张. %s',\\n    'ORDCOUNT' : '[本次批量发送订单]  总计: %d 条. %s',\\n    'THISBATCH' : '[信息]  正在处理 币种: %s 合约: %s 条数: %d. %s',\\n    'ORDSENT' : '[已发送订单]  币种: %s 合约: %s 条数: %d. %s',\\n    'NEEDSPLIT' : '[信息]  由于单合约单量大于5条 需要进行分片处理. %s',\\n    'CLEARALL' : '[信息]  已清除所有本地订单. %s',\\n    'CLEARS' : '[信息]  已清除所有 %s 本地订单. %s',\\n    'CLEAR' : '[信息]  已清除所有 %s %s 本地订单. %s'\\n}\\n\\nCOLORS = {\\n    'DE",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]  已清除所有 %s %s 本地订单. %s'\\n}\\n\\nCOLORS = {\\n    'DEEPBLUE' : '#1F618D',\\n    'BLUE' : '#0000FF',\\n    'LIGHTBLUE' : '#5DADE2',\\n    'DEEPGREEN' : '#27AE60',\\n    'GREEN' : '#00FF00',\\n    'LIGHTGREEN' : '#58D68D',\\n    'LAPIS' : '#26619C',\\n    'DEEPRED' : '#CB4335',\\n    'RED' : '#FF0000',\\n    'LIGHTRED' : '#EC7063'\\n}\\n\\n\\nclass OkEXFuture:\\n\\n    def __init__(self, exchange, future='this_week'):\\n        self.QUOTES = {}\\n        exchange.GetCurrency()\\n        if isinstance(exchange.GetCurrency(), bytes",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       if isinstance(exchange.GetCurrency(), bytes):\\n            self.symbol = str(exchange.GetCurrency(), \\\"utf-8\\\").lower()\\n            name = str(exchange.GetName(), \\\"utf-8\\\")\\n        else:\\n            self.symbol = exchange.GetCurrency()\\n            name = exchange.GetName()\\n        self.IO = exchange.IO\\n        self.future = future\\n        self.bulks = {}\\n        self.bulks[self.symbol] = {}\\n        self.bulks[self.symbol][self.future] = []\\n        if 'OKCoin' in str(name):\\n            Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        if 'OKCoin' in str(name):\\n            Log(QUOTES[LANG]['GREET'] % (self.symbol.upper(),self.future.upper(),COLORS['LAPIS']))\\n        else:\\n            Log(QUOTES[LANG]['INITF'] % (name))\\n\\n    def BulkAdd(self, side=None, price=None, amount=None, matchPrice=False, symbol=None, future=None):\\n        if type is None or price is None or amount is None:\\n            Log(QUOTES[LANG]['PARAMERR'] % (COLORS['RED']))\\n            return False\\n        side = side.lower()\\n        if side == 'buy':\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ide = side.lower()\\n        if side == 'buy':\\n            tp = 1\\n            cl = COLORS['DEEPGREEN']\\n        if side == 'sell':\\n            tp = 2\\n            cl = COLORS['DEEPRED']\\n        if side == 'closebuy':\\n            tp = 3\\n            cl = COLORS['LIGHTRED']\\n        if side == 'closesell':\\n            tp = 4\\n            cl = COLORS['LIGHTGREEN']\\n        if symbol is None:\\n            symbol = self.symbol\\n        if future is None:\\n            future = self.future\\n\\n        order = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          future = self.future\\n\\n        order = {}\\n        order['price'] = price\\n        order['amount'] = amount\\n        order['type'] = tp\\n\\n        if matchPrice:\\n            order['matchPrice'] = 1\\n\\n        try:\\n            self.bulks[symbol]\\n        except KeyError:\\n            self.bulks[symbol] = {}\\n        try:\\n            self.bulks[symbol][future]\\n        except KeyError:\\n            self.bulks[symbol][future] = []\\n\\n        self.bulks[symbol][future].append(order)\\n\\n        Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bulks[symbol][future].append(order)\\n\\n        Log(QUOTES[LANG]['NEWORDER'] % (symbol.upper(),future.upper(),side.upper(),price,amount,cl))\\n\\n        return True\\n\\n    def BulkOrders(self, symbol=None, future=None):\\n        if symbol is None:\\n            return self.bulks\\n        else:\\n            if future is None:\\n                return self.bulks[symbol]\\n            else:\\n                return self.bulks[symbol][future]\\n\\n    def BulkClear(self, symbol=None, future=None, notify=True):\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", symbol=None, future=None, notify=True):\\n        if symbol is None:\\n            self.bulks = {}\\n            if notify:\\n                Log(QUOTES[LANG]['CLEARALL'] % (COLORS['RED']))\\n        else:\\n            if future is None:\\n                self.bulks[symbol] = {}\\n                if notify:\\n                     Log(QUOTES[LANG]['CLEARS'] % (symbol.encode().upper(), COLORS['RED']))\\n            else:\\n                self.bulks[symbol][future] = []\\n                if notify:\\n                  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[]\\n                if notify:\\n                    Log(QUOTES[LANG]['CLEAR'] % (symbol.encode().upper(), future.encode().upper(), COLORS['RED']))\\n                    #Log(QUOTES[LANG]['CLEAR'] % (symbol.upper(), future.upper(), COLORS['RED']))\\n\\n        return True\\n\\n    #exchange.IO(\\\"api\\\", \\\"POST\\\", \\\"/api/v1/future_batch_trade.do\\\", \\\"symbol=etc_usd&contract_type=this_week&orders_data=\\\"+json.dumps(orders))\\n    def __post(self, symbol='', future=''):\\n        count = len(self.bulks[symbol][future])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n        count = len(self.bulks[symbol][future])\\n        orders = self.bulks[symbol][future]\\n        ret = []\\n        if count == 0:\\n            return\\n        Log(QUOTES[LANG]['THISBATCH'] % (symbol.upper(),future.upper(),count,COLORS['LAPIS']))\\n        if count <= 5:\\n            params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(orders))\\n            res = self.IO(\\\"api\\\", \\\"POST\\\", \\\"/api/v1/future_batch_trade.do\\\", params)\\n            ret+=res['order_info']\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", params)\\n            ret+=res['order_info']\\n            Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(orders),COLORS['LAPIS']))\\n        if count > 5:\\n            Log(QUOTES[LANG]['NEEDSPLIT'] % (COLORS['LAPIS']))\\n            batch = []\\n            for item in orders:\\n                batch.append(item)\\n                if len(batch) == 5:\\n                    params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(batch))\\n                    res = self.I",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "on.dumps(batch))\\n                    res = self.IO(\\\"api\\\", \\\"POST\\\", \\\"/api/v1/future_batch_trade.do\\\", params)\\n                    try:\\n                        ret+=res['order_info']\\n                    except:\\n                        pass\\n                    Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(batch),COLORS['LAPIS']))\\n                    batch = []\\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\\n\\n            params = 'symbol=%s&contract_type=%s&",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            params = 'symbol=%s&contract_type=%s&orders_data=%s' % (symbol, future, json.dumps(batch))\\n            res = self.IO(\\\"api\\\", \\\"POST\\\", \\\"/api/v1/future_batch_trade.do\\\", params)\\n            try:\\n                ret+=res['order_info']\\n            except:\\n                pass\\n            Log(QUOTES[LANG]['ORDSENT'] % (symbol.upper(),future.upper(),len(batch),COLORS['LAPIS']))\\n\\n        return ret\\n\\n    def BulkPost(self, symbol=None, future=None):\\n        ret = []\\n        count = 0\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "re=None):\\n        ret = []\\n        count = 0\\n        if symbol is None:\\n            symbols = self.bulks.keys()\\n            for s in symbols:\\n                futures = self.bulks[s].keys()\\n                for f in futures:\\n                    count+=len(self.bulks[s][f])\\n                    ret+=self.__post(s, f)\\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\\n\\n            self.BulkClear(notify=False)\\n        else:\\n            if future is None:\\n                futures = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    if future is None:\\n                futures = self.bulks[symbol].keys()\\n                for f in futures:\\n                    count+=len(self.bulks[symbol][f])\\n                    ret+=self.__post(symbol, f)\\n                    time.sleep(0.3)               # OkEX限制每秒只能进行三个请求\\n\\n                self.BulkClear(symbol=symbol, notify=False)\\n            else:\\n                count+=len(self.bulks[symbol][future])\\n                ret+=self.__post(symbol, future)\\n\\n                self.BulkClear(symbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l, future)\\n\\n                self.BulkClear(symbol=symbol, future=future, notify=False)\\n\\n        Log(QUOTES[LANG]['ORDCOUNT'] % (count,COLORS['LAPIS']))\\n        return ret\\n\\nclass OkEXSpot:\\n\\n    def __init__(self, exchange):\\n        self.IO = exchange.IO\\n\\n    #TBD\\n\\next.OkEXFuturePlus = OkEXFuture # 导出OkEXFuture Class, 主策略可以通过FuturePlus = ext.OkEXFuturePlus(exchange, future)调用\\next.OkEXSpotPlus = OkEXSpot # 导出OkEXSpot Class, 主策略可以通过SpotPlus = ext.OkEXSpotPlus(exchange)调用\\n\\n# 模块功能测试\\ndef main():\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "OkEXSpotPlus(exchange)调用\\n\\n# 模块功能测试\\ndef main():\\n    LogReset()\\n    Log(exchange.GetAccount())\\n    OKEXPlus = ext.OkEXFuturePlus(exchange)\\n    # 4 Buy 2 Sell 1 next_week\\n    base_price = exchange.GetTicker()['Last']\\n    OKEXPlus.BulkAdd(\\\"sell\\\", base_price*1.2, 1)\\n    OKEXPlus.BulkAdd(\\\"closebuy\\\", base_price*1.2, 1)\\n    OKEXPlus.BulkAdd(\\\"sell\\\", base_price*1.3, 1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.7, 1, future='next_week')\\n\\n    OKEXPlus.BulkClear()\\n\\n    OKEXPlus.BulkAdd(\\\"buy\\\", ba",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "us.BulkClear()\\n\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.8, 1)\\n    OKEXPlus.BulkAdd(\\\"closebuy\\\", base_price*1.2, 1)\\n    OKEXPlus.BulkAdd(\\\"sell\\\", base_price*1.3, 1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.7, 1, future='next_week')\\n\\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower(),future='this_week')\\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower(),future='next_week')\\n\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.8, 1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.7, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.7, 1, future='next_week')\\n    OKEXPlus.BulkClear(symbol=(exchange.GetCurrency()).lower())\\n\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.8, 1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.81, 1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.82, 1)\\n    OKEXPlus.BulkAdd(\\\"closesell\\\", base_price*0.8, 1)\\n    OKEXPlus.BulkAdd(\\\"sell\\\", base_price*1.2, 1)\\n    OKEXPlus.BulkAdd(\\\"closebuy\\\", base_price*1.2, 1)\\n    OKEXPlus.BulkAdd(\\\"sell\\\", base_price*1.3, 1)\\n    OK",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "XPlus.BulkAdd(\\\"sell\\\", base_price*1.3, 1)\\n    OKEXPlus.BulkAdd(\\\"buy\\\", base_price*0.7, 1, future='next_week')\\n\\n    Log(OKEXPlus.BulkOrders())\\n    for item in OKEXPlus.BulkPost():\\n        Log(str(item))\\n    Log(OKEXPlus.BulkOrders())\",\n    \"策略名称: OkEX-高级API功能-V110-期货批量下单现货TBD-Python2-3\\n\\n### 初始化\\n这个库整合了一些 OkEX 高级API 功能，使用前需要进行初始化。\"\n \n\n    \"strategy_17\",\n    \"python\\n\\nimport time\\nimport math\\nimport threading\\nimport decimal\\nfrom uuid import uuid4 as _uuid\\n\\ndef genUUID():\\n    return str(_uuid()",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "as _uuid\\n\\ndef genUUID():\\n    return str(_uuid())\\n\\nclass PositionManager:\\n\\n    def __init__(self, exchange, symbol, contract, getDepth, tickSize=0.01):\\n        self.okex = exchange\\n        self.symbol = symbol\\n        self.contract = contract\\n        self.tickSize = tickSize\\n        self.isFMZ = False\\n        if 'Asks' in getDepth().keys():\\n            self.isFMZ = True\\n        self.okexGetDepth = getDepth\\n        self.orderLock = threading.Lock()\\n        self.orderLocks = {}\\n        self.o",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ck()\\n        self.orderLocks = {}\\n        self.orders = {}\\n        self.cancels = []\\n        self.completeds = []\\n        self.init()\\n\\n    def init(self):\\n        self.okex.IO(\\\"currency\\\", self.symbol.upper())\\n        self.okex.SetContractType(self.contract)\\n        self.order_logs = {\\n            'buySent': 0,\\n            'buyCanceled': 0,\\n            'sellSent': 0,\\n            'sellCanceled': 0\\n        }\\n\\n    def toNearest(self, num):\\n        tickDec = decimal.Decimal(str(self.tickSize)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      tickDec = decimal.Decimal(str(self.tickSize))\\n        return float((decimal.Decimal(round(num / self.tickSize, 0)) * tickDec))\\n\\n    def getDepth(self):\\n        depth = self.okexGetDepth()\\n        if self.isFMZ:\\n            depth['asks'] = [[x['Price'], x['Amount']] for x in depth['Asks']]\\n            depth['bids'] = [[x['Price'], x['Amount']] for x in depth['Bids']]\\n        return depth\\n\\n    def getOrderLogs(self):\\n        return self.order_logs\\n\\n    def getBestPrices(self):\\n        best",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "logs\\n\\n    def getBestPrices(self):\\n        bestPrices = {}\\n        depth = self.getDepth()\\n        ask, bid = depth['asks'][0][0], depth['bids'][0][0]\\n        spread = ask - bid\\n        if spread <= self.tickSize*2:\\n            bestPrices['ask'] = ask\\n            bestPrices['bid'] = bid\\n        elif spread <= self.tickSize*6:\\n            bestPrices['ask'] = ask-self.tickSize\\n            bestPrices['bid'] = bid+self.tickSize\\n        elif spread >= self.tickSize*20:\\n            bestPrices['ask']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= self.tickSize*20:\\n            bestPrices['ask'] = ask-self.tickSize*5\\n            bestPrices['bid'] = bid+self.tickSize*5\\n        else:\\n            midPrice = self.toNearest((ask+bid)/2)\\n            bestPrices['ask'] = midPrice+self.tickSize*2\\n            bestPrices['bid'] = midPrice-self.tickSize*2\\n        return {\\n            'ask': self.toNearest(bestPrices['ask']),\\n            'bid': self.toNearest(bestPrices['bid'])\\n        }\\n\\n    def getPositions(self, noRetry=False, maxRetries=10):\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ositions(self, noRetry=False, maxRetries=10):\\n        if noRetry:\\n            return self.okex.GetPosition()\\n        attempts = 0\\n        while True:\\n            time.sleep(0.4)\\n            positions = self.okex.GetPosition()\\n            attempts+=1\\n            if len(positions) != 0:\\n                return positions\\n            if attempts == maxRetries:\\n                return False\\n\\n    def havePosition(self, type=None, noRetry=True, maxRetries=10):\\n        positions = self.getPositions(noRe",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s=10):\\n        positions = self.getPositions(noRetry=True)\\n        if not positions:\\n            positions = []\\n        if type == None:\\n            pass\\n        elif type == 'buy':\\n            key = 'buy_amount'\\n        elif type == 'sell':\\n            key = 'sell_amount'\\n        for position in positions:\\n            if type is not None:\\n                if position['Info'][key] != 0:\\n                    return positions\\n            else:\\n                return positions\\n        if noRetry:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             return positions\\n        if noRetry:\\n            return False\\n        attempts = 0\\n        while True:\\n            time.sleep(0.4)\\n            positions = self.getPositions(noRetry=True)\\n            if not positions:\\n                positions = []\\n            attempts+=1\\n            for position in positions:\\n                if type is not None:\\n                    if position['Info'][key] != 0:\\n                        return positions\\n                else:\\n                    re",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ons\\n                else:\\n                    return positions\\n            if attempts == maxRetries:\\n                return False\\n\\n    def orderDone(self, orderID):\\n        orders = self.okex.GetOrders()\\n        for order in orders:\\n            if order['Info']['order_id'] == orderID:\\n                return order['Info']['price'], order['Info']['amount']-order['Info']['deal_amount']\\n        return True\\n\\n    def getOrder(self, uuid):\\n        try:\\n            self.orders[uuid]\\n        except ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y:\\n            self.orders[uuid]\\n        except KeyError:\\n            Log('不存在订单 %s' % uuid)\\n            return 0\\n        return self.orders[uuid]\\n\\n    def getOrderInfo(self, uuid):\\n        return self.okex.GetOrder(self.getOrder(uuid))\\n\\n    def awaitOrder(self, uuid, timeout=None):\\n        start = time.time()\\n        try:\\n            self.orderLocks[uuid]\\n        except KeyError:\\n            return False\\n        while True:\\n            if self.orderLocks[uuid].acquire(False):\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "elf.orderLocks[uuid].acquire(False):\\n                del self.orderLocks[uuid]\\n                return self.getOrder(uuid)\\n            else:\\n                if timeout is not None:\\n                    if time.time()-timeout>start:\\n                        Log('等待订单成交已超时.')\\n                        return\\n            time.sleep(0.001)\\n\\n    def isDone(self, uuid):\\n        if uuid in self.completeds:\\n            return True\\n        return False\\n\\n    def cancel(self, uuid):\\n        self.cancels.app",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " def cancel(self, uuid):\\n        self.cancels.append(uuid)\\n        _cancel = self.okex.CancelOrder(self.getOrder(uuid))\\n        self.orderLocks[uuid].acquire()\\n        self.orderLocks[uuid].release()\\n        if _cancel:\\n            Log(uuid, str(self.getOrder(uuid)), '已取消.')\\n            return True\\n        Log(uuid, str(self.getOrder(uuid)), '取消失败.', str(self.okex.GetRawJSON()))\\n        return False\\n\\n    def trade(self, type, price, amount, matchPrice=False, noRetry=False, uuid=None):\\n        if",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rice=False, noRetry=False, uuid=None):\\n        if type == 'buy' or type == 'closesell':\\n            _trader = self.okex.Buy\\n            _side = 'buy'\\n            __side = 'bid'\\n        else:\\n            _trader = self.okex.Sell\\n            _side = 'sell'\\n            __side = 'ask'\\n        def trader(price, amount):\\n            self.orderLock.acquire()\\n            self.okex.SetDirection(type)\\n            order = _trader(price, amount)\\n            self.orders[uuid] = order\\n            self.order",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " self.orders[uuid] = order\\n            self.orderLock.release()\\n            self.order_logs['%sSent' % _side]+=1\\n            return order\\n        def isBestPrice(currentPrice, depth):\\n            ret = False\\n            if _side == 'buy':\\n                if currentPrice > depth['bids'][1][0]:\\n                    ret = True\\n            else:\\n                if currentPrice < depth['asks'][1][0]:\\n                    ret = True\\n            return ret\\n        if price is None:\\n            price = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t\\n        if price is None:\\n            price = self.getBestPrices()[__side]\\n        if matchPrice:\\n            price = -1\\n        order = trader(price, amount)\\n        if noRetry:\\n            self.completeds.append(uuid)\\n            self.orderLocks[uuid].release()\\n            return\\n        if order == False:\\n            if 20016 in str(self.okex.GetRawJSON()):\\n                order = trader(price, amount)\\n            if order == False:\\n                Log('%s 返回值: %s', (uuid, str(self.okex.G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          Log('%s 返回值: %s', (uuid, str(self.okex.GetRawJSON())))\\n                self.completeds.append(uuid)\\n                self.orderLocks[uuid].release()\\n                return\\n        time.sleep(1)\\n        while True:\\n            if uuid in self.cancels:\\n                Log('%s 已停止下单尝试.' % uuid)\\n                self.completeds.append(uuid)\\n                self.orderLocks[uuid].release()\\n                return\\n            time.sleep(1)\\n            depth = self.getDepth()\\n            isDone ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      depth = self.getDepth()\\n            isDone = self.orderDone(order)\\n            if isDone == True:\\n                self.completeds.append(uuid)\\n                self.orderLocks[uuid].release()\\n                return\\n            if isBestPrice(isDone[0], depth):\\n                continue\\n            if not self.okex.CancelOrder(order):\\n                time.sleep(1)\\n                if self.orderDone(order):\\n                    self.completeds.append(uuid)\\n                    self.orderLocks[uui",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "end(uuid)\\n                    self.orderLocks[uuid].release()\\n                    return\\n            self.order_logs['%sCanceled' % _side]+=1\\n            time.sleep(1)\\n            if price != -1:\\n                price = self.getBestPrices()[__side]\\n            if uuid in self.cancels:\\n                Log('%s 已停止下单尝试.' % uuid)\\n                self.completeds.append(uuid)\\n                self.orderLocks[uuid].release()\\n                return\\n            order = trader(price, isDone[1])\\n\\n    def ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      order = trader(price, isDone[1])\\n\\n    def openLong(self, amount, price=None, matchPrice=False, noRetry=False):\\n        uuid = genUUID()\\n        Log('%s 买入做多 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'buy',\\n                                                        'price': price,\\n                                                        'amount': amount,\\n                                                        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                                                  'matchPrice': matchPrice,\\n                                                        'noRetry': noRetry,\\n                                                        'uuid': uuid}), daemon=True).start()\\n        self.orderLocks[uuid] = threading.Lock()\\n        self.orderLocks[uuid].acquire()\\n        return uuid\\n\\n    def openShort(self, amount, price=None, matchPrice=False, noRetry=False):\\n        uuid = genUUID()\\n        Log('%s 卖出做空 是否使用对手价 %s 阻塞直至成功 %s' % ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "D()\\n        Log('%s 卖出做空 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'sell',\\n                                                        'price': price,\\n                                                        'amount': amount,\\n                                                        'matchPrice': matchPrice,\\n                                                        'noRetry': noRetry,\\n                                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y': noRetry,\\n                                                        'uuid': uuid}), daemon=True).start()\\n        self.orderLocks[uuid] = threading.Lock()\\n        self.orderLocks[uuid].acquire()\\n        return uuid\\n\\n    def coverLong(self, amount, price=None, matchPrice=False, noRetry=False):\\n        uuid = genUUID()\\n        Log('%s 卖出平多 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'closebuy',\\n                  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "args=dict({'type': 'closebuy',\\n                                                        'price': price,\\n                                                        'amount': amount,\\n                                                        'matchPrice': matchPrice,\\n                                                        'noRetry': noRetry,\\n                                                        'uuid': uuid}), daemon=True).start()\\n        self.orderLocks[uuid] = threading.Lock()\\n        self.orderLocks[uuid",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "] = threading.Lock()\\n        self.orderLocks[uuid].acquire()\\n        return uuid\\n\\n    def coverShort(self, amount, price=None, matchPrice=False, noRetry=False):\\n        uuid = genUUID()\\n        Log('%s 买入平空 是否使用对手价 %s 阻塞直至成功 %s' % (uuid, str(matchPrice), str(not noRetry)))\\n        threading.Thread(target=self.trade, kwargs=dict({'type': 'closesell',\\n                                                        'price': price,\\n                                                        'amount': amount,\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                           'amount': amount,\\n                                                        'matchPrice': matchPrice,\\n                                                        'noRetry': noRetry,\\n                                                        'uuid': uuid}), daemon=True).start()\\n        self.orderLocks[uuid] = threading.Lock()\\n        self.orderLocks[uuid].acquire()\\n        return uuid\\n\\next.okexPositionManager = PositionManager\",\n    \"策略名称: OkEX合约-仓位管理系统\\n\\n未找到描述\"\n \n\n    \"strategy_18",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"策略名称: OkEX合约-仓位管理系统\\n\\n未找到描述\"\n \n\n    \"strategy_18\",\n    \"python\\n\\n\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n#\\n#  Paul \\\"The Gambler\\\" Lévy.\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# Do What the Fuck You Want To Public License\\n#\\n\\nimport random\\nimport talib\\nimport numpy as np\\nfrom math import *\\n\\nAccount = {}\\nTicker = {}\\nRecords = {}\\nLPosition = 0\\nSPosition = 0\\nPositions = {}\\nTotalLoss = 0\\nTotalWin = 0\\nFullLoss = 0\\nMaxPosi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "TotalLoss = 0\\nTotalWin = 0\\nFullLoss = 0\\nMaxPosition = 0\\nTotalLongs = 0\\nTotalShorts = 0\\n\\ndef cancelAllOrders():\\n    orders = exchange.GetOrders()\\n    for order in orders:\\n        exchange.CancelOrder(order['Id'], order)\\n    return True\\n\\ndef updateMarket():\\n    global Ticker\\n    global Records\\n\\n    Ticker = exchange.GetTicker()\\n    Records = exchange.GetRecords()\\n\\n    return True\\n\\ndef getTAFormat(Records):\\n    Close = []\\n    for item in Records:\\n        Close.append(item['Close'])\\n\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " Records:\\n        Close.append(item['Close'])\\n\\n    return np.array(Close)\\n\\ndef updateAccount():\\n    global Account\\n    global LPosition\\n    global SPosition\\n    global Positions\\n    global MaxPosition\\n\\n    LPosition = 0\\n    SPosition = 0\\n    Positions = {}\\n    for item in exchange.GetPosition():\\n        if item['MarginLevel'] == LEVERAGE_RATE:\\n            if item['Type'] == 1:\\n                Positions['Short'] = item\\n                SPosition += item['Amount']\\n            else:\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tion += item['Amount']\\n            else:\\n                Positions['Long'] = item\\n                LPosition += item['Amount']\\n        MaxPosition = max(MaxPosition, SPosition, LPosition)\\n\\n    Account = exchange.GetAccount()\\n\\n    return True\\n\\ndef updatePositions():\\n    global TotalWin\\n    global TotalLoss\\n    global FullLoss\\n\\n    opened = False\\n\\n    try:\\n        Long = Positions['Long']['Amount']\\n        LongEntry = Positions['Long']['Price']\\n        Current = Ticker['Sell']\\n\\n        St",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "']\\n        Current = Ticker['Sell']\\n\\n        StopLoss = LongEntry * (1-STOP_LOSS)\\n        TakeProfit = LongEntry * (1+TAKE_PROFIT)\\n\\n        if Current > TakeProfit:\\n            Risked = True\\n            Log('多仓达到预设止盈价位. #0000FF')\\n            TotalWin+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverLong(Long, True)\\n        if Current < StopLoss:\\n            Risked =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if Current < StopLoss:\\n            Risked = True\\n            Log('多仓达到预设止损价位. #FF0000')\\n            TotalLoss+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverLong(Long, True)\\n            if Long*AMP < RISK_LIMIT:\\n                openShort(Long*AMP, True)\\n            else:\\n                FullLoss+=1\\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   Log('超过允许的最大仓位，停止开仓. #FF0000')\\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n\\n        opened = True\\n    except KeyError:\\n        pass\\n\\n    try:\\n        Short = Positions['Short']['Amount']\\n        ShortEntry = Positions['Short']['Price']\\n        Current = Ticker['Buy']\\n\\n        StopLoss = ShortEntry * (1+STOP_LOSS)\\n        TakeProfit = ShortEntry * (1-TAKE_PROFIT)\\n\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eProfit = ShortEntry * (1-TAKE_PROFIT)\\n\\n        if Current < TakeProfit:\\n            Risked = True\\n            Log('空仓达到预设止盈价位. #0000FF')\\n            TotalWin+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverShort(Short, True)\\n        if Current > StopLoss:\\n            Risked = True\\n            Log('空仓达到预设止损价位. #FF0000')\\n            TotalLoss+=1\\n            Log('总计止盈",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n            TotalLoss+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverShort(Short, True)\\n            if Short*AMP < RISK_LIMIT:\\n                openLong(Short*AMP, True)\\n            else:\\n                FullLoss+=1\\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', Ma",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "otalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n\\n        opened = True\\n    except KeyError:\\n        pass\\n\\n    if not opened:\\n        Log('还没开仓，随便开个仓位.')\\n        RSI = talib.RSI(getTAFormat(Records), timeperiod=14)\\n        if RSI[-2]<RSI[-1]:\\n            Log('RSI14: ', RSI[-1],' 正在开多.')\\n            openLong(START_SIZE, True)\\n        else:\\n            Log('RSI14: ', RSI[-1],' 正在开空.')\\n            openShort(START_SIZE, True)\\n\\n    return",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         openShort(START_SIZE, True)\\n\\n    return True\\n\\ndef openLong(Amount=0, marketPrice=False):\\n    global TotalLongs\\n\\n    Amount = floor(Amount)\\n\\n    TotalLongs+=Amount\\n\\n    exchange.SetDirection('buy')\\n\\n    if marketPrice:\\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\\n    else:\\n        exchange.Buy(Ticker['Sell'], Amount)\\n\\n    return True\\n\\ndef coverLong(Amount=0, marketPrice=False):\\n    exchange.SetDirection('closebuy')\\n\\n    if marketPrice:\\n        exchange.Sell(Ticker['Buy']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " marketPrice:\\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\\n    else:\\n        exchange.Sell(Ticker['Buy'], Amount)\\n\\n    return True\\n\\ndef openShort(Amount=0, marketPrice=False):\\n    global TotalShorts\\n\\n    Amount = floor(Amount)\\n\\n    TotalShorts+=Amount\\n\\n    exchange.SetDirection('sell')\\n\\n    if marketPrice:\\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\\n    else:\\n        exchange.Sell(Ticker['Buy'], Amount)\\n\\n    return True\\n\\ndef coverShort(Amount=0, marketPrice=False):\\n    exc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " coverShort(Amount=0, marketPrice=False):\\n    exchange.SetDirection('closesell')\\n\\n    if marketPrice:\\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\\n    else:\\n        exchange.Buy(Ticker['Sell'], Amount)\\n\\n    return True\\n\\ndef onTick():\\n    cancelAllOrders()\\n    updateMarket()\\n    updateAccount()\\n    updatePositions()\\n\\n    return True\\n\\ndef main():\\n    exchange.SetContractType(CONTRACT_TYPE)\\n    exchange.SetMarginLevel(LEVERAGE_RATE)\\n\\n    while True:\\n        onTick()\\n        Sleep(D",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    while True:\\n        onTick()\\n        Sleep(DELAY*1000)\",\n    \"策略名称: Paul-The-Gambler-Lévy-Gold-Edition\\n\\n##### 方向做错了就自动反向翻倍开仓\"\n \n\n    \"strategy_19\",\n    \"python\\n\\n\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n#\\n#  Paul \\\"The Gambler\\\" Lévy.\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# Do What the Fuck You Want To Public License\\n#\\n\\nimport random\\nfrom math import *\\n\\nAccount = {}\\nTicker = {}\\nLPosition = 0\\nSPosition = 0\\nPositions =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "er = {}\\nLPosition = 0\\nSPosition = 0\\nPositions = {}\\nTotalLoss = 0\\nTotalWin = 0\\nFullLoss = 0\\nMaxPosition = 0\\nTotalLongs = 0\\nTotalShorts = 0\\n\\ndef cancelAllOrders():\\n    orders = exchange.GetOrders()\\n    for order in orders:\\n        exchange.CancelOrder(order['Id'], order)\\n    return True\\n\\ndef updateMarket():\\n    global Ticker\\n\\n    Ticker = exchange.GetTicker()\\n\\n    return True\\n\\ndef updateAccount():\\n    global Account\\n    global LPosition\\n    global SPosition\\n    global Positions\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "on\\n    global SPosition\\n    global Positions\\n    global MaxPosition\\n\\n    LPosition = 0\\n    SPosition = 0\\n    Positions = {}\\n    for item in exchange.GetPosition():\\n        if item['MarginLevel'] == LEVERAGE_RATE:\\n            if item['Type'] == 1:\\n                Positions['Short'] = item\\n                SPosition += item['Amount']\\n            else:\\n                Positions['Long'] = item\\n                LPosition += item['Amount']\\n        MaxPosition = max(MaxPosition, SPosition, LPosition)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xPosition = max(MaxPosition, SPosition, LPosition)\\n\\n    Account = exchange.GetAccount()\\n\\n    return True\\n\\ndef updatePositions():\\n    global TotalWin\\n    global TotalLoss\\n    global FullLoss\\n\\n    opened = False\\n\\n    try:\\n        Long = Positions['Long']['Amount']\\n        LongEntry = Positions['Long']['Price']\\n        Current = Ticker['Sell']\\n\\n        StopLoss = LongEntry * (1-STOP_LOSS)\\n        TakeProfit = LongEntry * (1+TAKE_PROFIT)\\n\\n        if Current > TakeProfit:\\n            Risked",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if Current > TakeProfit:\\n            Risked = True\\n            Log('多仓达到预设止盈价位. #0000FF')\\n            TotalWin+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverLong(Long, True)\\n        if Current < StopLoss:\\n            Risked = True\\n            Log('多仓达到预设止损价位. #FF0000')\\n            TotalLoss+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverLong(Long, True)\\n            if Long*AMP < RISK_LIMIT:\\n                openShort(Long*AMP, True)\\n            else:\\n                FullLoss+=1\\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', Tota",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "axPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n\\n        opened = True\\n    except KeyError:\\n        pass\\n\\n    try:\\n        Short = Positions['Short']['Amount']\\n        ShortEntry = Positions['Short']['Price']\\n        Current = Ticker['Buy']\\n\\n        StopLoss = ShortEntry * (1+STOP_LOSS)\\n        TakeProfit = ShortEntry * (1-TAKE_PROFIT)\\n\\n        if Current < TakeProfit:\\n            Risked = True\\n            Log('空仓达到预设止盈价位. #0000FF')\\n            TotalWin+=1\\n            Log('总计止盈次",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n            TotalWin+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverShort(Short, True)\\n        if Current > StopLoss:\\n            Risked = True\\n            Log('空仓达到预设止损价位. #FF0000')\\n            TotalLoss+=1\\n            Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n            coverShort(Short, True)\\n            if Short*AMP < RISK_LIMIT:\\n                openLong(Short*AMP, True)\\n            else:\\n                FullLoss+=1\\n                Log('超过允许的最大仓位，停止开仓. #FF0000')\\n                Log('总计止盈次数: ', TotalWin, ' 总计止损次数: ', TotalLoss, ' 完全止损次数: ', FullLoss, ' 持有过的最大仓位: ', MaxPosition, ' 总计开多: ', TotalLongs, ' 总计开空: ', TotalShorts)\\n\\n        opened = True\\n    except KeyError:\\n        pass\\n\\n    if not opened:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cept KeyError:\\n        pass\\n\\n    if not opened:\\n        Log('还没开仓，随便开个仓位.')\\n        rand = random.choice([1,2,3,4,5,6])\\n        if rand in [1,3,5]:\\n            Log('骰子抛到了: ',rand,' 正在开多.')\\n            openLong(START_SIZE, True)\\n        else:\\n            Log('骰子抛到了: ',rand,' 正在开空.')\\n            openShort(START_SIZE, True)\\n\\n    return True\\n\\ndef openLong(Amount=0, marketPrice=False):\\n    global TotalLongs\\n\\n    Amount = floor(Amount)\\n\\n    TotalLongs+=Amount\\n\\n    exchange.SetDirection('buy'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "alLongs+=Amount\\n\\n    exchange.SetDirection('buy')\\n\\n    if marketPrice:\\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\\n    else:\\n        exchange.Buy(Ticker['Sell'], Amount)\\n\\n    return True\\n\\ndef coverLong(Amount=0, marketPrice=False):\\n    exchange.SetDirection('closebuy')\\n\\n    if marketPrice:\\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\\n    else:\\n        exchange.Sell(Ticker['Buy'], Amount)\\n\\n    return True\\n\\ndef openShort(Amount=0, marketPrice=False):\\n    global TotalShorts\\n\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "0, marketPrice=False):\\n    global TotalShorts\\n\\n    Amount = floor(Amount)\\n\\n    TotalShorts+=Amount\\n\\n    exchange.SetDirection('sell')\\n\\n    if marketPrice:\\n        exchange.Sell(Ticker['Buy']*0.99, Amount)\\n    else:\\n        exchange.Sell(Ticker['Buy'], Amount)\\n\\n    return True\\n\\ndef coverShort(Amount=0, marketPrice=False):\\n    exchange.SetDirection('closesell')\\n\\n    if marketPrice:\\n        exchange.Buy(Ticker['Sell']*1.01, Amount)\\n    else:\\n        exchange.Buy(Ticker['Sell'], Amount)\\n\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n        exchange.Buy(Ticker['Sell'], Amount)\\n\\n    return True\\n\\ndef onTick():\\n    cancelAllOrders()\\n    updateMarket()\\n    updateAccount()\\n    updatePositions()\\n\\n    return True\\n\\ndef main():\\n    exchange.SetContractType(CONTRACT_TYPE)\\n    exchange.SetMarginLevel(LEVERAGE_RATE)\\n\\n    while True:\\n        onTick()\\n        Sleep(DELAY*1000)\",\n    \"策略名称: Paul-The-Gambler-Lévy\\n\\n##### 方向做错了就自动反向翻倍开仓\"\n \n\n    \"strategy_20\",\n    \"python\\n\\n'''backtest\\nstart: 2019-09-14 00:00:00\\nend: 2019-10-13 ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "test\\nstart: 2019-09-14 00:00:00\\nend: 2019-10-13 00:00:00\\nperiod: 1h\\nexchanges: [{\\\"eid\\\":\\\"Bitfinex\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\n\\nimport sys\\nimport time\\nimport talib\\nimport json\\nimport traceback\\nimport matplotlib\\nimport numpy as np\\nimport matplotlib.pyplot as plt\\nimport mpl_toolkits.mplot3d\\n\\ndef main():\\n    testGlobal = [\\n            'Version', ['Log', 'ok', 3.5, True], ['Sleep', 100], ['LogProfit', 10.5],\\n            'LogProfitReset', ['LogProfit', 10.8], 'GetCommand', 'LogReset', [",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", ['LogProfit', 10.8], 'GetCommand', 'LogReset', ['LogStatus', 'x', True], ['EnableLog', True], \\n            ['SetErrorFilter', 'xxx'], 'GetPid', 'GetLastError', ['_G', 'x', 10], ['_G', 'x'], ['_G', 'x', None], '_G',\\n        ]\\n    g = globals()\\n    for item in testGlobal:\\n        if isinstance(item, list):\\n            ret = g[item[0]](*item[1:])\\n        else:\\n            ret = g[item]()\\n        Log('%s => %s' % (item, ret))\\n    Log(sys.version)\\n    testExchanges = [\\n            'GetName', 'GetUS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  testExchanges = [\\n            'GetName', 'GetUSDCNY', 'GetRate', ['SetRate', 1.0], 'GetAccount', 'GetCurrency', 'GetLabel', 'GetMinStock', 'GetMinPrice', 'GetFee',\\n            'GetRecords',\\n            ['Buy', 100, 0.1, \\\"OK\\\"],\\n            'GetOrders',\\n            ['GetOrder', 1],\\n            'GetAccount',\\n            'GetRawJSON',\\n            ['CancelOrder', 1],\\n            ['Buy', -1, 1000.0],\\n            'GetAccount',\\n            ['Sell', -1, 1],\\n            'GetAccount',\\n            ['Se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", 1],\\n            'GetAccount',\\n            ['Sell', 9999.9, 0.2, \\\"OK\\\"],\\n            'GetOrders',\\n            'GetAccount',\\n            ['CancelOrder', 2],\\n            ['Go', 'GetAccount'],\\n            ['IO', 'status'],\\n        ]\\n    for item in testExchanges:\\n        try:\\n            if isinstance(item, list):\\n                ret = getattr(exchange, item[0])(*item[1:])\\n            else:\\n                ret = getattr(exchange, item)()\\n        except:\\n            ret = traceback.format_exc(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  except:\\n            ret = traceback.format_exc()\\n        Log('exchange.%s => %s' % (item, ret))\\n    \\n    # test market order\\n    exchange.Buy(-1, 1000)\\n    exchange.Buy(-1, 200, \\\"buy 200 \\\")\\n    exchange.Sell(-1, exchange.GetAccount().Stocks)\\n    # test Go\\n    ret, ok = exchange.Go(\\\"GetTicker\\\").wait()\\n    if ok:\\n        Log(\\\"Go GetTicker\\\", ret)\\n    Log(\\\"EMA\\\", len(TA.EMA(exchange.GetRecords())))\\n    Log(\\\"EMA H1\\\", len(TA.EMA(exchange.GetRecords(PERIOD_H1))))\\n    \\n\\n    # test plot im",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tRecords(PERIOD_H1))))\\n    \\n\\n    # test plot image\\n    plt.plot([3,6,2,4,7,1])\\n    Log('支持直接打印plt图片 ', plt)\\n    \\n    fig = plt.figure()\\n    ax = fig.add_subplot(111)\\n    t = ax.scatter(np.random.rand(20), np.random.rand(20))\\n    Log(fig)\\n    \\n    x = np.linspace(0, 10, 1000)\\n    y = np.sin(x)\\n    z = np.cos(x**2)\\n\\n    plt.figure(figsize=(8,4))\\n    plt.plot(x,y,label=\\\"$sin(x)$\\\",color=\\\"red\\\",linewidth=2)\\n    plt.plot(x,z,\\\"b--\\\",label=\\\"$cos(x^2)$\\\")\\n    plt.xlabel(\\\"Time(s)\\\")\\n    plt.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "os(x^2)$\\\")\\n    plt.xlabel(\\\"Time(s)\\\")\\n    plt.ylabel(\\\"Volt\\\")\\n    plt.title(\\\"PyPlot Example\\\")\\n    plt.ylim(-1.2,1.2)\\n    plt.legend()\\n    Log(plt)\\n\\n    x,y=np.mgrid[-2:2:20j,-2:2:20j]\\n    z=x*np.exp(-x**2-y**2)\\n    ax=plt.subplot(111,projection='3d')\\n    ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)\\n    ax.set_xlabel('x')\\n    ax.set_ylabel('y')\\n    ax.set_zlabel('z')\\n    # plot image to status bar\\n    LogStatus(plt)\\n    \\n    # test plot chart\\n    x = Chart",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s(plt)\\n    \\n    # test plot chart\\n    x = Chart({\\n        'title' : { 'text' : 'test chart'},\\n        'xAxis': { 'type': 'datetime'},\\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\\n        })\\n    x.reset()\\n    for i in range(100):\\n        ts = int(time.time() * 1000)\\n        ticker = _C(exchange.GetTicker)\\n        x.add(0, [ts, ticker.Buy])\\n        x.add(1, [ts, ticker.Sell])\\n        Sleep(10000)\",\n    \"策略名称: Python-API-测试\\n\\nexchange.Buy(-1, 1000)\\n    exch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " Python-API-测试\\n\\nexchange.Buy(-1, 1000)\\n    exchange.Buy(-1, 200, \\\"buy 200 \\\")\\n    exchange.Sell(-1, exchange.GetAccount().Stocks)\\n    # test Go\\n    ret, ok = exchange.Go(\\\"GetTicker\\\").wait()\\n    if ok:\\n        Log(\\\"Go GetTicker\\\", ret)\\n    Log(\\\"EMA\\\", len(TA.EMA(exchange.GetRecords())))\\n    Log(\\\"EMA H1\\\", len(TA.EMA(exchange.GetRecords(PERIOD_H1))))\\n    \\n\\n    # test plot image\\n    plt.plot([3,6,2,4,7,1])\\n    Log('支持直接打印plt图片 ', plt)\\n    \\n    fig = plt.figure()\\n    ax = fig.add_subplot",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    fig = plt.figure()\\n    ax = fig.add_subplot(111)\\n    t = ax.scatter(np.random.rand(20), np.random.rand(20))\\n    Log(fig)\\n    \\n    x = np.linspace(0, 10, 1000)\\n    y = np.sin(x)\\n    z = np.cos(x**2)\\n\\n    plt.figure(figsize=(8,4))\\n    plt.plot(x,y,label=\\\"$sin(x)$\\\",color=\\\"red\\\",linewidth=2)\\n    plt.plot(x,z,\\\"b--\\\",label=\\\"$cos(x^2)$\\\")\\n    plt.xlabel(\\\"Time(s)\\\")\\n    plt.ylabel(\\\"Volt\\\")\\n    plt.title(\\\"PyPlot Example\\\")\\n    plt.ylim(-1.2,1.2)\\n    plt.legend()\\n    Log(plt)\\n\\n    x,y",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".2,1.2)\\n    plt.legend()\\n    Log(plt)\\n\\n    x,y=np.mgrid[-2:2:20j,-2:2:20j]\\n    z=x*np.exp(-x**2-y**2)\\n    ax=plt.subplot(111,projection='3d')\\n    ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)\\n    ax.set_xlabel('x')\\n    ax.set_ylabel('y')\\n    ax.set_zlabel('z')\\n    # plot image to status bar\\n    LogStatus(plt)\\n    \\n    # test plot chart\\n    x = Chart({\\n        'title' : { 'text' : 'test chart'},\\n        'xAxis': { 'type': 'datetime'},\\n        'series' : [{'name' ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'type': 'datetime'},\\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\\n        })\\n    x.reset()\\n    for i in range(100):\\n        ts = int(time.time() * 1000)\\n        ticker = _C(exchange.GetTicker)\\n        x.add(0, [ts, ticker.Buy])\\n        x.add(1, [ts, ticker.Sell])\\n        Sleep(10000)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/21365\\n\\n> Last Modified\\n\\n2019-10-14 12:35:16\"\n \n\n    \"strategy_21\",\n    \"python\\n'''backtest\\nstart: 2022-03-30 09:00:00\\nend: 2",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n'''backtest\\nstart: 2022-03-30 09:00:00\\nend: 2022-06-30 15:00:00\\nperiod: 1h\\nbasePeriod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\n\\n\\nimport sys\\ndef main():\\n    Log(sys.version)\\n    c = KLineChart()\\n    c.reset(0)\\n\\n    bars = exchange.GetRecords()\\n    for bar in bars:\\n        c.begin(bar)\\n        c.barcolor('rgba(255, 0, 0, 0.2)' if bar.Close > bar.Open else 'rgba(0, 0, 0, 0.2)')\\n        if bar.Close > bar.Open:\\n            c.bgcolor('rgba(0, 255, 0, 0.5)')\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            c.bgcolor('rgba(0, 255, 0, 0.5)')\\n        \\n        h = c.plot(bar.High, 'high')\\n        l = c.plot(bar.Low, 'low')\\n        c.fill(h, l, 'rgba(255, 0, 0, 1)' if bar.Close > bar.Open else '#000000')\\n        c.hline(bar.High)\\n        c.plotarrow(bar.Close - bar.Open)\\n        c.plotshape(bar.Low, style = 'diamond')\\n        c.plotchar(bar.Close, char = 'X')\\n        c.plotcandle(bar.Open*0.9, bar.High*0.9, bar.Low*0.9, bar.Close*0.9)\\n        if bar.Close > bar.Open:\\n            c.signal(\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " if bar.Close > bar.Open:\\n            c.signal(\\\"long\\\", bar.High, 1.5, \\\"LONG\\\")\\n        elif bar.Close < bar.Open:\\n            c.signal(\\\"closelong\\\", bar.Low, 1.5)\\n        c.close()\",\n    \"策略名称: Python-KLineChart\\n\\n未找到描述\"\n \n\n    \"strategy_22\",\n    \"python\\n'''backtest\\nstart: 2019-09-06 00:00:00\\nend: 2019-10-05 00:00:00\\nperiod: 1h\\nexchanges: [{\\\"eid\\\":\\\"Bitfinex\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\n\\nfrom sklearn import svm\\nimport numpy as np\\n\\ndef main():\\n    preTime = 0\\n    n = 0\\n    success",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f main():\\n    preTime = 0\\n    n = 0\\n    success = 0\\n    predict = None\\n    pTime = None\\n    marketPosition = 0\\n    initAccount = exchange.GetAccount()\\n    Log(\\\"Running...\\\")\\n    while True:\\n        r = exchange.GetRecords()\\n        if len(r) < 60:\\n            continue\\n        bar = r[len(r)-1]\\n        if bar.Time > preTime:\\n            preTime = bar.Time\\n            if pTime is not None and r[len(r)-2].Time == pTime:\\n                diff = r[len(r)-2].Close - r[len(r)-3].Close\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r[len(r)-2].Close - r[len(r)-3].Close\\n                if diff > SpreadVal:\\n                    success += 1 if predict == 0 else 0\\n                elif diff < -SpreadVal:\\n                    success += 1 if predict == 1 else 0\\n                else:\\n                    success += 1 if predict == 2 else 0\\n                pTime = None\\n                LogStatus(\\\"预测次数\\\", n, \\\"成功次数\\\", success, \\\"准确率:\\\", '%.3f %%' % round(float(success) * 100 / n, 2))\\n        else:\\n            Sleep(1000)\\n            c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     else:\\n            Sleep(1000)\\n            continue\\n        inputs_X, output_Y = [], []\\n        sets = [None, None, None]\\n        for i in xrange(1, len(r)-2, 1):\\n            inputs_X.append([r[i].Open, r[i].Close])\\n            Y = 0\\n            diff = r[i+1].Close - r[i].Close\\n            if diff > SpreadVal:\\n                Y = 0\\n                sets[0] = True\\n            elif diff < -SpreadVal:\\n                Y = 1\\n                sets[1] = True\\n            else:\\n                Y = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1] = True\\n            else:\\n                Y = 2\\n                sets[2] = True\\n            output_Y.append(Y)\\n        if None in sets:\\n            Log(\\\"样本不足, 无法预测 ...\\\")\\n            continue\\n        n += 1\\n        clf = svm.LinearSVC()\\n        clf.fit(inputs_X, output_Y)\\n        predict = clf.predict(np.array([bar.Open, bar.Close]).reshape((1, -1)))[0]\\n        pTime = bar.Time\\n        Log(\\\"预测当前Bar结束:\\\", bar.Time, ['涨', '跌', '横'][predict])\\n        if marketPosition == 0:\\n            if pre",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       if marketPosition == 0:\\n            if predict == 0:\\n                exchange.Buy(-1, initAccount.Balance/2)\\n                marketPosition = 1\\n            elif predict == 1:\\n                exchange.Sell(-1, initAccount.Stocks/2)\\n                marketPosition = -1\\n        else:\\n            nowAccount = exchange.GetAccount()\\n            if marketPosition > 0 and predict != 0:\\n                exchange.Sell(-1, nowAccount.Stocks - initAccount.Stocks)\\n                nowAccount = exchange.Ge",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".Stocks)\\n                nowAccount = exchange.GetAccount()\\n                marketPosition = 0\\n            elif marketPosition < 0 and predict != 1:\\n                while True:\\n                    dif = initAccount.Stocks - nowAccount.Stocks\\n                    if dif < 0.01:\\n                        break\\n                    ticker = exchange.GetTicker()\\n                    exchange.Buy(ticker.Sell + (ticker.Sell-ticker.Buy)*2, dif)\\n                    while True:\\n                        Sleep(10",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     while True:\\n                        Sleep(1000)\\n                        orders = exchange.GetOrders()\\n                        for order in orders:\\n                            exchange.CancelOrder(order.Id)\\n                        if len(orders) == 0:\\n                            break\\n                    nowAccount = exchange.GetAccount()\\n                marketPosition = 0\\n            if marketPosition == 0:\\n                LogProfit(_N(nowAccount.Balance - initAccount.Balance, 4), nowAccount)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "unt.Balance - initAccount.Balance, 4), nowAccount)\",\n    \"策略名称: Python-机器学习之-SVM-预测买卖\\n\\n未找到描述\"\n \n\n    \"strategy_23\",\n    \"python\\n# TableTemplet\\nimport json\\nlistener = {}\\n\\nclass Table():\\n    \\\"\\\"\\\"docstring for Table\\\"\\\"\\\"\\n    def __init__(self):\\n        self.tb = {\\n            \\\"type\\\" : \\\"table\\\",\\n            \\\"title\\\" : \\\"Table\\\",\\n            \\\"cols\\\" : [],\\n            \\\"rows\\\" : []\\n        }\\n\\n    def SetColRow(self, col_index, row_index, row):\\n        if (type(col_index) is int) and (typ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ow):\\n        if (type(col_index) is int) and (type(row_index) is int) :\\n            if (col_index > len(self.tb[\\\"cols\\\"])) or (row_index > len(self.tb[\\\"rows\\\"])) :\\n                Log(\\\"索引超出范围！col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            else :\\n                self.tb[\\\"rows\\\"][row_index - 1][col_index - 1] = row\\n        else :\\n            Log(\\\"col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            raise \\\"SetColRow 参数错误!\\\"\\n\\n    def SetBtn(self, col_index, row_index,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "误!\\\"\\n\\n    def SetBtn(self, col_index, row_index, cmd, name, callback):\\n        global listener\\n        if (type(col_index) is int) and (type(row_index) is int) :\\n            if (col_index > len(self.tb[\\\"cols\\\"])) or (row_index > len(self.tb[\\\"rows\\\"])) :\\n                Log(\\\"索引超出范围！col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            else :\\n                self.tb[\\\"rows\\\"][row_index - 1][col_index - 1] = {\\\"type\\\" : \\\"button\\\", \\\"cmd\\\" : cmd, \\\"name\\\" : name}\\n                listener[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": cmd, \\\"name\\\" : name}\\n                listener[cmd] = callback\\n        else :\\n            Log(\\\"col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            raise \\\"SetColRow 参数错误!\\\"\\n    \\n    def SetRows(self, row_index, Rows):\\n        pass\\n\\n    def SetCols(self, Cols):\\n        self.tb[\\\"cols\\\"] = Cols\\n\\n    def GetRows(self, row_index):\\n        if (type(row_index) is int) and (row_index < len(self.tb[\\\"rows\\\"])) :\\n            return self.tb[\\\"rows\\\"][row_index - 1]\\n        else :\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "b[\\\"rows\\\"][row_index - 1]\\n        else :\\n            Log(\\\"参数错误！ 或者 参数索引超出范围！\\\")\\n\\n    def Init(self, title, col_length, row_length):  \\n        self.tb[\\\"title\\\"] = title\\n        for i in range(1, row_length + 1) :\\n            if i == 1 :\\n                for n in range(1, col_length + 1) :\\n                    self.tb[\\\"cols\\\"].append(n)\\n            self.tb[\\\"rows\\\"].append([])\\n            for m in range(1, col_length + 1) :\\n                self.tb[\\\"rows\\\"][i - 1].append(str(i) + \\\"/\\\" + str(m))",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "b[\\\"rows\\\"][i - 1].append(str(i) + \\\"/\\\" + str(m))\\n\\n\\nclass CreateTableManager():\\n    \\\"\\\"\\\"docstring for CreateTableManager\\\"\\\"\\\"\\n    def __init__(self):        # CreateTableManager 构造函数\\n        self.tables = []       # 用于储存 table 对象\\n    \\n    def GetTable(self, index):\\n        if type(index) is int :\\n            return self.tables[index]\\n        elif type(index) is str :\\n            for i in range(len(self.tables)) :\\n                if self.tables[i][\\\"title\\\"] == index:\\n                    re",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "es[i][\\\"title\\\"] == index:\\n                    return self.tables[i]\\n        else :\\n            Log(\\\"GetTable参数:\\\", index)\\n            raise \\\"GetTable 参数错误！\\\"\\n    \\n    def AddTable(self, title, col_length, row_length):    # cols, rows\\n        tb = Table()\\n        tb.Init(title, col_length, row_length)\\n        self.tables.append(tb.tb)\\n        return tb\\n\\n    def UpdateCMD(self):\\n        global listener\\n        cmd = GetCommand()\\n        if cmd :\\n            cmdList = cmd.split(\\\":\\\")\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d :\\n            cmdList = cmd.split(\\\":\\\")\\n            if len(cmdList) == 2 :                                         # 增加了 对于 主策略 交互的 冲突 检测。\\n                Log(\\\"接收到 TableTemplet 模板以外的 交互命令！\\\", cmdList)     \\n                return\\n            if listener[cmd] :\\n                listener[cmd](cmd)\\n            else :\\n                Log(\\\"TableTemplet 模板中找不到名为：\\\" + cmd + \\\"的命令\\\")\\n    \\n    def LogStatus(self, before, end):\\n        self.UpdateCMD()\\n        LogStatus(before + '\\\\n`' + json.dumps(sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        LogStatus(before + '\\\\n`' + json.dumps(self.tables) + '`\\\\n' + end)\\n\\n# 导出函数\\next.CreateTableManager = CreateTableManager\\n\\n# 测试代码\\n\\ndef test1(cmd):        # 用作函数回调\\n    Log(_D(), cmd)\\n\\ndef main():\\n    account = exchange.GetAccount()\\n    array1 = [\\\"aa\\\", \\\"bb\\\", \\\"cc\\\"]\\n    array2 = [1, 2, 4, 55]\\n\\n    TbM = ext.CreateTableManager()\\n    tb1 = TbM.AddTable(\\\"tb1\\\", 6, 7)\\n    \\n    tb1.SetColRow(3, 4, \\\"hello\\\")\\n    tb1.SetColRow(3, 5, 12)\\n    tb1.SetColRow(3, 6, account)\\n    tb1.SetCol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    tb1.SetColRow(3, 6, account)\\n    tb1.SetColRow(3, 7, array1)\\n    tb1.SetColRow(3, 2, array2)\\n    tb1.SetBtn(3, 1, \\\"Cover\\\", \\\"平仓\\\", test1)    # 由于 python 没有多行 匿名函数（如JS 的 function(){...}）所以可以声明普通函数传入。\\n    tb_1 = TbM.GetTable(0)\\n    tb_2 = TbM.GetTable(\\\"tb1\\\")\\n    Log(tb_1)\\n    Log(tb_2, \\\"#FF0000\\\")\\n    tb1_row1 = tb1.GetRows(1)\\n    Log(tb1_row1)\\n    tb1_row1[0] = \\\"修改\\\"\\n    x = 0\\n    \\n    # tb2\\n    tb2 = TbM.AddTable(\\\"tb2\\\", 4, 4)\\n\\n    while True :\\n        x = x + 1\\n        tb1_ro",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   while True :\\n        x = x + 1\\n        tb1_row1[0] = _D()\\n        tb1.SetCols([x + 1, x + 2, x + 3, x + 4, x + 5, x + 6])\\n        TbM.LogStatus(\\\"begin\\\", \\\"end\\\")\\n        Sleep(1000)\",\n    \"策略名称: Python版-TableTemplet-测试版Python-Version-TableTemplet-Beta-Version\\n\\nimport json\\nlistener = {}\\n\\nclass Table():\\n    \\\"\\\"\\\"docstring for Table\\\"\\\"\\\"\\n    def __init__(self):\\n        self.tb = {\\n            \\\"type\\\" : \\\"table\\\",\\n            \\\"title\\\" : \\\"Table\\\",\\n            \\\"cols\\\" : [],\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"Table\\\",\\n            \\\"cols\\\" : [],\\n            \\\"rows\\\" : []\\n        }\\n\\n    def SetColRow(self, col_index, row_index, row):\\n        if (type(col_index) is int) and (type(row_index) is int) :\\n            if (col_index > len(self.tb[\\\"cols\\\"])) or (row_index > len(self.tb[\\\"rows\\\"])) :\\n                Log(\\\"索引超出范围！col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            else :\\n                self.tb[\\\"rows\\\"][row_index - 1][col_index - 1] = row\\n        else :\\n            Log(\\\"col_index:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " row\\n        else :\\n            Log(\\\"col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            raise \\\"SetColRow 参数错误!\\\"\\n\\n    def SetBtn(self, col_index, row_index, cmd, name, callback):\\n        global listener\\n        if (type(col_index) is int) and (type(row_index) is int) :\\n            if (col_index > len(self.tb[\\\"cols\\\"])) or (row_index > len(self.tb[\\\"rows\\\"])) :\\n                Log(\\\"索引超出范围！col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            else :\\n                self.t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "index)\\n            else :\\n                self.tb[\\\"rows\\\"][row_index - 1][col_index - 1] = {\\\"type\\\" : \\\"button\\\", \\\"cmd\\\" : cmd, \\\"name\\\" : name}\\n                listener[cmd] = callback\\n        else :\\n            Log(\\\"col_index:\\\", col_index, \\\"row_index:\\\", row_index)\\n            raise \\\"SetColRow 参数错误!\\\"\\n    \\n    def SetRows(self, row_index, Rows):\\n        pass\\n\\n    def SetCols(self, Cols):\\n        self.tb[\\\"cols\\\"] = Cols\\n\\n    def GetRows(self, row_index):\\n        if (type(row_index) i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s(self, row_index):\\n        if (type(row_index) is int) and (row_index < len(self.tb[\\\"rows\\\"])) :\\n            return self.tb[\\\"rows\\\"][row_index - 1]\\n        else :\\n            Log(\\\"参数错误！ 或者 参数索引超出范围！\\\")\\n\\n    def Init(self, title, col_length, row_length):  \\n        self.tb[\\\"title\\\"] = title\\n        for i in range(1, row_length + 1) :\\n            if i == 1 :\\n                for n in range(1, col_length + 1) :\\n                    self.tb[\\\"cols\\\"].append(n)\\n            self.tb[\\\"rows\\\"].append(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "].append(n)\\n            self.tb[\\\"rows\\\"].append([])\\n            for m in range(1, col_length + 1) :\\n                self.tb[\\\"rows\\\"][i - 1].append(str(i) + \\\"/\\\" + str(m))\\n\\n\\nclass CreateTableManager():\\n    \\\"\\\"\\\"docstring for CreateTableManager\\\"\\\"\\\"\\n    def __init__(self):        # CreateTableManager 构造函数\\n        self.tables = []       # 用于储存 table 对象\\n    \\n    def GetTable(self, index):\\n        if type(index) is int :\\n            return self.tables[index]\\n        elif type(index) is str :\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tables[index]\\n        elif type(index) is str :\\n            for i in range(len(self.tables)) :\\n                if self.tables[i][\\\"title\\\"] == index:\\n                    return self.tables[i]\\n        else :\\n            Log(\\\"GetTable参数:\\\", index)\\n            raise \\\"GetTable 参数错误！\\\"\\n    \\n    def AddTable(self, title, col_length, row_length):    # cols, rows\\n        tb = Table()\\n        tb.Init(title, col_length, row_length)\\n        self.tables.append(tb.tb)\\n        return tb\\n\\n    def UpdateCM",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pend(tb.tb)\\n        return tb\\n\\n    def UpdateCMD(self):\\n        global listener\\n        cmd = GetCommand()\\n        if cmd :\\n            cmdList = cmd.split(\\\":\\\")\\n            if len(cmdList) == 2 :                                         # 增加了 对于 主策略 交互的 冲突 检测。\\n                Log(\\\"接收到 TableTemplet 模板以外的 交互命令！\\\", cmdList)     \\n                return\\n            if listener[cmd] :\\n                listener[cmd](cmd)\\n            else :\\n                Log(\\\"TableTemplet 模板中找不到名为：\\\" + cmd + \\\"的命令",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      Log(\\\"TableTemplet 模板中找不到名为：\\\" + cmd + \\\"的命令\\\")\\n    \\n    def LogStatus(self, before, end):\\n        self.UpdateCMD()\\n        LogStatus(before + '\\\\n`' + json.dumps(self.tables) + '`\\\\n' + end)\"\n \n\n    \"strategy_24\",\n    \"python\\n'''backtest\\nstart: 2020-01-28 00:00:00\\nend: 2020-02-26 00:00:00\\nperiod: 1d\\nexchanges: [{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\n\\nChartCfg = {\\n    '__isStock': True,\\n    'title': {\\n        'text': 'Python画图'\\n   \\n    'yAxis': [{\\n        'title': {'text':",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'\\n   \\n    'yAxis': [{\\n        'title': {'text': 'K线'},\\n        'style': {'color': '#4572A7'},\\n        'opposite': False\\n  \\n        'title': {'text': '指标轴'},\\n        'opposite': True\\n    }],\\n    'series': [{\\n        'type': 'candlestick',\\n        'name': '当前周期',\\n        'id': 'primary',\\n        'data': []\\n  \\n        'type': 'line',\\n        'id': 'dif',\\n        'name': 'DIF',\\n        \\\"yAxis\\\" : 1,\\n        'data': []\\n  \\n        'type': 'line',\\n        'id': 'dea',\\n        'name': 'DEA'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ine',\\n        'id': 'dea',\\n        'name': 'DEA',\\n        \\\"yAxis\\\" : 1,\\n        'data': []\\n  \\n        'type': 'line',\\n        'id': 'macd',\\n        'name': 'MACD',\\n        \\\"yAxis\\\" : 1,\\n        'data': []\\n    }]\\n}\\n\\ndef main():\\n    global ChartCfg\\n    preTime = 0\\n    chart = Chart(ChartCfg)\\n    chart.reset()\\n    while True:\\n        while True:\\n            r = _C(exchange.GetRecords)\\n            if len(r) > 50:\\n                break\\n        # 计算指标\\n        macd = TA.MACD(r)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       # 计算指标\\n        macd = TA.MACD(r)\\n        \\n        LogStatus(_D(), len(r))\\n        \\n        # 画图\\n        for i in range(len(r)):\\n            if r[i][\\\"Time\\\"] == preTime:\\n                chart.add(0, [r[i][\\\"Time\\\"], r[i][\\\"Open\\\"], r[i][\\\"High\\\"], r[i][\\\"Low\\\"], r[i][\\\"Close\\\"]], -1)\\n                chart.add(1, [r[i][\\\"Time\\\"], macd[0][i]], -1)\\n                chart.add(2, [r[i][\\\"Time\\\"], macd[1][i]], -1)\\n                chart.add(3, [r[i][\\\"Time\\\"], macd[2][i]], -1)\\n            elif r[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "][\\\"Time\\\"], macd[2][i]], -1)\\n            elif r[i][\\\"Time\\\"] > preTime:\\n                chart.add(0, [r[i][\\\"Time\\\"], r[i][\\\"Open\\\"], r[i][\\\"High\\\"], r[i][\\\"Low\\\"], r[i][\\\"Close\\\"]])\\n                chart.add(1, [r[i][\\\"Time\\\"], macd[0][i]])\\n                chart.add(2, [r[i][\\\"Time\\\"], macd[1][i]])\\n                chart.add(3, [r[i][\\\"Time\\\"], macd[2][i]])\\n                preTime = r[i][\\\"Time\\\"]\\n        Sleep(500)\",\n    \"策略名称: Python版MACD指标画图范例\\n\\nmacd = TA.MACD(r)\\n        \\n        LogStatus(_D(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "macd = TA.MACD(r)\\n        \\n        LogStatus(_D(), len(r))\\n        \\n        # 画图\\n        for i in range(len(r)):\\n            if r[i][\\\"Time\\\"] == preTime:\\n                chart.add(0, [r[i][\\\"Time\\\"], r[i][\\\"Open\\\"], r[i][\\\"High\\\"], r[i][\\\"Low\\\"], r[i][\\\"Close\\\"]], -1)\\n                chart.add(1, [r[i][\\\"Time\\\"], macd[0][i]], -1)\\n                chart.add(2, [r[i][\\\"Time\\\"], macd[1][i]], -1)\\n                chart.add(3, [r[i][\\\"Time\\\"], macd[2][i]], -1)\\n            elif r[i][\\\"Time\\\"] > preTime:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "], -1)\\n            elif r[i][\\\"Time\\\"] > preTime:\\n                chart.add(0, [r[i][\\\"Time\\\"], r[i][\\\"Open\\\"], r[i][\\\"High\\\"], r[i][\\\"Low\\\"], r[i][\\\"Close\\\"]])\\n                chart.add(1, [r[i][\\\"Time\\\"], macd[0][i]])\\n                chart.add(2, [r[i][\\\"Time\\\"], macd[1][i]])\\n                chart.add(3, [r[i][\\\"Time\\\"], macd[2][i]])\\n                preTime = r[i][\\\"Time\\\"]\\n        Sleep(500)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/187379\\n\\n> Last Modified\\n\\n2020-02-27 19:02:49\"\n \n\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\n> Last Modified\\n\\n2020-02-27 19:02:49\"\n \n\n    \"strategy_25\",\n    \"python\\nimport random\\n\\ndef CancelPendingOrders():\\n    while True:\\n        orders = _C(exchange.GetOrders)\\n        if len(orders) == 0 :\\n            return \\n\\n        for j in range(len(orders)):\\n            exchange.CancelOrder(orders[j][\\\"Id\\\"])\\n            if j < len(orders) - 1:\\n                Sleep(Interval)\\n\\nLastBuyPrice = 0\\nInitAccount = None\\n\\ndef dispatch():\\n    global InitAccount, LastBuyPrice\\n    account = None",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "obal InitAccount, LastBuyPrice\\n    account = None\\n    ticker = _C(exchange.GetTicker)\\n    LogStatus(_D(), \\\"ticker:\\\", ticker)\\n    if LastBuyPrice > 0:\\n        if len(_C(exchange.GetOrders)) > 0:\\n            if ticker[\\\"Last\\\"] > LastBuyPrice  and ((ticker[\\\"Last\\\"] - LastBuyPrice) / LastBuyPrice) > (2 * (EntrustDepth / 100)): \\n                Log(\\\"偏离过多, 最新成交价:\\\", ticker[\\\"Last\\\"], \\\"委托价\\\", LastBuyPrice)\\n                CancelPendingOrders()\\n            else :\\n                return True\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      else :\\n                return True\\n        else :\\n            account = _C(exchange.GetAccount)\\n            Log(\\\"买单完成, 累计花费:\\\", _N(InitAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]), \\\"平均买入价:\\\", _N((InitAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]) / (account[\\\"Stocks\\\"] - InitAccount[\\\"Stocks\\\"])))\\n        LastBuyPrice = 0\\n\\n    BuyPrice = _N(ticker[\\\"Buy\\\"] * (1 - EntrustDepth / 100))\\n    if BuyPrice > MaxBuyPrice:\\n        return True\\n\\n    if not account:\\n        account = _C(exchange.GetAc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " not account:\\n        account = _C(exchange.GetAccount)\\n\\n    if (InitAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]) >= TotalBuyNet:\\n        return False\\n\\n    RandomAvgBuyOnce = (AvgBuyOnce * ((100.0 - FloatPoint) / 100.0)) + (((FloatPoint * 2) / 100.0) * AvgBuyOnce * random.random())   # 随机数 0~1\\n    UsedMoney = min(account[\\\"Balance\\\"], RandomAvgBuyOnce, TotalBuyNet - (InitAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]))\\n\\n    BuyAmount = _N(UsedMoney / BuyPrice)\\n    if BuyAmount < MinStock:\\n        re",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "uyPrice)\\n    if BuyAmount < MinStock:\\n        return False \\n    LastBuyPrice = BuyPrice\\n    exchange.Buy(BuyPrice, BuyAmount, \\\"花费：￥\\\", _N(UsedMoney), \\\"上次成交价\\\", ticker[\\\"Last\\\"])\\n    return True\\n\\ndef main():\\n    global LoopInterval, InitAccount\\n    CancelPendingOrders()\\n    InitAccount = _C(exchange.GetAccount)\\n    Log(InitAccount)\\n    if InitAccount[\\\"Balance\\\"] < TotalBuyNet:\\n        raise Exception(\\\"账户余额不足\\\")\\n    LoopInterval = max(LoopInterval, 1)\\n    while dispatch():\\n        Sleep(Lo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "erval, 1)\\n    while dispatch():\\n        Sleep(LoopInterval * 1000)\\n    Log(\\\"委托全部完成\\\", _C(exchange.GetAccount))\",\n    \"策略名称: Python版冰山委托-买入\\n\\nUsedMoney = min(account[\\\"Balance\\\"], RandomAvgBuyOnce, TotalBuyNet - (InitAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]))\\n\\n    BuyAmount = _N(UsedMoney / BuyPrice)\\n    if BuyAmount < MinStock:\\n        return False \\n    LastBuyPrice = BuyPrice\\n    exchange.Buy(BuyPrice, BuyAmount, \\\"花费：￥\\\", _N(UsedMoney), \\\"上次成交价\\\", ticker[\\\"Last\\\"])\\n    return True\\n\\ndef ma",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "交价\\\", ticker[\\\"Last\\\"])\\n    return True\\n\\ndef main():\\n    global LoopInterval, InitAccount\\n    CancelPendingOrders()\\n    InitAccount = _C(exchange.GetAccount)\\n    Log(InitAccount)\\n    if InitAccount[\\\"Balance\\\"] < TotalBuyNet:\\n        raise Exception(\\\"账户余额不足\\\")\\n    LoopInterval = max(LoopInterval, 1)\\n    while dispatch():\\n        Sleep(LoopInterval * 1000)\\n    Log(\\\"委托全部完成\\\", _C(exchange.GetAccount))\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/188435\\n\\n> Last Modified\\n\\n2020-03-07 16:5",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ategy/188435\\n\\n> Last Modified\\n\\n2020-03-07 16:58:07\"\n \n\n    \"strategy_26\",\n    \"python\\nimport random\\n\\ndef CancelPendingOrders():\\n    while True:\\n        orders = _C(exchange.GetOrders)\\n        if len(orders) == 0:\\n            return\\n        \\n        for j in range(len(orders)):\\n            exchange.CancelOrder(orders[j][\\\"Id\\\"])\\n            if j < len(orders) - 1:\\n                Sleep(Interval)\\n\\nLastSellPrice = 0\\nInitAccount = None\\n\\ndef dispatch():\\n    global LastSellPrice, InitAccount",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dispatch():\\n    global LastSellPrice, InitAccount\\n    account = None\\n    ticker = _C(exchange.GetTicker)\\n    LogStatus(_D(), \\\"ticker:\\\", ticker)\\n    if LastSellPrice > 0:\\n        if len(_C(exchange.GetOrders)) > 0:\\n            if ticker[\\\"Last\\\"] < LastSellPrice and ((LastSellPrice - ticker[\\\"Last\\\"]) / ticker[\\\"Last\\\"]) > (2 * (EntrustDepth / 100)):\\n                Log(\\\"偏离过多，最新成交价：\\\", ticker[\\\"Last\\\"], \\\"委托价\\\", LastSellPrice)\\n                CancelPendingOrders()\\n            else :\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "elPendingOrders()\\n            else :\\n                return True\\n        else :\\n            account = _C(exchange.GetAccount)\\n            Log(\\\"买单完成，累计卖出：\\\", _N(InitAccount[\\\"Stocks\\\"] - account[\\\"Stocks\\\"]), \\\"平均卖出价：\\\", _N((account[\\\"Balance\\\"] - InitAccount[\\\"Balance\\\"]) / (InitAccount[\\\"Stocks\\\"] - account[\\\"Stocks\\\"])))\\n            LastSellPrice = 0\\n\\n    SellPrice = _N(ticker[\\\"Sell\\\"] * (1 + EntrustDepth / 100))\\n    if SellPrice < MinSellPrice:\\n        return True\\n\\n    if not account:\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        return True\\n\\n    if not account:\\n        account = _C(exchange.GetAccount)\\n\\n    if (InitAccount[\\\"Stocks\\\"] - account[\\\"Stocks\\\"]) >= TotalSellStocks:\\n        return False \\n\\n    RandomAvgSellOnce = (AvgSellOnce * ((100.0 - FloatPoint) / 100.0)) + (((FloatPoint * 2) / 100.0) * AvgSellOnce * random.random())\\n    SellAmount = min(TotalSellStocks - (InitAccount[\\\"Stocks\\\"] - account[\\\"Stocks\\\"]), RandomAvgSellOnce)\\n    if SellAmount < MinStock:\\n        return False \\n\\n    LastSellPrice = S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k:\\n        return False \\n\\n    LastSellPrice = SellPrice\\n    exchange.Sell(SellPrice, SellAmount, \\\"上次成交价\\\", ticker[\\\"Last\\\"])\\n    return True\\n\\ndef main():\\n    global InitAccount, LoopInterval\\n    CancelPendingOrders()\\n    InitAccount = _C(exchange.GetAccount)\\n    Log(InitAccount)\\n    if InitAccount[\\\"Stocks\\\"] < TotalSellStocks:\\n        raise Exception(\\\"账户币数不足\\\")\\n    LoopInterval = max(LoopInterval, 1)\\n    while dispatch():\\n        Sleep(LoopInterval)\\n    Log(\\\"委托全部完成\\\", _C(exchange.GetAcc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pInterval)\\n    Log(\\\"委托全部完成\\\", _C(exchange.GetAccount))\",\n    \"策略名称: Python版冰山委托-卖出\\n\\n未找到描述\"\n \n\n    \"strategy_27\",\n    \"python\\n'''backtest\\nstart: 2019-12-01 00:00:00\\nend: 2020-02-01 11:00:00\\nperiod: 1m\\nexchanges: [{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":1}]\\n'''\\n\\nInitAccount = None\\n\\ndef CancelPendingOrders():\\n    ret = False\\n    while True:\\n        orders = _C(exchange.GetOrders)\\n        if len(orders) == 0 :\\n            return ret\\n\\n        for j in range(len(orders)):\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " ret\\n\\n        for j in range(len(orders)):\\n            exchange.CancelOrder(orders[j].Id)\\n            ret = True\\n            if j < len(orders) - 1:\\n                Sleep(Interval)\\n    return ret \\n\\ndef onTick():\\n    acc = _C(exchange.GetAccount)\\n    ticker = _C(exchange.GetTicker)\\n    spread = ticker.Sell - ticker.Buy\\n    diffAsset = (acc.Balance - (acc.Stocks * ticker.Sell)) / 2\\n    ratio = diffAsset / acc.Balance\\n    LogStatus(\\\"ratio:\\\", ratio, _D())\\n    if abs(ratio) < threshold:\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tio, _D())\\n    if abs(ratio) < threshold:\\n        return False\\n    if ratio > 0 :\\n        buyPrice = _N(ticker.Sell + spread, ZPrecision)\\n        buyAmount = _N(diffAsset / buyPrice, XPrecision)\\n        if buyAmount < MinStock:\\n            return False\\n        exchange.Buy(buyPrice, buyAmount, diffAsset, ratio)\\n    else :\\n        sellPrice = _N(ticker.Buy - spread, ZPrecision)\\n        sellAmount = _N(-diffAsset / sellPrice, XPrecision)\\n        if sellAmount < MinStock:\\n            return False ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " sellAmount < MinStock:\\n            return False \\n        exchange.Sell(sellPrice, sellAmount, diffAsset, ratio)\\n    return True\\n\\ndef main():\\n    global InitAccount, LoopInterval\\n    InitAccount = _C(exchange.GetAccount)\\n    LoopInterval = max(LoopInterval, 1)\\n    while True:\\n        if onTick():\\n            Sleep(1000)\\n            CancelPendingOrders()\\n            Log(_C(exchange.GetAccount))\\n        Sleep(LoopInterval * 1000)\",\n    \"策略名称: Python版单平台均衡策略教学\\n\\n未找到描述\"\n \n\n    \"strategy_28\",\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hon版单平台均衡策略教学\\n\\n未找到描述\"\n \n\n    \"strategy_28\",\n    \"python\\n'''backtest\\nstart: 2019-02-20 00:00:00\\nend: 2020-01-10 00:00:00\\nperiod: 1m\\nexchanges: [{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"BTC_USDT\\\"},{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"ETH_USDT\\\",\\\"stocks\\\":30},{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"LTC_USDT\\\",\\\"stocks\\\":100}]\\n'''\\n\\nimport time\\nimport json\\n\\nparams = {\\n    \\\"arrBasePrice\\\": [-1, -1, -1],     # -1\\n    \\\"arrRatio\\\": [0.05, 0.05, 0.05],         # 0.05\\n    \\\"arrAcc\\\": [],           # _C(exchange.GetAc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    \\\"arrAcc\\\": [],           # _C(exchange.GetAccount)\\n    \\\"arrLastCancelAll\\\": [0, 0, 0], # 0\\n    \\\"arrMinStocks\\\": [0.01, 0.01, 0.01],     # 0.01\\n    \\\"arrPricePrecision\\\": [2, 2, 2], # 2\\n    \\\"arrAmountPrecision\\\": [3, 2, 2], # 2\\n    \\\"arrTick\\\":[]\\n}\\n\\ndef CancelAll(e):\\n    while True : \\n        orders = _C(e.GetOrders)\\n        for i in range(len(orders)) :\\n            e.CancelOrder(orders[i][\\\"Id\\\"], orders[i])\\n        if len(orders) == 0 :\\n            break\\n        Sleep(1000)\\n\\ndef p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n            break\\n        Sleep(1000)\\n\\ndef process(e, index):\\n    global params\\n    ticker = _C(e.GetTicker)\\n    params[\\\"arrTick\\\"][index] = ticker\\n    if params[\\\"arrBasePrice\\\"][index] == -1 :\\n        params[\\\"arrBasePrice\\\"][index] = ticker.Last\\n    if ticker.Last - params[\\\"arrBasePrice\\\"][index] > 0 and (ticker.Last - params[\\\"arrBasePrice\\\"][index]) / params[\\\"arrBasePrice\\\"][index] > params[\\\"arrRatio\\\"][index]:\\n        params[\\\"arrAcc\\\"][index] = _C(e.GetAccount)\\n        if params[\\\"a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "][index] = _C(e.GetAccount)\\n        if params[\\\"arrAcc\\\"][index].Balance * params[\\\"arrRatio\\\"][index] / ticker.Last > params[\\\"arrMinStocks\\\"][index]:\\n            e.Buy(ticker.Last, params[\\\"arrAcc\\\"][index].Balance * params[\\\"arrRatio\\\"][index] / ticker.Last)\\n            params[\\\"arrBasePrice\\\"][index] = ticker.Last\\n    if ticker.Last - params[\\\"arrBasePrice\\\"][index] < 0 and (params[\\\"arrBasePrice\\\"][index] - ticker.Last) / params[\\\"arrBasePrice\\\"][index] > params[\\\"arrRatio\\\"][index]: \\n        para",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dex] > params[\\\"arrRatio\\\"][index]: \\n        params[\\\"arrAcc\\\"][index] = _C(e.GetAccount)\\n        if params[\\\"arrAcc\\\"][index].Stocks * params[\\\"arrRatio\\\"][index] > params[\\\"arrMinStocks\\\"][index]:\\n            e.Sell(ticker.Last, params[\\\"arrAcc\\\"][index].Stocks * params[\\\"arrRatio\\\"][index])\\n            params[\\\"arrBasePrice\\\"][index] = ticker.Last\\n    ts = time.time()\\n    if ts - params[\\\"arrLastCancelAll\\\"][index] > 60 * 5 :\\n        CancelAll(e)\\n        params[\\\"arrLastCancelAll\\\"][index] = ts \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        params[\\\"arrLastCancelAll\\\"][index] = ts \\n\\ndef main():\\n    global params\\n    \\n    for i in range(len(exchanges)) :    \\n        params[\\\"arrAcc\\\"].append(_C(exchanges[i].GetAccount))\\n        params[\\\"arrTick\\\"].append(_C(exchanges[i].GetTicker))\\n        exchanges[i].SetPrecision(params[\\\"arrPricePrecision\\\"][i], params[\\\"arrAmountPrecision\\\"][i])\\n\\n    for key in params :\\n        if len(params[key]) < len(exchanges):\\n            raise \\\"params error!\\\"\\n\\n    while True:\\n        tblAcc = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ams error!\\\"\\n\\n    while True:\\n        tblAcc = {\\n            \\\"type\\\" : \\\"table\\\",\\n            \\\"title\\\": \\\"account\\\",\\n            \\\"cols\\\": [\\\"账户信息\\\"], \\n            \\\"rows\\\": []\\n        }        \\n\\n        tblTick = {\\n            \\\"type\\\" : \\\"table\\\",\\n            \\\"title\\\": \\\"ticker\\\",\\n            \\\"cols\\\": [\\\"行情信息\\\"], \\n            \\\"rows\\\": []\\n        }\\n        for i in range(len(exchanges)): \\n            process(exchanges[i], i)\\n\\n        for i in range(len(exchanges)):\\n            tblA",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " for i in range(len(exchanges)):\\n            tblAcc[\\\"rows\\\"].append([json.dumps(params[\\\"arrAcc\\\"][i])])\\n            tblTick[\\\"rows\\\"].append([json.dumps(params[\\\"arrTick\\\"][i])])\\n\\n        LogStatus(_D(), \\\"\\\\n`\\\" + json.dumps([tblAcc, tblTick]) + \\\"`\\\")\\n        Sleep(500)\",\n    \"策略名称: Python版多品种追涨杀跌策略教学\\n\\n\\\"arrRatio\\\": [0.05, 0.05, 0.05],         # 0.05\\n    \\\"arrAcc\\\": [],           # _C(exchange.GetAccount)\\n    \\\"arrLastCancelAll\\\": [0, 0, 0], # 0\\n    \\\"arrMinStocks\\\": [0.01, 0.01, 0.01],     # ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    \\\"arrMinStocks\\\": [0.01, 0.01, 0.01],     # 0.01\\n    \\\"arrPricePrecision\\\": [2, 2, 2], # 2\\n    \\\"arrAmountPrecision\\\": [3, 2, 2], # 2\\n    \\\"arrTick\\\":[]\\n}\\n\\ndef CancelAll(e):\\n    while True : \\n        orders = _C(e.GetOrders)\\n        for i in range(len(orders)) :\\n            e.CancelOrder(orders[i][\\\"Id\\\"], orders[i])\\n        if len(orders) == 0 :\\n            break\\n        Sleep(1000)\\n\\ndef process(e, index):\\n    global params\\n    ticker = _C(e.GetTicker)\\n    params[\\\"arrTick\\\"][index]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = _C(e.GetTicker)\\n    params[\\\"arrTick\\\"][index] = ticker\\n    if params[\\\"arrBasePrice\\\"][index] == -1 :\\n        params[\\\"arrBasePrice\\\"][index] = ticker.Last\\n    if ticker.Last - params[\\\"arrBasePrice\\\"][index] > 0 and (ticker.Last - params[\\\"arrBasePrice\\\"][index]) / params[\\\"arrBasePrice\\\"][index] > params[\\\"arrRatio\\\"][index]:\\n        params[\\\"arrAcc\\\"][index] = _C(e.GetAccount)\\n        if params[\\\"arrAcc\\\"][index].Balance * params[\\\"arrRatio\\\"][index] / ticker.Last > params[\\\"arrMinStocks\\\"][ind",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ndex] / ticker.Last > params[\\\"arrMinStocks\\\"][index]:\\n            e.Buy(ticker.Last, params[\\\"arrAcc\\\"][index].Balance * params[\\\"arrRatio\\\"][index] / ticker.Last)\\n            params[\\\"arrBasePrice\\\"][index] = ticker.Last\\n    if ticker.Last - params[\\\"arrBasePrice\\\"][index] < 0 and (params[\\\"arrBasePrice\\\"][index] - ticker.Last) / params[\\\"arrBasePrice\\\"][index] > params[\\\"arrRatio\\\"][index]: \\n        params[\\\"arrAcc\\\"][index] = _C(e.GetAccount)\\n        if params[\\\"arrAcc\\\"][index].Stocks * params[\\\"a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  if params[\\\"arrAcc\\\"][index].Stocks * params[\\\"arrRatio\\\"][index] > params[\\\"arrMinStocks\\\"][index]:\\n            e.Sell(ticker.Last, params[\\\"arrAcc\\\"][index].Stocks * params[\\\"arrRatio\\\"][index])\\n            params[\\\"arrBasePrice\\\"][index] = ticker.Last\\n    ts = time.time()\\n    if ts - params[\\\"arrLastCancelAll\\\"][index] > 60 * 5 :\\n        CancelAll(e)\\n        params[\\\"arrLastCancelAll\\\"][index] = ts \\n\\ndef main():\\n    global params\\n    \\n    for i in range(len(exchanges)) :    \\n        params[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " i in range(len(exchanges)) :    \\n        params[\\\"arrAcc\\\"].append(_C(exchanges[i].GetAccount))\\n        params[\\\"arrTick\\\"].append(_C(exchanges[i].GetTicker))\\n        exchanges[i].SetPrecision(params[\\\"arrPricePrecision\\\"][i], params[\\\"arrAmountPrecision\\\"][i])\\n\\n    for key in params :\\n        if len(params[key]) < len(exchanges):\\n            raise \\\"params error!\\\"\\n\\n    while True:\\n        tblAcc = {\\n            \\\"type\\\" : \\\"table\\\",\\n            \\\"title\\\": \\\"account\\\",\\n            \\\"cols\\\": [",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\\"title\\\": \\\"account\\\",\\n            \\\"cols\\\": [\\\"账户信息\\\"], \\n            \\\"rows\\\": []\\n        }        \\n\\n        tblTick = {\\n            \\\"type\\\" : \\\"table\\\",\\n            \\\"title\\\": \\\"ticker\\\",\\n            \\\"cols\\\": [\\\"行情信息\\\"], \\n            \\\"rows\\\": []\\n        }\\n        for i in range(len(exchanges)): \\n            process(exchanges[i], i)\\n\\n        for i in range(len(exchanges)):\\n            tblAcc[\\\"rows\\\"].append([json.dumps(params[\\\"arrAcc\\\"][i])])\\n            tblTick[\\\"rows\\\"].append([js",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"][i])])\\n            tblTick[\\\"rows\\\"].append([json.dumps(params[\\\"arrTick\\\"][i])])\\n\\n        LogStatus(_D(), \\\"\\\\n`\\\" + json.dumps([tblAcc, tblTick]) + \\\"`\\\")\\n        Sleep(500)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/182268\\n\\n> Last Modified\\n\\n2020-01-20 17:44:33\"\n \n\n    \"strategy_29\",\n    \"python\\n'''backtest\\nstart: 2019-01-22 00:00:00\\nend: 2019-01-23 00:00:00\\nperiod: 30m\\nexchanges: [{\\\"eid\\\":\\\"OKCoin_EN\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\n\\nimport random\\nimport time\\ndef main():\\n    c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\nimport random\\nimport time\\ndef main():\\n    cfgA = {\\n        \\\"extension\\\" : {\\n            \\\"layout\\\" : \\\"single\\\", \\n            \\\"height\\\" : 300,\\n            \\\"col\\\" : 8\\n        \\n        \\\"title\\\" : {\\n            \\\"text\\\" : \\\"盘口图表\\\"\\n       \\n        \\\"xAxis\\\" : {\\n            \\\"type\\\" : \\\"datetime\\\" \\n        \\n        \\\"series\\\" : [{\\n            \\\"name\\\" : \\\"买一\\\",\\n            \\\"data\\\" : []\\n      \\n            \\\"name\\\" : \\\"卖一\\\", \\n            \\\"data\\\" : []\\n        }]\\n    }    \\n\\n    cfgB",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\\"data\\\" : []\\n        }]\\n    }    \\n\\n    cfgB = {\\n        \\\"title\\\" : {\\n            \\\"text\\\" : \\\"差价图\\\"\\n        \\n        \\\"xAxis\\\" : {\\n            \\\"type\\\" : \\\"datetime\\\",\\n        \\n        \\\"series\\\" : [{\\n            \\\"name\\\" : \\\"差价\\\", \\n            \\\"type\\\" : \\\"column\\\", \\n            \\\"data\\\" : []\\n        }]\\n    }    \\n\\n    cfgC = {\\n        \\\"__isStock\\\" : False,\\n        \\\"title\\\" : {\\n            \\\"text\\\" : \\\"饼图\\\"\\n        \\n        \\\"series\\\" : [{\\n            \\\"type\\\" : \\\"pie\\\", \\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ies\\\" : [{\\n            \\\"type\\\" : \\\"pie\\\", \\n            \\\"name\\\" : \\\"one\\\", \\n            \\\"data\\\" : [\\n                [\\\"A\\\", 25],\\n                [\\\"B\\\", 25],\\n                [\\\"C\\\", 25],\\n                [\\\"D\\\", 25],\\n            ]\\n        }]\\n    }    \\n\\n    cfgD = {\\n        \\\"extension\\\" : {\\n            \\\"layout\\\" : \\\"single\\\",\\n            \\\"col\\\" : 8,\\n            \\\"height\\\" : \\\"300px\\\"\\n        \\n        \\\"title\\\" : {\\n            \\\"text\\\" : \\\"盘口图表\\\"\\n        \\n        \\\"series\\\" : [{\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\\"盘口图表\\\"\\n        \\n        \\\"series\\\" : [{\\n            \\\"name\\\" : \\\"买一\\\", \\n            \\\"data\\\" : []\\n      \\n            \\\"name\\\" : \\\"卖一\\\",\\n            \\\"data\\\" : []\\n        }]\\n    }    \\n\\n    cfgE = {\\n        \\\"__isStock\\\" : False, \\n        \\\"extension\\\" : {\\n            \\\"layout\\\" : \\\"single\\\", \\n            \\\"col\\\" : 4,\\n            \\\"height\\\" : \\\"300px\\\"\\n        \\n        \\\"title\\\" : {\\n            \\\"text\\\" : \\\"饼图2\\\"\\n       \\n        \\\"series\\\" : [{\\n            \\\"type\\\" : \\\"pie\\\",\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s\\\" : [{\\n            \\\"type\\\" : \\\"pie\\\",\\n            \\\"name\\\" : \\\"one\\\", \\n            \\\"data\\\" : [\\n                [\\\"A\\\", 25], \\n                [\\\"B\\\", 25], \\n                [\\\"C\\\", 25], \\n                [\\\"D\\\", 25]\\n            ]\\n        }]\\n    }\\n    \\n    chart = Chart([cfgA, cfgB, cfgC, cfgD, cfgE])\\n    chart.reset()\\n    chart.add(3, {\\n        \\\"name\\\" : \\\"ZZ\\\",\\n        \\\"y\\\" : random.random() * 100\\n    })\\n    \\n    while True:\\n        Sleep(1000)\\n        ticker = exchange.GetTicker()\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "leep(1000)\\n        ticker = exchange.GetTicker()\\n        if not ticker :\\n            continue\\n        diff = ticker[\\\"Sell\\\"] - ticker[\\\"Buy\\\"]\\n        cfgA[\\\"subtitle\\\"] = {\\n            \\\"text\\\" : \\\"买一\\\" + str(ticker[\\\"Buy\\\"]) + \\\"卖一\\\" + str(ticker[\\\"Sell\\\"])\\n        }\\n        cfgB[\\\"subtitle\\\"] = {\\n            \\\"text\\\" : \\\"价差 \\\" + str(diff)\\n        }\\n        \\n        chart.add(0, [time.time() * 1000, ticker[\\\"Buy\\\"]])\\n        chart.add(1, [time.time() * 1000, ticker[\\\"Sell\\\"]])\\n        chart",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e.time() * 1000, ticker[\\\"Sell\\\"]])\\n        chart.add(2, [time.time() * 1000, diff])\\n        chart.add(4, [time.time() * 1000, ticker[\\\"Buy\\\"]])\\n        chart.add(5, [time.time() * 1000, ticker[\\\"Buy\\\"]])\\n        cfgC[\\\"series\\\"][0][\\\"data\\\"][0][1] = random.random() * 100\\n        cfgE[\\\"series\\\"][0][\\\"data\\\"][0][1] = random.random() * 100\",\n    \"策略名称: Python版多图表范例\\n\\n未找到描述\"\n \n\n    \"strategy_30\",\n    \"python\\n'''backtest\\nstart: 2019-07-01 00:00:00\\nend: 2020-01-03 00:00:00\\nperiod: 1m\\nexchanges: [{\\\"e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 2020-01-03 00:00:00\\nperiod: 1m\\nexchanges: [{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\n\\nimport json\\n\\n# 参数\\nbeginPrice = 5000\\nendPrice = 8000\\ndistance = 20\\npointProfit = 50\\namount = 0.01\\nminBalance = 300\\n\\n# 全局变量\\narrNet = []\\narrMsg = []\\nacc = None\\n\\ndef findOrder (orderId, NumOfTimes, ordersList = []) :\\n    for j in range(NumOfTimes) :\\n        orders = None\\n        if len(ordersList) == 0:\\n            orders = _C(exchange.GetOrders)\\n        else :\\n            orders = ordersList",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n        else :\\n            orders = ordersList\\n        for i in range(len(orders)):\\n            if orderId == orders[i][\\\"Id\\\"]:\\n                return True\\n        Sleep(1000)\\n    return False\\n\\ndef cancelOrder (price, orderType) :\\n    orders = _C(exchange.GetOrders)\\n    for i in range(len(orders)) : \\n        if price == orders[i][\\\"Price\\\"] and orderType == orders[i][\\\"Type\\\"]: \\n            exchange.CancelOrder(orders[i][\\\"Id\\\"])\\n            Sleep(500)\\n\\ndef checkOpenOrders (orders, ticker",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " Sleep(500)\\n\\ndef checkOpenOrders (orders, ticker) :\\n    global arrNet, arrMsg\\n    for i in range(len(arrNet)) : \\n        if not findOrder(arrNet[i][\\\"id\\\"], 1, orders) and arrNet[i][\\\"state\\\"] == \\\"pending\\\" :\\n            orderId = exchange.Sell(arrNet[i][\\\"coverPrice\\\"], arrNet[i][\\\"amount\\\"], arrNet[i], ticker)\\n            if orderId :\\n                arrNet[i][\\\"state\\\"] = \\\"cover\\\"\\n                arrNet[i][\\\"id\\\"] = orderId                \\n            else :\\n                # 撤销\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         else :\\n                # 撤销\\n                cancelOrder(arrNet[i][\\\"coverPrice\\\"], ORDER_TYPE_SELL)\\n                arrMsg.append(\\\"挂单失败!\\\" + json.dumps(arrNet[i]) + \\\", time:\\\" + _D())\\n\\ndef checkCoverOrders (orders, ticker) :\\n    global arrNet, arrMsg\\n    for i in range(len(arrNet)) : \\n        if not findOrder(arrNet[i][\\\"id\\\"], 1, orders) and arrNet[i][\\\"state\\\"] == \\\"cover\\\" :\\n            arrNet[i][\\\"id\\\"] = -1\\n            arrNet[i][\\\"state\\\"] = \\\"idle\\\"\\n            Log(arrNet[i], \\\"节",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tate\\\"] = \\\"idle\\\"\\n            Log(arrNet[i], \\\"节点平仓，重置为空闲状态。\\\", \\\"#FF0000\\\")\\n\\n\\ndef onTick () :\\n    global arrNet, arrMsg, acc\\n\\n    ticker = _C(exchange.GetTicker)\\n    for i in range(len(arrNet)):\\n        if i != len(arrNet) - 1 and arrNet[i][\\\"state\\\"] == \\\"idle\\\" and ticker.Sell > arrNet[i][\\\"price\\\"] and ticker.Sell < arrNet[i + 1][\\\"price\\\"]:\\n            acc = _C(exchange.GetAccount)\\n            if acc.Balance < minBalance :\\n                arrMsg.append(\\\"资金不足\\\" + json.dumps(acc) + \\\"！\\\" + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rrMsg.append(\\\"资金不足\\\" + json.dumps(acc) + \\\"！\\\" + \\\", time:\\\" + _D())\\n                break\\n\\n            orderId = exchange.Buy(arrNet[i][\\\"price\\\"], arrNet[i][\\\"amount\\\"], arrNet[i], ticker)\\n            if orderId : \\n                arrNet[i][\\\"state\\\"] = \\\"pending\\\"\\n                arrNet[i][\\\"id\\\"] = orderId\\n            else :\\n                # 撤单\\n                cancelOrder(arrNet[i][\\\"price\\\"], ORDER_TYPE_BUY)\\n                arrMsg.append(\\\"挂单失败!\\\" + json.dumps(arrNet[i]) + \\\", time:\\\" + _D(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "单失败!\\\" + json.dumps(arrNet[i]) + \\\", time:\\\" + _D())\\n    Sleep(1000)\\n    orders = _C(exchange.GetOrders)\\n    checkOpenOrders(orders, ticker)\\n    Sleep(1000)\\n    orders = _C(exchange.GetOrders)\\n    checkCoverOrders(orders, ticker)\\n\\n    tbl = {\\n        \\\"type\\\" : \\\"table\\\", \\n        \\\"title\\\" : \\\"网格状态\\\",\\n        \\\"cols\\\" : [\\\"节点索引\\\", \\\"详细信息\\\"], \\n        \\\"rows\\\" : [], \\n    }    \\n\\n    for i in range(len(arrNet)) : \\n        tbl[\\\"rows\\\"].append([i, json.dumps(arrNet[i])])\\n\\n    errTbl = {\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "i, json.dumps(arrNet[i])])\\n\\n    errTbl = {\\n        \\\"type\\\" : \\\"table\\\", \\n        \\\"title\\\" : \\\"记录\\\",\\n        \\\"cols\\\" : [\\\"节点索引\\\", \\\"详细信息\\\"], \\n        \\\"rows\\\" : [], \\n    }\\n\\n    orderTbl = {\\n     \\t\\\"type\\\" : \\\"table\\\", \\n        \\\"title\\\" : \\\"orders\\\",\\n        \\\"cols\\\" : [\\\"节点索引\\\", \\\"详细信息\\\"], \\n        \\\"rows\\\" : [],    \\n    }\\n\\n    while len(arrMsg) > 20 : \\n        arrMsg.pop(0)\\n\\n    for i in range(len(arrMsg)) : \\n        errTbl[\\\"rows\\\"].append([i, json.dumps(arrMsg[i])])    \\n\\n    for",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".append([i, json.dumps(arrMsg[i])])    \\n\\n    for i in range(len(orders)) : \\n        orderTbl[\\\"rows\\\"].append([i, json.dumps(orders[i])])\\n\\n    LogStatus(_D(), \\\"\\\\n\\\", acc, \\\"\\\\n\\\", \\\"arrMsg length:\\\", len(arrMsg), \\\"\\\\n\\\", \\\"`\\\" + json.dumps([tbl, errTbl, orderTbl]) + \\\"`\\\")\\n\\n\\ndef main ():\\n    global arrNet\\n    for i in range(int((endPrice - beginPrice) / distance)):\\n        arrNet.append({\\n            \\\"price\\\" : beginPrice + i * distance,\\n            \\\"amount\\\" : amount,\\n            \\\"state",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         \\\"amount\\\" : amount,\\n            \\\"state\\\" : \\\"idle\\\",    # pending / cover / idle\\n            \\\"coverPrice\\\" : beginPrice + i * distance + pointProfit,\\n            \\\"id\\\" : -1,\\n        })\\n        \\n    while True:\\n        onTick()\\n        Sleep(500)\",\n    \"策略名称: Python版简单网格策略教学\\n\\nbeginPrice = 5000\\nendPrice = 8000\\ndistance = 20\\npointProfit = 50\\namount = 0.01\\nminBalance = 300\"\n \n\n    \"strategy_31\",\n    \"python\\n'''backtest\\nstart: 2019-02-20 00:00:00\\nend: 2020-01-10 00:00:00\\nperiod: 1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "2-20 00:00:00\\nend: 2020-01-10 00:00:00\\nperiod: 1m\\nexchanges: [{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\n\\nimport time\\n\\nbasePrice = -1\\nratio = 0.05\\nacc = _C(exchange.GetAccount)\\nlastCancelAll = 0\\nminStocks = 0.01\\n\\ndef CancelAll():\\n    while True : \\n        orders = _C(exchange.GetOrders)\\n        for i in range(len(orders)) :\\n            exchange.CancelOrder(orders[i][\\\"Id\\\"], orders[i])\\n        if len(orders) == 0 :\\n            break\\n        Sleep(1000)\\n\\ndef main():\\n    global ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k\\n        Sleep(1000)\\n\\ndef main():\\n    global basePrice, acc, lastCancelAll\\n    exchange.SetPrecision(2, 3)\\n    while True:\\n        ticker = _C(exchange.GetTicker)\\n        if basePrice == -1 :\\n            basePrice = ticker.Last\\n        if ticker.Last - basePrice > 0 and (ticker.Last - basePrice) / basePrice > ratio :\\n            acc = _C(exchange.GetAccount)\\n            if acc.Balance * ratio / ticker.Last > minStocks :\\n                exchange.Buy(ticker.Last, acc.Balance * ratio / ticker.Las",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".Buy(ticker.Last, acc.Balance * ratio / ticker.Last)\\n                basePrice = ticker.Last\\n        if ticker.Last - basePrice < 0 and (basePrice - ticker.Last) / basePrice > ratio : \\n            acc = _C(exchange.GetAccount)\\n            if acc.Stocks * ratio > minStocks :\\n                exchange.Sell(ticker.Last, acc.Stocks * ratio)\\n                basePrice = ticker.Last\\n        ts = time.time()\\n        if ts - lastCancelAll > 60 * 5 :\\n            CancelAll()\\n            lastCancelAll = ts \\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   CancelAll()\\n            lastCancelAll = ts \\n        LogStatus(_D(), \\\"\\\\n\\\", \\\"行情信息:\\\", ticker, \\\"\\\\n\\\", \\\"账户信息:\\\", acc)\\n        Sleep(500)\",\n    \"策略名称: Python版追涨杀跌策略教学\\n\\n未找到描述\"\n \n\n    \"strategy_32\",\n    \"python\\n'''backtest\\nstart: 2021-05-01 00:00:00\\nend: 2021-05-29 00:00:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"Futures_Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\n\\n# 原版代码是现货版：\\n# https://www.fmz.com/bbs-topic/4908\\n\\n# 现在改为合约版。\\n\\n# ———— 韬奋量化（微信：himandy）\\n\\n\\n# 好的交易平台可以让你的策略扶摇直上九万里，通",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "——— 韬奋量化（微信：himandy）\\n\\n\\n# 好的交易平台可以让你的策略扶摇直上九万里，通过链接注册可获得两个月VIP5的手续费率优惠：\\n# （现货：挂单0%，吃单0.07%。合约：挂单0%，吃单0.04%）\\n# https://www.kucoin.cc/ucenter/signup?rcode=1wxJ2fQ&lang=zh_CN&utmsource=VIP_TF\\n\\nimport time\\n\\nbasePrice = -1\\nratio = 0.05\\nacc = _C(exchange.GetAccount)\\npos = _C(exchange.GetPosition)\\nlastCancelAll = 0\\nminStocks = 0.01\\n\\ndef CancelAll():\\n    while True : \\n        orders = _C(exchange.GetOrders)\\n        for i in range(len(orders)) :\\n            exchange.CancelOrder(orders[i][\\\"Id\\\"], ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          exchange.CancelOrder(orders[i][\\\"Id\\\"], orders[i])\\n        if len(orders) == 0 :\\n            break\\n        Sleep(1000)\\n\\ndef main():\\n    global basePrice, acc, lastCancelAll, leverage, StopGain, StopLoss\\n    #Log(StopLoss * -1)\\n    exchange.SetContractType(\\\"swap\\\")\\n    exchange.SetMarginLevel(leverage)\\n    exchange.SetPrecision(2, 3)\\n    pos = _C(exchange.GetPosition)\\n    while True:\\n        ticker = _C(exchange.GetTicker)\\n        if basePrice == -1 :\\n            basePrice = ticker.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "basePrice == -1 :\\n            basePrice = ticker.Last\\n        if ticker.Last - basePrice > 0 and (ticker.Last - basePrice) / basePrice > ratio :\\n            acc = _C(exchange.GetAccount)            \\n            if acc.Balance * ratio * leverage / ticker.Last > minStocks and len(pos) == 0:\\n                exchange.SetDirection(\\\"buy\\\")\\n                exchange.Buy(_N(ticker.Last, 2), _N(acc.Balance * ratio / ticker.Last, 3))\\n                basePrice = ticker.Last\\n                ts = time.time()\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " ticker.Last\\n                ts = time.time()\\n                if ts - lastCancelAll > 60 * 5 :\\n                    CancelAll()\\n                    lastCancelAll = ts\\n                pos = _C(exchange.GetPosition)\\n        if ticker.Last - basePrice < 0 and (basePrice - ticker.Last) / basePrice > ratio : \\n            acc = _C(exchange.GetAccount)\\n            pos = _C(exchange.GetPosition)\\n            if acc.Balance * ratio * leverage / ticker.Last > minStocks and len(pos) == 0:\\n                excha",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "inStocks and len(pos) == 0:\\n                exchange.SetDirection(\\\"sell\\\")\\n                exchange.Sell(_N(ticker.Last, 2), _N(acc.Balance * ratio / ticker.Last, 3))\\n                basePrice = ticker.Last\\n                ts = time.time()\\n                if ts - lastCancelAll > 60 * 5 :\\n                    CancelAll()\\n                    lastCancelAll = ts\\n                pos = _C(exchange.GetPosition)\\n        if len(pos) == 1 :\\n        \\t#Log(pos)\\n            if pos[0][\\\"Profit\\\"] / pos[0][\\\"M",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s)\\n            if pos[0][\\\"Profit\\\"] / pos[0][\\\"Margin\\\"] > StopGain :\\n                if pos[0][\\\"Type\\\"] == 0 :\\n                    exchange.SetDirection(\\\"closebuy\\\")\\n                    exchange.Sell(-1, pos[0][\\\"Amount\\\"])\\n                    pos = _C(exchange.GetPosition)\\n                elif pos[0][\\\"Type\\\"] == 1 :\\n                    exchange.SetDirection(\\\"closesell\\\")\\n                    exchange.Buy(-1, pos[0][\\\"Amount\\\"])\\n                    pos = _C(exchange.GetPosition)\\n            e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     pos = _C(exchange.GetPosition)\\n            elif pos[0][\\\"Profit\\\"] / pos[0][\\\"Margin\\\"] < StopLoss * -1 :\\n                if pos[0][\\\"Type\\\"] == 0 :\\n                    exchange.SetDirection(\\\"closebuy\\\")\\n                    exchange.Sell(-1, pos[0][\\\"Amount\\\"])\\n                    pos = _C(exchange.GetPosition)\\n                elif pos[0][\\\"Type\\\"] == 1 :\\n                    exchange.SetDirection(\\\"closesell\\\")\\n                    exchange.Buy(-1, pos[0][\\\"Amount\\\"])\\n                    pos =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "-1, pos[0][\\\"Amount\\\"])\\n                    pos = _C(exchange.GetPosition)\\n\\n        LogStatus(_D(), \\\"\\\\n\\\", \\\"行情信息:\\\", ticker, \\\"\\\\n\\\", \\\"账户信息:\\\", acc)\\n        if exchange.GetName() == \\\"Futures_Binance\\\" and IsVirtual() == false :\\n            LogProfit(_N(float(acc[\\\"Info\\\"][\\\"totalWalletBalance\\\"], 4)))\\n        Sleep(500)\",\n    \"策略名称: Python版追涨杀跌策略教学币安USDT永续合约\\n\\n# https://www.fmz.com/bbs-topic/4908\"\n \n\n    \"strategy_33\",\n    \"python\\nimport time\\nimport talib\\n\\ndef main():\\n    LogProfitReset()\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mport talib\\n\\ndef main():\\n    LogProfitReset()\\n    LogReset()\\n    Log(\\\"init OK\\\", time.strftime('%Y-%m-%d %X', time.localtime(time.time())))\\n    Log(a,b,c,d)\\n    _G(\\\"ok\\\", 123)\\n    Log(GetPid(), _G(), _G(\\\"ok\\\"), _G(\\\"dummy\\\"))\\n    Sleep(1000)\\n    _G(None)\\n    Log(_G(\\\"ok\\\"))\\n\\n    LogStatus(\\\"Time\\\", time.time())\\n    EnableLog(True)\\n    SetErrorFilter(\\\"net\\\")\\n    Log(GetLastError())\\n    Log(GetCommand())\\n    ticker = exchange.GetTicker()\\n    Log('ticker buy', ticker.Buy, ticker['Buy']);",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    Log('ticker buy', ticker.Buy, ticker['Buy']);\\n    \\n    r = _C(exchange.GetRecords)\\n    Log(TA.ATR(r))\\n    Log(TA.EMA(r, 10))\\n    # test talib\\n    Log(str(talib.EMA(r.Close, 10)))\\n\\n    for e in exchanges:\\n        Log(e.GetName(), e.GetRate(), e.GetCurrency())\\n        Log(e.GetAccount())\\n        Log(_C(e.GetOrders))\\n        Log(e.GetOrder(10))\\n        Log(e.CancelOrder(10000))\\n \\n        Log(e.GetUSDCNY())\\n        #Log(e.GetPosition())\\n        #Log(e.SetContractType(\\\"next_week\\\"))\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     #Log(e.SetContractType(\\\"next_week\\\"))\\n        Log(e.GetTicker())\\n        Log('Asks:', len(e.GetDepth().Asks))\\n        #Log(e.SetMarginLevel(10))\\n        #Log(e.SetDirection(\\\"buy\\\"))\\n        #Log(e.SetContractType(\\\"quarter\\\"))\\n        #Log(e.GetRecords(PERIOD_M30)[0])\\n        Log(e.GetRecords()[0])\\n    x = Chart({\\n        'title' : { 'text' : 'test chart'},\\n        'xAxis': { 'type': 'datetime'},\\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\\n        })",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": []}, {'name' : 'Sell', 'data' : []}]\\n        })\\n    x.reset()\\n    Log(\\\"策略将每10秒更新一次ticker\\\");\\n    for i in range(100):\\n        ts = int(time.time() * 1000)\\n        ticker = _C(exchange.GetTicker)\\n        x.add(0, [ts, ticker.Buy])\\n        x.add(1, [ts, ticker.Sell])\\n        LogStatus(ticker)\\n        Sleep(10000)\",\n    \"策略名称: Python简单测试策略\\n\\nLog(str(talib.EMA(r.Close, 10)))\\n\\n    for e in exchanges:\\n        Log(e.GetName(), e.GetRate(), e.GetCurrency())\\n        Log(e.GetAccount())\\n        Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rency())\\n        Log(e.GetAccount())\\n        Log(_C(e.GetOrders))\\n        Log(e.GetOrder(10))\\n        Log(e.CancelOrder(10000))\\n \\n        Log(e.GetUSDCNY())\\n        #Log(e.GetPosition())\\n        #Log(e.SetContractType(\\\"next_week\\\"))\\n        Log(e.GetTicker())\\n        Log('Asks:', len(e.GetDepth().Asks))\\n        #Log(e.SetMarginLevel(10))\\n        #Log(e.SetDirection(\\\"buy\\\"))\\n        #Log(e.SetContractType(\\\"quarter\\\"))\\n        #Log(e.GetRecords(PERIOD_M30)[0])\\n        Log(e.GetRecords()[0])\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s(PERIOD_M30)[0])\\n        Log(e.GetRecords()[0])\\n    x = Chart({\\n        'title' : { 'text' : 'test chart'},\\n        'xAxis': { 'type': 'datetime'},\\n        'series' : [{'name' : 'Buy', 'data' : []}, {'name' : 'Sell', 'data' : []}]\\n        })\\n    x.reset()\\n    Log(\\\"策略将每10秒更新一次ticker\\\");\\n    for i in range(100):\\n        ts = int(time.time() * 1000)\\n        ticker = _C(exchange.GetTicker)\\n        x.add(0, [ts, ticker.Buy])\\n        x.add(1, [ts, ticker.Sell])\\n        LogStatus(ticker)\\n        S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "icker.Sell])\\n        LogStatus(ticker)\\n        Sleep(10000)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/20761\\n\\n> Last Modified\\n\\n2018-06-05 16:43:46\"\n \n\n    \"strategy_34\",\n    \"python\\n#!/usr/local/bin/python\\n#-*- coding: UTF-8 -*-\\n#R-Breaker 交易策略\\n#策略提供者 @FJK   QQ:171938416\\n#改进  @太极  QQ:7650371\\n\\ndef my_buy(): #开仓\\n    try:\\n        global buy_price,buy_qty\\n        initAccount = ext.GetAccount()  #交易模板的导出函数， 获得账户状态，保存策略运行前账户初始状态\\n        opAmount=1\\n        PositionRatio =1\\n        #开仓之前判断有",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ount=1\\n        PositionRatio =1\\n        #开仓之前判断有币没有没有先进行买入\\n        if int(initAccount.Stocks)>1:\\n            if buy_price<1:\\n                buy_price=_C(exchange.GetTicker).Last\\n                buy_qty=initAccount.Stocks\\n            #Log('开仓信息1 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\\n            return 1\\n        if int(initAccount.Stocks)<1:\\n            if int(str(initAccount.Stocks).replace('0.',''))>=3:\\n                if buy_price<1:\\n                    buy_price=_C(exchange",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rice<1:\\n                    buy_price=_C(exchange.GetTicker).Last\\n                    buy_qty=initAccount.Stocks\\n                #Log('开仓信息2 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\\n                return 1\\n\\n        #if int(str(initAccount.Stocks).replace('0.',''))==0:\\n        opAmount = _N(initAccount.Balance*PositionRatio,3)  #买入数量\\n        Log(\\\"开仓没有币先进行 开仓买入%s元\\\"%(str(opAmount)))   #生成LOG日志\\n\\n        Dict = ext.Buy(opAmount)  #买入ext.Buy\\n        if(Dict):#确认开仓成功\\n            buy_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xt.Buy\\n        if(Dict):#确认开仓成功\\n            buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\\n            buy_qty=Dict['amount']  #买入数量\\n            #LogProfit(_N(gains,4),'开仓信息 钱:',initAccount.Balance,'--币:',initAccount.Stocks,'--开仓详情:',Dict)\\n            print_log(1,initAccount)\\n            return 1\\n        return 0\\n\\n    except Exception,ex:\\n        Log('except Exception my_buy:',ex)\\n        return 0\\n\\n\\nimport time\\nimport datetime\\ndef Caltime(date1,date2):   #计算运行天数\\n    try",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time\\ndef Caltime(date1,date2):   #计算运行天数\\n    try:\\n        date1=time.strptime(date1,\\\"%Y-%m-%d %H:%M:%S\\\")\\n        date2=time.strptime(date2,\\\"%Y-%m-%d %H:%M:%S\\\")\\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\\n        return date2-date1\\n    except Exception,ex:\\n        Log('except Exception Caltime:',ex)\\n        return \\\"except Exception\\\"\\n\\nstart_timexx =time.localtime(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xcept Exception\\\"\\n\\nstart_timexx =time.localtime(time.time()) #time.clock()\\nstart_time=time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",start_timexx)\\nbuy_price=0 #买入价格\\nbuy_qty=0  #买入数量\\ngains=0  #盈利\\n\\nbeng_Account = ext.GetAccount()  #初始化信息\\nbeng_ticker = _C(exchange.GetTicker).Last#Ticker \\t市场行情   最后成交价\\nbeng_Balance=(beng_Account.Stocks*beng_ticker)+beng_Account.Balance #初始化账户钱\\ndef print_log(k_p,data=\\\"\\\"):  #输出\\n    try:\\n        name=\\\"\\\"\\n        if k_p:\\n            name=\\\"开仓\\\"\\n        else:\\n            na",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        name=\\\"开仓\\\"\\n        else:\\n            name=\\\"平仓\\\"\\n        global beng_Account,beng_ticker,beng_Balance\\n        global gains\\n        end_Account = ext.GetAccount()  #当前账户信息\\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \\t市场行情   最后成交价\\n        #################################################\\n        date1=time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",time.localtime(time.time()))\\n        msg_data0=(\\\"本次开始运行时间:%s已运行:%s\\\\r\\\\n\\\"%(start_time,Caltime(start_time,date1)))\\n        ###################",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e(start_time,date1)))\\n        #################################################\\n        msg_data1=(\\\"本次初始化状态:%s\\\\r\\\\n当前运行状态:%s\\\\r\\\\n\\\"%(beng_Account,end_Account))\\n        #################################################\\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\\n        msg_data2=(\\\"初始化钱:%s现在钱:%s盈亏:%s\\\\r\\\\n\\\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\\n        #################################################\\n        total = end_Account.B",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "###################\\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\\n        roi = ((total/beng_Balance) -1)*100\\n        msg_data3=(\\\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\\\r\\\\n\\\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\\n        #################################################\\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\\n        msg_data4=(\\\"本次盈亏:%s(RMB)\\\\t总盈亏:%.2f(RMB) %.2f\\\\r\\\\n\\\"%(str(gains),inco",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "RMB)\\\\t总盈亏:%.2f(RMB) %.2f\\\\r\\\\n\\\"%(str(gains),income,roi))\\n        #################################################\\n        #盈利计算方法\\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\\n        new_end_balance2=(end_Acco",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " x 初始价格 + 初始钱）\\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\\n        msg_data5=(\\\"浮动利润:%s(RMB)\\\\r\\\\n账面利润:%s(RMB)\\\\r\\\\n\\\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\\n        #################################################\\n        LogStatus(\\\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\\\r\\\\n\\\",\\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,\\n                  \\\"更新时间:%s\\\\r\\\\n\\\"%(dat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g_data5,\\n                  \\\"更新时间:%s\\\\r\\\\n\\\"%(date1),\\n                  \\\"%s\\\"%(data)\\n                  )\\n        #################################################\\n        #################################################\\n        #################################################\\n    except Exception,ex:\\n        Log('except Exception print_log:',ex)\\n\\ndef my_sell(): #平仓\\n    try:\\n        global buy_price,buy_qty,gains,ExitPeriod\\n        ExitPeriod = 0\\n        nowAccount = ext.GetAccount()  #交易模板的",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= 0\\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\\n        if nowAccount.Stocks<=0.002:  #保证满足交易量\\n            #Log('不满足最小交易量:',nowAccount.Stocks)\\n            return 1\\n\\n        #history_Last=_N(Volume_averages(Ticker_list),2)    #历史均价\\n        #cur_last = _N(_C(exchange.GetTicker).Last,2)\\n\\n        #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod :   #当前价格一定要大于  开仓价格\\n        if True:\\n            #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod and  history_Last - cur_l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",2)>buy_price+ExitPeriod and  history_Last - cur_last >0 and  history_Last - cur_last < 2 :   #当前价格一定要大于  开仓价格\\n            #Log('历史差价:',history_Last - cur_last)\\n            Dict = ext.Sell(nowAccount.Stocks)\\n            #Dict ={\\\"price\\\":_C(exchange.GetTicker).Last}\\n            if(Dict):\\n                #sell_count+=1\\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\\n                gains=gains+sell_gains\\n                buy_price=0 #买入价格\\n                buy_qty=0  #买入数量\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " #买入价格\\n                buy_qty=0  #买入数量\\n                LogProfit(_N(gains,4),'平仓信息 钱:',nowAccount.Balance,'--币:',nowAccount.Stocks,'--平仓详情:',Dict)#收益曲线\\n                print_log(0,nowAccount)\\n                return 1\\n        else:\\n            current_Last = _N(_C(exchange.GetTicker).Last,2)    ##当前价格\\n            data=\\\"不具备平仓条件:买入-当前=差价:%s-%s=%s\\\"%(buy_price,current_Last,_N(buy_price-current_Last,2))\\n            print_log(0,nowAccount,data)\\n        return 0\\n    except Exception,ex:\\n        Log('e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "return 0\\n    except Exception,ex:\\n        Log('except Exception my_sell:',ex)\\n        return 0\\n\\n########################################################\\ndef onTick():\\n    try:\\n        records =exchange.GetRecords()  #由你自己设定的周期数返回的数据\\n        HH = records[-2]['High'] #最日最高\\n        LC = records[-2]['Low']  #昨日最低\\n        HC = records[-2]['Close'] #昨日收盘\\n        LL = records[-2]['Low']  #昨日最低\\n        Pivot = (HH+HC+LC)/3 #枢轴点\\n        R1 = 2*Pivot-LC #阻力1\\n        R2 = Pivot+(HH-LC) #阻力2\\n        R3 ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#阻力1\\n        R2 = Pivot+(HH-LC) #阻力2\\n        R3 = HH +2*(Pivot-LC) #阻力3\\n\\n        S1 = 2*Pivot-HH  #支撑位1\\n        S2 = Pivot - (HH-LC)  #支撑位2\\n        S3 = LC-2*(HH-Pivot)  #支撑位3\\n        #Log('r1',R1,\\\"R2\\\",R2,'R3',R3)\\n        #Log('S1',S1,\\\"S2\\\",S2,'S3',S3)\\n        To = records[-1]['Open'] #今日开盘价\\n        Th = records[-1]['High'] #今日最高价\\n        Tl = records[-1]['Low'] #今日最低价\\n        current_price = _C(exchange.GetTicker).Last #当前价格\\n\\n        #当前价格>阻力3   开仓\\n        if current_price > R3: #突破上轨开多\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "阻力3   开仓\\n        if current_price > R3: #突破上轨开多\\n            if my_buy(): #Log('多')\\n                return\\n\\n        #当前价格<支撑位3  平仓\\n        if current_price < S3: #突破下轨卖空\\n            if my_sell(): #Log('空')\\n                return\\n\\n        # 条件1   今日最高价>阻力2\\n        # 条件2   今日最高价<阻力3\\n        # 条件3   当前价格<阻力1\\n        # 同时具备这3个条件平仓\\n        if Th >R2 and Th <R3 and current_price <R1: #趋势反转卖出\\n            if my_sell(): #Log('空')\\n                return\\n\\n        # 条件1   今日最低价<支撑位2\\n        # 条件2   今日",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\n        # 条件1   今日最低价<支撑位2\\n        # 条件2   今日最低价>支撑位3\\n        # 条件3   当前价格<支撑位1\\n        # 同时具备这3个条件开仓\\n        if Tl <S2 and Tl >S3 and current_price <S1: #支撑位1\\n            if my_buy(): #Log('多')\\n                return\\n                # Log(records[-1])#今日K\\n                # Log(records[-2])#昨日K\\n                # Log(exchange.GetTicker())#当前\\n\\n    except Exception,ex:\\n        Log('except Exception onTick:',ex)\\n\\n\\n\\ndef main():\\n    global outAccount\\n    outAccount = ext.GetAccount()  #初始化信息",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Account\\n    outAccount = ext.GetAccount()  #初始化信息\\n    Log(\\\"run  \\\",outAccount)  #输出初始账户信息\\n    while True:\\n        onTick()\\n        Sleep(1000)\",\n    \"策略名称: R-Breaker-交易策略\\n\\nmsg_data0=(\\\"本次开始运行时间:%s已运行:%s\\\\r\\\\n\\\"%(start_time,Caltime(start_time,date1)))\\n        #################################################\\n        msg_data1=(\\\"本次初始化状态:%s\\\\r\\\\n当前运行状态:%s\\\\r\\\\n\\\"%(beng_Account,end_Account))\\n        #################################################\\n        end_Balance=(end_Account.Stocks*end_ticker",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\\n        msg_data2=(\\\"初始化钱:%s现在钱:%s盈亏:%s\\\\r\\\\n\\\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\\n        #################################################\\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\\n        roi = ((total/beng_Balance) -1)*100\\n        msg_data3=(\\\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\\\r\\\\n\\\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",str(end_Account.Balance),str(end_Account.Stocks),roi))\\n        #################################################\\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\\n        msg_data4=(\\\"本次盈亏:%s(RMB)\\\\t总盈亏:%.2f(RMB) %.2f\\\\r\\\\n\\\"%(str(gains),income,roi))\\n        #################################################\\n        #盈利计算方法\\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ount.Stocks-beng_Account.Stocks    #比的差值\\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\\n        msg_data5=(\\\"浮动利润:%s(RMB)\\\\r\\\\n账面利润:%s(RMB)\\\\r\\\\n\\\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "balance,3)),str(_N(new_end_balance2,3))))\\n        #################################################\\n        LogStatus(\\\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\\\r\\\\n\\\",\\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,\\n                  \\\"更新时间:%s\\\\r\\\\n\\\"%(date1),\\n                  \\\"%s\\\"%(data)\\n                  )\\n        #################################################\\n        #################################################\\n        #######################################",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#\\n        #################################################\\n    except Exception,ex:\\n        Log('except Exception print_log:',ex)\\n\\ndef my_sell(): #平仓\\n    try:\\n        global buy_price,buy_qty,gains,ExitPeriod\\n        ExitPeriod = 0\\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\\n        if nowAccount.Stocks<=0.002:  #保证满足交易量\\n            #Log('不满足最小交易量:',nowAccount.Stocks)\\n            return 1\\n\\n        #history_Last=_N(Volume_averages(Ticker_list),2)    #历史均价\\n        #cur_last = _N(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(Ticker_list),2)    #历史均价\\n        #cur_last = _N(_C(exchange.GetTicker).Last,2)\\n\\n        #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod :   #当前价格一定要大于  开仓价格\\n        if True:\\n            #if _N(_C(exchange.GetTicker).Last,2)>buy_price+ExitPeriod and  history_Last - cur_last >0 and  history_Last - cur_last < 2 :   #当前价格一定要大于  开仓价格\\n            #Log('历史差价:',history_Last - cur_last)\\n            Dict = ext.Sell(nowAccount.Stocks)\\n            #Dict ={\\\"price\\\":_C(exchange.GetTicker).Last}\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ict ={\\\"price\\\":_C(exchange.GetTicker).Last}\\n            if(Dict):\\n                #sell_count+=1\\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\\n                gains=gains+sell_gains\\n                buy_price=0 #买入价格\\n                buy_qty=0  #买入数量\\n                LogProfit(_N(gains,4),'平仓信息 钱:',nowAccount.Balance,'--币:',nowAccount.Stocks,'--平仓详情:',Dict)#收益曲线\\n                print_log(0,nowAccount)\\n                return 1\\n        else:\\n            current_Last = _N(_C(exch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      else:\\n            current_Last = _N(_C(exchange.GetTicker).Last,2)    ##当前价格\\n            data=\\\"不具备平仓条件:买入-当前=差价:%s-%s=%s\\\"%(buy_price,current_Last,_N(buy_price-current_Last,2))\\n            print_log(0,nowAccount,data)\\n        return 0\\n    except Exception,ex:\\n        Log('except Exception my_sell:',ex)\\n        return 0\"\n \n\n    \"strategy_35\",\n    \"python\\n# botvs@f976b25629baf8373e73da860a54030d\\n#!/usr/local/bin/python\\n#-*- coding: UTF-8 -*-\\n#删除反转止损\\nimport math\\nimport talib\\ndef adjustFloa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#删除反转止损\\nimport math\\nimport talib\\ndef adjustFloat(v):\\n    v =math.floor(v*1000)\\n    return v/1000\\n\\ndef GetAccount():\\n    account = _C(exchange.GetAccount)\\n    while account == null:\\n        account = _C(exchange.GetAccount)\\n        Sleep(1000)\\n    return account\\n\\ndef GetTicker():\\n    ticker = exchange.GetTicker()\\n    while ticker ==null:\\n        ticker = exchange.GetTicker()\\n        Sleep(1000)\\n    return ticker\\n# def updateProfit(accountInit, accountNow, ticker):\\n#     netNow = accountN",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nit, accountNow, ticker):\\n#     netNow = accountNow.Balance + accountNow.FrozenBalance + ((accountNow.Stocks + accountNow.FrozenStocks) * ticker.Buy)\\n#     netInit = accountInit.Balance + accountInit.FrozenBalance + ((accountInit.Stocks + accountInit.FrozenStocks) * ticker.Buy)\\n#     LogProfit(adjustFloat(netNow - netInit), accountNow)\\n\\n#获取当期账户总额\\ndef GetNowamount():\\n    account =GetAccount()\\n    ticker = exchange.GetTicker()\\n    return account.Balance + account.FrozenBalance + ((account.Stocks + ac",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ce + account.FrozenBalance + ((account.Stocks + account.FrozenStocks) * ticker.Buy)\\n#获取当前账户市值\\ndef GetStockcap():\\n    account=GetAccount()\\n    ticker = GetTicker()\\n    return (account.Stocks + account.FrozenStocks) * ticker.Buy\\n\\n\\n\\n#type 0 总持仓比例 1 可买入币的百分比\\ndef my_buy(ratio,type):\\n    try:\\n        global InitAccount\\n        account = GetAccount()\\n        ticker=_C(exchange.GetTicker)\\n        #计算买入量\\n        if type == 0:\\n            unit =(GetNowamount()/ticker.Buy)*ratio - account.Stocks - acc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "wamount()/ticker.Buy)*ratio - account.Stocks - account.FrozenStocks\\n        else:\\n            unit =((GetNowamount()/ticker.Buy) - account.Stocks - account.FrozenStocks)*ratio\\n        \\n        #不足最低交易退出买入操作\\n        if unit < exchange.GetMinStock():\\n            return 0\\n        Dict = ext.Buy(unit)  #买入ext.Buy\\n        if(Dict):#确认开仓成功\\n            #buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\\n            #buy_qty=Dict['amount']  #买入数量\\n            #LogProfit(_N(gains,4),'开仓信息 ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  #买入数量\\n            #LogProfit(_N(gains,4),'开仓信息 钱:',initAccount.Balance,'--币:',initAccount.Stocks,'--开仓详情:',Dict)\\n            #updateProfit(InitAccount, GetAccount(), GetTicker())\\n            Balance_log() #收益计算\\n            print_log(1,InitAccount)\\n            return 1\\n        return 0\\n    except Exception,ex:\\n        Log('except Exception my_buy:',ex)\\n        return 0\\n\\ndef my_sell(ratio,type):\\n    try:\\n        global InitAccount\\n        account = GetAccount()\\n        if type == 0:\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt = GetAccount()\\n        if type == 0:\\n            unit = 1\\n        else:\\n            unit =(account.Stocks + account.FrozenStocks)*ratio\\n\\n        if unit<exchange.GetMinStock():\\n            return 0\\n\\n        Dict = ext.Sell(unit)\\n            #Dict ={\\\"price\\\":_C(exchange.GetTicker).Last}\\n        if(Dict):\\n            #updateProfit(InitAccount, GetAccount(), GetTicker())\\n            Balance_log() #收益计算\\n            print_log(0,GetAccount())\\n            return 1\\n    except Exception,ex:\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          return 1\\n    except Exception,ex:\\n        Log('except Exception my_sell:',ex)\\n        return 0\\n\\n\\n########################################################\\nimport datetime\\ndef Caltime(date1,date2):\\n    try:\\n        date1=time.strptime(date1,\\\"%Y-%m-%d %H:%M:%S\\\")\\n        date2=time.strptime(date2,\\\"%Y-%m-%d %H:%M:%S\\\")\\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ate2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\\n        return date2-date1\\n    except Exception,ex:\\n        Log('except Exception Caltime:',ex)\\n        return \\\"except Exception\\\"\\n\\n\\nimport time\\nstart_timexx =time.localtime(time.time()) #time.clock()\\nstart_time=time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",start_timexx)\\nbuy_price=0 #买入价格\\nbuy_qty=0  #买入数量\\ngains=0  #盈利\\n\\nbeng_Account = ext.GetAccount()  #初始化信息\\nbeng_ticker = _C(exchange.GetTicker).Last#Ticker \\t市场行情   最后成交价\\nbeng_Balance=(beng_Account",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#Ticker \\t市场行情   最后成交价\\nbeng_Balance=(beng_Account.Stocks*beng_ticker)+beng_Account.Balance #初始化账户钱\\n\\ndef Balance_log(): #收益计算\\n    try:\\n        end_Account = ext.GetAccount()  #当前账户信息\\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \\t市场行情   最后成交价\\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\\n        LogProfit(end_Balance-beng_Balance) \\t#记录盈利值\\n    except Exception,ex:\\n        Log('except Exception Balance_log:',ex)\\n\\ndef print_log(k_p,data=\\\"\\\"):  #输出\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g:',ex)\\n\\ndef print_log(k_p,data=\\\"\\\"):  #输出\\n    try:\\n        name=\\\"\\\"\\n        if k_p:\\n            name=\\\"开仓\\\"\\n        else:\\n            name=\\\"平仓\\\"\\n        global beng_Account,beng_ticker,beng_Balance\\n        global R1,R2,R3,S1,S2,S3\\n        global gains\\n        end_Account = ext.GetAccount()  #当前账户信息\\n        end_ticker = _C(exchange.GetTicker).Last#Ticker \\t市场行情   最后成交价\\n        #################################################\\n        date1=time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",time.localtime",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",time.localtime(time.time()))\\n        msg_data0=(\\\"本次开始运行时间:%s已运行:%s\\\\r\\\\n\\\"%(start_time,Caltime(start_time,date1)))\\n        #################################################\\n        msg_data1=(\\\"本次初始化状态:%s\\\\r\\\\n当前运行状态:%s\\\\r\\\\n\\\"%(beng_Account,end_Account))\\n        #################################################\\n        end_Balance=(end_Account.Stocks*end_ticker)+end_Account.Balance #当前账面上钱数\\n        msg_data2=(\\\"初始化钱:%s现在钱:%s盈亏:%s\\\\r\\\\n\\\"%(str(beng_Balance),str(end",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "钱:%s现在钱:%s盈亏:%s\\\\r\\\\n\\\"%(str(beng_Balance),str(end_Balance),str(end_Balance-beng_Balance)))\\n        #################################################\\n        total = end_Account.Balance+end_Account.Stocks*_C(exchange.GetTicker).Last #账户总额\\n        roi = ((total/beng_Balance) -1)*100\\n        msg_data3=(\\\"当前状态:%s--钱:%s--币:%s--总值约:%.2f\\\\r\\\\n\\\"%(str(name),str(end_Account.Balance),str(end_Account.Stocks),roi))\\n        #################################################\\n        income = total - beng_Account['B",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "########\\n        income = total - beng_Account['Balance'] - beng_Account['Stocks']*beng_ticker #总盈亏\\n        msg_data4=(\\\"本次盈亏:%s(RMB)\\\\t总盈亏:%.2f(RMB) %.2f\\\\r\\\\n\\\"%(str(gains),income,roi))\\n        #################################################\\n        #盈利计算方法\\n        #盈利计算方法   浮动利润： 按 （现在币 - 初始币）x 现在的价格 + （现在的钱 - 初始的钱）\\n        diff_stocks=end_Account.Stocks-beng_Account.Stocks    #比的差值\\n        diff_balance=end_Account.Balance-beng_Account.Balance   #钱的差值\\n        new_end_balance=diff_stocks*end_tic",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#钱的差值\\n        new_end_balance=diff_stocks*end_ticker+diff_balance #实现盈亏   #当前的盈利\\n        #盈利计算方法   账面利润 ： （现在币 x 现在价格+现在钱） - （初始币 x 初始价格 + 初始钱）\\n        new_end_balance2=(end_Account.Stocks*end_ticker+end_Account.Balance)-(beng_Account.Stocks*beng_ticker+beng_Account.Balance)\\n        msg_data5=(\\\"浮动利润:%s(RMB)\\\\r\\\\n账面利润:%s(RMB)\\\\r\\\\n\\\"%(str(_N(new_end_balance,3)),str(_N(new_end_balance2,3))))\\n        msg_data6 ='R1',R1,'R2',R2,'R3',R3,'\\\\r\\\\n'\\n        msg_data7 ='S1',S1,'S2',S2,'S3',S3,'\\\\r\\\\n'\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g_data7 ='S1',S1,'S2',S2,'S3',S3,'\\\\r\\\\n'\\n        msg_data8 =\\\"当前价格:\\\",end_ticker,'\\\\r\\\\n'\\n        #################################################\\n        LogStatus(\\\"初始化投入2016/9/24  投入0.2个币=等于行情800RMB\\\\r\\\\n\\\",\\n                  msg_data0,msg_data1,msg_data2,msg_data3,msg_data4,msg_data5,msg_data6,msg_data7,msg_data8,\\n                  \\\"更新时间:%s\\\\r\\\\n\\\"%(date1),\\n                  \\\"%s\\\"%(data)\\n                  )\\n        #################################################\\n        ##################",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "######################\\n        #################################################\\n        #################################################\\n    except Exception,ex:\\n        Log('except Exception print_log:',ex)\\n\\n\\n\\n\\ndef _GetCommand():\\n    get_command=GetCommand()\\n    if get_command:\\n        global K1,K2,N\\n        arr =get_command.split(\\\":\\\")\\n        if arr[0] == 'K1':\\n            K1 = float(arr[-1])\\n        if arr[0] =='K2':\\n            K2 = float(arr[-1])\\n        if arr[0] =='N':\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "float(arr[-1])\\n        if arr[0] =='N':\\n            N = int(arr[-1])\\n\\n\\nN=2\\n\\nLastDeal = 0 #上次交易时间\\ndef onTick(exchange):\\n    try:\\n        global R1,R2,R3,S1,S2,S3,short_state_buy,short_state_sell,LastDeal,task_state,buy_count,sell_count\\n        amount = GetAccount() # 获取账户状态\\n        records =exchange.GetRecords() #默认5分钟\\n        To = records[-1]['Open'] #今日开盘价\\n        Th = records[-1]['High'] #今日最高价\\n        Tl = records[-1]['Low'] #今日最低\\n        time = records[-1].Time\\n        if LastDeal == ti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time = records[-1].Time\\n        if LastDeal == time:\\n            return 0\\n        else:\\n            LastDeal = 0\\n\\n        \\n        records1 =exchange.GetRecords(PERIOD_M30) #监控周期\\n        #time =(records1[-2].Time - records1[-1].Time)/(60*1000)\\n        #Log(time);\\n        records.pop()\\n        records1.pop()\\n        ma5 = TA.MA(records1,5)\\n        ma10 = TA.MA(records1,10)\\n     \\n\\n\\n        # HH = records[-2]['High'] #最日最高\\n        # LC = records[-2]['Low']  #昨日最低\\n        HC = records[-1]['Cl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ds[-2]['Low']  #昨日最低\\n        HC = records[-1]['Close'] #昨日收盘\\n        # LL = records[-2]['Low']  #昨日最低\\n        HH = TA.Highest(records,N,'High') #N日high的最高价\\n            #lc = records[-2]['Low']\\n        #HC = TA.Lowest(records,N,'Close') #//N日close的最低价\\n            #hc = records[-2]['Close']\\n        #HH = TA.Highest(records,N,'Close') #N日close的最高价\\n            #ll = records[-2]['Low']\\n        LC = TA.Lowest(records,N,'Low') #//N日low的最低价\\n        #HC = TA.Highest(records,N,'Close')\\n        if ma5[-1] <",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "A.Highest(records,N,'Close')\\n        if ma5[-1] <ma10[-1]:\\n            HC = records[-1]['Open']\\n\\n        Pivot = (HH+HC+LC)/3 #枢轴点\\n        Pivot = Pivot\\n        R1 = 2*Pivot-LC #阻力1W\\n        R2 = Pivot+(HH-LC) #阻力2\\n        R3 = HH +2*(Pivot-LC) #阻力3\\n\\n        S1 = 2*Pivot-HH\\n        S2 = Pivot - (HH-LC)\\n        S3 = LC-2*(HH-Pivot)\\n        # Log('r1',R1,\\\"R2\\\",R2,'R3',R3)\\n        # Log('S1',S1,\\\"S2\\\",S2,'S3',S3)\\n        \\n        current_price = _C(exchange.GetTicker).Last #当前价格\\n        capra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= _C(exchange.GetTicker).Last #当前价格\\n        capratio = (amount.Stocks + amount.FrozenStocks)/GetNowamount()\\n        #突破上轨 和半小时 均线向上 资金大于100 则买入\\n        if ma5[-1] >ma10[-1] :\\n            if current_price > R3 and amount.Balance > 100 and ma5[-1] >ma10[-1] and capratio <0.8 and buy_count <3 :\\n               # Log(ma5[-1],ma10[-1])\\n                Log('开多')\\n                if my_buy(0.4,1):\\n                    LastDeal = time\\n                    sell_count = 0\\n                    buy_count+=1\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "count = 0\\n                    buy_count+=1\\n                    return\\n            #突破下轨卖空 有币 进入卖出操作\\n            if current_price < S3 and amount.Stocks > 0.03 :\\n                Log('清仓')\\n                if my_sell(1,0):\\n                    sell_count+=1\\n                    buy_count = 0\\n                    LastDeal = time\\n                    return\\n            if Th >R2 and Th <R3 and current_price <R1 and current_price >S1   and amount.Stocks > 0.003 and buy_count <3:\\n                Log('趋势反转卖",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".003 and buy_count <3:\\n                Log('趋势反转卖')\\n                if my_sell(0.5,1):\\n                    LastDeal = time\\n                    buy_count = 0\\n                    sell_count+=1\\n                    return\\n            if Tl <S2 and Tl >S3 and current_price <S1  and current_price < R1 and capratio <0.6 and ma5[-1] >ma10[-1] and buy_count <3 :\\n                #Log(ma5[-1],ma10[-1])\\n                Log('趋势反转买')\\n                if my_buy(0.2,1):\\n                    buy_count+=1\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "2,1):\\n                    buy_count+=1\\n                    sell_count = 0\\n                    LastDeal = time\\n                    return\\n        else :\\n            if(current_price > R3 and amount.Stocks > 0.03):\\n                if my_sell(0.5,1):\\n                    Log('测试买')\\n                    LastDeal = time\\n                    return\\n\\n            if (current_price < S3 and ma5[-1] >ma5[-5]):\\n                if my_buy(0.05,1):\\n                    Log('测试买入')\\n                    LastDeal ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        Log('测试买入')\\n                    LastDeal = time\\n                    buy_count = 0\\n                    return\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n    except Exception,ex:\\n        Log('except Exception onTick:',ex)\\n        return 0\\n\\n\\ndef main():\\n    global outAccount,init_price,InitAccount,short_state_buy,short_state_sell,task_state,buy_count,sell_count\\n    init_price = _C(exchange.GetTicker).Last\\n    InitAccount = GetAccount()\\n    Log(init_price)\\n    short_state_buy =short_state_sell = 0\\n    tas",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    short_state_buy =short_state_sell = 0\\n    task_state =0\\n    buy_count = 0\\n    sell_count = 0\\n    while True:\\n            onTick(exchange)\\n            nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\\n            print_log(0,nowAccount)\\n            Sleep(1000)\",\n    \"策略名称: R-Breaker11-交易策略\\n\\n#!/usr/local/bin/python\"\n \n\n    \"strategy_36\",\n    \"python\\nimport _thread\\nimport pymongo\\nimport json\\nimport math\\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\\nfrom urllib.parse import pars",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eHTTPRequestHandler\\nfrom urllib.parse import parse_qs, urlparse\\n\\ndef url2Dict(url):\\n    query = urlparse(url).query  \\n    params = parse_qs(query)  \\n    result = {key: params[key][0] for key in params}  \\n    return result\\n\\nclass Provider(BaseHTTPRequestHandler):\\n    def do_GET(self):\\n        try:\\n            self.send_response(200)\\n            self.send_header(\\\"Content-type\\\", \\\"application/json\\\")\\n            self.end_headers()\\n\\n            dictParam = url2Dict(self.path)\\n            Log(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " dictParam = url2Dict(self.path)\\n            Log(\\\"自定义数据源服务接收到请求，self.path:\\\", self.path, \\\"query 参数：\\\", dictParam)\\n            \\n            # 目前回测系统只能从列表中选择交易所名称，在添加自定义数据源时，设置为币安，即：Binance\\n            exName = exchange.GetName()                                     \\n            # 注意，period为底层K线周期\\n            tabName = \\\"%s_%s\\\" % (\\\"records\\\", int(int(dictParam[\\\"period\\\"]) / 1000))  \\n            priceRatio = math.pow(10, int(dictParam[\\\"round\\\"]))\\n            amountRatio = math.pow(10, int(dictPara",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           amountRatio = math.pow(10, int(dictParam[\\\"vround\\\"]))\\n            fromTS = int(dictParam[\\\"from\\\"]) * int(1000)\\n            toTS = int(dictParam[\\\"to\\\"]) * int(1000)\\n            \\n            \\n            # 连接数据库\\n            Log(\\\"连接数据库服务，获取数据，数据库：\\\", exName, \\\"表：\\\", tabName)\\n            myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")\\n            ex_DB = myDBClient[exName]\\n            exRecords = ex_DB[tabName]\\n            \\n            \\n            # 要求应答的数据\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\n            \\n            # 要求应答的数据\\n            data = {\\n                \\\"schema\\\" : [\\\"time\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"],\\n                \\\"data\\\" : []\\n            }\\n            \\n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\\n            dbQuery = {\\\"$and\\\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\\n            Log(\\\"查询条件：\\\", dbQuery, \\\"查询条数：\\\", exRecords.find(dbQuery).count(), \\\"数据库总条数：\\\", exRecords.find().count())\\n            \\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "数：\\\", exRecords.find().count())\\n            \\n            for x in exRecords.find(dbQuery).sort(\\\"Time\\\"):\\n                # 需要根据请求参数round和vround，处理数据精度\\n                bar = [x[\\\"Time\\\"], int(x[\\\"Open\\\"] * priceRatio), int(x[\\\"High\\\"] * priceRatio), int(x[\\\"Low\\\"] * priceRatio), int(x[\\\"Close\\\"] * priceRatio), int(x[\\\"Volume\\\"] * amountRatio)]\\n                data[\\\"data\\\"].append(bar)\\n            \\n            Log(\\\"数据：\\\", data, \\\"响应回测系统请求。\\\")\\n            # 写入数据应答\\n            self.wfile.write(json.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      # 写入数据应答\\n            self.wfile.write(json.dumps(data).encode())\\n        except BaseException as e:\\n            Log(\\\"Provider do_GET error, e:\\\", e)\\n\\n\\ndef createServer(host):\\n    try:\\n        server = HTTPServer(host, Provider)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except BaseException as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\ndef main():\\n    LogReset(1)\\n    exName = exchange.GetName()\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   LogReset(1)\\n    exName = exchange.GetName()\\n    period = exchange.GetPeriod()\\n    Log(\\\"收集\\\", exName, \\\"交易所的K线数据，\\\", \\\"K线周期:\\\", period, \\\"秒\\\")\\n    \\n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\\n    Log(\\\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\\\")\\n    myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")   \\n    # 创建数据库\\n    ex_DB = myDBClient[exName]\\n    \\n    # 打印目前数据库表\\n    collist = ex_DB.list_collection_names()\\n    Log(\\\"mongodb \\\", exName, \\\" collist:\\\", co",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n    Log(\\\"mongodb \\\", exName, \\\" collist:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.loads(dropNames)\\n    if isinstance(arrDropNames, list):\\n        for i in range(len(arrDropNames)):\\n            dropName = arrDropNames[i]\\n            if isinstance(dropName, str):\\n                if not dropName in collist:\\n                    continue\\n                tab = ex_DB[dropName]\\n                Log(\\\"dropName:\\\", dropName, \\\"删除：\\\", dropName)\\n                ret = tab.drop()\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "me)\\n                ret = tab.drop()\\n                collist = ex_DB.list_collection_names()\\n                if dropName in collist:\\n                    Log(dropName, \\\"删除失败\\\")\\n                else :\\n                    Log(dropName, \\\"删除成功\\\")\\n    \\n    # 开启一个线程，提供自定义数据源服务\\n    try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))     # 本机测试\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))         # VPS服务器上测试\\n        Log(\\\"开启自定义数据源服务线程\\\", \\\"#FF0000",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "VPS服务器上测试\\n        Log(\\\"开启自定义数据源服务线程\\\", \\\"#FF0000\\\")\\n    except BaseException as e:\\n        Log(\\\"启动自定义数据源服务失败！\\\")\\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")\\n    \\n    # 创建records表\\n    ex_DB_Records = ex_DB[\\\"%s_%d\\\" % (\\\"records\\\", period)]\\n    Log(\\\"开始收集\\\", exName, \\\"K线数据\\\", \\\"周期：\\\", period, \\\"打开（创建）数据库表：\\\", \\\"%s_%d\\\" % (\\\"records\\\", period), \\\"#FF0000\\\")\\n    preBarTime = 0\\n    index = 1\\n    while True:\\n        r = _C(exchange.GetRecords)\\n        if len(r) < 2:\\n            S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "GetRecords)\\n        if len(r) < 2:\\n            Sleep(1000)\\n            continue\\n        if preBarTime == 0:\\n            # 首次写入所有BAR数据\\n            for i in range(len(r) - 1):\\n                bar = r[i]\\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\\n                retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n                if retQuery.count() > 0:\\n                    continue\\n                \\n                # 写入bar到数据库表\\n                ex_DB_Records.insert_o",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "写入bar到数据库表\\n                ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})                \\n                index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        elif preBarTime != r[-1][\\\"Time\\\"]:\\n            bar = r[-2]\\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\\n            retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n            if retQuery.count() > 0:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[\\\"Time\\\"]})\\n            if retQuery.count() > 0:\\n                continue\\n            \\n            ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})\\n            index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        LogStatus(_D(), \\\"preBarTime:\\\", preBarTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\\"index:\\\", index)\\n        # 增加画图展示\\n        ext.PlotRecords(r, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ex)\\n        # 增加画图展示\\n        ext.PlotRecords(r, \\\"%s_%d\\\" % (\\\"records\\\", period))\\n        Sleep(10000)\",\n    \"策略名称: RecordsCollecter-升级提供自定义数据源功能\\n\\nexName = exchange.GetName()                                     \\n            # 注意，period为底层K线周期\\n            tabName = \\\"%s_%s\\\" % (\\\"records\\\", int(int(dictParam[\\\"period\\\"]) / 1000))  \\n            priceRatio = math.pow(10, int(dictParam[\\\"round\\\"]))\\n            amountRatio = math.pow(10, int(dictParam[\\\"vround\\\"]))\\n            fromTS = int(dictParam[\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"vround\\\"]))\\n            fromTS = int(dictParam[\\\"from\\\"]) * int(1000)\\n            toTS = int(dictParam[\\\"to\\\"]) * int(1000)\\n            \\n            \\n            # 连接数据库\\n            Log(\\\"连接数据库服务，获取数据，数据库：\\\", exName, \\\"表：\\\", tabName)\\n            myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")\\n            ex_DB = myDBClient[exName]\\n            exRecords = ex_DB[tabName]\\n            \\n            \\n            # 要求应答的数据\\n            data = {\\n                \\\"schema\\\" : [\\\"time\\\", ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "data = {\\n                \\\"schema\\\" : [\\\"time\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"],\\n                \\\"data\\\" : []\\n            }\\n            \\n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\\n            dbQuery = {\\\"$and\\\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\\n            Log(\\\"查询条件：\\\", dbQuery, \\\"查询条数：\\\", exRecords.find(dbQuery).count(), \\\"数据库总条数：\\\", exRecords.find().count())\\n            \\n            for x in exRecords.find(dbQuery).sort(\\\"Time",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      for x in exRecords.find(dbQuery).sort(\\\"Time\\\"):\\n                # 需要根据请求参数round和vround，处理数据精度\\n                bar = [x[\\\"Time\\\"], int(x[\\\"Open\\\"] * priceRatio), int(x[\\\"High\\\"] * priceRatio), int(x[\\\"Low\\\"] * priceRatio), int(x[\\\"Close\\\"] * priceRatio), int(x[\\\"Volume\\\"] * amountRatio)]\\n                data[\\\"data\\\"].append(bar)\\n            \\n            Log(\\\"数据：\\\", data, \\\"响应回测系统请求。\\\")\\n            # 写入数据应答\\n            self.wfile.write(json.dumps(data).encode())\\n        except BaseException a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ps(data).encode())\\n        except BaseException as e:\\n            Log(\\\"Provider do_GET error, e:\\\", e)\\n\\n\\ndef createServer(host):\\n    try:\\n        server = HTTPServer(host, Provider)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except BaseException as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\ndef main():\\n    LogReset(1)\\n    exName = exchange.GetName()\\n    period = exchange.GetPeriod()\\n    Log(\\\"收集\\\", exN",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "period = exchange.GetPeriod()\\n    Log(\\\"收集\\\", exName, \\\"交易所的K线数据，\\\", \\\"K线周期:\\\", period, \\\"秒\\\")\\n    \\n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\\n    Log(\\\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\\\")\\n    myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")   \\n    # 创建数据库\\n    ex_DB = myDBClient[exName]\\n    \\n    # 打印目前数据库表\\n    collist = ex_DB.list_collection_names()\\n    Log(\\\"mongodb \\\", exName, \\\" collist:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.loads(dropNames)\\n    if isinstance(arrDropNames, list):\\n        for i in range(len(arrDropNames)):\\n            dropName = arrDropNames[i]\\n            if isinstance(dropName, str):\\n                if not dropName in collist:\\n                    continue\\n                tab = ex_DB[dropName]\\n                Log(\\\"dropName:\\\", dropName, \\\"删除：\\\", dropName)\\n                ret = tab.drop()\\n                collist = ex_DB.list_collection_names()\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  collist = ex_DB.list_collection_names()\\n                if dropName in collist:\\n                    Log(dropName, \\\"删除失败\\\")\\n                else :\\n                    Log(dropName, \\\"删除成功\\\")\\n    \\n    # 开启一个线程，提供自定义数据源服务\\n    try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))     # 本机测试\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))         # VPS服务器上测试\\n        Log(\\\"开启自定义数据源服务线程\\\", \\\"#FF0000\\\")\\n    except BaseException as e:\\n        Log(\\\"启动",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    except BaseException as e:\\n        Log(\\\"启动自定义数据源服务失败！\\\")\\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")\\n    \\n    # 创建records表\\n    ex_DB_Records = ex_DB[\\\"%s_%d\\\" % (\\\"records\\\", period)]\\n    Log(\\\"开始收集\\\", exName, \\\"K线数据\\\", \\\"周期：\\\", period, \\\"打开（创建）数据库表：\\\", \\\"%s_%d\\\" % (\\\"records\\\", period), \\\"#FF0000\\\")\\n    preBarTime = 0\\n    index = 1\\n    while True:\\n        r = _C(exchange.GetRecords)\\n        if len(r) < 2:\\n            Sleep(1000)\\n            continue\\n        if preBarTi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "p(1000)\\n            continue\\n        if preBarTime == 0:\\n            # 首次写入所有BAR数据\\n            for i in range(len(r) - 1):\\n                bar = r[i]\\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\\n                retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n                if retQuery.count() > 0:\\n                    continue\\n                \\n                # 写入bar到数据库表\\n                ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "{\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})                \\n                index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        elif preBarTime != r[-1][\\\"Time\\\"]:\\n            bar = r[-2]\\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\\n            retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n            if retQuery.count() > 0:\\n                continue\\n            \\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               continue\\n            \\n            ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})\\n            index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        LogStatus(_D(), \\\"preBarTime:\\\", preBarTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\\"index:\\\", index)\\n        # 增加画图展示\\n        ext.PlotRecords(r, \\\"%s_%d\\\" % (\\\"records\\\", period))\\n        Sleep(100",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s_%d\\\" % (\\\"records\\\", period))\\n        Sleep(10000)\\n        \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/205143\\n\\n> Last Modified\\n\\n2020-05-09 15:58:04\"\n \n\n    \"strategy_37\",\n    \"python\\nimport _thread\\nimport pymongo\\nimport json\\nimport math\\nimport csv\\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\\nfrom urllib.parse import parse_qs, urlparse\\n\\ndef url2Dict(url):\\n    query = urlparse(url).query  \\n    params = parse_qs(query)  \\n    result = {key: params[key][0] for key in par",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    result = {key: params[key][0] for key in params}  \\n    return result\\n\\nclass Provider(BaseHTTPRequestHandler):\\n    def do_GET(self):\\n        global isOnlySupportCSV, filePathForCSV\\n        try:\\n            self.send_response(200)\\n            self.send_header(\\\"Content-type\\\", \\\"application/json\\\")\\n            self.end_headers()\\n\\n            dictParam = url2Dict(self.path)\\n            Log(\\\"自定义数据源服务接收到请求，self.path:\\\", self.path, \\\"query 参数：\\\", dictParam)\\n            \\n            # 目前回测系统只能",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", dictParam)\\n            \\n            # 目前回测系统只能从列表中选择交易所名称，在添加自定义数据源时，设置为币安，即：Binance\\n            exName = exchange.GetName()                                     \\n            # 注意，period为底层K线周期\\n            tabName = \\\"%s_%s\\\" % (\\\"records\\\", int(int(dictParam[\\\"period\\\"]) / 1000))  \\n            priceRatio = math.pow(10, int(dictParam[\\\"round\\\"]))\\n            amountRatio = math.pow(10, int(dictParam[\\\"vround\\\"]))\\n            fromTS = int(dictParam[\\\"from\\\"]) * int(1000)\\n            toTS = int(dictP",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "from\\\"]) * int(1000)\\n            toTS = int(dictParam[\\\"to\\\"]) * int(1000)\\n\\n            # 要求应答的数据\\n            data = {\\n                \\\"schema\\\" : [\\\"time\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"],\\n                \\\"data\\\" : []\\n            }\\n            \\n            if isOnlySupportCSV:\\n                # 处理CSV读取,filePathForCSV路径\\n                listDataSequence = []\\n                with open(filePathForCSV, \\\"r\\\") as f:\\n                    reader = csv.reader(f)\\n                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      reader = csv.reader(f)\\n                    # 获取表头\\n                    header = next(reader)\\n                    headerIsNoneCount = 0\\n                    if len(header) != len(data[\\\"schema\\\"]):\\n                        Log(\\\"CSV文件格式有误，列数不同，请检查！\\\", \\\"#FF0000\\\")\\n                        return \\n                    for ele in header:\\n                        for i in range(len(data[\\\"schema\\\"])):\\n                            if data[\\\"schema\\\"][i] == ele or ele == \\\"\\\":\\n                           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= ele or ele == \\\"\\\":\\n                                if ele == \\\"\\\":\\n                                    headerIsNoneCount += 1\\n                                if headerIsNoneCount > 1:\\n                                    Log(\\\"CSV文件格式有误，请检查！\\\", \\\"#FF0000\\\")\\n                                    return \\n                                listDataSequence.append(i)\\n                                break\\n                    \\n                    # 读取内容\\n                    while True:\\n                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                 while True:\\n                        record = next(reader, -1)\\n                        if record == -1:\\n                            break\\n                        index = 0\\n                        arr = [0, 0, 0, 0, 0, 0]\\n                        for ele in record:\\n                            arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\\n                     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t(float(ele) * priceRatio))\\n                            index += 1\\n                        data[\\\"data\\\"].append(arr)\\n                \\n                Log(\\\"数据：\\\", data, \\\"响应回测系统请求。\\\")\\n                self.wfile.write(json.dumps(data).encode())\\n                return \\n            \\n            # 连接数据库\\n            Log(\\\"连接数据库服务，获取数据，数据库：\\\", exName, \\\"表：\\\", tabName)\\n            myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")\\n            ex_DB = myDBClient[exName]\\n            exRecor",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   ex_DB = myDBClient[exName]\\n            exRecords = ex_DB[tabName]\\n            \\n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\\n            dbQuery = {\\\"$and\\\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\\n            Log(\\\"查询条件：\\\", dbQuery, \\\"查询条数：\\\", exRecords.find(dbQuery).count(), \\\"数据库总条数：\\\", exRecords.find().count())\\n            \\n            for x in exRecords.find(dbQuery).sort(\\\"Time\\\"):\\n                # 需要根据请求参数round和vround，处理数据精度\\n                bar = [",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "根据请求参数round和vround，处理数据精度\\n                bar = [x[\\\"Time\\\"], int(x[\\\"Open\\\"] * priceRatio), int(x[\\\"High\\\"] * priceRatio), int(x[\\\"Low\\\"] * priceRatio), int(x[\\\"Close\\\"] * priceRatio), int(x[\\\"Volume\\\"] * amountRatio)]\\n                data[\\\"data\\\"].append(bar)\\n            \\n            Log(\\\"数据：\\\", data, \\\"响应回测系统请求。\\\")\\n            # 写入数据应答\\n            self.wfile.write(json.dumps(data).encode())\\n        except BaseException as e:\\n            Log(\\\"Provider do_GET error, e:\\\", e)\\n\\n\\ndef createServe",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ovider do_GET error, e:\\\", e)\\n\\n\\ndef createServer(host):\\n    try:\\n        server = HTTPServer(host, Provider)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except BaseException as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\ndef main():\\n    LogReset(1)\\n    if (isOnlySupportCSV):\\n        try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))         # 本机测试\\n            _thread.start_new",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", ))         # 本机测试\\n            _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))         # VPS服务器上测试\\n            Log(\\\"开启自定义数据源服务线程，数据由CSV文件提供。\\\", \\\"#FF0000\\\")\\n        except BaseException as e:\\n            Log(\\\"启动自定义数据源服务失败！\\\")\\n            Log(\\\"错误信息：\\\", e)\\n            raise Exception(\\\"stop\\\")\\n        while True:\\n            LogStatus(_D(), \\\"只启动自定义数据源服务，不收集数据！\\\")\\n            Sleep(2000)\\n    \\n    exName = exchange.GetName()\\n    period = exchange.GetPeriod()\\n    Log(\\\"收集\\\", exN",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "period = exchange.GetPeriod()\\n    Log(\\\"收集\\\", exName, \\\"交易所的K线数据，\\\", \\\"K线周期:\\\", period, \\\"秒\\\")\\n    \\n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\\n    Log(\\\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\\\")\\n    myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")   \\n    # 创建数据库\\n    ex_DB = myDBClient[exName]\\n    \\n    # 打印目前数据库表\\n    collist = ex_DB.list_collection_names()\\n    Log(\\\"mongodb \\\", exName, \\\" collist:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.loads(dropNames)\\n    if isinstance(arrDropNames, list):\\n        for i in range(len(arrDropNames)):\\n            dropName = arrDropNames[i]\\n            if isinstance(dropName, str):\\n                if not dropName in collist:\\n                    continue\\n                tab = ex_DB[dropName]\\n                Log(\\\"dropName:\\\", dropName, \\\"删除：\\\", dropName)\\n                ret = tab.drop()\\n                collist = ex_DB.list_collection_names()\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  collist = ex_DB.list_collection_names()\\n                if dropName in collist:\\n                    Log(dropName, \\\"删除失败\\\")\\n                else :\\n                    Log(dropName, \\\"删除成功\\\")\\n    \\n    # 开启一个线程，提供自定义数据源服务\\n    try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))     # 本机测试\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))         # VPS服务器上测试\\n        Log(\\\"开启自定义数据源服务线程\\\", \\\"#FF0000\\\")\\n    except BaseException as e:\\n        Log(\\\"启动",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    except BaseException as e:\\n        Log(\\\"启动自定义数据源服务失败！\\\")\\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")\\n    \\n    # 创建records表\\n    ex_DB_Records = ex_DB[\\\"%s_%d\\\" % (\\\"records\\\", period)]\\n    Log(\\\"开始收集\\\", exName, \\\"K线数据\\\", \\\"周期：\\\", period, \\\"打开（创建）数据库表：\\\", \\\"%s_%d\\\" % (\\\"records\\\", period), \\\"#FF0000\\\")\\n    preBarTime = 0\\n    index = 1\\n    while True:\\n        r = _C(exchange.GetRecords)\\n        if len(r) < 2:\\n            Sleep(1000)\\n            continue\\n        if preBarTi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "p(1000)\\n            continue\\n        if preBarTime == 0:\\n            # 首次写入所有BAR数据\\n            for i in range(len(r) - 1):\\n                bar = r[i]\\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\\n                retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n                if retQuery.count() > 0:\\n                    continue\\n                \\n                # 写入bar到数据库表\\n                ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "{\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})                \\n                index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        elif preBarTime != r[-1][\\\"Time\\\"]:\\n            bar = r[-2]\\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\\n            retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n            if retQuery.count() > 0:\\n                continue\\n            \\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               continue\\n            \\n            ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})\\n            index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        LogStatus(_D(), \\\"preBarTime:\\\", preBarTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\\"index:\\\", index)\\n        # 增加画图展示\\n        ext.PlotRecords(r, \\\"%s_%d\\\" % (\\\"records\\\", period))\\n        Sleep(100",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s_%d\\\" % (\\\"records\\\", period))\\n        Sleep(10000)\",\n    \"策略名称: RecordsCollecter-升级提供自定义数据源功能支持CSV数据文件提供数据源\\n\\nexName = exchange.GetName()                                     \\n            # 注意，period为底层K线周期\\n            tabName = \\\"%s_%s\\\" % (\\\"records\\\", int(int(dictParam[\\\"period\\\"]) / 1000))  \\n            priceRatio = math.pow(10, int(dictParam[\\\"round\\\"]))\\n            amountRatio = math.pow(10, int(dictParam[\\\"vround\\\"]))\\n            fromTS = int(dictParam[\\\"from\\\"]) * int(1000)\\n            toTS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dictParam[\\\"from\\\"]) * int(1000)\\n            toTS = int(dictParam[\\\"to\\\"]) * int(1000)\\n\\n            # 要求应答的数据\\n            data = {\\n                \\\"schema\\\" : [\\\"time\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"],\\n                \\\"data\\\" : []\\n            }\\n            \\n            if isOnlySupportCSV:\\n                # 处理CSV读取,filePathForCSV路径\\n                listDataSequence = []\\n                with open(filePathForCSV, \\\"r\\\") as f:\\n                    reader = csv.reader(f)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                  reader = csv.reader(f)\\n                    # 获取表头\\n                    header = next(reader)\\n                    headerIsNoneCount = 0\\n                    if len(header) != len(data[\\\"schema\\\"]):\\n                        Log(\\\"CSV文件格式有误，列数不同，请检查！\\\", \\\"#FF0000\\\")\\n                        return \\n                    for ele in header:\\n                        for i in range(len(data[\\\"schema\\\"])):\\n                            if data[\\\"schema\\\"][i] == ele or ele == \\\"\\\":\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hema\\\"][i] == ele or ele == \\\"\\\":\\n                                if ele == \\\"\\\":\\n                                    headerIsNoneCount += 1\\n                                if headerIsNoneCount > 1:\\n                                    Log(\\\"CSV文件格式有误，请检查！\\\", \\\"#FF0000\\\")\\n                                    return \\n                                listDataSequence.append(i)\\n                                break\\n                    \\n                    # 读取内容\\n                    while True:\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " # 读取内容\\n                    while True:\\n                        record = next(reader, -1)\\n                        if record == -1:\\n                            break\\n                        index = 0\\n                        arr = [0, 0, 0, 0, 0, 0]\\n                        for ele in record:\\n                            arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "== 5 else int(float(ele) * priceRatio))\\n                            index += 1\\n                        data[\\\"data\\\"].append(arr)\\n                \\n                Log(\\\"数据：\\\", data, \\\"响应回测系统请求。\\\")\\n                self.wfile.write(json.dumps(data).encode())\\n                return \\n            \\n            # 连接数据库\\n            Log(\\\"连接数据库服务，获取数据，数据库：\\\", exName, \\\"表：\\\", tabName)\\n            myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")\\n            ex_DB = myDBClient[exName]\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n            ex_DB = myDBClient[exName]\\n            exRecords = ex_DB[tabName]\\n            \\n            # 构造查询条件：大于某个值{'age': {'$gt': 20}} 小于某个值{'age': {'$lt': 20}}\\n            dbQuery = {\\\"$and\\\":[{'Time': {'$gt': fromTS}}, {'Time': {'$lt': toTS}}]}\\n            Log(\\\"查询条件：\\\", dbQuery, \\\"查询条数：\\\", exRecords.find(dbQuery).count(), \\\"数据库总条数：\\\", exRecords.find().count())\\n            \\n            for x in exRecords.find(dbQuery).sort(\\\"Time\\\"):\\n                # 需要根据请求参数round和vround，处理数据精度\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        # 需要根据请求参数round和vround，处理数据精度\\n                bar = [x[\\\"Time\\\"], int(x[\\\"Open\\\"] * priceRatio), int(x[\\\"High\\\"] * priceRatio), int(x[\\\"Low\\\"] * priceRatio), int(x[\\\"Close\\\"] * priceRatio), int(x[\\\"Volume\\\"] * amountRatio)]\\n                data[\\\"data\\\"].append(bar)\\n            \\n            Log(\\\"数据：\\\", data, \\\"响应回测系统请求。\\\")\\n            # 写入数据应答\\n            self.wfile.write(json.dumps(data).encode())\\n        except BaseException as e:\\n            Log(\\\"Provider do_GET error, e:\\\", e)\\n\\n\\ndef",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    Log(\\\"Provider do_GET error, e:\\\", e)\\n\\n\\ndef createServer(host):\\n    try:\\n        server = HTTPServer(host, Provider)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except BaseException as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\ndef main():\\n    LogReset(1)\\n    if (isOnlySupportCSV):\\n        try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))         # 本机测试\\n            _thre",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ost\\\", 9090), ))         # 本机测试\\n            _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))         # VPS服务器上测试\\n            Log(\\\"开启自定义数据源服务线程，数据由CSV文件提供。\\\", \\\"#FF0000\\\")\\n        except BaseException as e:\\n            Log(\\\"启动自定义数据源服务失败！\\\")\\n            Log(\\\"错误信息：\\\", e)\\n            raise Exception(\\\"stop\\\")\\n        while True:\\n            LogStatus(_D(), \\\"只启动自定义数据源服务，不收集数据！\\\")\\n            Sleep(2000)\\n    \\n    exName = exchange.GetName()\\n    period = exchange.GetPeriod()\\n    Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Name()\\n    period = exchange.GetPeriod()\\n    Log(\\\"收集\\\", exName, \\\"交易所的K线数据，\\\", \\\"K线周期:\\\", period, \\\"秒\\\")\\n    \\n    # 连接数据库服务，服务地址 mongodb://127.0.0.1:27017 具体看服务器上安装的mongodb设置\\n    Log(\\\"连接托管者所在设备mongodb服务，mongodb://localhost:27017\\\")\\n    myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")   \\n    # 创建数据库\\n    ex_DB = myDBClient[exName]\\n    \\n    # 打印目前数据库表\\n    collist = ex_DB.list_collection_names()\\n    Log(\\\"mongodb \\\", exName, \\\" collist:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropN",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.loads(dropNames)\\n    if isinstance(arrDropNames, list):\\n        for i in range(len(arrDropNames)):\\n            dropName = arrDropNames[i]\\n            if isinstance(dropName, str):\\n                if not dropName in collist:\\n                    continue\\n                tab = ex_DB[dropName]\\n                Log(\\\"dropName:\\\", dropName, \\\"删除：\\\", dropName)\\n                ret = tab.drop()\\n                collist = ex_DB.list_collection_name",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "              collist = ex_DB.list_collection_names()\\n                if dropName in collist:\\n                    Log(dropName, \\\"删除失败\\\")\\n                else :\\n                    Log(dropName, \\\"删除成功\\\")\\n    \\n    # 开启一个线程，提供自定义数据源服务\\n    try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))     # 本机测试\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))         # VPS服务器上测试\\n        Log(\\\"开启自定义数据源服务线程\\\", \\\"#FF0000\\\")\\n    except BaseException as e:\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"#FF0000\\\")\\n    except BaseException as e:\\n        Log(\\\"启动自定义数据源服务失败！\\\")\\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")\\n    \\n    # 创建records表\\n    ex_DB_Records = ex_DB[\\\"%s_%d\\\" % (\\\"records\\\", period)]\\n    Log(\\\"开始收集\\\", exName, \\\"K线数据\\\", \\\"周期：\\\", period, \\\"打开（创建）数据库表：\\\", \\\"%s_%d\\\" % (\\\"records\\\", period), \\\"#FF0000\\\")\\n    preBarTime = 0\\n    index = 1\\n    while True:\\n        r = _C(exchange.GetRecords)\\n        if len(r) < 2:\\n            Sleep(1000)\\n            continue\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        Sleep(1000)\\n            continue\\n        if preBarTime == 0:\\n            # 首次写入所有BAR数据\\n            for i in range(len(r) - 1):\\n                bar = r[i]\\n                # 逐根写入，需要判断当前数据库表中是否已经有该条数据，基于时间戳检测，如果有该条数据，则跳过，没有则写入\\n                retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n                if retQuery.count() > 0:\\n                    continue\\n                \\n                # 写入bar到数据库表\\n                ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})                \\n                index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        elif preBarTime != r[-1][\\\"Time\\\"]:\\n            bar = r[-2]\\n            # 写入数据前检测，数据是否已经存在，基于时间戳检测\\n            retQuery = ex_DB_Records.find({\\\"Time\\\": bar[\\\"Time\\\"]})\\n            if retQuery.count() > 0:\\n                continue\\n            \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt() > 0:\\n                continue\\n            \\n            ex_DB_Records.insert_one({\\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})\\n            index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        LogStatus(_D(), \\\"preBarTime:\\\", preBarTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\\"index:\\\", index)\\n        # 增加画图展示\\n        ext.PlotRecords(r, \\\"%s_%d\\\" % (\\\"records\\\", period))\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cords(r, \\\"%s_%d\\\" % (\\\"records\\\", period))\\n        Sleep(10000)\\n        \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/209461\\n\\n> Last Modified\\n\\n2020-05-23 17:38:55\"\n \n\n    \"strategy_38\",\n    \"python\\nimport pymongo\\nimport json\\n\\ndef main():\\n    Log(\\\"测试数据收集\\\")\\n    \\n    # 连接数据库服务\\n    myDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")   # mongodb://127.0.0.1:27017\\n    # 创建数据库\\n    huobi_DB = myDBClient[\\\"huobi\\\"]\\n    \\n    # 打印目前数据库表\\n    collist = huobi_DB.list_collection_nam",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "目前数据库表\\n    collist = huobi_DB.list_collection_names()\\n    Log(\\\"collist:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.loads(dropNames)\\n    if isinstance(arrDropNames, list):\\n        for i in range(len(arrDropNames)):\\n            dropName = arrDropNames[i]\\n            if isinstance(dropName, str):\\n                if not dropName in collist:\\n                    continue\\n                tab = huobi_DB[dropName]\\n                Log(\\\"dropName:\\\", dropName, \\\"删除：\\\", dropName)\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ame:\\\", dropName, \\\"删除：\\\", dropName)\\n                ret = tab.drop()\\n                collist = huobi_DB.list_collection_names()\\n                if dropName in collist:\\n                    Log(dropName, \\\"删除失败\\\")\\n                else :\\n                    Log(dropName, \\\"删除成功\\\")\\n    \\n    # 创建records表\\n    huobi_DB_Records = huobi_DB[\\\"records\\\"]\\n    \\n    # 请求数据\\n    preBarTime = 0\\n    index = 1\\n    while True:\\n        r = _C(exchange.GetRecords)\\n        if len(r) < 2:\\n            Sleep(1000)\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        if len(r) < 2:\\n            Sleep(1000)\\n            continue\\n        if preBarTime == 0:\\n            # 首次写入所有BAR数据\\n            for i in range(len(r) - 1):\\n                # 逐根写入\\n                bar = r[i]\\n                huobi_DB_Records.insert_one({\\\"index\\\": index, \\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})                \\n                index += 1\\n            preBarTime = r[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        elif preBarTime != r[-1][\\\"Time\\\"]:\\n            bar = r[-2]\\n            huobi_DB_Records.insert_one({\\\"index\\\": index, \\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})\\n            index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        LogStatus(_D(), \\\"preBarTime:\\\", preBarTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\\"index:\\\", index)\\n        Sleep(10000)\",\n    \"策略名称: RecordsCollecter-教学\\n\\nmyDBClient = pymongo.MongoClient(\\\"mongodb://localhost:27017\\\")   # mongodb://127.0.0.1:27017\\n    # 创建数据库\\n    huobi_DB = myDBClient[\\\"huobi\\\"]\\n    \\n    # 打印目前数据库表\\n    collist = huobi_DB.list_collection_names()\\n    Log(\\\"collist:\\\", collist)\\n    \\n    # 检测是否删除表\\n    arrDropNames = json.loads(dropNames)\\n    if isinstance(arrDropNames, list):\\n        for i in range(len(arrDropN",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Names, list):\\n        for i in range(len(arrDropNames)):\\n            dropName = arrDropNames[i]\\n            if isinstance(dropName, str):\\n                if not dropName in collist:\\n                    continue\\n                tab = huobi_DB[dropName]\\n                Log(\\\"dropName:\\\", dropName, \\\"删除：\\\", dropName)\\n                ret = tab.drop()\\n                collist = huobi_DB.list_collection_names()\\n                if dropName in collist:\\n                    Log(dropName, \\\"删除失败\\\")\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                 Log(dropName, \\\"删除失败\\\")\\n                else :\\n                    Log(dropName, \\\"删除成功\\\")\\n    \\n    # 创建records表\\n    huobi_DB_Records = huobi_DB[\\\"records\\\"]\\n    \\n    # 请求数据\\n    preBarTime = 0\\n    index = 1\\n    while True:\\n        r = _C(exchange.GetRecords)\\n        if len(r) < 2:\\n            Sleep(1000)\\n            continue\\n        if preBarTime == 0:\\n            # 首次写入所有BAR数据\\n            for i in range(len(r) - 1):\\n                # 逐根写入\\n                bar = r[i]\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          # 逐根写入\\n                bar = r[i]\\n                huobi_DB_Records.insert_one({\\\"index\\\": index, \\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})                \\n                index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        elif preBarTime != r[-1][\\\"Time\\\"]:\\n            bar = r[-2]\\n            huobi_DB_Records.insert_one({\\\"index\\\": index, \\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"index\\\": index, \\\"High\\\": bar[\\\"High\\\"], \\\"Low\\\": bar[\\\"Low\\\"], \\\"Open\\\": bar[\\\"Open\\\"], \\\"Close\\\": bar[\\\"Close\\\"], \\\"Time\\\": bar[\\\"Time\\\"], \\\"Volume\\\": bar[\\\"Volume\\\"]})\\n            index += 1\\n            preBarTime = r[-1][\\\"Time\\\"]\\n        LogStatus(_D(), \\\"preBarTime:\\\", preBarTime, \\\"_D(preBarTime):\\\", _D(preBarTime/1000), \\\"index:\\\", index)\\n        Sleep(10000)\\n        \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/199120\\n\\n> Last Modified\\n\\n2020-04-16 15:18:28\"\n \n\n    \"strategy_39\",\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\n2020-04-16 15:18:28\"\n \n\n    \"strategy_39\",\n    \"python\\n# 现货网格管理\\n'''\\n# Example:\\n\\ndef main():\\n    spot_g_stra = ext.SpotGridStra({'exchange': exchanges[1],    #现货交易所\\n                         'ZPrecision': 2,\\n                         'XPrecision': 3,\\n                          'MinStock': 0.001,\\n                          'GridSize': 0.03,\\n                          'Symbol': 'BNB',\\n                          'BalancePoint': 0.5\\n                         })\\n    while True:\\n        spot_g_stra.run",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      })\\n    while True:\\n        spot_g_stra.run()\\n        Sleep(60*10000)\\n\\n'''\\n\\n\\nclass SpotGridStra():\\n    \\n    def __init__(self, cfg):\\n        self.cfg = cfg\\n        self.exchange = cfg['exchange']                     #交易所\\n        self.ZPrecision = cfg['ZPrecision']                 #币的价格精度, 整数\\n        self.XPrecision = cfg['XPrecision']                 #币的交易量最小分位数， 如BNB是2\\n        self.Symbol = cfg['Symbol']                         #币的符号\\n        self.GridSize = cfg['GridSize']             ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      self.GridSize = cfg['GridSize']                     #差额多大就调整\\n        self.MinStock = cfg['MinStock']                     #币的最小交易量\\n        self.BalancePoint = cfg.get('BalancePoint', 0.5)    #特定币种占仓位的平衡点\\n        \\n    def CancelPendingOrders(self):\\n        ret = False\\n        while True:\\n            orders = _C(self.exchange.GetOrders)\\n            if len(orders) == 0 :\\n                return ret\\n\\n            for j in range(len(orders)):\\n                self.exchange.CancelOrder(orders[j].Id)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           self.exchange.CancelOrder(orders[j].Id)\\n                ret = True\\n                if j < len(orders) - 1:\\n                    Sleep(1000)\\n        return ret \\n\\n    def onTick(self):\\n        self.exchange.SetCurrency(self.Symbol + '_USDT')\\n        acc = _C(self.exchange.GetAccount)\\n        #Log(acc)\\n        ticker = _C(self.exchange.GetTicker)\\n        spread = ticker.Sell - ticker.Buy\\n        account_info = acc['Info']\\n        bals = account_info['balances']\\n        sel_asset = None ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ccount_info['balances']\\n        sel_asset = None \\n        usdt_val = 0.0\\n        for asset in bals:\\n            if asset['asset'] == self.Symbol:\\n                sel_asset = asset\\n            if asset['asset'] == 'USDT':\\n                usdt_val = float(asset['free'])\\n        assert sel_asset is not None, '找不到对应资产:' + self.Symbol\\n        asset_val = ((float(sel_asset['free']) + float(sel_asset['locked'])) * ticker.Sell)\\n        total_val = usdt_val + asset_val\\n        Log(self.Symbol, total_val, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " + asset_val\\n        Log(self.Symbol, total_val, '=', acc.Balance, '+', asset_val)\\n        diffAsset = (total_val*self.BalancePoint  - asset_val)\\n        ratio = diffAsset / total_val\\n        #Log(\\\"ratio:\\\", ratio, _D())\\n        if abs(ratio) < self.GridSize:\\n            return False\\n        if ratio > 0 :\\n            buyPrice = _N(ticker.Sell + spread, self.ZPrecision)\\n            buyAmount = _N(diffAsset / buyPrice, self.XPrecision)\\n            if buyAmount < self.MinStock:\\n                ret",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if buyAmount < self.MinStock:\\n                return False\\n            self.exchange.Buy(buyPrice, buyAmount, diffAsset, ratio)\\n        else :\\n            sellPrice = _N(ticker.Buy - spread, self.ZPrecision)\\n            sellAmount = _N(-diffAsset / sellPrice, self.XPrecision)\\n            if sellAmount < self.MinStock:\\n                return False \\n            self.exchange.Sell(sellPrice, sellAmount, diffAsset, ratio)\\n        return True\\n    \\n    def run(self):\\n        if self.onTick():\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "def run(self):\\n        if self.onTick():\\n            Sleep(1000)\\n            self.CancelPendingOrders()\\n\\next.SpotGridStra = SpotGridStra\",\n    \"策略名称: SpotGridStra\\n\\n'''\"\n \n\n    \"strategy_40\",\n    \"python\\n'''backtest\\nstart: 2020-01-01 00:00:00\\nend: 2020-04-01 00:00:00\\nperiod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Futures_OKCoin\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\n\\nimport pandas as pd\\nimport time\\n\\ndef main():\\n    exchange.SetContractType(\\\"quarter\\\")\\n    preTime = 0\\n    Log(exchange.GetAccount())\\n    w",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "preTime = 0\\n    Log(exchange.GetAccount())\\n    while True:\\n        records = exchange.GetRecords(PERIOD_M15)\\n        if records and records[-2].Time > preTime:\\n            preTime = records[-2].Time\\n            doTicker(records[:-1])\\n        Sleep(1000 *60)\\n    '''\\n    while True:  \\n        a=time.localtime(Unix())\\n        if(14<a.tm_min<16):\\n            Log(a)\\n        if(a.tm_min==0 or a.tm_min==15 or a.tm_min==30 or a.tm_min==45):\\n            doTicker()\\n        Sleep(1000 *60)\\n    '''\\n\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " doTicker()\\n        Sleep(1000 *60)\\n    '''\\n\\n        \\ndef doTicker(records):\\n    #Log('onTick',exchange.GetTicker())\\n    M15 = pd.DataFrame(records)\\n\\n    #Factor=3\\n    #Pd=7\\n    \\n    M15.columns = ['time','open','high','low','close','volume','OpenInterest']  \\n    \\n    #HL2\\n    M15['hl2']=(M15['high']+M15['low'])/2\\n\\n    #ATR(PD)\\n    length=Pd\\n    M15['prev_close']=M15['close'].shift(1)\\n    ranges= [M15['high'] - M15['low'],M15['high']-M15['prev_close'],M15['low']-M15['prev_close']]\\n    M",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'prev_close'],M15['low']-M15['prev_close']]\\n    M15['tr'] = pd.DataFrame(ranges).T.abs().max(axis=1)\\n    alpha = (1.0 / length) if length > 0 else 0.5\\n    M15['atr']=M15['tr'].ewm(alpha=alpha, min_periods=length).mean()\\n\\n\\n    M15['Up']=M15['hl2']-(Factor*M15['atr'])\\n    M15['Dn']=M15['hl2']+(Factor*M15['atr'])\\n    \\n    M15['TrendUp']=0.0\\n    M15['TrendDown']=0.0\\n    M15['Trend']=1\\n    M15['Tsl']=0.0\\n    M15['linecolor']='Homily'\\n    M15 = M15.fillna(0)\\n\\n    for x in range(len(M15)):\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "illna(0)\\n\\n    for x in range(len(M15)):\\n        M15['TrendUp'].values[x] = max(M15['Up'].values[x],M15['TrendUp'].values[x-1]) if (M15['close'].values[x-1]>M15['TrendUp'].values[x-1]) else M15['Up'].values[x]\\n        M15['TrendDown'].values[x] = min(M15['Dn'].values[x],M15['TrendDown'].values[x-1]) if (M15['close'].values[x-1]<M15['TrendDown'].values[x-1]) else M15['Dn'].values[x]\\n        M15['Trend'].values[x] = 1 if (M15['close'].values[x] > M15['TrendDown'].values[x-1]) else ( -1 if (M15['close'].va",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dDown'].values[x-1]) else ( -1 if (M15['close'].values[x]< M15['TrendUp'].values[x-1])else M15['Trend'].values[x-1] )\\n        M15['Tsl'].values[x] = M15['TrendUp'].values[x] if  (M15['Trend'].values[x]==1) else M15['TrendDown'].values[x]\\n        M15['linecolor'].values[x]= 'Long' if ( M15['Trend'].values[x]==1) else  'Short'\\n \\n\\n    linecolor=M15['linecolor'].values[-2]\\n    close=M15['close'].values[-2]\\n    Tsl=M15['Tsl'].values[-2] \\n\\n    \\n    if(M15['Trend'].values[-1] == 1 and M15['Trend'].values",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "5['Trend'].values[-1] == 1 and M15['Trend'].values[-2] == -1):\\n\\n        Log('SuperTrend V.1 Alert Long','Create Order Buy')\\n        Log('Tsl=',Tsl)\\n        position = exchange.GetPosition()\\n        if len(position) > 0:\\n            Amount=position[0][\\\"Amount\\\"]\\n            exchange.SetDirection(\\\"closesell\\\")\\n            exchange.Buy(_C(exchange.GetTicker).Sell*1.01, Amount);\\n        \\n        exchange.SetDirection(\\\"buy\\\")\\n        exchange.Buy(_C(exchange.GetTicker).Sell*1.01, vol);\\n\\n    if(M1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(exchange.GetTicker).Sell*1.01, vol);\\n\\n    if(M15['Trend'].values[-1] == -1 and M15['Trend'].values[-2] == 1):\\n        Log('SuperTrend V.1 Alert Long','Create Order Sell')\\n        Log('Tsl=',Tsl)\\n        position = exchange.GetPosition()\\n        if len(position) > 0:\\n            Amount=position[0][\\\"Amount\\\"]\\n            exchange.SetDirection(\\\"closebuy\\\")\\n            exchange.Sell(_C(exchange.GetTicker).Buy*0.99,Amount);\\n        exchange.SetDirection(\\\"sell\\\")\\n        exchange.Sell(_C(exchange.G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ion(\\\"sell\\\")\\n        exchange.Sell(_C(exchange.GetTicker).Buy*0.99, vol*2);\",\n    \"策略名称: SuperTrend-V1\\n\\n未找到描述\"\n \n\n    \"strategy_41\",\n    \"python\\n'''backtest\\nstart: 2021-01-01 00:00:00\\nend: 2021-03-12 00:00:00\\nperiod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Futures_OKCoin\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\n\\nimport time\\nimport pandas as pd\\nimport numpy as np\\n\\ndef main():\\n    exchange.SetContractType(\\\"quarter\\\")\\n    while True:\\n        #start_time = time.time()\\n        records = exchange.GetRecords(PERIO",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ime()\\n        records = exchange.GetRecords(PERIOD_H1)\\n        if len(records) < 100:\\n            Sleep(1000)\\n            return\\n        kline = pd.DataFrame(records)\\n        kline.columns = ['time','open','high','low','close','volume','OpenInterest']\\n        i = 0\\n        j = 0\\n        for x in range(len(kline)-40,len(kline)):\\n            if kline['close'].values[x] > kline['close'].values[x-4]:\\n                i += 1\\n            else:\\n                i = 0\\n            if kline['close'].value",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        i = 0\\n            if kline['close'].values[x] < kline['close'].values[x-4]:\\n                j -= 1\\n            else:\\n                j = 0\\n        TDindex = i if i>0 else j\\n        #if 13 > TDindex >= 8 :\\n            #Log('温馨警告，进入超买区域，可考虑卖出止盈：')\\n        #elif 21 > TDindex >= 13 :\\n            #Log('一般警告，进入超级超买区域，可考虑卖出止盈：')\\n        #elif TDindex >= 21 :\\n            #Log('严重警告，进入超级超级超买区域，可考虑清仓止盈：')\\n        #elif -13 < TDindex <= -8 :\\n            #Log('温馨警告，进入超卖区域，可考虑买入博个反弹：')\\n        #eli",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      #Log('温馨警告，进入超卖区域，可考虑买入博个反弹：')\\n        #elif -21 < TDindex <= -13 :\\n            #Log('一般警告，进入超级超卖区域，可考虑加仓买入：')\\n        #elif TDindex <= -21 :\\n            #Log('严重警告，进入超级超级超卖区域，可考虑全仓杀入：')\\n        position = exchange.GetPosition()\\n        #if len(position) > 0:\\n            #Log(position[0][\\\"Type\\\"])\\n        if TDindex == 9 or TDindex == 13 or TDindex == 22:  #and len(position) == 0 :\\n            Log('上根K线的TD序列为：',TDindex)\\n            exchange.SetDirection(\\\"sell\\\")\\n            id2 = exchange",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "SetDirection(\\\"sell\\\")\\n            id2 = exchange.Sell(-1, 1)\\n        \\n        if TDindex == -9 or TDindex == -13 or TDindex == -22:  #and len(position) == 0 :\\n            Log('上根K线的TD序列为：',TDindex)\\n            exchange.SetDirection(\\\"buy\\\")\\n            id2 = exchange.Buy(-1, 1)\\n        if len(position) > 0:\\n            if position[0][\\\"Type\\\"] ==0 and TDindex >= 2 :\\n                #Log(position[0][\\\"Type\\\"])\\n                Log('上根K线的TD序列为：',TDindex)\\n                exchange.SetDirection(\\\"clos",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dex)\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                id2 = exchange.Sell(-1, 1)\\n            \\n            if position[0][\\\"Type\\\"] ==1 and TDindex <= -2 :\\n                #Log(position[0][\\\"Type\\\"])\\n                Log('上根K线的TD序列为：',TDindex)\\n                exchange.SetDirection(\\\"closesell\\\")\\n                id2 = exchange.Buy(-1, 1)\\n        # end_time = time.time()\\n        #spend_time = end_time - start_time\\n        Sleep(1000*900)\",\n    \"策略名称: TD狄马克序列\\n\\n#spend_time = end_ti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "*900)\",\n    \"策略名称: TD狄马克序列\\n\\n#spend_time = end_time - start_time\\n        Sleep(1000*900)\\n                \\n                \\n                \\n    \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/262467\\n\\n> Last Modified\\n\\n2021-03-16 11:18:47\"\n \n\n    \"strategy_42\",\n    \"# key 为 Bot key\\n## 获取 Bot key 可以参考 https://www.ccino.org/create-a-telegram-bot.html\\n# chat_id 为收信用户Telegram ID\\n## Telegram ID 可以通过 @dwx_aibot 机器人获取， 连接至此机器人后发送 /getid 即可获得 ChatID\\nTelegram = ext.Telegram(key=string, chat_id=intege",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Telegram = ext.Telegram(key=string, chat_id=integer)    # 创建一个新的接口对象\\n\\n# ==========================================\\n\\npython\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n# \\n# Telegram Interface for FMZ.com\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# Do What the Fuck You Want To Public License\\n#\\n\\ntry:\\n    import requests\\nexcept:\\n    print('Requests not installed. Try: pip install requests')\\n    Log('Requests not installed. Try: pip inst",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "')\\n    Log('Requests not installed. Try: pip install requests')\\n    \\n    raise Exception('Requests not installed. Try: pip install requests')\\n\\nclass Telegram:\\n    def __init__(self):\\n        self.key = KEY\\n        self.chat_id = CHATID\\n        self.url = 'https://api.telegram.org/bot%s' % self.key\\n        \\n    def Send(self, message='', chat_id=None):\\n        if chat_id is None:\\n            chat_id = self.chat_id\\n        PARAM = {}\\n        PARAM['chat_id'] = chat_id\\n        PARAM['text'] = m",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "AM['chat_id'] = chat_id\\n        PARAM['text'] = message\\n        PARAM['parse_mode'] = 'markdown'\\n        URL = self.url + '/sendMessage'\\n        try:\\n            res = requests.post(URL, data = PARAM)\\n            return True\\n        except IOError as e:\\n            print(e)\\n            return False\\n        \\n\\next.Telegram = Telegram\\n\\n# 模块功能测试\\ndef main():\\n    if DEBUG == 1:\\n        msger = ext.Telegram(KEY, CHATID)\\n        msger.Send(\\\"Hello World!\\\")\\n    \\n    return True\",\n    \"策略名称: Tele",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "World!\\\")\\n    \\n    return True\",\n    \"策略名称: Telegram-发信接口-V200-Python\\n\\n##### 这个库目前只能Telegram发信 后续会增加更多功能。\"\n \n\n    \"strategy_43\",\n    \"python\\n'''\\n请求格式：http://x.x.x.x:xxxx/data?access_key=xxx&secret_key=yyy&type=buy&amount=0.001\\n策略机器人参数：\\n- 类型：加密字符串，AccessKey , SecretKey ，可以用FMZ平台的低权限的API KEY，或者自己生成KEY也可以。\\n- 类型：字符串，合约ID，ContractType\\n- 类型：数值，端口号，Port\\n'''\\n\\nimport re\\nimport _thread\\nimport json\\nfrom http.server import ThreadingHTTPServer, BaseHTTPRequestHandler\\nfrom urllib.parse import parse_qs, u",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "questHandler\\nfrom urllib.parse import parse_qs, urlparse\\n\\ndef url2Dict(url):\\n    query = urlparse(url).query  \\n    params = parse_qs(query)  \\n    result = {key: params[key][0] for key in params}  \\n    return result\\n\\nclass Executor(BaseHTTPRequestHandler):\\n    def do_GET(self):\\n        try:\\n            dictParam = url2Dict(self.path)\\n            Log(\\\"测试\\\", dictParam)\\n        except Exception as e:\\n            Log(\\\"Provider do_GET error, e:\\\", e)\\n    def do_POST(self):\\n        try:\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " e)\\n    def do_POST(self):\\n        try:\\n            self.send_response(200)\\n            self.send_header(\\\"Content-type\\\", \\\"application/json\\\")\\n            self.end_headers()\\n            dictParam = url2Dict(self.path)\\n            \\n            # 测试POST请求Body信息            \\n            data = self.rfile.read(200)   # 指定了读取长度\\n            Log(\\\"data:\\\", data)            # 打印POST请求的数据，可以根据请求中的数据具体再让机器人执行对应的操作\\n            \\n            # 校验\\n            if len(dictParam) == 4 and dictParam[\\\"access_ke",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  if len(dictParam) == 4 and dictParam[\\\"access_key\\\"] == AccessKey and dictParam[\\\"secret_key\\\"] == SecretKey:\\n                del dictParam[\\\"access_key\\\"]\\n                del dictParam[\\\"secret_key\\\"]\\n                Log(\\\"接收到请求\\\", \\\"参数：\\\", dictParam, \\\"#FF0000\\\")\\n                '''\\n                map[access_key:xxx amount:0.001 secret_key:yyy type:buy]\\n                '''\\n                isSpot = True\\n                if exchange.GetName().find(\\\"Futures\\\") != -1:\\n                    if Contra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"Futures\\\") != -1:\\n                    if ContractType != \\\"\\\":\\n                        exchange.SetContractType(ContractType)\\n                        isSpot = False \\n                    else :\\n                        raise \\\"未设置期货合约\\\"\\n                                \\n                q = None\\n                if exchange.GetName() == \\\"Futures_CTP\\\" and UseMarketOrderForCTP == False:\\n                    q = ext.NewTaskQueue()\\n                \\n                if isSpot and dictParam[\\\"type\\\"] == \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            if isSpot and dictParam[\\\"type\\\"] == \\\"buy\\\":\\n                    exchange.Buy(-1, float(dictParam[\\\"amount\\\"]))\\n                    Log(exchange.GetAccount())\\n                elif isSpot and dictParam[\\\"type\\\"] == \\\"sell\\\":\\n                    exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))\\n                    Log(exchange.GetAccount())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"long\\\":\\n                    exchange.SetDirection(\\\"buy\\\")\\n                    if not q:\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rection(\\\"buy\\\")\\n                    if not q:\\n                        exchange.Buy(-1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"buy\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"short\\\":\\n                    exchange.SetDirection(\\\"sell\\\")\\n                    if no",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".SetDirection(\\\"sell\\\")\\n                    if not q:\\n                        exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"sell\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"cover_long\\\":\\n                    exchange.SetDirection(\\\"closebuy\\\")\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      exchange.SetDirection(\\\"closebuy\\\")\\n                    if not q:\\n                        exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"closebuy\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"cover_short\\\":\\n                    exchange.SetDirection",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hort\\\":\\n                    exchange.SetDirection(\\\"closesell\\\")\\n                    if not q:\\n                        exchange.Buy(-1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"closesell\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                \\n                if q is not None:\\n                    while q.size() > 0:\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t None:\\n                    while q.size() > 0:\\n                        q.poll()\\n                        Sleep(500)\\n            \\n            # 处理body数据\\n            if isDealBodyMsg:\\n                if exchange.GetName().find(\\\"Futures\\\") != -1:\\n                    Log(\\\"data:\\\", data.decode('utf-8'))  # 测试\\n                    if re.search(r'buy', data.decode('utf-8')):\\n                        Log(\\\"触发buy\\\")\\n                        exchange.SetContractType(ct)\\n                        exchange.Set",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ractType(ct)\\n                        exchange.SetDirection(\\\"buy\\\")\\n                        exchange.Buy(-1, amount)\\n                    elif re.search(r'sell', data.decode('utf-8')):\\n                        Log(\\\"触发sell\\\")\\n                        exchange.SetContractType(ct)\\n                        exchange.SetDirection(\\\"sell\\\")\\n                        exchange.Sell(-1, amount)\\n            \\n            # 写入数据应答\\n            self.wfile.write(json.dumps({\\\"state\\\": \\\"ok\\\"}).encode())\\n        excep",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "umps({\\\"state\\\": \\\"ok\\\"}).encode())\\n        except Exception as e:\\n            Log(\\\"Provider do_POST error, e:\\\", e)\\n\\n\\ndef createServer(host):\\n    try:\\n        server = ThreadingHTTPServer(host, Executor)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except Exception as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\ndef main():\\n    # 开启一个线程\\n    try:\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\",",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "read.start_new_thread(createServer, ((\\\"0.0.0.0\\\", Port), ))         # VPS服务器上测试           \\n    except Exception as e:        \\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")    \\n    if exchange.GetName().find(\\\"Futures\\\") != -1:\\n        exchange.SetContractType(ContractType)\\n    Log(\\\"账户资产信息：\\\", _C(exchange.GetAccount))\\n    while True:\\n        if exchange.GetName() == \\\"Futures_CTP\\\":\\n            if exchange.IO(\\\"status\\\"):\\n                LogStatus(_D(), \\\"CTP连接\\\")\\n            else:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     LogStatus(_D(), \\\"CTP连接\\\")\\n            else:\\n                LogStatus(_D(), \\\"CTP未连接\\\")\\n        else:\\n            LogStatus(_D())\\n        Sleep(2000)\",\n    \"策略名称: TradingViewWebHook直连策略\\n\\ndata = self.rfile.read(200)   # 指定了读取长度\\n            Log(\\\"data:\\\", data)            # 打印POST请求的数据，可以根据请求中的数据具体再让机器人执行对应的操作\\n            \\n            # 校验\\n            if len(dictParam) == 4 and dictParam[\\\"access_key\\\"] == AccessKey and dictParam[\\\"secret_key\\\"] == SecretKey:\\n                del dictParam[\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"] == SecretKey:\\n                del dictParam[\\\"access_key\\\"]\\n                del dictParam[\\\"secret_key\\\"]\\n                Log(\\\"接收到请求\\\", \\\"参数：\\\", dictParam, \\\"#FF0000\\\")\\n                '''\\n                map[access_key:xxx amount:0.001 secret_key:yyy type:buy]\\n                '''\\n                isSpot = True\\n                if exchange.GetName().find(\\\"Futures\\\") != -1:\\n                    if ContractType != \\\"\\\":\\n                        exchange.SetContractType(ContractType)\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.SetContractType(ContractType)\\n                        isSpot = False \\n                    else :\\n                        raise \\\"未设置期货合约\\\"\\n                                \\n                q = None\\n                if exchange.GetName() == \\\"Futures_CTP\\\" and UseMarketOrderForCTP == False:\\n                    q = ext.NewTaskQueue()\\n                \\n                if isSpot and dictParam[\\\"type\\\"] == \\\"buy\\\":\\n                    exchange.Buy(-1, float(dictParam[\\\"amount\\\"]))\\n                  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " float(dictParam[\\\"amount\\\"]))\\n                    Log(exchange.GetAccount())\\n                elif isSpot and dictParam[\\\"type\\\"] == \\\"sell\\\":\\n                    exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))\\n                    Log(exchange.GetAccount())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"long\\\":\\n                    exchange.SetDirection(\\\"buy\\\")\\n                    if not q:\\n                        exchange.Buy(-1, float(dictParam[\\\"amount\\\"]))\\n                    else",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"buy\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"short\\\":\\n                    exchange.SetDirection(\\\"sell\\\")\\n                    if not q:\\n                        exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))\\n                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"sell\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"cover_long\\\":\\n                    exchange.SetDirection(\\\"closebuy\\\")\\n                    if not q:\\n                        exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   exchange.Sell(-1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"closebuy\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                elif not isSpot and dictParam[\\\"type\\\"] == \\\"cover_short\\\":\\n                    exchange.SetDirection(\\\"closesell\\\")\\n                    if not q:\\n                        exchange.Buy(-1, float(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n                        exchange.Buy(-1, float(dictParam[\\\"amount\\\"]))\\n                    else :\\n                        q.pushTask(exchange, ContractType, \\\"closesell\\\", float(dictParam[\\\"amount\\\"]), lambda task, ret: Log(task[\\\"desc\\\"], ret, \\\"#FF0000\\\"))\\n                    Log(\\\"持仓：\\\", exchange.GetPosition())\\n                \\n                if q is not None:\\n                    while q.size() > 0:\\n                        q.poll()\\n                        Sleep(500)\\n            \\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             Sleep(500)\\n            \\n            # 处理body数据\\n            if isDealBodyMsg:\\n                if exchange.GetName().find(\\\"Futures\\\") != -1:\\n                    Log(\\\"data:\\\", data.decode('utf-8'))  # 测试\\n                    if re.search(r'buy', data.decode('utf-8')):\\n                        Log(\\\"触发buy\\\")\\n                        exchange.SetContractType(ct)\\n                        exchange.SetDirection(\\\"buy\\\")\\n                        exchange.Buy(-1, amount)\\n                    elif ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchange.Buy(-1, amount)\\n                    elif re.search(r'sell', data.decode('utf-8')):\\n                        Log(\\\"触发sell\\\")\\n                        exchange.SetContractType(ct)\\n                        exchange.SetDirection(\\\"sell\\\")\\n                        exchange.Sell(-1, amount)\\n            \\n            # 写入数据应答\\n            self.wfile.write(json.dumps({\\\"state\\\": \\\"ok\\\"}).encode())\\n        except Exception as e:\\n            Log(\\\"Provider do_POST error, e:\\\", e)\\n\\n\\ndef createServer(hos",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " do_POST error, e:\\\", e)\\n\\n\\ndef createServer(host):\\n    try:\\n        server = ThreadingHTTPServer(host, Executor)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except Exception as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\ndef main():\\n    # 开启一个线程\\n    try:\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", Port), ))         # VPS服务器上测试           \\n    except Exception as e:        \\n        Log(\\\"错误",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  except Exception as e:        \\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")    \\n    if exchange.GetName().find(\\\"Futures\\\") != -1:\\n        exchange.SetContractType(ContractType)\\n    Log(\\\"账户资产信息：\\\", _C(exchange.GetAccount))\\n    while True:\\n        if exchange.GetName() == \\\"Futures_CTP\\\":\\n            if exchange.IO(\\\"status\\\"):\\n                LogStatus(_D(), \\\"CTP连接\\\")\\n            else:\\n                LogStatus(_D(), \\\"CTP未连接\\\")\\n        else:\\n            LogStatus(_D())\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        else:\\n            LogStatus(_D())\\n        Sleep(2000)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/221850\\n\\n> Last Modified\\n\\n2021-03-31 11:33:30\"\n \n\n    \"strategy_44\",\n    \"python\\nimport numpy as np\\nimport pandas as pd\\n\\ndata = DataAPI.MktIdxdGet(indexID=u\\\"\\\",ticker=u\\\"000300\\\",tradeDate=u\\\"\\\",beginDate=u\\\"20100101\\\",endDate=u\\\"20180501\\\",exchangeCD=u\\\"XSHE,XSHG\\\",field=u\\\"\\\",pandas=\\\"1\\\")\\ndata.set_index('tradeDate', inplace = True)\\n# 获取HS300的每日价格数据\\n\\nfor i in range(1, 21, 1):\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "# 获取HS300的每日价格数据\\n\\nfor i in range(1, 21, 1):\\n    data['close-' + str(i) + 'd'] = data['closeIndex'].shift(i)\\n# 对于收盘价，在data中增加了20列数据，分别为1天前的收盘价至20天前的收盘价\\n    \\nhs_close = data[[x for x in data.columns if 'close' in x]].iloc[20:]\\n# 选取今天及1-20天前的收盘价，iloc[20:]剔除了无效数据\\n\\nhs_close = hs_close.iloc[:, ::-1]\\n# 将新DataFrame的列按倒序排列\\n################################################################################################\\nfrom sklearn import svm\\n# 从sklearn库中导入svm算法\\n\\ndays = 1500\\n# 设定全局变量，分割训练集和测试集的数据，1500",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "导入svm算法\\n\\ndays = 1500\\n# 设定全局变量，分割训练集和测试集的数据，1500在上文数据中约占75%\\n\\nclf_close = svm.SVR(kernel='linear')\\n# 使用svm下的SVR算法，'linear'表示线性核\\nf_close_train = hs_close[:days]\\n# 训练集features\\nl_close_train = hs_close['closeIndex'].shift(-1)[:days]\\n# 训练集labels，将收盘价shift(-1)表示预测的是下一天的收盘价\\nf_close_test = hs_close[days:]\\n# 测试集features\\nl_close_test = hs_close['closeIndex'].shift(-1)[days:]\\n# 训练集labels，将收盘价shift(-1)表示预测的是下一天的收盘价\\nclf_close.fit(f_close_train, l_close_train)\\n# 训练模型\\n\\n####################################",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n)\\n# 训练模型\\n\\n######################################################################################\\n\\np_close_train = clf_close.predict(f_close_train)\\n# 将训练集features导入模型进行预测，生成预测的收盘价\\ndf_close_train = pd.DataFrame(l_close_train)\\n# 新建一个DataFrame，内容为训练集labels,即下一天的收盘价\\ndf_close_train.columns = ['next close']\\n# 列名重命名为'next close'\\ndf_close_train['predicted next close'] = p_close_train\\n# 加入一列预测的收盘价数据\\ndf_close_train['next open'] = data['openIndex'][20:20 + days].shift(-1)\\n# 加入一列下一天开盘价的数据，从data而非hs_close中",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " days].shift(-1)\\n# 加入一列下一天开盘价的数据，从data而非hs_close中获取，需要切片\\n\\ntrigger = 1.0\\ndf_close_train['position'] = np.where(df_close_train['predicted next close'] > df_close_train['next open'] * trigger, 1, 0)\\n# 通过np.where函数判断，当预测的下一天收盘价 > 下一天开盘价相乘或相加一个trigger时，仓位设置为1，否则为0\\ndf_close_train['PL'] = np.where(df_close_train['position'] == 1, (df_close_train['next close'] - df_close_train['next open']) / df_close_train['next open'], 0)\\n# 当仓位为1时，在下一天开盘时买入，收盘时卖出，记录下一天应获得的收益率，否则收益率为0\\n\\ndf_close_train['strategy'] = (df_clo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "益率，否则收益率为0\\n\\ndf_close_train['strategy'] = (df_close_train['PL'].shift(1) + 1).cumprod()\\n# 策略每日收益的累积收益率，其中shift(1)表示当日记录的是下一天才能获得的收益率，当日无法获得\\ndf_close_train['return'] = (df_close_train['next close'].pct_change() + 1).cumprod()\\n# benchmark的累积收益率\\n\\ndf_close_train[['strategy', 'return']].dropna().plot()\\n# 画出策略与benchmark的累计收益率图\\n\\n##########################################################################\\ndef main():\\n    Log(exchange.GetAccount())\",\n    \"策略名称: VNC-SVM-Test\\n\\nfor i in range(1, 21, 1):\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "名称: VNC-SVM-Test\\n\\nfor i in range(1, 21, 1):\\n    data['close-' + str(i) + 'd'] = data['closeIndex'].shift(i)\"\n \n\n    \"strategy_45\",\n    \"python\\n'''backtest\\nstart: 2021-03-19 05:00:00\\nend: 2021-03-21 00:00:00\\nperiod: 15m\\nbasePeriod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Futures_HuobiDM\\\",\\\"currency\\\":\\\"BTC_USD\\\"},{\\\"eid\\\":\\\"Futures_HuobiDM\\\",\\\"currency\\\":\\\"ETH_USD\\\",\\\"stocks\\\":300},{\\\"eid\\\":\\\"Futures_HuobiDM\\\",\\\"currency\\\":\\\"EOS_USD\\\",\\\"stocks\\\":5000}]\\nargs: [[\\\"openConMode\\\",null]]\\n'''\\n\\n#!/usr/bin/env pyth",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"openConMode\\\",null]]\\n'''\\n\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\nimport json\\nimport time\\nimport talib\\nimport math\\nimport urllib.request\\n\\nChartCfg = {\\n    '__isStock': True,\\n    'title': {\\n        'text': 'WR'\\n   \\n    'yAxis': [{\\n        'title': {'text': 'WR'},\\n        'style': {'color': '#4572A7'},\\n        'opposite': False #右边轴\\n    }],\\n    'series': [{\\n        'type': 'line',\\n        'id': 'wr',\\n        'name': 'wr',\\n        'data': []\\n    }]\\n}\\n\\ndef MyLog(str1,ktime,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    'data': []\\n    }]\\n}\\n\\ndef MyLog(str1,ktime,price=''):\\n    if (_G('str')!=str1 or _G('ktime')!=ktime) and  not (_G('str2')==str1 and ktime==_G('ktime2')) :\\n        _G('str2',_G('str'))\\n        _G('ktime2',_G('ktime'))\\n\\n        _G('str',str1)\\n        _G('ktime',ktime)\\n        Log(str1+str(price)) \\n\\n\\ndef moveStocks(_moveStocks):\\n    global todayProfit\\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance  只有币本位有交割且共用资金 2-U本位向现货   4-币本位向现货  返回tranId\\n        if exchanges[0].GetCur",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "4-币本位向现货  返回tranId\\n        if exchanges[0].GetCurrency().find('USDT')>=0:\\n            movecurrency = 'USDT'\\n            mtype = 2\\n        else:#币本位\\n            movecurrency = 'BTC'\\n            mtype = 4\\n        timestamp = Unix()*1000       \\n        params = \\\"type=\\\"+str(mtype)+\\\"&asset=\\\"+movecurrency+\\\"&amount=\\\"+str(_moveStocks)+\\\"&timestamp=\\\"+str(timestamp)\\n        exchanges[0].SetBase('https://api.binance.com')\\n        moveid = exchange.IO(\\\"api\\\", \\\"POST\\\", \\\"/sapi/v1/futures/transfer\\\", p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"api\\\", \\\"POST\\\", \\\"/sapi/v1/futures/transfer\\\", params)   \\n        exchanges[0].SetBase('https://fapi.binance.com')\\n        if moveid is not None:\\n            Log('资金转出成功',moveid)\\n            _G('moveStocks',_G('moveStocks')+_moveStocks)\\n            todayProfit[\\\"initStocks\\\"] = todayProfit[\\\"initStocks\\\"] - _moveStocks\\n            _G('todayProfit',todayProfit)\\n            \\n        else:\\n            Log('资金转出失败')\\n    else:\\n        Log('暂不支持该交易所转移')\\n    \\ndef cancelOD(i):\\n    orders = _C(exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "')\\n    \\ndef cancelOD(i):\\n    orders = _C(exchanges[i].GetOrders)\\n    for order in orders:\\n        exchanges[i].CancelOrder(order.Id)\\n        Sleep(100)\\n\\ndef coverAll(i):\\n    position = _C(exchanges[i].GetPosition)\\n    cancelOD(i)\\n    Sleep(200)\\n    for j in range(len(position)):\\n        pamount = position[j][\\\"Amount\\\"] #-position[0][\\\"FrozenAmount\\\"]\\n        if position[j][\\\"Type\\\"]==0:     #持多单\\n            Deal(-1 , pamount, \\\"closebuy\\\", exchanges[i].GetCurrency()+'手动市价清仓',i)\\n        elif",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "changes[i].GetCurrency()+'手动市价清仓',i)\\n        elif position[j][\\\"Type\\\"]==1:     #持空单\\n            Deal(-1 , pamount, \\\"closesell\\\", exchanges[i].GetCurrency()+'手动市价清仓',i)\\n        \\ndef  getOpenPrice(position):\\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):#huobi\\n        return position[0].Info.cost_open\\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'avg_cost'):#ok\\n        return position[0].Info.avg_cost\\n    elif hasattr(position[0],'Info') and hasat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st\\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'entryPrice'):#binance\\n        return position[0].Info.entryPrice\\n    else:\\n        return position[0][\\\"Price\\\"] \\n\\n    \\ndef UpdateAccout():\\n    accout = _C(exchanges[0].GetAccount)\\n    acc1 = accout.FrozenBalance    #其它币的冻结余额  是否共用?\\n    acc2 = accout.Balance\\n    \\n    _G(\\\"ableAccount\\\", acc2)#当前可用U\\n    _G(\\\"allAccount\\\",acc1+acc2+GetMargin()) #没计算浮盈\\n    if acc2<1:\\n        Log(\\\"账户保证金余额不足\\\")\\n        Sleep(8000)\\n\\ndef GetMa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g(\\\"账户保证金余额不足\\\")\\n        Sleep(8000)\\n\\ndef GetMargin():\\n    allMargin = 0\\n    for i in range(len(exchanges)):\\n        allMargin += _G(\\\"margin\\\")[i]\\n    return _N(allMargin,2)\\n\\n\\ndef GetHighest(records,i,period):\\n    high = 0\\n    for i in range(i-period+1,i+1):\\n        if records[i].High > high:\\n            high = records[i].High\\n    return high\\n\\ndef GetLowest(records,i,period):\\n    low = 1000000\\n    for i in range(i-period+1,i+1):\\n        if records[i].Low < low:\\n            low = record",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if records[i].Low < low:\\n            low = records[i].Low\\n    return low\\n    \\n        \\ndef SetType(type):\\n    if type==0:\\n        _G(\\\"contractType\\\",\\\"swap\\\")\\n    elif type==1:\\n        _G(\\\"contractType\\\",\\\"this_week\\\")\\n    elif type==2:\\n        _G(\\\"contractType\\\",\\\"next_week\\\")\\n    elif type==3:\\n        _G(\\\"contractType\\\",\\\"quarter\\\")\\n    elif type==4:\\n        _G(\\\"contractType\\\",\\\"next_quarter\\\")\\n        \\ndef Deal(price, num, btype, beizhu='',i=0 ):\\n    Sleep(50)\\n    #if beizhu!='':\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "zhu='',i=0 ):\\n    Sleep(50)\\n    #if beizhu!='':\\n    #    Log(beizhu)\\n    exchanges[i].SetDirection(btype)\\n    if btype==\\\"closebuy\\\" or btype==\\\"sell\\\" :\\n        exchanges[i].Sell(price , num, beizhu)\\n        #Log('开空',price)\\n    else:\\n        exchanges[i].Buy(price , num, beizhu)\\n        #Log('开多',price)\\n\\n\\ndef myProfit():\\n    LogProfit( _G(\\\"allAccount\\\")-_G(\\\"initStocks\\\") )\\n\\n\\ndef initData():\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|No need to change|reused\\\")\\n    global allCoinData\\n    Log(\\\"正在初始化...\\\")\\n\\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance\\n        getBinanceAllCoinData()\\n        Sleep(3000)\\n        Log(\\\"获取交易所信息结束\\\")\\n    else:\\n        Log('暂不支持该交易所')\\n        return\\n    \\n    if _G(\\\"moveStocks\\\") is None:\\n        _G(\\\"moveStocks\\\",0)\\n    if _G(\\\"moveInStocks\\\") is None:\\n        _G(\\\"moveInStocks\\\",0)\\n        \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s None:\\n        _G(\\\"moveInStocks\\\",0)\\n        \\n    for i in range(len(exchanges)):#初始化 交易所\\n        symbol = exchanges[i].GetCurrency().split('_')[0]\\n        exchanges[i].SetContractType(\\\"swap\\\")\\n        exchanges[i].SetPrecision(allCoinData[symbol]['tick_size'], allCoinData[symbol]['size_increment'])\\n        exchanges[i].SetMarginLevel(marginLevel)\\n        timestamp = Unix()*1000      \\n        exchanges[i].IO(\\\"api\\\", \\\"POST\\\", \\\"/fapi/v1/positionSide/dual\\\", \\\"dualSidePosition=true&timestamp=\\\"+",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Side/dual\\\", \\\"dualSidePosition=true&timestamp=\\\"+str(timestamp))\\n        \\n    \\n        \\ndef main():\\n    global allCoinData, orderID\\n    if _G(\\\"contractType\\\") is None:\\n        _G(\\\"contractType\\\",\\\"swap\\\")\\n    global ChartCfg\\n    preTime = 0\\n    chart = Chart(ChartCfg)\\n    chart.reset()\\n    \\n    margin = [0 for i in range(len(exchanges)) ] \\n    _G(\\\"margin\\\",margin)\\n    preTime = 0\\n    bucTimes = [0 for i in range(len(exchanges)) ] \\n    initData()\\n    #LogProfitReset(1)\\n    #暂未考虑仓位不足\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "itData()\\n    #LogProfitReset(1)\\n    #暂未考虑仓位不足\\n    while(true):\\n        #Log('测试循环')\\n        cmd = GetCommand()\\n        if cmd:\\n            if cmd == \\\"清仓停机\\\":\\n                for i in range(len(exchanges)):\\n                    Sleep(100)\\n                    coverAll(i)\\n                Sleep(1000)\\n                return\\n            if cmd.find('cover-')>=0:\\n                arr = cmd.split(\\\"-\\\")\\n                coverAll(int(arr[1]))\\n                Sleep(2000)\\n            elif cmd == 'cancel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      Sleep(2000)\\n            elif cmd == 'cancelOD':\\n                cancelOD()\\n                Sleep(1000)\\n        \\n        tab1 = {\\n            \\\"type\\\": \\\"table\\\", \\n            \\\"title\\\": \\\"账户信息\\\", \\n            \\\"cols\\\": [\\\"初始资金\\\", \\\"当前资金\\\" , \\\"可用资金\\\", \\\"已移出资金\\\", \\\"总盈利率\\\"], \\n            \\\"rows\\\": []\\n        }\\n        tab2 = {\\n            \\\"type\\\": \\\"table\\\", \\n            \\\"title\\\": \\\"持仓状态\\\", \\n            \\\"cols\\\": [\\\"币种\\\", \\\"最新价\\\",\\\"持仓数\\\", \\\"持仓均价\\\",  \\\"浮动盈亏\\\",\\\"操作\\\"], \\n            \\\"rows\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"持仓均价\\\",  \\\"浮动盈亏\\\",\\\"操作\\\"], \\n            \\\"rows\\\": []\\n        }\\n        \\n        \\n        UpdateAccout() \\n        if _G(\\\"initStocks\\\") is None or _G(\\\"initStocks\\\")<10 :\\n            _G(\\\"initStocks\\\", _G(\\\"allAccount\\\"))\\n        if autoMoveStocks>100 and _G('ableAccount')>autoMoveStocks :\\n                Log('自动移出资金：100U#32CD32')\\n                moveStocks(100)\\n                continue\\n\\n        for i in range(len(exchanges)):\\n            Sleep(100)\\n            records = _C(exchanges[i].GetR",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "p(100)\\n            records = _C(exchanges[i].GetRecords,60 * period)\\n            #wr_high = TA.Highest(records, WRperiod, 'High')\\n            #wr_low = TA.Lowest(records, WRperiod, 'Low')\\n            #wr = (records[-1].Close-wr_high)/(wr_high-wr_low)*100\\n            position = _C(exchanges[i].GetPosition)\\n            margin = _G(\\\"margin\\\")\\n            if len(position)>0:\\n                oprice = float(getOpenPrice(position))\\n                margin[i] = position[0][\\\"Margin\\\"]\\n                floa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "i] = position[0][\\\"Margin\\\"]\\n                floatProfit =  float(position[0][\\\"Profit\\\"])\\n                pamount = float(position[0]['Amount'])\\n                #止损\\n                if -1*floatProfit > oprice*pamount/marginLevel*zhis/100:\\n                    if position[0]['Type']==0:\\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止损'+format(records[-1].Close,'.4f'),i)\\n                    else:\\n                        Deal(-1, pamount, 'closesell',exchanges[i].Ge",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止损'+format(records[-1].Close,'.4f'),i)\\n                    Sleep(500)\\n                    myProfit()\\n                    bucTimes[i] += 1\\n                    if bucTimes[i]>maxBuc:\\n                        bucTimes[i] = maxBuc\\n                #止盈\\n                if floatProfit > oprice*pamount/marginLevel*zhiy/100:\\n                    if position[0]['Type']==0:\\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurre",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止盈'+format(records[-1].Close,'.4f'),i)\\n                    else:\\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止盈'+format(records[-1].Close,'.4f'),i)\\n                    Sleep(500)\\n                    myProfit()\\n                    bucTimes[i] = 0\\n            else:\\n                oprice = 0\\n                margin[i] = 0\\n                floatProfit = ''\\n\\n            _G(\\\"margin\\\", margin)\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'\\n\\n            _G(\\\"margin\\\", margin)\\n            \\n            \\n            for k in range(50, len(records)):\\n\\n                wr_high1 = GetHighest(records,k, WRperiod)\\n                wr_low1 = GetLowest(records,k, WRperiod)\\n                wr1 = (records[k].Close-wr_high1)/(wr_high1-wr_low1)*100\\n                if k==len(records)-1:\\n                    if wr1>-5:#开空\\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==0):#平多\\n                            if ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]['Type']==0):#平多\\n                            if len(position)>0:\\n                                Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单清仓'+format(records[-1].Close,'.4f'),i)\\n                                Sleep(500)\\n                                myProfit()\\n                                if floatProfit<0:\\n                                    bucTimes[i] += 1\\n                                    if bucTimes[i]>maxBuc:\\n                                        bucTimes[i] = maxBu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                               bucTimes[i] = maxBuc\\n                                else:\\n                                    bucTimes[i] = 0\\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\\n                            if famount==0:\\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\\n                                continue\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "大开仓U')\\n                                continue\\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\\n                            Deal(-1, pamount, 'sell',exchanges[i].GetCurrency()+' 空单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)\\n                    elif wr1<-95:#开多\\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==1):#平空",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r (len(position)>0 and position[0]['Type']==1):#平空\\n                            if len(position)>0:\\n                                Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单清仓'+format(records[-1].Close,'.4f'),i)\\n                                Sleep(500)\\n                                myProfit()\\n                                if floatProfit<0:\\n                                    bucTimes[i] += 1\\n                                    if bucTimes[i]>maxBuc:\\n                         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " if bucTimes[i]>maxBuc:\\n                                        bucTimes[i] = maxBuc\\n                                else:\\n                                    bucTimes[i] = 0\\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\\n                            if famount==0:\\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\\n                                continue\\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\\n                            Deal(-1, pamount, 'buy',exchanges[i].GetCurrency()+' 多单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)        \\n                    #Log(wr1)\\n                \\n                #画图\\n                if i==",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     \\n                #画图\\n                if i==0 and records[k]['Time'] == preTime:\\n                    chart.add(0, [records[k]['Time'], wr1], -1)\\n                elif i==0 and records[k]['Time'] > preTime:\\n                    #Log('insert',records[k]['Time'],wr_high1,wr_low1,records[k].Close,wr1)\\n                    chart.add(0, [records[k]['Time'], wr1])\\n                    preTime = records[k]['Time']\\n            \\n\\n            #myProfit()\\n\\n            if len(position)>0 and position[0]['Typ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           if len(position)>0 and position[0]['Type']==0:\\n                pamount = '多：'+str(position[0]['Amount'])+str('#32CD32')\\n            elif len(position)>0 and position[0]['Type']==1:\\n                pamount = '空：'+str(position[0]['Amount'])+str('#BC1717')\\n            else:\\n                pamount = ''\\n            if len(position)>0:\\n                floatProfit = format( position[0][\\\"Profit\\\"],'.2f')\\n            symbol = exchanges[i].GetCurrency().split('_')[0]\\n            tab2[\\\"rows\\\"].a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ency().split('_')[0]\\n            tab2[\\\"rows\\\"].append([ exchanges[i].GetCurrency() , records[-1].Close \\\\\\n                             , pamount, format(oprice,'.'+str(allCoinData[symbol]['tick_size'])+'f'), floatProfit \\\\\\n                             , { \\\"type\\\": \\\"button\\\",  \\\"cmd\\\": 'cover-'+str(i), \\\"name\\\": \\\"清仓\\\" } ])\\n\\n        #总盈利\\n        allzhiy = float(_G('allAccount'))-float(_G('moveInStocks'))+float(_G('moveStocks'))-float(_G('initStocks'))\\n        if _G('initStocks')==0:\\n            al",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n        if _G('initStocks')==0:\\n            allzhiyl=0\\n        else:\\n            allzhiyl = (float(_G('moveStocks'))+float(_G('allAccount'))-float(_G('moveInStocks'))-float(_G('initStocks')))/float(_G('initStocks'))*100\\n         \\n        tab1[\\\"rows\\\"].append([format(_G('initStocks'),'.1f')+'U', format(_G('allAccount'),'.1f')+'U', format(_G('ableAccount'),'.1f')+'U', format(_G('moveStocks'),'.1f')+'U' \\\\\\n                             , format(allzhiyl,'.1f')+'%('+format(allzhiy,'.1f')+'U)'])    \\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l,'.1f')+'%('+format(allzhiy,'.1f')+'U)'])    \\n        LogStatus(  '`' +json.dumps(tab1) + \\\"`\\\\n\\\" +\\\"`\\\" + json.dumps(tab2) + \\\"`\\\\n\\\"  )\\n           \\n        Sleep(1000)\\n           \\n                \\n\\n# 获取Binance永续合约所有币对消息\\ndef getBinanceAllCoinData():\\n    global allCoinData\\n    tmp = dict()\\n    data = getUrlData(\\\"http://fapi.binance.com/fapi/v1/exchangeInfo\\\")\\n    for item in data['symbols']:\\n        # 需要USDT为衡量币对\\n        if \\\"USDT\\\" in item[\\\"symbol\\\"]:\\n            size = item['filters'][1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"symbol\\\"]:\\n            size = item['filters'][1]['stepSize']    # DOGE 1.00000000   BTC 0.00000100\\n            if float(size) == 1:\\n                sizein = 0\\n            elif len(size.split(\\\".\\\"))>1:\\n                sizein = str(size).split(\\\".\\\")[1].find('1')+1\\n            else:\\n                sizein = 0\\n            tmp[item[\\\"baseAsset\\\"]] = {\\n                'tick_size': int(item['pricePrecision']),  # 价格精度\\n                'old_increment': item['filters'][1]['stepSize'],#最小购买值\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "item['filters'][1]['stepSize'],#最小购买值\\n                'size_increment': sizein # 折算数量\\n            }\\n    allCoinData = tmp\\n    \\n    \\n# 通过url获取数据\\ndef getUrlData(url):\\n    response = urllib.request.urlopen(url)\\n    html = response.read().decode('utf-8')#decode('utf-8') 解决:the JSON object must be str, not 'bytes'\\n    try:\\n        tmp = json.loads(html)\\n        return json.loads(html)\\n    except Exception as e:\\n        Log('e:',e)      \\n\\n        \\n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\\ndef zhiyingzh",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\\ndef zhiyingzhisun(i, amount, directionStr, positionSide, zhiying, zhisun, cangType = 0):\\n    return bianSwap(i, amount, directionStr, positionSide, zhiying, zhisun)\\n \\n# 发送请求\\ndef AsynIo(i, paramList):\\n        if (len(paramList) == 3):\\n            arrRoutine = exchanges[i].Go(\\\"IO\\\", paramList[0], paramList[1], paramList[2])\\n        elif (len(paramList) == 4):\\n            arrRoutine = exchanges[i].Go(\\\"IO\\\", paramList[0], paramList[1], paramList[2], paramList[3])\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st[0], paramList[1], paramList[2], paramList[3])\\n        elif (len(paramList) == 5):\\n            arrRoutine = exchanges[i].Go(\\\"IO\\\", paramList[0], paramList[1], paramList[2], paramList[3], paramList[4])\\n        data, ok = arrRoutine.wait()\\n        Log(data)\\n        return data\\n\\n# 币安合约\\ndef bianSwap(i, amount, directionStr, positionSide, zhiying, zhisun):\\n    global orderID\\n    instrument_id = exchanges[i].GetCurrency().replace('_',\\\"\\\")\\n    # U本位或币本位，设置请求url\\n    if instrument_id.find('USDT') >= ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "币本位，设置请求url\\n    if instrument_id.find('USDT') >= 0 :\\n        url = \\\"/fapi/v1/order\\\"\\n    elif instrument_id.find('USD') >= 0 :\\n        url = '/dapi/v1/order'\\n    else:\\n        return False\\n    # 止损  side = SELL  BUY\\n    '''\\n    timestamp = Unix()*1000      \\n    params = \\\"symbol=\\\"+instrument_id+\\\"&side=\\\"+str(directionStr)+\\\"&positionSide=\\\"+positionSide+\\\"&type=STOP_MARKET&stopPrice=\\\"+str(zhisun)+\\\"&closePosition=true&timestamp=\\\"+str(timestamp)\\n    Log(params)\\n    zhisunData = exchanges[i].",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n    Log(params)\\n    zhisunData = exchanges[i].IO(\\\"api\\\", \\\"POST\\\", \\\"/fapi/v1/order\\\", params)\\n    Log(zhisunData)\\n    '''\\n    zhisunData = AsynIo(i, ['api', 'POST', url , '', json.dumps({\\n        \\\"symbol\\\": instrument_id,\\n        \\\"side\\\": directionStr,\\n        \\\"positionSide\\\":positionSide,\\n        \\\"type\\\": \\\"STOP_MARKET\\\",\\n        #\\\"quantity\\\": amount,\\n        \\\"closePosition\\\":\\\"true\\\",\\n        #\\\"price\\\": zhisun,\\n        \\\"stopPrice\\\": zhisun,\\n        \\\"timestamp\\\": str(int(round(ti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": zhisun,\\n        \\\"timestamp\\\": str(int(round(time.time() * 1000)))\\n    })])\\n\\n    if int(float(zhisunData['stopPrice'])) != int(float(zhisun)):\\n        Log('止损价格不一样',float(zhisunData['stopPrice']),int(float(zhisunData['stopPrice'])), float(zhisun), int(float(zhisun)) )\\n        return False\\n    orderID[i][0] = zhisunData['orderId']\\n    Log('设置'+exchanges[i].GetCurrency()+'止损，订单号：'+str(orderID[i][0]))\\n    # 止盈\\n    zhiyingData = AsynIo(i, ['api', 'POST', url , '', json.dumps({\\n        \\\"symbol\\\": i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ST', url , '', json.dumps({\\n        \\\"symbol\\\": instrument_id,\\n        \\\"side\\\": directionStr,\\n        \\\"positionSide\\\":positionSide,\\n        \\\"type\\\": \\\"TAKE_PROFIT_MARKET\\\",\\n        #\\\"quantity\\\": amount,\\n        \\\"closePosition\\\":\\\"true\\\",\\n        #\\\"price\\\": zhiying,\\n        \\\"stopPrice\\\": zhiying,\\n        \\\"timestamp\\\": str(int(round(time.time() * 1000)))\\n    })])\\n    if int(float(zhiyingData['stopPrice'])) != int(zhiying):\\n        Log('止盈价格不一样',float(zhiyingData['stopPrice']),int(float(zhi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "不一样',float(zhiyingData['stopPrice']),int(float(zhiyingData['stopPrice'])), float(zhiying), int(float(zhiying)) )\\n        return False\\n    orderID[i][1] = zhiyingData['orderId']\\n    Log('设置'+exchanges[i].GetCurrency()+'止盈，订单号：'+str(orderID[i][1]))\\n    _G(\\\"orderID\\\",orderID)\\n    return True\",\n    \"策略名称: WR-突破马丁\\n\\nimport json\\nimport time\\nimport talib\\nimport math\\nimport urllib.request\\n\\nChartCfg = {\\n    '__isStock': True,\\n    'title': {\\n        'text': 'WR'\\n   \\n    'yAxis': [{\\n        'title':",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ext': 'WR'\\n   \\n    'yAxis': [{\\n        'title': {'text': 'WR'},\\n        'style': {'color': '#4572A7'},\\n        'opposite': False #右边轴\\n    }],\\n    'series': [{\\n        'type': 'line',\\n        'id': 'wr',\\n        'name': 'wr',\\n        'data': []\\n    }]\\n}\\n\\ndef MyLog(str1,ktime,price=''):\\n    if (_G('str')!=str1 or _G('ktime')!=ktime) and  not (_G('str2')==str1 and ktime==_G('ktime2')) :\\n        _G('str2',_G('str'))\\n        _G('ktime2',_G('ktime'))\\n\\n        _G('str',str1)\\n        _G('ktime'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e'))\\n\\n        _G('str',str1)\\n        _G('ktime',ktime)\\n        Log(str1+str(price)) \\n\\n\\ndef moveStocks(_moveStocks):\\n    global todayProfit\\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance  只有币本位有交割且共用资金 2-U本位向现货   4-币本位向现货  返回tranId\\n        if exchanges[0].GetCurrency().find('USDT')>=0:\\n            movecurrency = 'USDT'\\n            mtype = 2\\n        else:#币本位\\n            movecurrency = 'BTC'\\n            mtype = 4\\n        timestamp = Unix()*1000       \\n        params = \\\"typ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "stamp = Unix()*1000       \\n        params = \\\"type=\\\"+str(mtype)+\\\"&asset=\\\"+movecurrency+\\\"&amount=\\\"+str(_moveStocks)+\\\"&timestamp=\\\"+str(timestamp)\\n        exchanges[0].SetBase('https://api.binance.com')\\n        moveid = exchange.IO(\\\"api\\\", \\\"POST\\\", \\\"/sapi/v1/futures/transfer\\\", params)   \\n        exchanges[0].SetBase('https://fapi.binance.com')\\n        if moveid is not None:\\n            Log('资金转出成功',moveid)\\n            _G('moveStocks',_G('moveStocks')+_moveStocks)\\n            todayProfit[\\\"in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tocks')+_moveStocks)\\n            todayProfit[\\\"initStocks\\\"] = todayProfit[\\\"initStocks\\\"] - _moveStocks\\n            _G('todayProfit',todayProfit)\\n            \\n        else:\\n            Log('资金转出失败')\\n    else:\\n        Log('暂不支持该交易所转移')\\n    \\ndef cancelOD(i):\\n    orders = _C(exchanges[i].GetOrders)\\n    for order in orders:\\n        exchanges[i].CancelOrder(order.Id)\\n        Sleep(100)\\n\\ndef coverAll(i):\\n    position = _C(exchanges[i].GetPosition)\\n    cancelOD(i)\\n    Sleep(200)\\n    for j in ra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    cancelOD(i)\\n    Sleep(200)\\n    for j in range(len(position)):\\n        pamount = position[j][\\\"Amount\\\"] #-position[0][\\\"FrozenAmount\\\"]\\n        if position[j][\\\"Type\\\"]==0:     #持多单\\n            Deal(-1 , pamount, \\\"closebuy\\\", exchanges[i].GetCurrency()+'手动市价清仓',i)\\n        elif position[j][\\\"Type\\\"]==1:     #持空单\\n            Deal(-1 , pamount, \\\"closesell\\\", exchanges[i].GetCurrency()+'手动市价清仓',i)\\n        \\ndef  getOpenPrice(position):\\n    if hasattr(position[0],'Info') and hasattr(position[0].",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):#huobi\\n        return position[0].Info.cost_open\\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'avg_cost'):#ok\\n        return position[0].Info.avg_cost\\n    elif hasattr(position[0],'Info') and hasattr(position[0].Info,'entryPrice'):#binance\\n        return position[0].Info.entryPrice\\n    else:\\n        return position[0][\\\"Price\\\"] \\n\\n    \\ndef UpdateAccout():\\n    accout = _C(exchanges[0].GetAccount)\\n    acc1 = a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "accout = _C(exchanges[0].GetAccount)\\n    acc1 = accout.FrozenBalance    #其它币的冻结余额  是否共用?\\n    acc2 = accout.Balance\\n    \\n    _G(\\\"ableAccount\\\", acc2)#当前可用U\\n    _G(\\\"allAccount\\\",acc1+acc2+GetMargin()) #没计算浮盈\\n    if acc2<1:\\n        Log(\\\"账户保证金余额不足\\\")\\n        Sleep(8000)\\n\\ndef GetMargin():\\n    allMargin = 0\\n    for i in range(len(exchanges)):\\n        allMargin += _G(\\\"margin\\\")[i]\\n    return _N(allMargin,2)\\n\\n\\ndef GetHighest(records,i,period):\\n    high = 0\\n    for i in range(i-period+1,i+1):\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    high = 0\\n    for i in range(i-period+1,i+1):\\n        if records[i].High > high:\\n            high = records[i].High\\n    return high\\n\\ndef GetLowest(records,i,period):\\n    low = 1000000\\n    for i in range(i-period+1,i+1):\\n        if records[i].Low < low:\\n            low = records[i].Low\\n    return low\\n    \\n        \\ndef SetType(type):\\n    if type==0:\\n        _G(\\\"contractType\\\",\\\"swap\\\")\\n    elif type==1:\\n        _G(\\\"contractType\\\",\\\"this_week\\\")\\n    elif type==2:\\n        _G(\\\"contractT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "week\\\")\\n    elif type==2:\\n        _G(\\\"contractType\\\",\\\"next_week\\\")\\n    elif type==3:\\n        _G(\\\"contractType\\\",\\\"quarter\\\")\\n    elif type==4:\\n        _G(\\\"contractType\\\",\\\"next_quarter\\\")\\n        \\ndef Deal(price, num, btype, beizhu='',i=0 ):\\n    Sleep(50)\\n    #if beizhu!='':\\n    #    Log(beizhu)\\n    exchanges[i].SetDirection(btype)\\n    if btype==\\\"closebuy\\\" or btype==\\\"sell\\\" :\\n        exchanges[i].Sell(price , num, beizhu)\\n        #Log('开空',price)\\n    else:\\n        exchanges[i].Buy(pr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "开空',price)\\n    else:\\n        exchanges[i].Buy(price , num, beizhu)\\n        #Log('开多',price)\\n\\n\\ndef myProfit():\\n    LogProfit( _G(\\\"allAccount\\\")-_G(\\\"initStocks\\\") )\\n\\n\\ndef initData():\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|No need to change|reused\\\")\\n    global allCoinData\\n    Log(\\\"正在初始化...\\\")\\n\\n    if exchanges[0].GetName().find('Binance')>=0:#Futures_Binance\\n        getBinanceAllCoinData()\\n        Slee",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nce\\n        getBinanceAllCoinData()\\n        Sleep(3000)\\n        Log(\\\"获取交易所信息结束\\\")\\n    else:\\n        Log('暂不支持该交易所')\\n        return\\n    \\n    if _G(\\\"moveStocks\\\") is None:\\n        _G(\\\"moveStocks\\\",0)\\n    if _G(\\\"moveInStocks\\\") is None:\\n        _G(\\\"moveInStocks\\\",0)\\n        \\n    for i in range(len(exchanges)):#初始化 交易所\\n        symbol = exchanges[i].GetCurrency().split('_')[0]\\n        exchanges[i].SetContractType(\\\"swap\\\")\\n        exchanges[i].SetPrecision(allCoinData[symbol]['tick_size'], a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "].SetPrecision(allCoinData[symbol]['tick_size'], allCoinData[symbol]['size_increment'])\\n        exchanges[i].SetMarginLevel(marginLevel)\\n        timestamp = Unix()*1000      \\n        exchanges[i].IO(\\\"api\\\", \\\"POST\\\", \\\"/fapi/v1/positionSide/dual\\\", \\\"dualSidePosition=true&timestamp=\\\"+str(timestamp))\\n        \\n    \\n        \\ndef main():\\n    global allCoinData, orderID\\n    if _G(\\\"contractType\\\") is None:\\n        _G(\\\"contractType\\\",\\\"swap\\\")\\n    global ChartCfg\\n    preTime = 0\\n    chart = Chart(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "obal ChartCfg\\n    preTime = 0\\n    chart = Chart(ChartCfg)\\n    chart.reset()\\n    \\n    margin = [0 for i in range(len(exchanges)) ] \\n    _G(\\\"margin\\\",margin)\\n    preTime = 0\\n    bucTimes = [0 for i in range(len(exchanges)) ] \\n    initData()\\n    #LogProfitReset(1)\\n    #暂未考虑仓位不足\\n    while(true):\\n        #Log('测试循环')\\n        cmd = GetCommand()\\n        if cmd:\\n            if cmd == \\\"清仓停机\\\":\\n                for i in range(len(exchanges)):\\n                    Sleep(100)\\n                    cove",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "              Sleep(100)\\n                    coverAll(i)\\n                Sleep(1000)\\n                return\\n            if cmd.find('cover-')>=0:\\n                arr = cmd.split(\\\"-\\\")\\n                coverAll(int(arr[1]))\\n                Sleep(2000)\\n            elif cmd == 'cancelOD':\\n                cancelOD()\\n                Sleep(1000)\\n        \\n        tab1 = {\\n            \\\"type\\\": \\\"table\\\", \\n            \\\"title\\\": \\\"账户信息\\\", \\n            \\\"cols\\\": [\\\"初始资金\\\", \\\"当前资金\\\" , \\\"可用资金\\\", \\\"已移出资金",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\\"cols\\\": [\\\"初始资金\\\", \\\"当前资金\\\" , \\\"可用资金\\\", \\\"已移出资金\\\", \\\"总盈利率\\\"], \\n            \\\"rows\\\": []\\n        }\\n        tab2 = {\\n            \\\"type\\\": \\\"table\\\", \\n            \\\"title\\\": \\\"持仓状态\\\", \\n            \\\"cols\\\": [\\\"币种\\\", \\\"最新价\\\",\\\"持仓数\\\", \\\"持仓均价\\\",  \\\"浮动盈亏\\\",\\\"操作\\\"], \\n            \\\"rows\\\": []\\n        }\\n        \\n        \\n        UpdateAccout() \\n        if _G(\\\"initStocks\\\") is None or _G(\\\"initStocks\\\")<10 :\\n            _G(\\\"initStocks\\\", _G(\\\"allAccount\\\"))\\n        if autoMoveStocks>100 and _G('abl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "unt\\\"))\\n        if autoMoveStocks>100 and _G('ableAccount')>autoMoveStocks :\\n                Log('自动移出资金：100U#32CD32')\\n                moveStocks(100)\\n                continue\\n\\n        for i in range(len(exchanges)):\\n            Sleep(100)\\n            records = _C(exchanges[i].GetRecords,60 * period)\\n            #wr_high = TA.Highest(records, WRperiod, 'High')\\n            #wr_low = TA.Lowest(records, WRperiod, 'Low')\\n            #wr = (records[-1].Close-wr_high)/(wr_high-wr_low)*100\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".Close-wr_high)/(wr_high-wr_low)*100\\n            position = _C(exchanges[i].GetPosition)\\n            margin = _G(\\\"margin\\\")\\n            if len(position)>0:\\n                oprice = float(getOpenPrice(position))\\n                margin[i] = position[0][\\\"Margin\\\"]\\n                floatProfit =  float(position[0][\\\"Profit\\\"])\\n                pamount = float(position[0]['Amount'])\\n                #止损\\n                if -1*floatProfit > oprice*pamount/marginLevel*zhis/100:\\n                    if posit",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "arginLevel*zhis/100:\\n                    if position[0]['Type']==0:\\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止损'+format(records[-1].Close,'.4f'),i)\\n                    else:\\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止损'+format(records[-1].Close,'.4f'),i)\\n                    Sleep(500)\\n                    myProfit()\\n                    bucTimes[i] += 1\\n                    if bucTimes[i]>maxBuc:\\n                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if bucTimes[i]>maxBuc:\\n                        bucTimes[i] = maxBuc\\n                #止盈\\n                if floatProfit > oprice*pamount/marginLevel*zhiy/100:\\n                    if position[0]['Type']==0:\\n                        Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单止盈'+format(records[-1].Close,'.4f'),i)\\n                    else:\\n                        Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单止盈'+format(records[-1].Close,'.4f'),i)\\n                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(records[-1].Close,'.4f'),i)\\n                    Sleep(500)\\n                    myProfit()\\n                    bucTimes[i] = 0\\n            else:\\n                oprice = 0\\n                margin[i] = 0\\n                floatProfit = ''\\n\\n            _G(\\\"margin\\\", margin)\\n            \\n            \\n            for k in range(50, len(records)):\\n\\n                wr_high1 = GetHighest(records,k, WRperiod)\\n                wr_low1 = GetLowest(records,k, WRperiod)\\n                wr1 = (records[k].Cl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k, WRperiod)\\n                wr1 = (records[k].Close-wr_high1)/(wr_high1-wr_low1)*100\\n                if k==len(records)-1:\\n                    if wr1>-5:#开空\\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==0):#平多\\n                            if len(position)>0:\\n                                Deal(-1, pamount, 'closebuy',exchanges[i].GetCurrency()+' 多单清仓'+format(records[-1].Close,'.4f'),i)\\n                                Sleep(500)\\n                            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          Sleep(500)\\n                                myProfit()\\n                                if floatProfit<0:\\n                                    bucTimes[i] += 1\\n                                    if bucTimes[i]>maxBuc:\\n                                        bucTimes[i] = maxBuc\\n                                else:\\n                                    bucTimes[i] = 0\\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\\n                            famount = _N( baseAm",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\\n                            if famount==0:\\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\\n                                continue\\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\\n                            Deal(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ords[-1].Close)\\n                            Deal(-1, pamount, 'sell',exchanges[i].GetCurrency()+' 空单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)\\n                    elif wr1<-95:#开多\\n                        if len(position)==0 or (len(position)>0 and position[0]['Type']==1):#平空\\n                            if len(position)>0:\\n                                Deal(-1, pamount, 'closesell',exchanges[i].GetCurrency()+' 空单清仓'+format(records[-1].Close,'.4f'),i)\\n                                Sleep(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",'.4f'),i)\\n                                Sleep(500)\\n                                myProfit()\\n                                if floatProfit<0:\\n                                    bucTimes[i] += 1\\n                                    if bucTimes[i]>maxBuc:\\n                                        bucTimes[i] = maxBuc\\n                                else:\\n                                    bucTimes[i] = 0\\n                            symbol = exchanges[i].GetCurrency().split('_')[0]\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ges[i].GetCurrency().split('_')[0]\\n                            famount = _N( baseAmount/records[-1].Close, allCoinData[symbol]['size_increment'] )\\n                            if famount==0:\\n                                Log(exchanges[i].GetCurrency(),'当前开仓U不足购买，请更换币种或加大开仓U')\\n                                continue\\n                            pamount = (baseAmount*(2**bucTimes[i]))/records[-1].Close\\n                            Log(exchanges[i].GetCurrency(),baseAmount,bucTimes[i],records[-1].Close)\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rency(),baseAmount,bucTimes[i],records[-1].Close)\\n                            Deal(-1, pamount, 'buy',exchanges[i].GetCurrency()+' 多单开仓'+format(records[-1].Close,'.4f')+' WR:'+str(wr1),i)        \\n                    #Log(wr1)\\n                \\n                #画图\\n                if i==0 and records[k]['Time'] == preTime:\\n                    chart.add(0, [records[k]['Time'], wr1], -1)\\n                elif i==0 and records[k]['Time'] > preTime:\\n                    #Log('insert',records[k]['Time'],wr_hi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            #Log('insert',records[k]['Time'],wr_high1,wr_low1,records[k].Close,wr1)\\n                    chart.add(0, [records[k]['Time'], wr1])\\n                    preTime = records[k]['Time']\\n            \\n\\n            #myProfit()\\n\\n            if len(position)>0 and position[0]['Type']==0:\\n                pamount = '多：'+str(position[0]['Amount'])+str('#32CD32')\\n            elif len(position)>0 and position[0]['Type']==1:\\n                pamount = '空：'+str(position[0]['Amount'])+str('#BC1717')\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "空：'+str(position[0]['Amount'])+str('#BC1717')\\n            else:\\n                pamount = ''\\n            if len(position)>0:\\n                floatProfit = format( position[0][\\\"Profit\\\"],'.2f')\\n            symbol = exchanges[i].GetCurrency().split('_')[0]\\n            tab2[\\\"rows\\\"].append([ exchanges[i].GetCurrency() , records[-1].Close \\\\\\n                             , pamount, format(oprice,'.'+str(allCoinData[symbol]['tick_size'])+'f'), floatProfit \\\\\\n                             , { \\\"type\\\": \\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\\\\\n                             , { \\\"type\\\": \\\"button\\\",  \\\"cmd\\\": 'cover-'+str(i), \\\"name\\\": \\\"清仓\\\" } ])\\n\\n        #总盈利\\n        allzhiy = float(_G('allAccount'))-float(_G('moveInStocks'))+float(_G('moveStocks'))-float(_G('initStocks'))\\n        if _G('initStocks')==0:\\n            allzhiyl=0\\n        else:\\n            allzhiyl = (float(_G('moveStocks'))+float(_G('allAccount'))-float(_G('moveInStocks'))-float(_G('initStocks')))/float(_G('initStocks'))*100\\n         \\n        tab1[\\\"rows\\\"].append([for",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "100\\n         \\n        tab1[\\\"rows\\\"].append([format(_G('initStocks'),'.1f')+'U', format(_G('allAccount'),'.1f')+'U', format(_G('ableAccount'),'.1f')+'U', format(_G('moveStocks'),'.1f')+'U' \\\\\\n                             , format(allzhiyl,'.1f')+'%('+format(allzhiy,'.1f')+'U)'])    \\n        LogStatus(  '`' +json.dumps(tab1) + \\\"`\\\\n\\\" +\\\"`\\\" + json.dumps(tab2) + \\\"`\\\\n\\\"  )\\n           \\n        Sleep(1000)\"\n \n\n    \"strategy_46\",\n    \"python\\n#!Python3\\n\\n\\\"\\\"\\\"\\n《策略代写》 与 （此程序帮助），致信QQ：35787501\\n\\nZT 交易所",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\\"\\\"\\\"\\n《策略代写》 与 （此程序帮助），致信QQ：35787501\\n\\nZT 交易所接口，可用于对接 平台暂不支持的冷门交易所 ZT\\n\\\"\\\"\\\"\\n\\nfrom requests import get, post\\nfrom hashlib import md5\\nfrom urllib.parse import urlencode\\n\\n\\nclass ZT:\\n    def __init__(self, api_key, secret_key):\\n        self.api_key = api_key\\n        self.secret_key = secret_key\\n        self.host = \\\"https://www.ztb.im\\\"\\n        self.headers = {\\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\\n                          'AppleWebKit/537.36 (KHTML, like G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                'AppleWebKit/537.36 (KHTML, like Gecko) '\\n                          'Chrome/92.0.4515.159 Safari/537.36',\\n            \\\"content-type\\\": \\\"application/x-www-form-urlencoded\\\",\\n            'X-SITE-ID': '1',\\n        }\\n\\n    def http_post(self, path, params):\\n        return post(f\\\"{self.host}{path}\\\", data=urlencode(params), headers=self.headers, timeout=5)\\n\\n    def get_sign(self, params):\\n        return md5((urlencode(params) + f\\\"&secret_key={self.secret_key}\\\").encode()).hexdigest()",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ret_key={self.secret_key}\\\").encode()).hexdigest().upper()\\n\\n    def get_ticker(self, symbol):\\n        return float(\\n            get(\\n                f\\\"{self.host}/api/v1/trades?symbol={symbol}&size=1\\\", headers=self.headers, timeout=5\\n            ).json()[0][\\\"price\\\"]\\n        )\\n\\n    def send_order(self, symbol, side, price, amount):\\n        path = \\\"/api/v1/private/trade/limit\\\"\\n        params = {\\n            \\\"amount\\\": amount,\\n            \\\"api_key\\\": self.api_key,\\n            \\\"market\\\": ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "api_key\\\": self.api_key,\\n            \\\"market\\\": symbol,\\n            \\\"price\\\": price,\\n        }\\n        all_side = {\\\"close_sell\\\": 1, \\\"open_buy\\\": 2}\\n        params[\\\"side\\\"] = all_side[side]\\n        params[\\\"sign\\\"] = self.get_sign(params)\\n        return str(self.http_post(path, params).json().get(\\\"result\\\", {'id': \\\"0\\\"})[\\\"id\\\"])\\n\\n    def select_order(self, symbol, oid):\\n        path = \\\"/api/v1/private/order/pending/detail\\\"\\n        params = {\\n            \\\"api_key\\\": self.api_key,\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = {\\n            \\\"api_key\\\": self.api_key,\\n            \\\"market\\\": symbol,\\n            \\\"order_id\\\": oid,\\n        }\\n        params[\\\"sign\\\"] = self.get_sign(params)\\n        return not self.http_post(path, params).json()['result']\\n\\n    def cancel_order(self, symbol, oid):\\n        path = \\\"/api/v1/private/trade/cancel\\\"\\n        params = {\\n            \\\"api_key\\\": self.api_key,\\n            \\\"market\\\": symbol,\\n            \\\"order_id\\\": oid,\\n        }\\n        params[\\\"sign\\\"] = self.get_sign(para",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  }\\n        params[\\\"sign\\\"] = self.get_sign(params)\\n        return self.http_post(path, params).json()\",\n    \"策略名称: ZT-交易所接口可用于对接平台暂不支持的冷门交易所-ZT\\n\\n未找到描述\"\n \n\n    \"strategy_47\",\n    \"python\\n# -*- coding = utf-8 -*-\\n# @Time:2023/2/20 11:04\\n# @Author: 作手君\\n# @File: binance.py\\n# @Software: PyCharm\\n\\nimport json\\nimport time\\nimport hmac\\nfrom hashlib import sha256\\nimport requests\\nfrom logger import logger\\n\\n\\ndef cleanNoneValue(d) -> dict:\\n    out = {}\\n    for k in d.keys():\\n        if d[k] is not",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "{}\\n    for k in d.keys():\\n        if d[k] is not None:\\n            out[k] = d[k]\\n    return out\\n\\n\\ndef get_timestamp() -> int:\\n    return int(time.time()) * 1000\\n    # cet_tz = pytz.timezone('Etc/GMT+0')\\n    # t = datetime.now(cet_tz)\\n    # return int(time.mktime(t.timetuple())) * 1000\\n    # return (int(time.time()) - (8*60*60)) * 1000\\n    # utc_t = datetime.datetime.utcnow().timestamp()\\n    # return int(utc_t * 1000)\\n\\n\\nclass Binance(object):\\n    def __init__(self, api_key, secret_key):\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    def __init__(self, api_key, secret_key):\\n        self.api_key = api_key\\n        self.secret_key = secret_key\\n        self.host = 'https://fapi.binance.com'\\n        self.timestamp = ''\\n        self.method = ''\\n        self.request_path = ''\\n\\n    # 交易\\n    def trade_order(self, symbol, pos_side, trade_side, sz, client_id, ord_type=\\\"market\\\", px=None):\\n        self.request_path = '/fapi/v1/order'\\n        self.method = 'POST'\\n        params = {\\n            'symbol': symbol.upper() + 'USDT',\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            'symbol': symbol.upper() + 'USDT',\\n            'side': trade_side.upper(),  # 买卖方向 SELL, BUY\\n            'positionSide': pos_side,  # long short\\n            'type': ord_type.upper(),\\n            'quantity': sz,  # 数量\\n            'newClientOrderId': 'x-YZChr3zS' + str(client_id),  # 客户订单号\\n            # 'timeInForce': 'GTC',\\n        }\\n        if ord_type == 'limit':\\n            params['timeInForce'] = 'GTC'\\n            params['price'] = str(px)\\n        url = self.generate_url(params)\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " str(px)\\n        url = self.generate_url(params)\\n        # 0 成功 1暂停几秒 2忽略此次交易 3 用户停止策略\\n        try:\\n            response = self.send(url)\\n            if 'code' in response.keys():\\n                if int(response['code']) == -2018 or int(response['code']) == -2019:\\n                    # 余额不足 直接清仓\\n                    return {\\\"code\\\": 3, \\\"msg\\\": response.get('msg', ''), \\\"data\\\": {}}\\n                return {\\\"code\\\": 1, \\\"msg\\\": response.get('msg', ''), \\\"data\\\": {}}\\n                pass\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'), \\\"data\\\": {}}\\n                pass\\n            else:\\n                return {\\n                    'code': 0,\\n                    'msg': '',\\n                    'data': {\\n                        'clOrdId': response['clientOrderId'],\\n                        'ordId': response['orderId'],\\n                    }\\n                }\\n        except Exception as e:\\n            logger.error('binance error')\\n            logger.error(e)\\n            return {\\\"code\\\": 2, \\\"msg\\\": str(e), \\\"data\\\": {}}\\n\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n {\\\"code\\\": 2, \\\"msg\\\": str(e), \\\"data\\\": {}}\\n\\n    # 获取挂单列表\\n    def get_open_order(self):\\n        self.request_path = '/fapi/v1/openOrders'\\n        self.method = 'GET'\\n        url = self.generate_url({})\\n        response = self.send(url)\\n        return response\\n\\n    def get_kline(self, symbol, limit, interval):\\n        self.request_path = '/fapi/v1/klines'\\n        self.method = 'GET'\\n        params = {\\n            'symbol': symbol.upper() + 'USDT',\\n            'interval': interval,\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "SDT',\\n            'interval': interval,\\n            'limit': limit,\\n        }\\n        url = self.generate_url(params)\\n        response = self.send(url)\\n        return response\\n\\n    # 获取单币种挂单列表\\n    def get_symbol_open_order(self, symbol):\\n        self.request_path = '/fapi/v1/openOrders'\\n        self.method = 'GET'\\n        url = self.generate_url({\\n            'symbol': symbol.upper() + 'USDT'\\n        })\\n        response = self.send(url)\\n        return response\\n\\n    # 获取挂单列表\\n    def get_po",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   return response\\n\\n    # 获取挂单列表\\n    def get_positions(self, symbol):\\n\\n        self.request_path = '/fapi/v2/account'\\n        self.method = 'GET'\\n        url = self.generate_url({})\\n        response = self.send(url)\\n        positions = response['positions']\\n        return positions\\n\\n    # 撤单\\n    def cancel_order(self, symbol):\\n        self.request_path = '/fapi/v1/allOpenOrders'\\n        self.method = 'DELETE'\\n        params = {\\n            'symbol': symbol.upper() + 'USDT',\\n        }\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "symbol': symbol.upper() + 'USDT',\\n        }\\n        url = self.generate_url(params)\\n        response = self.send(url)\\n        if 'code' in response.keys() and int(response.get('code', 0)) != 200:\\n            raise Exception(response.get('msg'))\\n        return response\\n\\n    def generate_url(self, params, use_timestamp=True):\\n        if use_timestamp:\\n            params['timestamp'] = get_timestamp()\\n        return '{}{}?{}'.format(self.host, self.request_path, self.generate_sign(params))\\n\\n    de",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "equest_path, self.generate_sign(params))\\n\\n    def generate_sign(self, params):\\n        query_string = ''\\n        for k in params.keys():\\n            query_string = query_string + '{}={}&'.format(k, params.get(k))\\n        query_string = query_string[:-1]\\n        if self.secret_key:\\n            signature = hmac.new(self.secret_key.encode(\\\"utf-8\\\"),\\n                                 query_string.encode(\\\"utf-8\\\"), digestmod=sha256).hexdigest()\\n            query_string = query_string + '&signature=' +",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     query_string = query_string + '&signature=' + signature\\n        return query_string\\n\\n    def send(self, url, params=None):\\n        session = requests.Session()\\n        session.headers.update(\\n          \\n                \\\"Content-Type\\\": \\\"application/json;charset=utf-8\\\",\\n                \\\"X-MBX-APIKEY\\\": self.api_key,\\n            }\\n        )\\n        if self.method == 'GET':\\n            response = session.get(url=url, params=params)\\n        elif self.method == 'DELETE':\\n            respon",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " elif self.method == 'DELETE':\\n            response = session.delete(url=url, params=params)\\n        else:\\n            response = session.post(url=url, params=params)\\n        # logger.info('币安请求信息')\\n        # logger.info(params)\\n        # logger.info(response.text)\\n        return json.loads(response.text)\",\n    \"策略名称: binance部分交易封装示例\\n\\n# @Time:2023/2/20 11:04\"\n \n\n    \"strategy_48\",\n    \"python\\nimport numpy as np\\nimport talib\\nimport time\\nif period == 1:\\n\\tper = PERIOD_M1\\nif period == 2:\\n\\tper ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == 1:\\n\\tper = PERIOD_M1\\nif period == 2:\\n\\tper = PERIOD_M3\\nif period == 3:\\n\\tper = PERIOD_M5\\nif period == 4:\\n\\tper = PERIOD_M15\\nif period == 5:\\n\\tper = PERIOD_M30\\nif period == 6:\\n\\tper = PERIOD_H1\\n\\t\\nstatus=0 #多：1  空：2\\n\\nposition = 0\\n\\ndef ontick():\\n\\tglobal position\\n\\trecords = exchange.GetRecords(per)\\n\\t#------------指标计算---------\\n\\t#rsi = TA.RSI(records,14)\\n\\t#if rsi[-1] > 65 or rsi[-1] < 35:\\n\\t#    return\\n\\tbb = talib.BBANDS(records.Close,timeperiod=bo, nbdevup=2, nbdevdn=2, matype=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Close,timeperiod=bo, nbdevup=2, nbdevdn=2, matype=0) #计算BB\\n\\trsi = talib.RSI(records.Close,timeperiod=12)\\n\\tcmi = talib.CMO(records.Close,timeperiod=12)\\n\\tprint(cmi[-1])\\n\\tmove = talib.SMA(records.Close,ma2)#收盘价ma\\n\\tmabt = talib.SMA(bb[0],ma)#上轨ma\\n\\tmabd = talib.SMA(bb[2],ma)#下跪ma\\n\\taccount = exchange.GetAccount()\\n\\n\\t\\n\\n\\tif bb[0][-1] > mabt[-1] and bb[0][-2] < mabt[-2] and bb[2][-1] < bb[2][-2] and bb[1][-1] > bb[1][-2] and records.Close[-1] > move[-1] and rsi[-1]>60:\\n\\t\\tposition += 1\\n\\t\\texch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e[-1] and rsi[-1]>60:\\n\\t\\tposition += 1\\n\\t\\texchange.Buy(-1,account.Balance*0.1)\\n\\t\\t#log('向上突破开多 '+ str(close[-1]))\\n\\t\\n\\tif bb[2][-1] < mabd[-1] and bb[2][-2] > mabd[-2] and bb[0][-1] > bb[0][-2] and bb[1][-1] < bb[1][-2] and records.Close[-1] < move[-1] and rsi[-1]<40:\\n\\t\\tposition -= 1\\n\\t\\texchange.Sell(-1,account.Stocks*0.1)\\n\\t\\t#log('向下突破开空 '+ str(close[-1]))\\n\\t\\n\\tif bb[0][-1]-bb[2][-1] < bb[0][-2]-bb[2][-2]:\\n\\t\\tif bb[0][-1] < mabt[-1] and bb[0][-2] > mabt[-2] and position> 0:\\n\\t\\t\\tpositi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "b[0][-2] > mabt[-2] and position> 0:\\n\\t\\t\\tposition -= 1\\n\\t\\t\\texchange.Sell(-1,account.Stocks*0.1)\\n\\t\\t\\t#log('多单平仓 '+ str(close[-1]))\\n\\n\\t\\tif bb[2][-1] > mabd[-1] and bb[2][-2] < mabd[-2] and position < 0:\\n\\t\\t\\tposition += 1\\n\\t\\t\\texchange.Buy(-1,account.Balance*0.1)\\n\\t\\t\\t#log('空单平仓 '+ str(close[-1]))\\n\\ndef main():\\n\\twhile True:\\n\\t\\tontick()\\n\\t\\tSleep(30000)\",\n    \"策略名称: bollmaboll\\n\\nbb = talib.BBANDS(records.Close,timeperiod=bo, nbdevup=2, nbdevdn=2, matype=0) #计算BB\\n\\trsi = talib.RSI(reco",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nbdevdn=2, matype=0) #计算BB\\n\\trsi = talib.RSI(records.Close,timeperiod=12)\\n\\tcmi = talib.CMO(records.Close,timeperiod=12)\\n\\tprint(cmi[-1])\\n\\tmove = talib.SMA(records.Close,ma2)#收盘价ma\\n\\tmabt = talib.SMA(bb[0],ma)#上轨ma\\n\\tmabd = talib.SMA(bb[2],ma)#下跪ma\\n\\taccount = exchange.GetAccount()\\n\\n\\t\\n\\n\\tif bb[0][-1] > mabt[-1] and bb[0][-2] < mabt[-2] and bb[2][-1] < bb[2][-2] and bb[1][-1] > bb[1][-2] and records.Close[-1] > move[-1] and rsi[-1]>60:\\n\\t\\tposition += 1\\n\\t\\texchange.Buy(-1,account.Balance*0.1)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ion += 1\\n\\t\\texchange.Buy(-1,account.Balance*0.1)\\n\\t\\t#log('向上突破开多 '+ str(close[-1]))\\n\\t\\n\\tif bb[2][-1] < mabd[-1] and bb[2][-2] > mabd[-2] and bb[0][-1] > bb[0][-2] and bb[1][-1] < bb[1][-2] and records.Close[-1] < move[-1] and rsi[-1]<40:\\n\\t\\tposition -= 1\\n\\t\\texchange.Sell(-1,account.Stocks*0.1)\\n\\t\\t#log('向下突破开空 '+ str(close[-1]))\\n\\t\\n\\tif bb[0][-1]-bb[2][-1] < bb[0][-2]-bb[2][-2]:\\n\\t\\tif bb[0][-1] < mabt[-1] and bb[0][-2] > mabt[-2] and position> 0:\\n\\t\\t\\tposition -= 1\\n\\t\\t\\texchange.Sell(-1,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "> 0:\\n\\t\\t\\tposition -= 1\\n\\t\\t\\texchange.Sell(-1,account.Stocks*0.1)\\n\\t\\t\\t#log('多单平仓 '+ str(close[-1]))\\n\\n\\t\\tif bb[2][-1] > mabd[-1] and bb[2][-2] < mabd[-2] and position < 0:\\n\\t\\t\\tposition += 1\\n\\t\\t\\texchange.Buy(-1,account.Balance*0.1)\\n\\t\\t\\t#log('空单平仓 '+ str(close[-1]))\\n\\ndef main():\\n\\twhile True:\\n\\t\\tontick()\\n\\t\\tSleep(30000)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/146391\\n\\n> Last Modified\\n\\n2020-04-23 16:46:09\"\n \n\n    \"strategy_49\",\n    \"python\\nlast_tick = []\\nline = []\\ngrid_b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "9\",\n    \"python\\nlast_tick = []\\nline = []\\ngrid_buy_list = []\\n\\ndef net(now_price):\\n    global line\\n    print(now_price)\\n    line = [now_price*(1+0.003*i) for i in range(-1000,1000)]\\n    Log(line)\\n    \\ndef ontick():\\n    global last_tick\\n    global  line\\n    global grid_buy_list\\n    account = exchange.GetAccount()\\n    ticker = exchange.GetTicker()\\n    last_tick.append(ticker['Last'])\\n    if len(last_tick) == 1:return\\n    elif len(last_tick) == 100:del last_tick[0]\\n    for i in range(len(line",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 100:del last_tick[0]\\n    for i in range(len(line)):\\n        if last_tick[-1] > line[i] and last_tick[-2] < line[i] and len(grid_buy_list)!= 0 and i > min(grid_buy_list)  and account['Stocks'] >= 0.001:\\n            exchange.Sell(last_tick[-1],0.01)\\n            del grid_buy_list[grid_buy_list.index(min(grid_buy_list))]\\n            Log(exchange.GetAccount())\\n        elif last_tick[-1] < line[i] and last_tick[-2] > line[i] and i not in grid_buy_list:\\n            exchange.Buy(last_tick[-1],0.01)\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         exchange.Buy(last_tick[-1],0.01)\\n            grid_buy_list.append(i)\\n            Log(exchange.GetAccount())\\n\\ndef main():\\n    net(exchange.GetTicker()['Last'])\\n    Log(exchange.GetAccount())\\n    while(True):\\n        ontick()\\n        Sleep(1000)\",\n    \"策略名称: grid\\n\\n未找到描述\"\n \n\n    \"strategy_50\",\n    \"python\\nimport json\\n\\ndef main():\\n    tab = {\\n        \\\"type\\\" : \\\"table\\\", \\n        \\\"title\\\" : \\\"demo\\\", \\n        \\\"cols\\\" : [\\\"a\\\", \\\"b\\\", \\\"c\\\"], \\n        \\\"rows\\\" : [[\\\"1\\\", \\\"2\\\", {\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", \\\"c\\\"], \\n        \\\"rows\\\" : [[\\\"1\\\", \\\"2\\\", {\\\"type\\\" : \\\"button\\\", \\\"cmd\\\" : \\\"coverAll\\\", \\\"name\\\" : \\\"平仓\\\"}]]    # 在状态栏表格 第一行，第三列上配置一个按钮 名字是平仓\\n    }\\n    \\n    LogStatus(\\\"`\\\" + json.dumps(tab) + \\\"`\\\")\",\n    \"策略名称: python-状态栏表格-显示按钮范例\\n\\n}\\n    \\n    LogStatus(\\\"`\\\" + json.dumps(tab) + \\\"`\\\")\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/147155\\n\\n> Last Modified\\n\\n2019-05-10 11:35:13\"\n \n\n    \"strategy_51\",\n    \"python\\n'''backtest\\nstart: 2021-06-26 00:00:00\\nend: 2022-01-23 00:00:00\\nperiod:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "-06-26 00:00:00\\nend: 2022-01-23 00:00:00\\nperiod: 1d\\nbasePeriod: 1h\\nexchanges: [{\\\"eid\\\":\\\"Futures_Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\ndef main():\\n    exchange.SetMarginLevel(7)\\n    exchange.SetContractType(\\\"swap\\\")\\n    exchange.SetDirection(\\\"buy\\\")\\n    ticker = exchange.GetTicker()\\n    Log(ticker)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 100, 0.001)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 500, 0.001)\\n    exchange.Buy(ticker[\\\"Last\\\"] -1000, 0.002)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 1500, 0.00",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "2)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 1500, 0.003)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 2000, 0.005)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 2500, 0.008)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 3000, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 3500, 0.021)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 4000, 0.034)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 4500, 0.055)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 5000, 0.089)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 5500, 0.144)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 6000, 0.233)\\n    exch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.Buy(ticker[\\\"Last\\\"] - 6000, 0.233)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 6500, 0.377)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 7000, 0.610)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 7500, 0.987)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 8000, 1.597)\\n    exchange.Buy(ticker[\\\"Last\\\"] - 8500, 2.584)\\n    \\n    exchange.SetContractType(\\\"swap\\\")\\n    exchange.SetDirection(\\\"sell\\\")\\n    ticker = exchange.GetTicker()\\n    Log(ticker)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 100, 0.001)\\n    exchange.Sell(ticker[\\\"Last\\\"] ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "+ 100, 0.001)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 500, 0.001)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 1000, 0.002)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 1500, 0.003)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 2000, 0.005)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 2500, 0.008)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 3000, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 3500, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 4000, 0.034)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 4500, 0.055)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 50",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "0, 0.055)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 5000, 0.089)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 5500, 0.144)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 6000, 0.233)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 6500, 0.377)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 7000, 0.610)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 7500, 0.987)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 8000, 1.597)\\n    exchange.Sell(ticker[\\\"Last\\\"] + 8500, 2.584)\\n    \\n    Log(\\\"orders\\\", exchange.GetOrders())\\n    Sleep(1000)\",\n    \"策略名称: python\\n\\n未找到描述",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s())\\n    Sleep(1000)\",\n    \"策略名称: python\\n\\n未找到描述\"\n \n\n    \"strategy_52\",\n    \"python\\n'''backtest\\nstart: 2021-11-04 00:00:00\\nend: 2022-02-01 00:00:00\\nperiod: 1h\\nbasePeriod: 15m\\n'''\\n\\nimport time\\nimport asyncio\\nfrom aiohttp import ClientSession\\nimport time\\nimport datetime\\nglobal tasks\\ntasks = []\\n\\nasync def fetch_exchangeinfo():\\n    exchangeinfo=\\\"https://fapi.binance.com//fapi/v1/exchangeInfo\\\"\\n    async with ClientSession() as session:\\n        async with session.get(exchangeinfo) as respon",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    async with session.get(exchangeinfo) as response:\\n            result=await response.read()\\n            Log(result.text, time.time())\\n            return result\\n            \\n\\nasync def fetch_depth(symbol,limit):\\n    symbol_depth=\\\"https://fapi.binance.com//fapi/v1/depth?symbol=\\\"+str(symbol)+\\\"&limit=\\\"+str(limit)\\n    async with ClientSession() as session:\\n        async with session.get(symbol_depth) as response:\\n            result=await response.read()\\n            Log(result.text, time.time())",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".read()\\n            Log(result.text, time.time())\\n            return result\\n            \\n\\nasync def fetch_klines(symbol,interval,limit):\\n    symbol_kline=\\\"https://fapi.binance.com//fapi/v1/klines?symbol=\\\"+str(symbol)+\\\"&interval=\\\"+str(interval)+\\\"&limit=\\\"+str(limit)\\n    async with ClientSession() as session:\\n        async with session.get(symbol_kline) as response:\\n            result = await response.read()\\n            Log(symbol,result, time.time())\\n            return result\\n           \\nas",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ime())\\n            return result\\n           \\nasync def fetch_all_ticker():\\n    all_symbol_ticker = \\\"https://fapi.binance.com/fapi/v1/ticker/price\\\"\\n    async with ClientSession() as session:\\n        async with session.get(all_symbol_ticker) as response:\\n            result = await response.read()\\n            Log(result.text, time.time())\\n            return result\\n            \\n\\ndef main():\\n    while True:\\n        Log(datetime.datetime.now(),'开始')\\n        symbol_list=['BTCUSDT','ETHUSDT','BNBUS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n        symbol_list=['BTCUSDT','ETHUSDT','BNBUSDT','ETCUSDT','EOSUSDT','SANDUSDT','XRPUSDT','ADAUSDT','GALAUSDT','IOTXUSDT','BNBUSDT','MATICUSDT']\\n        for i in range(12):\\n            task = asyncio.ensure_future(fetch_klines(symbol_list[i],'15m',500))\\n            tasks.append(task)\\n        loop = asyncio.get_event_loop()\\n        result = loop.run_until_complete(asyncio.gather(*tasks))\\n        Log(datetime.datetime.now(),'完成')\\n        Sleep(1000)\",\n    \"策略名称: python利用asyncio-http获取行情数据示范\\n\\n未找到",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\",\n    \"策略名称: python利用asyncio-http获取行情数据示范\\n\\n未找到描述\"\n \n\n    \"strategy_53\",\n    \"python\\nimport time\\nclass Error_noSupport(BaseException):\\n    def __init__(self):\\n        Log(\\\"只支持OKCoin期货！#FF0000\\\")\\n\\nclass Error_AtBeginHasPosition(BaseException):\\n    def __init__(self):\\n        Log(\\\"启动时有期货持仓! #FF0000\\\")\\n\\nChartCfg = {\\n    '__isStock': True,\\n    'title': {\\n        'text': 'Dual Thrust 上下轨图'\\n   \\n    'yAxis': {\\n        'plotLines': [{\\n            'value': 0,\\n            'color': 'red',\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   'value': 0,\\n            'color': 'red',\\n            'width': 2,\\n            'label': {\\n                'text': '上轨',\\n                'align': 'center'\\n           \\n      \\n            'value': 0,\\n            'color': 'green',\\n            'width': 2,\\n            'label': {\\n                'text': '下轨',\\n                'align': 'center'\\n           \\n        }]\\n   \\n    'series': [{\\n        'type': 'candlestick',\\n        'name': '当前周期',\\n        'id': 'primary',\\n        'data': []\\n  \\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   'id': 'primary',\\n        'data': []\\n  \\n        'type': 'flags',\\n        'onSeries': 'primary',\\n        'data': []\\n    }]\\n}\\n\\nSTATE_IDLE = 0\\nSTATE_LONG = 1\\nSTATE_SHORT = 2\\nState = STATE_IDLE\\n\\nLastBarTime = 0\\nUpTrack = 0\\nBottomTrack = 0\\nchart = None\\nInitAccount = None\\nLastAccount = None\\nCounter = {\\n    'w': 0,\\n    'l': 0\\n}\\n\\ndef GetPosition(posType):  # if the positions has no this posType ,will return [] ,Another case is return a dict of object\\n    positions = exchange.GetPosition(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t of object\\n    positions = exchange.GetPosition()\\n    return [{'Price': position['Price'], 'Amount': position['Amount']} for position in positions if position['Type'] == posType]\\n\\ndef CancelPendingOrders():\\n    while True:\\n        orders = exchange.GetOrders()\\n        [exchange.CancelOrder(order['Id']) for order in orders if not Sleep(500)]\\n        if len(orders) == 0:\\n            break \\n\\ndef Trade(currentState,nextState):\\n    global InitAccount,LastAccount,OpenPrice,ClosePrice\\n    ticker = _C",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",LastAccount,OpenPrice,ClosePrice\\n    ticker = _C(exchange.GetTicker)\\n    slidePrice = 1\\n    pfn = exchange.Buy if nextState == STATE_LONG else exchange.Sell \\n    if currentState != STATE_IDLE:\\n        Log(_C(exchange.GetPosition)) # ceshi \\n        exchange.SetDirection(\\\"closebuy\\\" if currentState == STATE_LONG else \\\"closesell\\\")\\n        while True:\\n            ID = pfn( (ticker['Last'] - slidePrice) if currentState == STATE_LONG else (ticker['Last'] + slidePrice), AmountOP) # xiugai 限价单\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'] + slidePrice), AmountOP) # xiugai 限价单\\n            # ID = pfn(-1, AmountOP) # xiugai  市价单\\n            # ID = pfn(AmountOP) # xiugai  市价单\\n            Sleep(Interval)\\n            Log(exchange.GetOrder(ID)) # xiugai\\n            ClosePrice = (exchange.GetOrder(ID))['AvgPrice'] # \\n            CancelPendingOrders()\\n            if len(GetPosition(PD_LONG if currentState == STATE_LONG else PD_SHORT)) == 0:\\n                break \\n        account = exchange.GetAccount()\\n        if account['Stocks'] > Last",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".GetAccount()\\n        if account['Stocks'] > LastAccount['Stocks']:\\n            Counter['w'] += 1\\n        else:\\n            Counter['l'] += 1\\n        # Log(\\\"ceshi account:\\\",account,InitAccount) #ceshi\\n        Log(account) # xiugai\\n        LogProfit((account['Stocks'] - InitAccount['Stocks']),\\\"收益率:\\\", ((account['Stocks'] - InitAccount['Stocks']) * 100 / InitAccount['Stocks']),'%')\\n        Cal(OpenPrice,ClosePrice)\\n        LsatAccount = account \\n    \\n    exchange.SetDirection(\\\"buy\\\" if nextStat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   \\n    exchange.SetDirection(\\\"buy\\\" if nextState == STATE_LONG else \\\"sell\\\") \\n    Log(_C(exchange.GetAccount))\\n    while True:\\n        ID = pfn( (ticker['Last'] + slidePrice) if nextState == STATE_LONG else (ticker['Last'] - slidePrice), AmountOP) # 限价单\\n        # ID = pfn(-1, AmountOP) # 市价单\\n        # ID = pfn(AmountOP) # 市价单\\n        Sleep(Interval)\\n        Log(exchange.GetOrder(ID)) # xiugai\\n        CancelPendingOrders()\\n        pos = GetPosition(PD_LONG if nextState == STATE_LONG else PD_SHOR",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "on(PD_LONG if nextState == STATE_LONG else PD_SHORT)\\n        if len(pos) != 0:\\n            Log(\\\"持仓均价\\\",pos[0]['Price'],\\\"数量:\\\",pos[0]['Amount'])\\n            OpenPrice = (exchange.GetOrder(ID))['AvgPrice'] # pos[0]['Price']\\n            Log(\\\"now account:\\\",exchange.GetAccount())\\n            break \\n\\ndef onTick(exchange):\\n    global LastBarTime,chart,State,UpTrack,DownTrack,LastAccount\\n    records = exchange.GetRecords()\\n    if not records or len(records) <= NPeriod:\\n        return \\n    Bar = reco",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ords) <= NPeriod:\\n        return \\n    Bar = records[-1]\\n    if LastBarTime != Bar['Time']:\\n        HH = TA.Highest(records, NPeriod, 'High')\\n        HC = TA.Highest(records, NPeriod, 'Close')\\n        LL = TA.Lowest(records, NPeriod, 'Low')\\n        LC = TA.Lowest(records, NPeriod, 'Close')\\n        \\n        Range = max(HH - LC, HC - LL)\\n        UpTrack = _N(Bar['Open'] + (Ks * Range))\\n        DownTrack = _N(Bar['Open'] - (Kx * Range))\\n        if LastBarTime > 0:\\n            PreBar = records[-2]\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "stBarTime > 0:\\n            PreBar = records[-2]\\n            chart.add(0, [PreBar['Time'], PreBar['Open'], PreBar['High'], PreBar['Low'], PreBar['Close']], -1)\\n        else:\\n            for i in range(len(records) - min(len(records), NPeriod * 3), len(records)):\\n                b = records[i]\\n                chart.add(0,[b['Time'], b['Open'], b['High'], b['Low'], b['Close']])\\n                \\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']])\\n        ChartCfg['yAx",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " Bar['Low'], Bar['Close']])\\n        ChartCfg['yAxis']['plotLines'][0]['value'] = UpTrack \\n        ChartCfg['yAxis']['plotLines'][1]['value'] = DownTrack \\n        ChartCfg['subtitle'] = {\\n            'text': '上轨' + str(UpTrack) + '下轨' + str(DownTrack)\\n        }\\n        chart.update(ChartCfg)\\n        chart.reset(PeriodShow)\\n        \\n        LastBarTime = Bar['Time']\\n    else:\\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']], -1)\\n        \\n    LogStatus(\\\"Price:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r['Close']], -1)\\n        \\n    LogStatus(\\\"Price:\\\", Bar[\\\"Close\\\"], \\\"up:\\\", UpTrack, \\\"down:\\\", DownTrack, \\\"wins:\\\", Counter['w'], \\\"losses:\\\", Counter['l'], \\\"Date:\\\", time.time())\\n    msg = \\\"\\\"\\n    if State == STATE_IDLE or State == STATE_SHORT:\\n        if Bar['Close'] >= UpTrack:\\n            msg = \\\"做多，触发价：\\\" + str(Bar['Close']) + \\\"上轨\\\" + str(UpTrack)\\n            Log(msg)\\n            Trade(State, STATE_LONG)\\n            State = STATE_LONG \\n            chart.add(1,{'x': Bar['Time'], 'color':",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           chart.add(1,{'x': Bar['Time'], 'color': 'red', 'shape': 'flag', 'title': '多', 'text': msg})\\n    \\n    if State == STATE_IDLE or State == STATE_LONG:\\n        if Bar['Close'] <= DownTrack:\\n            msg = \\\"做空，触发价：\\\" + str(Bar['Close']) + \\\"下轨\\\" + str(DownTrack)\\n            Log(msg)\\n            Trade(State, STATE_SHORT)\\n            State = STATE_SHORT\\n            chart.add(1,{'x': Bar['Time'], 'color': 'green', 'shape': 'circlepin', 'title': '空', 'text': msg})\\n\\nOpenPrice = 0\\nClosePrice ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": '空', 'text': msg})\\n\\nOpenPrice = 0\\nClosePrice = 0\\ndef Cal(OpenPrice, ClosePrice):\\n    global AmountOP,State\\n    if State == STATE_SHORT:\\n        Log(AmountOP,OpenPrice,ClosePrice,\\\"策略盈亏:\\\", (AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice, \\\"个币，  手续费：\\\", - (100 * AmountOP * 0.0003), \\\"美元,折合：\\\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \\\"个币\\\")\\n        Log(((AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\\n    if State == STATE_LONG",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "P * 0.0003/OpenPrice))\\n    if State == STATE_LONG:\\n        Log(AmountOP,OpenPrice,ClosePrice,\\\"策略盈亏:\\\", (AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice, \\\"个币，  手续费：\\\", - (100 * AmountOP * 0.0003), \\\"美元,折合：\\\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \\\"个币\\\")\\n        Log(((AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\\n\\ndef main():\\n    global LoopInterval,chart,LastAccount,InitAccount\\n    if exchange.GetName() != 'Futures_OKCoin':\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    if exchange.GetName() != 'Futures_OKCoin':\\n        raise Error_noSupport\\n    exchange.SetRate(1)\\n    exchange.SetContractType([\\\"this_week\\\",\\\"next_week\\\",\\\"quarter\\\"][ContractTypeIdx]) \\n    exchange.SetMarginLevel([10,20][MarginLevelIdx])\\n    \\n    # Log(\\\"Fee:\\\",exchange.GetFee())\\n    if len(exchange.GetPosition()) > 0:\\n        raise Error_AtBeginHasPosition\\n    CancelPendingOrders()\\n    InitAccount = LastAccount = exchange.GetAccount()\\n    LoopInterval = min(1,LoopInterval)\\n    Log(\\\"交易平",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " LoopInterval = min(1,LoopInterval)\\n    Log(\\\"交易平台:\\\",exchange.GetName(), InitAccount)\\n    LogStatus(\\\"Ready...\\\")\\n    \\n    LogProfitReset()\\n    chart = Chart(ChartCfg)\\n    chart.reset()\\n    \\n    LoopInterval = max(LoopInterval, 1)\\n    while True:\\n        onTick(exchange)\\n        Sleep(LoopInterval * 1000)\",\n    \"策略名称: python版-Dual-Thrust-OKCoin-期货\\n\\npositions = exchange.GetPosition()\\n    return [{'Price': position['Price'], 'Amount': position['Amount']} for position in positions if position['T",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Amount']} for position in positions if position['Type'] == posType]\\n\\ndef CancelPendingOrders():\\n    while True:\\n        orders = exchange.GetOrders()\\n        [exchange.CancelOrder(order['Id']) for order in orders if not Sleep(500)]\\n        if len(orders) == 0:\\n            break \\n\\ndef Trade(currentState,nextState):\\n    global InitAccount,LastAccount,OpenPrice,ClosePrice\\n    ticker = _C(exchange.GetTicker)\\n    slidePrice = 1\\n    pfn = exchange.Buy if nextState == STATE_LONG else exchange.Sell \\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " if nextState == STATE_LONG else exchange.Sell \\n    if currentState != STATE_IDLE:\\n        Log(_C(exchange.GetPosition)) # ceshi \\n        exchange.SetDirection(\\\"closebuy\\\" if currentState == STATE_LONG else \\\"closesell\\\")\\n        while True:\\n            ID = pfn( (ticker['Last'] - slidePrice) if currentState == STATE_LONG else (ticker['Last'] + slidePrice), AmountOP) # xiugai 限价单\\n            # ID = pfn(-1, AmountOP) # xiugai  市价单\\n            # ID = pfn(AmountOP) # xiugai  市价单\\n            Sleep(Inte",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "fn(AmountOP) # xiugai  市价单\\n            Sleep(Interval)\\n            Log(exchange.GetOrder(ID)) # xiugai\\n            ClosePrice = (exchange.GetOrder(ID))['AvgPrice'] # \\n            CancelPendingOrders()\\n            if len(GetPosition(PD_LONG if currentState == STATE_LONG else PD_SHORT)) == 0:\\n                break \\n        account = exchange.GetAccount()\\n        if account['Stocks'] > LastAccount['Stocks']:\\n            Counter['w'] += 1\\n        else:\\n            Counter['l'] += 1\\n        # Log(\\\"c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            Counter['l'] += 1\\n        # Log(\\\"ceshi account:\\\",account,InitAccount) #ceshi\\n        Log(account) # xiugai\\n        LogProfit((account['Stocks'] - InitAccount['Stocks']),\\\"收益率:\\\", ((account['Stocks'] - InitAccount['Stocks']) * 100 / InitAccount['Stocks']),'%')\\n        Cal(OpenPrice,ClosePrice)\\n        LsatAccount = account \\n    \\n    exchange.SetDirection(\\\"buy\\\" if nextState == STATE_LONG else \\\"sell\\\") \\n    Log(_C(exchange.GetAccount))\\n    while True:\\n        ID = pfn( (ticker['Las",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n    while True:\\n        ID = pfn( (ticker['Last'] + slidePrice) if nextState == STATE_LONG else (ticker['Last'] - slidePrice), AmountOP) # 限价单\\n        # ID = pfn(-1, AmountOP) # 市价单\\n        # ID = pfn(AmountOP) # 市价单\\n        Sleep(Interval)\\n        Log(exchange.GetOrder(ID)) # xiugai\\n        CancelPendingOrders()\\n        pos = GetPosition(PD_LONG if nextState == STATE_LONG else PD_SHORT)\\n        if len(pos) != 0:\\n            Log(\\\"持仓均价\\\",pos[0]['Price'],\\\"数量:\\\",pos[0]['Amount'])\\n            Ope",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Price'],\\\"数量:\\\",pos[0]['Amount'])\\n            OpenPrice = (exchange.GetOrder(ID))['AvgPrice'] # pos[0]['Price']\\n            Log(\\\"now account:\\\",exchange.GetAccount())\\n            break \\n\\ndef onTick(exchange):\\n    global LastBarTime,chart,State,UpTrack,DownTrack,LastAccount\\n    records = exchange.GetRecords()\\n    if not records or len(records) <= NPeriod:\\n        return \\n    Bar = records[-1]\\n    if LastBarTime != Bar['Time']:\\n        HH = TA.Highest(records, NPeriod, 'High')\\n        HC = TA.Hi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hest(records, NPeriod, 'High')\\n        HC = TA.Highest(records, NPeriod, 'Close')\\n        LL = TA.Lowest(records, NPeriod, 'Low')\\n        LC = TA.Lowest(records, NPeriod, 'Close')\\n        \\n        Range = max(HH - LC, HC - LL)\\n        UpTrack = _N(Bar['Open'] + (Ks * Range))\\n        DownTrack = _N(Bar['Open'] - (Kx * Range))\\n        if LastBarTime > 0:\\n            PreBar = records[-2]\\n            chart.add(0, [PreBar['Time'], PreBar['Open'], PreBar['High'], PreBar['Low'], PreBar['Close']], -1)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "['High'], PreBar['Low'], PreBar['Close']], -1)\\n        else:\\n            for i in range(len(records) - min(len(records), NPeriod * 3), len(records)):\\n                b = records[i]\\n                chart.add(0,[b['Time'], b['Open'], b['High'], b['Low'], b['Close']])\\n                \\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']])\\n        ChartCfg['yAxis']['plotLines'][0]['value'] = UpTrack \\n        ChartCfg['yAxis']['plotLines'][1]['value'] = DownTrack \\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s']['plotLines'][1]['value'] = DownTrack \\n        ChartCfg['subtitle'] = {\\n            'text': '上轨' + str(UpTrack) + '下轨' + str(DownTrack)\\n        }\\n        chart.update(ChartCfg)\\n        chart.reset(PeriodShow)\\n        \\n        LastBarTime = Bar['Time']\\n    else:\\n        chart.add(0,[Bar['Time'], Bar['Open'], Bar['High'], Bar['Low'], Bar['Close']], -1)\\n        \\n    LogStatus(\\\"Price:\\\", Bar[\\\"Close\\\"], \\\"up:\\\", UpTrack, \\\"down:\\\", DownTrack, \\\"wins:\\\", Counter['w'], \\\"losses:\\\", Counter['l'], \\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ns:\\\", Counter['w'], \\\"losses:\\\", Counter['l'], \\\"Date:\\\", time.time())\\n    msg = \\\"\\\"\\n    if State == STATE_IDLE or State == STATE_SHORT:\\n        if Bar['Close'] >= UpTrack:\\n            msg = \\\"做多，触发价：\\\" + str(Bar['Close']) + \\\"上轨\\\" + str(UpTrack)\\n            Log(msg)\\n            Trade(State, STATE_LONG)\\n            State = STATE_LONG \\n            chart.add(1,{'x': Bar['Time'], 'color': 'red', 'shape': 'flag', 'title': '多', 'text': msg})\\n    \\n    if State == STATE_IDLE or State == STATE_LONG:\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if State == STATE_IDLE or State == STATE_LONG:\\n        if Bar['Close'] <= DownTrack:\\n            msg = \\\"做空，触发价：\\\" + str(Bar['Close']) + \\\"下轨\\\" + str(DownTrack)\\n            Log(msg)\\n            Trade(State, STATE_SHORT)\\n            State = STATE_SHORT\\n            chart.add(1,{'x': Bar['Time'], 'color': 'green', 'shape': 'circlepin', 'title': '空', 'text': msg})\\n\\nOpenPrice = 0\\nClosePrice = 0\\ndef Cal(OpenPrice, ClosePrice):\\n    global AmountOP,State\\n    if State == STATE_SHORT:\\n        Log(AmountO",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    if State == STATE_SHORT:\\n        Log(AmountOP,OpenPrice,ClosePrice,\\\"策略盈亏:\\\", (AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice, \\\"个币，  手续费：\\\", - (100 * AmountOP * 0.0003), \\\"美元,折合：\\\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \\\"个币\\\")\\n        Log(((AmountOP * 100) / ClosePrice - (AmountOP * 100) / OpenPrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\\n    if State == STATE_LONG:\\n        Log(AmountOP,OpenPrice,ClosePrice,\\\"策略盈亏:\\\", (AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePri",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "P * 100) / OpenPrice - (AmountOP * 100) / ClosePrice, \\\"个币，  手续费：\\\", - (100 * AmountOP * 0.0003), \\\"美元,折合：\\\", _N( - 100 * AmountOP * 0.0003/OpenPrice,8), \\\"个币\\\")\\n        Log(((AmountOP * 100) / OpenPrice - (AmountOP * 100) / ClosePrice) + (- 100 * AmountOP * 0.0003/OpenPrice))\\n\\ndef main():\\n    global LoopInterval,chart,LastAccount,InitAccount\\n    if exchange.GetName() != 'Futures_OKCoin':\\n        raise Error_noSupport\\n    exchange.SetRate(1)\\n    exchange.SetContractType([\\\"this_week\\\",\\\"next_week\\\",",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.SetContractType([\\\"this_week\\\",\\\"next_week\\\",\\\"quarter\\\"][ContractTypeIdx]) \\n    exchange.SetMarginLevel([10,20][MarginLevelIdx])\\n    \\n    # Log(\\\"Fee:\\\",exchange.GetFee())\\n    if len(exchange.GetPosition()) > 0:\\n        raise Error_AtBeginHasPosition\\n    CancelPendingOrders()\\n    InitAccount = LastAccount = exchange.GetAccount()\\n    LoopInterval = min(1,LoopInterval)\\n    Log(\\\"交易平台:\\\",exchange.GetName(), InitAccount)\\n    LogStatus(\\\"Ready...\\\")\\n    \\n    LogProfitReset()\\n    chart = Chart(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\")\\n    \\n    LogProfitReset()\\n    chart = Chart(ChartCfg)\\n    chart.reset()\\n    \\n    LoopInterval = max(LoopInterval, 1)\\n    while True:\\n        onTick(exchange)\\n        Sleep(LoopInterval * 1000)\\n    \\n    \\n\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/21856\\n\\n> Last Modified\\n\\n2018-03-23 16:53:49\"\n \n\n    \"strategy_54\",\n    \"python\\n# Python 2/3 兼容版本\\nimport time\\nchart = None\\nseries = []\\nlabelIdx = {}\\npreBarTime = 0\\npreFlagTime = 0\\npreDotTime = {}\\n\\ncfg = {\\n    \\\"tooltip\\\" : {\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "reDotTime = {}\\n\\ncfg = {\\n    \\\"tooltip\\\" : {\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\"\\n   \\n    \\\"legend\\\" : {\\n        \\\"enabled\\\" : True\\n   \\n    \\\"plotOptions\\\" : {\\n        \\\"candlestick\\\" : {\\n            \\\"color\\\" : \\\"#d75442\\\",\\n            \\\"upColor\\\" : \\\"#6ba583\\\"\\n        }\\n   \\n    \\\"rangeSelector\\\" : {\\n        \\\"buttons\\\" : [{\\n            \\\"type\\\" : \\\"hour\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1h\\\",\\n      \\n            \\\"type\\\" : 'hour',\\n            \\\"count",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           \\\"type\\\" : 'hour',\\n            \\\"count\\\" : 3,\\n            \\\"text\\\" : \\\"3h\\\"\\n      \\n            \\\"type\\\" : \\\"hour\\\",\\n            \\\"count\\\" : 8,\\n            \\\"text\\\" : \\\"8h\\\"\\n      \\n            \\\"type\\\" : \\\"all\\\",\\n            \\\"text\\\" : \\\"All\\\"\\n        }],\\n        \\\"selected\\\" : 2,\\n        \\\"inputEnabled\\\" : True\\n   \\n    \\\"series\\\" : series,\\n}\\n\\ndef GetCfg():\\n    global cfg\\n    return cfg\\n\\n# 画水平线\\ndef PlotHLine(value = None, label = None, color = None, style = None):\\n    global",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l = None, color = None, style = None):\\n    global cfg, chart\\n    if (\\\"yAxis\\\" in cfg) == False :\\n        cfg.setdefault(\\\"yAxis\\\", {\\\"plotLines\\\" : []})\\n    elif (\\\"plotLines\\\" in cfg[\\\"yAxis\\\"]) == False :\\n        cfg[\\\"yAxis\\\"].setdefault(\\\"plotLines\\\", [])\\n    \\n    obj = {\\n        \\\"value\\\" : value,\\n        \\\"color\\\" : color or \\\"red\\\",\\n        \\\"width\\\" : 2,\\n        \\\"dashStyle\\\" : style or \\\"Solid\\\",\\n        \\\"label\\\" : {\\n            \\\"text\\\" : label or \\\"\\\",\\n            \\\"align\\\" : \\\"ce",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t\\\" : label or \\\"\\\",\\n            \\\"align\\\" : \\\"center\\\"\\n        }\\n    }\\n    found = False\\n    for i in range(len(cfg[\\\"yAxis\\\"][\\\"plotLines\\\"])) : \\n        if cfg[\\\"yAxis\\\"][\\\"plotLines\\\"][i][\\\"label\\\"][\\\"text\\\"] == label : \\n            cfg[\\\"yAxis\\\"][\\\"plotLines\\\"][i] = obj\\n            found = True\\n    if not found :\\n        cfg[\\\"yAxis\\\"][\\\"plotLines\\\"].append(obj)\\n    if not chart :\\n        chart = Chart(cfg)\\n        chart.update(cfg)    # 更新图表\\n    else :\\n        chart.update(cfg)\\n\\n# 画K线",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "图表\\n    else :\\n        chart.update(cfg)\\n\\n# 画K线\\ndef PlotRecords(records, title = None):\\n    global labelIdx, series, preBarTime, chart\\n    if not chart :\\n        chart = Chart(cfg)\\n        chart.reset()\\n    if (\\\"candlestick\\\" in labelIdx) == False : \\n        cfg[\\\"__isStock\\\"] = True\\n        seriesIdx = len(series)\\n        series.append({\\n            \\\"type\\\" : \\\"candlestick\\\",\\n            \\\"name\\\" : \\\"\\\" if title == None else title,\\n            \\\"id\\\" : \\\"primary\\\",\\n            \\\"data\\\" : ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    \\\"id\\\" : \\\"primary\\\",\\n            \\\"data\\\" : []\\n            })\\n        chart.update(cfg)\\n        labelIdx.setdefault(\\\"candlestick\\\", seriesIdx)\\n    else :\\n        seriesIdx = labelIdx[\\\"candlestick\\\"]\\n    if isinstance(records, dict) and (\\\"Time\\\" in records) == True :\\n        Bar = records\\n        if Bar[\\\"Time\\\"] == preBarTime :\\n            chart.add(seriesIdx, [Bar[\\\"Time\\\"], Bar[\\\"Open\\\"], Bar[\\\"High\\\"], Bar[\\\"Low\\\"], Bar[\\\"Close\\\"]], -1)\\n        elif Bar[\\\"Time\\\"] > preBarTime : \\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        elif Bar[\\\"Time\\\"] > preBarTime : \\n            preBarTime = Bar.Time\\n            chart.add(seriesIdx, [Bar[\\\"Time\\\"], Bar[\\\"Open\\\"], Bar[\\\"High\\\"], Bar[\\\"Low\\\"], Bar[\\\"Close\\\"]])    \\n    else :\\n        for i in range(len(records)) :\\n            if records[i][\\\"Time\\\"] == preBarTime :\\n                chart.add(seriesIdx, [records[i][\\\"Time\\\"], records[i][\\\"Open\\\"], records[i][\\\"High\\\"], records[i][\\\"Low\\\"], records[i][\\\"Close\\\"]], -1)\\n            elif records[i][\\\"Time\\\"] > preBarTime :\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    elif records[i][\\\"Time\\\"] > preBarTime :\\n                preBarTime = records[i][\\\"Time\\\"]\\n                chart.add(seriesIdx, [records[i][\\\"Time\\\"], records[i][\\\"Open\\\"], records[i][\\\"High\\\"], records[i][\\\"Low\\\"], records[i][\\\"Close\\\"]])\\n    return chart\\n\\n# 画指标线\\ndef PlotLine(label, dot, Ntime = None):\\n    global labelIdx, chart, series, preDotTime\\n    if not chart :\\n        cfg.setdefault(\\\"xAxis\\\", {\\n            \\\"type\\\" : \\\"datetime\\\"\\n            })\\n        chart = Chart(cfg)\\n        ch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        })\\n        chart = Chart(cfg)\\n        chart.reset()\\n    if (label in labelIdx) == False :\\n        seriesIdx = len(series)\\n        preDotTime.setdefault(str(seriesIdx), 0)\\n        labelIdx[label] = seriesIdx\\n        series.append({\\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"yAxis\\\" : 0,\\n            \\\"showInLegend\\\" : True,\\n            \\\"name\\\" : label,\\n            \\\"data\\\" : [],\\n            \\\"tooltip\\\" : {\\\"valueDecimals\\\" : 5}\\n            })\\n        chart.update(cfg)\\n    else :\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       })\\n        chart.update(cfg)\\n    else :\\n        seriesIdx = labelIdx[label]\\n    if Ntime == None :\\n        Ntime = _N(time.time() * 1000, 0)\\n    if preDotTime[str(seriesIdx)] != Ntime :\\n        preDotTime[str(seriesIdx)] = Ntime\\n        chart.add(seriesIdx, [Ntime, dot])\\n    else :\\n        chart.add(seriesIdx, [Ntime, dot], -1)\\n    return chart\\n\\n# 画标记\\ndef PlotFlag(time, text, title, shape = \\\"\\\", color = \\\"\\\"):\\n    global chart, cfg, labelIdx, preFlagTime\\n    if not chart :\\n        c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "belIdx, preFlagTime\\n    if not chart :\\n        chart = Chart(cfg)\\n        chart.reset()\\n    label = \\\"flag\\\"\\n    if (label in labelIdx) == False : \\n        seriesIdx = len(series)\\n        labelIdx[label] = seriesIdx\\n        series.append({\\n            \\\"type\\\" : \\\"flags\\\",\\n            \\\"onSeries\\\" : \\\"primary\\\",\\n            \\\"data\\\" : []\\n            })\\n        chart.update(cfg)\\n    else :\\n        seriesIdx = labelIdx[label]\\n    obj = {\\n        \\\"x\\\" : time,\\n        \\\"color\\\" : color,\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   \\\"x\\\" : time,\\n        \\\"color\\\" : color,\\n        \\\"shape\\\" : shape,\\n        \\\"title\\\" : title,\\n        \\\"text\\\" : text\\n    }\\n    if preFlagTime != time : \\n        preFlagTime = time\\n        chart.add(seriesIdx, obj)\\n    else :\\n        chart.add(seriesIdx, obj, -1)\\n    return chart\\n\\n# 设置图表标题\\ndef PlotTitle(title, chartTitle = None):\\n    global cfg\\n    if (\\\"subtitle\\\" in cfg) == True : \\n        cfg[\\\"subtitle\\\"] = {\\\"text\\\" : title}\\n    else :\\n        cfg.setdefault(\\\"subtitle\\\", {\\\"text",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "se :\\n        cfg.setdefault(\\\"subtitle\\\", {\\\"text\\\" : title})\\n    if chartTitle != None :\\n        if (title in cfg) == True :\\n            cfg[\\\"title\\\"] = {\\\"text\\\" : chartTitle}\\n        else :\\n            cfg.setdefault(\\\"title\\\", {\\\"text\\\" : chartTitle})\\n    if chart :\\n        chart.update(cfg)\\n\\n# 导出函数\\next.GetCfg = GetCfg\\next.PlotHLine = PlotHLine\\next.PlotRecords = PlotRecords\\next.PlotLine = PlotLine\\next.PlotFlag = PlotFlag\\next.PlotTitle = PlotTitle\\n\\n# 测试代码\\ndef main():\\n    isFirst = Tr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "PlotTitle\\n\\n# 测试代码\\ndef main():\\n    isFirst = True\\n    while True:\\n        records = exchange.GetRecords()\\n        if records and len(records) > 0 :\\n            ext.PlotRecords(records, \\\"BTC\\\")\\n            if isFirst :\\n                ext.PlotFlag(records[-1][\\\"Time\\\"], \\\"Start\\\", \\\"S\\\")\\n                isFirst = False\\n                ext.PlotHLine(records[-1][\\\"Close\\\"], \\\"Close\\\")\\n        ticker = exchange.GetTicker()\\n        if ticker :\\n            ext.PlotLine(\\\"Last\\\", ticker.Last)\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        ext.PlotLine(\\\"Last\\\", ticker.Last)\\n            ext.PlotLine(\\\"buy\\\", ticker.Buy + 10)\\n            ext.PlotTitle(\\\"Last\\\" + str(ticker.Last))\\n        Sleep(60000)\",\n    \"策略名称: python版-画线类库-兼容2-3-Python-Version-Drawing-Class-Library-Compatible-2-3\\n\\n> Source (python)\\n\\n``` python\"\n \n\n    \"strategy_55\",\n    \"python\\nimport types # 导入类型模块\\nimport time  # 导入时间模块\\nimport platform # 版本信息 \\n\\nversionMainValue = None\\nisFirstCheck = True\\ndef typeOfstr(str):\\n    if str == \\\"list\\\":\\n        if version",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "str):\\n    if str == \\\"list\\\":\\n        if versionMainValue == 2:\\n            return types.ListType\\n        elif versionMainValue == 3:\\n            return list\\n    elif str == \\\"int\\\":\\n        if versionMainValue == 2:\\n            return types.IntType\\n        elif versionMainValue == 3:\\n            return int\\n    elif str == \\\"float\\\":\\n        if versionMainValue == 2:\\n            return types.FloatType\\n        elif versionMainValue == 3:\\n            return float\\n    else:\\n        Log(\\\"error",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      return float\\n    else:\\n        Log(\\\"error , typeOfstr used false\\\")\\n            \\ndef CheckVersion():\\n    global versionMainValue,isFirstCheck\\n    platformInfo = platform.python_version()\\n    if platformInfo[0] == '2':\\n        Log(\\\"您使用的托管者 python编译环境的python版本是\\\",platformInfo)\\n        versionMainValue = 2\\n    elif platformInfo[0] == '3':\\n        Log(\\\"您使用的托管者 python编译环境的python版本是\\\",platformInfo)\\n        versionMainValue = 3\\n    else:\\n        Log(\\\"其它版本\\\")\\n    isFirstCheck = False\\n\\ndef",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    Log(\\\"其它版本\\\")\\n    isFirstCheck = False\\n\\ndef CancelPendingOrders(e, orderType = \\\"\\\") : # 取消所有未完成挂单\\n    while True: # 循环\\n        orders = e.GetOrders()\\n        LogStatus(\\\"orders:\\\",orders,time.time()) # 测试\\n        if(type(orders) != typeOfstr(\\\"list\\\")):\\n            Sleep(RetryDelay)\\n            continue\\n        processed = 0\\n        for j in range(len(orders)):\\n            if (type(orderType) == typeOfstr(\\\"int\\\") and orders[j].Type != orderType):\\n                continue\\n            e.Ca",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Type):\\n                continue\\n            e.CancelOrder(orders[j].Id,orders[j])\\n            processed += 1\\n            if (j < (len(orders) - 1)):\\n                Sleep(RetryDelay)\\n        if(processed == 0):\\n            break\\n\\ndef GetAccount(e, waitFrozen = False):\\n    account = null\\n    alreadyAlert = False\\n    while True:\\n        account = _C(e.GetAccount)\\n        if(not waitFrozen or (account.FrozenStocks < _GetMinStocks and account.FrozenBalance < 0.01)):\\n            break\\n        if(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nBalance < 0.01)):\\n            break\\n        if(not alreadyAlert):\\n            alreadyAlert = True\\n            Log(\\\"发现账户有冻结的钱或币\\\",account)\\n        Sleep(RetryDelay)\\n    return account\\n\\ndef StripOrders(e,orderId = null):\\n    order = null\\n    while True:\\n        dropped = 0\\n        orders = _C(e.GetOrders)\\n        for i in range(len(orders)):\\n            if(orders[i].Id == orderId):\\n                order = orders[i]\\n            else:\\n                extra = \\\"\\\"\\n                if(orders[i]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        extra = \\\"\\\"\\n                if(orders[i].DealAmount > 0):\\n                    extra = \\\"成交：\\\" + str(orders[i].DealAmount)\\n                else:\\n                    extra = \\\"未成交\\\"\\n                e.CancelOrder(orders[i].Id,\\\"买单\\\" if orders[i].Type == ORDER_TYPE_BUY else \\\"卖单\\\",extra)\\n                dropped += 1\\n        if(dropped == 0):\\n            break\\n        Sleep(RetryDelay)\\n    return order\\n\\ndef Trade(e,tradeType,tradeAmount,mode,slidePrice,maxAmount,maxSpace,retryDelay):\\n    in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "slidePrice,maxAmount,maxSpace,retryDelay):\\n    initAccount = GetAccount(e,True)\\n    nowAccount = initAccount\\n    orderId = null\\n    prePrice = 0.0\\n    dealAmount = 0.0\\n    diffMoney = 0.0\\n    isFirst = True\\n    tradeFunc = e.Buy if tradeType == ORDER_TYPE_BUY else e.Sell\\n    isBuy = (tradeType == ORDER_TYPE_BUY)\\n    while True:\\n        ticker = _C(e.GetTicker)\\n        tradePrice = 0.0\\n        if(isBuy):\\n            tradePrice = _N((ticker.Sell if mode == 0 else ticker.Buy) + slidePrice,4)\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if mode == 0 else ticker.Buy) + slidePrice,4)\\n        else:\\n            tradePrice = _N((ticker.Buy if mode == 0 else ticker.Sell) - slidePrice,4)\\n        if(not orderId):\\n            if(isFirst):\\n                isFirst = False\\n            else:\\n                nowAccount = GetAccount(e,True)\\n            doAmount = 0.0;\\n            if(isBuy):\\n                diffMoney = _N(initAccount.Balance - nowAccount.Balance,4)\\n                dealAmount = _N(nowAccount.Stocks - initAccount.Stocks,4)\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "N(nowAccount.Stocks - initAccount.Stocks,4)\\n                doAmount = min(maxAmount,tradeAmount - dealAmount,_N((nowAccount.Balance - 10) / tradePrice,4))\\n            else:\\n                diffMoney = _N(nowAccount.Balance - initAccount.Balance,4)\\n                dealAmount = _N(initAccount.Stocks - nowAccount.Stocks,4)\\n                doAmount = min(maxAmount,tradeAmount - dealAmount,nowAccount.Stocks)\\n            if(doAmount < _GetMinStocks):\\n                break\\n            prePrice = tradePric",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           break\\n            prePrice = tradePrice\\n            orderId = tradeFunc(tradePrice,doAmount,ticker)\\n            if(not orderId):\\n                CancelPendingOrders(e,tradeType)\\n        else:\\n            if(mode == 0 or (abs(tradePrice - prePrice) > maxSpace)):\\n                orderId = null\\n            order = StripOrders(e,orderId)\\n            if(not order):\\n                orderId = null\\n        Sleep(retryDelay)\\n    if(dealAmount <= 0):\\n        Log(\\\"交易失败--TradeType:\\\",\\\"buy\\\" if",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= 0):\\n        Log(\\\"交易失败--TradeType:\\\",\\\"buy\\\" if tradeType == ORDER_TYPE_BUY else \\\"sell\\\",\\\"  ,diffMoney:\\\",diffMoney,\\\"  ,dealAmount\\\",dealAmount,\\\"  ,doAmount\\\",doAmount)\\n        return null\\n    \\n    ret = {'price': _N(diffMoney/dealAmount,4),'amount':dealAmount}\\n    return ret\\n    # 调用时 这样写  ret['price'] 、 ret['amount']\\n\\ndef _Buy(e = exchange,amount = 0):\\n    if isFirstCheck:\\n        CheckVersion()\\n    if (type(e) == typeOfstr(\\\"int\\\") or type(e) == typeOfstr(\\\"float\\\")):\\n        amount = e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e(e) == typeOfstr(\\\"float\\\")):\\n        amount = e\\n        e = exchange\\n    return Trade(e,ORDER_TYPE_BUY,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\\n\\ndef _Sell(e = exchange,amount = 0):\\n    if isFirstCheck:\\n        CheckVersion()\\n    if (type(e) == typeOfstr(\\\"int\\\") or type(e) == typeOfstr(\\\"float\\\")):\\n        amount = e\\n        e = exchange\\n    return Trade(e,ORDER_TYPE_SELL,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\\n\\ndef _CancelPendingOrders(e = exchange,orderType = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "def _CancelPendingOrders(e = exchange,orderType = \\\"\\\"):\\n    if isFirstCheck:\\n        CheckVersion()\\n    return CancelPendingOrders(e,orderType)\\n\\ndef _GetAccount(e = exchange):\\n    if isFirstCheck:\\n        CheckVersion()\\n    return _C(e.GetAccount)\\n\\n_MACalcMethod = [TA.EMA,TA.MA][MAType]\\nInterval = 200\\ndef Cross(a,b):\\n    if isFirstCheck:\\n        CheckVersion()\\n    crossNum = 0\\n    arr1 = []\\n    arr2 = []\\n    if type(a) == typeOfstr(\\\"list\\\") and type(b) == typeOfstr(\\\"list\\\"):\\n        ar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\") and type(b) == typeOfstr(\\\"list\\\"):\\n        arr1 = a\\n        arr2 = b\\n    else:\\n        records = null\\n        while True:\\n            records = exchange.GetRecords()\\n            if records and len(records) > a and len(records) > b:\\n                break\\n            Sleep(Interval)\\n        arr1 = _MACalcMethod(records,a)\\n        arr2 = _MACalcMethod(records,b)\\n    if len(arr1) != len(arr2):\\n        raise Exception(\\\"array length not equal\\\")\\n    for i in range(len(arr1) - 1,-1,-1):\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    for i in range(len(arr1) - 1,-1,-1):\\n        if (type(arr1[i]) != typeOfstr(\\\"int\\\") and type(arr1[i]) != typeOfstr(\\\"float\\\")) or (type(arr2[i]) != typeOfstr(\\\"int\\\") and type(arr2[i]) != typeOfstr(\\\"float\\\")):\\n            break\\n        if arr1[i] < arr2[i] :\\n            if crossNum > 0 :\\n                break\\n            crossNum -= 1\\n        elif arr1[i] > arr2[i] :\\n            if crossNum < 0 :\\n                break\\n            crossNum += 1\\n        else:\\n            break\\n    return c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 1\\n        else:\\n            break\\n    return crossNum\\n\\n\\n# 导出函数\\next.Buy = _Buy\\next.Sell = _Sell\\next.CancelPendingOrders = _CancelPendingOrders\\next.GetAccount = _GetAccount\\next.Cross = Cross\\n\\n# 测试\\ndef main():\\n    ret = ext.Buy(0.2)\\n    exchange.Sell(4500,1)\\n    Sleep(10 * 1000)\\n    ext.CancelPendingOrders()\\n    Log(\\\"ret:\\\",ret)\\n    avgprice = ret['price']\\n    dealamount = ret['amount']\\n    Log(\\\"avgprice:\\\",avgprice,\\\"  dealamount:\\\",dealamount)\",\n    \"策略名称: python版现货数字货币交易类库Python-Ver",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "alamount)\",\n    \"策略名称: python版现货数字货币交易类库Python-Version-Spot-Cryptocurrency-Trading-Class-Library\\n\\nimport time  # 导入时间模块\\nimport platform # 版本信息 \\n\\nversionMainValue = None\\nisFirstCheck = True\\ndef typeOfstr(str):\\n    if str == \\\"list\\\":\\n        if versionMainValue == 2:\\n            return types.ListType\\n        elif versionMainValue == 3:\\n            return list\\n    elif str == \\\"int\\\":\\n        if versionMainValue == 2:\\n            return types.IntType\\n        elif versionMainValue == 3:\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tType\\n        elif versionMainValue == 3:\\n            return int\\n    elif str == \\\"float\\\":\\n        if versionMainValue == 2:\\n            return types.FloatType\\n        elif versionMainValue == 3:\\n            return float\\n    else:\\n        Log(\\\"error , typeOfstr used false\\\")\\n            \\ndef CheckVersion():\\n    global versionMainValue,isFirstCheck\\n    platformInfo = platform.python_version()\\n    if platformInfo[0] == '2':\\n        Log(\\\"您使用的托管者 python编译环境的python版本是\\\",platformInfo)\\n        v",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "管者 python编译环境的python版本是\\\",platformInfo)\\n        versionMainValue = 2\\n    elif platformInfo[0] == '3':\\n        Log(\\\"您使用的托管者 python编译环境的python版本是\\\",platformInfo)\\n        versionMainValue = 3\\n    else:\\n        Log(\\\"其它版本\\\")\\n    isFirstCheck = False\\n\\ndef CancelPendingOrders(e, orderType = \\\"\\\") : # 取消所有未完成挂单\\n    while True: # 循环\\n        orders = e.GetOrders()\\n        LogStatus(\\\"orders:\\\",orders,time.time()) # 测试\\n        if(type(orders) != typeOfstr(\\\"list\\\")):\\n            Sleep(RetryDelay)\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r(\\\"list\\\")):\\n            Sleep(RetryDelay)\\n            continue\\n        processed = 0\\n        for j in range(len(orders)):\\n            if (type(orderType) == typeOfstr(\\\"int\\\") and orders[j].Type != orderType):\\n                continue\\n            e.CancelOrder(orders[j].Id,orders[j])\\n            processed += 1\\n            if (j < (len(orders) - 1)):\\n                Sleep(RetryDelay)\\n        if(processed == 0):\\n            break\\n\\ndef GetAccount(e, waitFrozen = False):\\n    account = null\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t(e, waitFrozen = False):\\n    account = null\\n    alreadyAlert = False\\n    while True:\\n        account = _C(e.GetAccount)\\n        if(not waitFrozen or (account.FrozenStocks < _GetMinStocks and account.FrozenBalance < 0.01)):\\n            break\\n        if(not alreadyAlert):\\n            alreadyAlert = True\\n            Log(\\\"发现账户有冻结的钱或币\\\",account)\\n        Sleep(RetryDelay)\\n    return account\\n\\ndef StripOrders(e,orderId = null):\\n    order = null\\n    while True:\\n        dropped = 0\\n        orders =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "while True:\\n        dropped = 0\\n        orders = _C(e.GetOrders)\\n        for i in range(len(orders)):\\n            if(orders[i].Id == orderId):\\n                order = orders[i]\\n            else:\\n                extra = \\\"\\\"\\n                if(orders[i].DealAmount > 0):\\n                    extra = \\\"成交：\\\" + str(orders[i].DealAmount)\\n                else:\\n                    extra = \\\"未成交\\\"\\n                e.CancelOrder(orders[i].Id,\\\"买单\\\" if orders[i].Type == ORDER_TYPE_BUY else \\\"卖单\\\",extra)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s[i].Type == ORDER_TYPE_BUY else \\\"卖单\\\",extra)\\n                dropped += 1\\n        if(dropped == 0):\\n            break\\n        Sleep(RetryDelay)\\n    return order\\n\\ndef Trade(e,tradeType,tradeAmount,mode,slidePrice,maxAmount,maxSpace,retryDelay):\\n    initAccount = GetAccount(e,True)\\n    nowAccount = initAccount\\n    orderId = null\\n    prePrice = 0.0\\n    dealAmount = 0.0\\n    diffMoney = 0.0\\n    isFirst = True\\n    tradeFunc = e.Buy if tradeType == ORDER_TYPE_BUY else e.Sell\\n    isBuy = (tradeTyp",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " ORDER_TYPE_BUY else e.Sell\\n    isBuy = (tradeType == ORDER_TYPE_BUY)\\n    while True:\\n        ticker = _C(e.GetTicker)\\n        tradePrice = 0.0\\n        if(isBuy):\\n            tradePrice = _N((ticker.Sell if mode == 0 else ticker.Buy) + slidePrice,4)\\n        else:\\n            tradePrice = _N((ticker.Buy if mode == 0 else ticker.Sell) - slidePrice,4)\\n        if(not orderId):\\n            if(isFirst):\\n                isFirst = False\\n            else:\\n                nowAccount = GetAccount(e,True)\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                nowAccount = GetAccount(e,True)\\n            doAmount = 0.0;\\n            if(isBuy):\\n                diffMoney = _N(initAccount.Balance - nowAccount.Balance,4)\\n                dealAmount = _N(nowAccount.Stocks - initAccount.Stocks,4)\\n                doAmount = min(maxAmount,tradeAmount - dealAmount,_N((nowAccount.Balance - 10) / tradePrice,4))\\n            else:\\n                diffMoney = _N(nowAccount.Balance - initAccount.Balance,4)\\n                dealAmount = _N(initAccount.Stock",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                dealAmount = _N(initAccount.Stocks - nowAccount.Stocks,4)\\n                doAmount = min(maxAmount,tradeAmount - dealAmount,nowAccount.Stocks)\\n            if(doAmount < _GetMinStocks):\\n                break\\n            prePrice = tradePrice\\n            orderId = tradeFunc(tradePrice,doAmount,ticker)\\n            if(not orderId):\\n                CancelPendingOrders(e,tradeType)\\n        else:\\n            if(mode == 0 or (abs(tradePrice - prePrice) > maxSpace)):\\n                orderI",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " - prePrice) > maxSpace)):\\n                orderId = null\\n            order = StripOrders(e,orderId)\\n            if(not order):\\n                orderId = null\\n        Sleep(retryDelay)\\n    if(dealAmount <= 0):\\n        Log(\\\"交易失败--TradeType:\\\",\\\"buy\\\" if tradeType == ORDER_TYPE_BUY else \\\"sell\\\",\\\"  ,diffMoney:\\\",diffMoney,\\\"  ,dealAmount\\\",dealAmount,\\\"  ,doAmount\\\",doAmount)\\n        return null\\n    \\n    ret = {'price': _N(diffMoney/dealAmount,4),'amount':dealAmount}\\n    return ret\\n    # 调用时 这样写",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "amount':dealAmount}\\n    return ret\\n    # 调用时 这样写  ret['price'] 、 ret['amount']\\n\\ndef _Buy(e = exchange,amount = 0):\\n    if isFirstCheck:\\n        CheckVersion()\\n    if (type(e) == typeOfstr(\\\"int\\\") or type(e) == typeOfstr(\\\"float\\\")):\\n        amount = e\\n        e = exchange\\n    return Trade(e,ORDER_TYPE_BUY,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\\n\\ndef _Sell(e = exchange,amount = 0):\\n    if isFirstCheck:\\n        CheckVersion()\\n    if (type(e) == typeOfstr(\\\"int\\\") or type(e) == ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  if (type(e) == typeOfstr(\\\"int\\\") or type(e) == typeOfstr(\\\"float\\\")):\\n        amount = e\\n        e = exchange\\n    return Trade(e,ORDER_TYPE_SELL,amount,OpMode,SlidePrice,MaxAmount,MaxSpace,RetryDelay)\\n\\ndef _CancelPendingOrders(e = exchange,orderType = \\\"\\\"):\\n    if isFirstCheck:\\n        CheckVersion()\\n    return CancelPendingOrders(e,orderType)\\n\\ndef _GetAccount(e = exchange):\\n    if isFirstCheck:\\n        CheckVersion()\\n    return _C(e.GetAccount)\\n\\n_MACalcMethod = [TA.EMA,TA.MA][MAType]\\nIn",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "unt)\\n\\n_MACalcMethod = [TA.EMA,TA.MA][MAType]\\nInterval = 200\\ndef Cross(a,b):\\n    if isFirstCheck:\\n        CheckVersion()\\n    crossNum = 0\\n    arr1 = []\\n    arr2 = []\\n    if type(a) == typeOfstr(\\\"list\\\") and type(b) == typeOfstr(\\\"list\\\"):\\n        arr1 = a\\n        arr2 = b\\n    else:\\n        records = null\\n        while True:\\n            records = exchange.GetRecords()\\n            if records and len(records) > a and len(records) > b:\\n                break\\n            Sleep(Interval)\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        break\\n            Sleep(Interval)\\n        arr1 = _MACalcMethod(records,a)\\n        arr2 = _MACalcMethod(records,b)\\n    if len(arr1) != len(arr2):\\n        raise Exception(\\\"array length not equal\\\")\\n    for i in range(len(arr1) - 1,-1,-1):\\n        if (type(arr1[i]) != typeOfstr(\\\"int\\\") and type(arr1[i]) != typeOfstr(\\\"float\\\")) or (type(arr2[i]) != typeOfstr(\\\"int\\\") and type(arr2[i]) != typeOfstr(\\\"float\\\")):\\n            break\\n        if arr1[i] < arr2[i] :\\n            if crossNum > 0 :\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1[i] < arr2[i] :\\n            if crossNum > 0 :\\n                break\\n            crossNum -= 1\\n        elif arr1[i] > arr2[i] :\\n            if crossNum < 0 :\\n                break\\n            crossNum += 1\\n        else:\\n            break\\n    return crossNum\"\n \n\n    \"strategy_56\",\n    \"python\\n# -*- coding: utf-8 -*-\\nimport time\\nimport json\\n\\ntry:\\n    import md5\\n    import urllib2\\n    from urllib import urlencode\\nexcept:\\n    import hashlib as md5\\n    import urllib.request as urllib2\\n    f",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s md5\\n    import urllib.request as urllib2\\n    from urllib.parse import urlencode\\n\\ndef api(method, *args):\\n    d = {\\n        'version': '1.0',\\n        'access_key': accessKey,\\n        'method': method,\\n        'args': json.dumps(list(args)),\\n        'nonce': int(time.time() * 1000),\\n        }\\n\\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1',",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "oads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\\n\\nRobotParams = json.loads(strRobotParams)\\n\\ndef main():\\n    global RobotParams \\n    arrParams = []\\n    nowDay = 0\\n    strPush = \\\"\\\"\\n    if isPushMsg:\\n        strPush = \\\"@\\\"\\n\\n    for i in range(len(RobotParams)):\\n        param = {}\\n        arr = RobotParams[i].split(\\\",\\\")\\n        if len(arr) != 2:\\n            raise Exception(\\\"字符串配置错误：分隔符号,\\\")\\n        param[\\\"id\\\"] = arr[0]\\n        par",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "号,\\\")\\n        param[\\\"id\\\"] = arr[0]\\n        param[\\\"isProcessOpenThisDay\\\"] = False\\n        param[\\\"isProcessCloseThisDay\\\"] = False\\n\\n        arr = arr[1].split(\\\"-\\\")\\n        if len(arr) != 2:\\n            raise Exception(\\\"字符串配置错误：分隔符号-\\\")\\n\\n        begin = arr[0]\\n        arrBegin = begin.split(\\\":\\\")\\n        if len(arrBegin) != 3:\\n            raise Exception(\\\"字符串配置错误：起始时间分隔符号:\\\")\\n        \\n        param[\\\"begin\\\"] = {}\\n        param[\\\"begin\\\"][\\\"hour\\\"] = float(arrBegin[0])\\n        param[\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"][\\\"hour\\\"] = float(arrBegin[0])\\n        param[\\\"begin\\\"][\\\"min\\\"] = float(arrBegin[1])\\n        param[\\\"begin\\\"][\\\"sec\\\"] = float(arrBegin[2])\\n\\n        end = arr[1]\\n        arrEnd = end.split(\\\":\\\")\\n        if len(arrEnd) != 3:\\n            raise Exception(\\\"字符串配置错误：结束时间分隔符号:\\\")            \\n        \\n        param[\\\"end\\\"] = {}\\n        param[\\\"end\\\"][\\\"hour\\\"] = float(arrEnd[0])\\n        param[\\\"end\\\"][\\\"min\\\"] = float(arrEnd[1])\\n        param[\\\"end\\\"][\\\"sec\\\"] = float(arrEnd[2])\\n        arrParam",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d\\\"][\\\"sec\\\"] = float(arrEnd[2])\\n        arrParams.append(param)\\n\\n    # 测试\\n    Log(\\\"输出参数\\\", arrParams, \\\"#FF0000\\\")  \\n\\n    while True:\\n        nowTime = time.localtime(time.time())\\n        nowHour = nowTime.tm_hour \\n        nowMin = nowTime.tm_min\\n        nowSec = nowTime.tm_sec\\n        \\n        tbl = {\\n            \\\"type\\\" : \\\"table\\\", \\n            \\\"title\\\" : \\\"msg\\\", \\n            \\\"cols\\\" : [\\\"id\\\", \\\"begin\\\", \\\"end\\\", \\\"今天是否执行过启动\\\", \\\"今天是否执行过停止\\\"],\\n            \\\"rows\\\" : []\\n        }\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "否执行过停止\\\"],\\n            \\\"rows\\\" : []\\n        }\\n\\n        for i in range(len(arrParams)):\\n            tbl[\\\"rows\\\"].append([arrParams[i][\\\"id\\\"], json.dumps(arrParams[i][\\\"begin\\\"]), json.dumps(arrParams[i][\\\"end\\\"]), arrParams[i][\\\"isProcessOpenThisDay\\\"], arrParams[i][\\\"isProcessCloseThisDay\\\"]])\\n            if nowDay != nowTime.tm_mday:\\n                arrParams[i][\\\"isProcessOpenThisDay\\\"] = False\\n                arrParams[i][\\\"isProcessCloseThisDay\\\"] = False\\n\\n            if arrParams[i][\\\"isPr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y\\\"] = False\\n\\n            if arrParams[i][\\\"isProcessOpenThisDay\\\"] == False:\\n                if nowTime.tm_hour == arrParams[i][\\\"begin\\\"][\\\"hour\\\"] and nowTime.tm_min >= arrParams[i][\\\"begin\\\"][\\\"min\\\"] and nowTime.tm_sec >= arrParams[i][\\\"begin\\\"][\\\"sec\\\"]:\\n                    ret = api('RestartRobot', int(arrParams[i][\\\"id\\\"]))                    \\n                    arrParams[i][\\\"isProcessOpenThisDay\\\"] = True\\n                    Log(\\\"机器人ID:\\\", arrParams[i][\\\"id\\\"], \\\"执行启动，请登录平台检查是否启动成功\\\", \\\"扩展",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "arrParams[i][\\\"id\\\"], \\\"执行启动，请登录平台检查是否启动成功\\\", \\\"扩展API返回值：\\\", ret, strPush)\\n\\n            if arrParams[i][\\\"isProcessCloseThisDay\\\"] == False:\\n                if nowTime.tm_hour == arrParams[i][\\\"end\\\"][\\\"hour\\\"] and nowTime.tm_min >= arrParams[i][\\\"end\\\"][\\\"min\\\"] and nowTime.tm_sec >= arrParams[i][\\\"end\\\"][\\\"sec\\\"]:\\n                    ret = api('StopRobot', int(arrParams[i][\\\"id\\\"]))\\n                    arrParams[i][\\\"isProcessCloseThisDay\\\"] = True\\n                    Log(\\\"机器人ID:\\\", arrParams[i][\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                   Log(\\\"机器人ID:\\\", arrParams[i][\\\"id\\\"], \\\"执行停止，请登录平台检查是否停止成功\\\", \\\"扩展API返回值：\\\", ret, strPush)\\n        \\n        if nowDay != nowTime.tm_mday:\\n            nowDay = nowTime.tm_mday\\n\\n        LogStatus(_D(), nowTime, \\\"\\\\n`\\\" + json.dumps(tbl) + \\\"`\\\")\\n        Sleep(500)\",\n    \"策略名称: robotCtrl教学策略\\n\\nimport time\\nimport json\\n\\ntry:\\n    import md5\\n    import urllib2\\n    from urllib import urlencode\\nexcept:\\n    import hashlib as md5\\n    import urllib.request as urllib2\\n    from urllib",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " import urllib.request as urllib2\\n    from urllib.parse import urlencode\\n\\ndef api(method, *args):\\n    d = {\\n        'version': '1.0',\\n        'access_key': accessKey,\\n        'method': method,\\n        'args': json.dumps(list(args)),\\n        'nonce': int(time.time() * 1000),\\n        }\\n\\n    d['sign'] = md5.md5(('%s|%s|%s|%d|%s' % (d['version'], d['method'], d['args'], d['nonce'], secretKey)).encode('utf-8')).hexdigest()\\n    return json.loads(urllib2.urlopen('https://www.fmz.com/api/v1', urlencode",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "b2.urlopen('https://www.fmz.com/api/v1', urlencode(d).encode('utf-8')).read().decode('utf-8'))\\n\\nRobotParams = json.loads(strRobotParams)\\n\\ndef main():\\n    global RobotParams \\n    arrParams = []\\n    nowDay = 0\\n    strPush = \\\"\\\"\\n    if isPushMsg:\\n        strPush = \\\"@\\\"\\n\\n    for i in range(len(RobotParams)):\\n        param = {}\\n        arr = RobotParams[i].split(\\\",\\\")\\n        if len(arr) != 2:\\n            raise Exception(\\\"字符串配置错误：分隔符号,\\\")\\n        param[\\\"id\\\"] = arr[0]\\n        param[\\\"isPro",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     param[\\\"id\\\"] = arr[0]\\n        param[\\\"isProcessOpenThisDay\\\"] = False\\n        param[\\\"isProcessCloseThisDay\\\"] = False\\n\\n        arr = arr[1].split(\\\"-\\\")\\n        if len(arr) != 2:\\n            raise Exception(\\\"字符串配置错误：分隔符号-\\\")\\n\\n        begin = arr[0]\\n        arrBegin = begin.split(\\\":\\\")\\n        if len(arrBegin) != 3:\\n            raise Exception(\\\"字符串配置错误：起始时间分隔符号:\\\")\\n        \\n        param[\\\"begin\\\"] = {}\\n        param[\\\"begin\\\"][\\\"hour\\\"] = float(arrBegin[0])\\n        param[\\\"begin\\\"][",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"] = float(arrBegin[0])\\n        param[\\\"begin\\\"][\\\"min\\\"] = float(arrBegin[1])\\n        param[\\\"begin\\\"][\\\"sec\\\"] = float(arrBegin[2])\\n\\n        end = arr[1]\\n        arrEnd = end.split(\\\":\\\")\\n        if len(arrEnd) != 3:\\n            raise Exception(\\\"字符串配置错误：结束时间分隔符号:\\\")            \\n        \\n        param[\\\"end\\\"] = {}\\n        param[\\\"end\\\"][\\\"hour\\\"] = float(arrEnd[0])\\n        param[\\\"end\\\"][\\\"min\\\"] = float(arrEnd[1])\\n        param[\\\"end\\\"][\\\"sec\\\"] = float(arrEnd[2])\\n        arrParams.append(p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"] = float(arrEnd[2])\\n        arrParams.append(param)\\n\\n    # 测试\\n    Log(\\\"输出参数\\\", arrParams, \\\"#FF0000\\\")  \\n\\n    while True:\\n        nowTime = time.localtime(time.time())\\n        nowHour = nowTime.tm_hour \\n        nowMin = nowTime.tm_min\\n        nowSec = nowTime.tm_sec\\n        \\n        tbl = {\\n            \\\"type\\\" : \\\"table\\\", \\n            \\\"title\\\" : \\\"msg\\\", \\n            \\\"cols\\\" : [\\\"id\\\", \\\"begin\\\", \\\"end\\\", \\\"今天是否执行过启动\\\", \\\"今天是否执行过停止\\\"],\\n            \\\"rows\\\" : []\\n        }\\n\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            \\\"rows\\\" : []\\n        }\\n\\n        for i in range(len(arrParams)):\\n            tbl[\\\"rows\\\"].append([arrParams[i][\\\"id\\\"], json.dumps(arrParams[i][\\\"begin\\\"]), json.dumps(arrParams[i][\\\"end\\\"]), arrParams[i][\\\"isProcessOpenThisDay\\\"], arrParams[i][\\\"isProcessCloseThisDay\\\"]])\\n            if nowDay != nowTime.tm_mday:\\n                arrParams[i][\\\"isProcessOpenThisDay\\\"] = False\\n                arrParams[i][\\\"isProcessCloseThisDay\\\"] = False\\n\\n            if arrParams[i][\\\"isProcessOpenT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "se\\n\\n            if arrParams[i][\\\"isProcessOpenThisDay\\\"] == False:\\n                if nowTime.tm_hour == arrParams[i][\\\"begin\\\"][\\\"hour\\\"] and nowTime.tm_min >= arrParams[i][\\\"begin\\\"][\\\"min\\\"] and nowTime.tm_sec >= arrParams[i][\\\"begin\\\"][\\\"sec\\\"]:\\n                    ret = api('RestartRobot', int(arrParams[i][\\\"id\\\"]))                    \\n                    arrParams[i][\\\"isProcessOpenThisDay\\\"] = True\\n                    Log(\\\"机器人ID:\\\", arrParams[i][\\\"id\\\"], \\\"执行启动，请登录平台检查是否启动成功\\\", \\\"扩展API返回值：\\\",",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "i][\\\"id\\\"], \\\"执行启动，请登录平台检查是否启动成功\\\", \\\"扩展API返回值：\\\", ret, strPush)\\n\\n            if arrParams[i][\\\"isProcessCloseThisDay\\\"] == False:\\n                if nowTime.tm_hour == arrParams[i][\\\"end\\\"][\\\"hour\\\"] and nowTime.tm_min >= arrParams[i][\\\"end\\\"][\\\"min\\\"] and nowTime.tm_sec >= arrParams[i][\\\"end\\\"][\\\"sec\\\"]:\\n                    ret = api('StopRobot', int(arrParams[i][\\\"id\\\"]))\\n                    arrParams[i][\\\"isProcessCloseThisDay\\\"] = True\\n                    Log(\\\"机器人ID:\\\", arrParams[i][\\\"id\\\"], \\\"执",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         Log(\\\"机器人ID:\\\", arrParams[i][\\\"id\\\"], \\\"执行停止，请登录平台检查是否停止成功\\\", \\\"扩展API返回值：\\\", ret, strPush)\\n        \\n        if nowDay != nowTime.tm_mday:\\n            nowDay = nowTime.tm_mday\\n\\n        LogStatus(_D(), nowTime, \\\"\\\\n`\\\" + json.dumps(tbl) + \\\"`\\\")\\n        Sleep(500)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/184600\\n\\n> Last Modified\\n\\n2020-05-08 10:47:52\"\n \n\n    \"strategy_57\",\n    \"python\\n#!python2\\n# -*- coding:utf-8 -*-\\nfrom time import sleep\\n\\nQ3 = 0.5\\ntax = 0.0015   #交易费率，0.15%",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "port sleep\\n\\nQ3 = 0.5\\ntax = 0.0015   #交易费率，0.15%\\n\\n\\nclass fmz_market():\\n\\n    # 基础行情数据处理,根据传入的交易对，获取数据，返回行情dict\\n    def basic_data_handle(self, pair):\\n        pair_depth = {'sale_volume': 0, 'sale_price': 0, 'buy_volume': 0, 'buy_price': 0}\\n        depth = exchanges[pair].GetDepth()\\n        asks_infor = depth.Asks[0]\\n        bids_infor = depth.Bids[0]\\n        pair_depth['sale_volume'] = asks_infor.Amount\\n        pair_depth['sale_price'] = asks_infor.Price\\n        pair_depth['buy_volume'] = bids",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "for.Price\\n        pair_depth['buy_volume'] = bids_infor.Amount\\n        pair_depth['buy_price'] = bids_infor.Price\\n        #Log(pair_depth)\\n        return pair_depth\\n\\n\\n\\n    #进行参数计算\\n    def profit_calculation(self):\\n        profit_obtain = 0\\n        #先获取行情数据\\n        P1_depth = self.basic_data_handle(0)\\n        P2_depth = self.basic_data_handle(1)\\n        P3_depth = self.basic_data_handle(2)\\n        #买一价格整理\\n        p1_sale_price =float(P1_depth['sale_price'])\\n        p1_buy_price = float(P1_de",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'sale_price'])\\n        p1_buy_price = float(P1_depth['buy_price'])\\n        p2_sale_price = float(P2_depth['sale_price'])\\n        p2_buy_price = float(P2_depth['buy_price'])\\n        p3_sale_price = float(P3_depth['sale_price'])\\n        p3_buy_price = float(P3_depth['buy_price'])\\n\\n        #深度数据整理\\n        p1_sale_volume = float(P1_depth['sale_volume'])\\n        p1_buy_volume = float(P1_depth['buy_volume'])\\n        p2_sale_volume = float(P2_depth['sale_volume'])\\n        p2_buy_volume = float(P2_depth[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "volume'])\\n        p2_buy_volume = float(P2_depth['buy_volume'])\\n        p3_sale_volume = float(P3_depth['sale_volume'])\\n        p3_buy_volume = float(P3_depth['buy_volume'])\\n        # 进行数据分析，正向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_ETH,卖出EOS，买入BTC，买入EOS（卖，买，买）\\n        if p1_buy_price / p2_sale_price > p3_sale_price:\\n            #总的手续费计算\\n            tax_account = (p1_buy_price + p3_sale_price*p2_sale_price + p3_sale_price*p2_sale_price) * Q3 * tax\\n            #总的获利计算\\n            profit_sum = (p1_buy_pr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      #总的获利计算\\n            profit_sum = (p1_buy_price / p2_sale_price - p3_sale_price) * Q3 * p2_buy_price\\n            Log('P1;',p1_buy_price,',P2:',p2_sale_price,',P3:',p3_sale_price,',tax_account:',tax_account,',profit_sum:',profit_sum)\\n            #如果总的获利 < 手续费，则直接退出\\n            if profit_sum < tax_account:\\n                return 0\\n            p1_accout_receive = p1_buy_price * Q3 * (1 - tax) #卖出EOS得到usdt，同时减去税\\n            p3_accout_used = p3_sale_price * Q3 * (1 + tax)  #计算买入Q3 EOS的时候,需要的BTC\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rice * Q3 * (1 + tax)  #计算买入Q3 EOS的时候,需要的BTC\\n            p2_accout_used =  p2_sale_price *  p3_accout_used * (1 + tax) #计算买入的BTC 需要耗费的USDT数量\\n            #获利总量计算\\n            profit_obtain = p1_accout_receive - p2_accout_used  #卖EOS得到的usdt - 买入同样数量的EOS需要的USDT\\n            return profit_obtain\\n\\n        # 进行数据分析，逆向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_BTC,卖出EOS->BTC，卖出BTC，买入EOS（卖，卖，买）\\n        if p1_buy_price / p2_sale_price < p3_sale_price:\\n            # 总的手续费计算\\n            tax_account = (p3_buy_price * p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "手续费计算\\n            tax_account = (p3_buy_price * p2_buy_price + p3_buy_price * p2_buy_price + p1_sale_price) * Q3 * tax\\n            # 总的获利计算\\n            profit_sum = (p3_sale_price - p1_buy_price / p2_sale_price) * Q3 * p2_buy_price\\n            Log('P1;', p1_buy_price, ',P2:', p2_sale_price, ',P3:', p3_sale_price, ',tax_account:', tax_account, ',profit_sum:', profit_sum)\\n            # 如果总的获利 < 手续费，则直接退出\\n            if profit_sum < tax_account:\\n                return 0\\n            p3_accout_receive = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        return 0\\n            p3_accout_receive = p3_buy_price * Q3 * (1 - tax)  # 卖出EOS得到BTC，同时减去税\\n            p1_accout_used = p1_sale_price * Q3 * (1 + tax)  # 计算买入Q3 EOS的时候,需要的USDT\\n            p2_accout_receive = p2_buy_price * p3_accout_receive * (1 - tax)  # 计算卖出的BTC 得到的USDT数量\\n            # 获利总量计算\\n            profit_obtain = p2_accout_receive - p1_accout_used   #卖出的BTC得到的usdt - 买入EOS锁需要消耗的usdt\\n            return profit_obtain\\n\\n        return 0\\n\\n    #循环计算\\n    def profit_calculation_cycle(self",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    #循环计算\\n    def profit_calculation_cycle(self):\\n        usdt_remain = 0\\n        for i in range(10000):\\n            profit_obtain = self.profit_calculation()\\n            usdt_remain = usdt_remain + profit_obtain\\n            if profit_obtain > 0:\\n                Log(u'EOS:',Q3,u'.....USDT:',usdt_remain)\\n\\n\\n\\ndef main():\\n    Log(exchange.GetAccount())\\n    Log(\\\"测试\\\")\\n    fmz_market_instances = fmz_market()\\n    fmz_market_instances.profit_calculation_cycle()\\n    # fmz_market_instances.basic_da",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ation_cycle()\\n    # fmz_market_instances.basic_data_handle(0)\",\n    \"策略名称: 三角套利-基础版\\n\\nfrom time import sleep\\n\\nQ3 = 0.5\\ntax = 0.0015   #交易费率，0.15%\\n\\n\\nclass fmz_market():\\n\\n    # 基础行情数据处理,根据传入的交易对，获取数据，返回行情dict\\n    def basic_data_handle(self, pair):\\n        pair_depth = {'sale_volume': 0, 'sale_price': 0, 'buy_volume': 0, 'buy_price': 0}\\n        depth = exchanges[pair].GetDepth()\\n        asks_infor = depth.Asks[0]\\n        bids_infor = depth.Bids[0]\\n        pair_depth['sale_volume'] = asks_infor.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]\\n        pair_depth['sale_volume'] = asks_infor.Amount\\n        pair_depth['sale_price'] = asks_infor.Price\\n        pair_depth['buy_volume'] = bids_infor.Amount\\n        pair_depth['buy_price'] = bids_infor.Price\\n        #Log(pair_depth)\\n        return pair_depth\\n\\n\\n\\n    #进行参数计算\\n    def profit_calculation(self):\\n        profit_obtain = 0\\n        #先获取行情数据\\n        P1_depth = self.basic_data_handle(0)\\n        P2_depth = self.basic_data_handle(1)\\n        P3_depth = self.basic_data_handle(2)\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       P3_depth = self.basic_data_handle(2)\\n        #买一价格整理\\n        p1_sale_price =float(P1_depth['sale_price'])\\n        p1_buy_price = float(P1_depth['buy_price'])\\n        p2_sale_price = float(P2_depth['sale_price'])\\n        p2_buy_price = float(P2_depth['buy_price'])\\n        p3_sale_price = float(P3_depth['sale_price'])\\n        p3_buy_price = float(P3_depth['buy_price'])\\n\\n        #深度数据整理\\n        p1_sale_volume = float(P1_depth['sale_volume'])\\n        p1_buy_volume = float(P1_depth['buy_volume'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       p1_buy_volume = float(P1_depth['buy_volume'])\\n        p2_sale_volume = float(P2_depth['sale_volume'])\\n        p2_buy_volume = float(P2_depth['buy_volume'])\\n        p3_sale_volume = float(P3_depth['sale_volume'])\\n        p3_buy_volume = float(P3_depth['buy_volume'])\\n        # 进行数据分析，正向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_ETH,卖出EOS，买入BTC，买入EOS（卖，买，买）\\n        if p1_buy_price / p2_sale_price > p3_sale_price:\\n            #总的手续费计算\\n            tax_account = (p1_buy_price + p3_sale_price*p2_sale_price",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ount = (p1_buy_price + p3_sale_price*p2_sale_price + p3_sale_price*p2_sale_price) * Q3 * tax\\n            #总的获利计算\\n            profit_sum = (p1_buy_price / p2_sale_price - p3_sale_price) * Q3 * p2_buy_price\\n            Log('P1;',p1_buy_price,',P2:',p2_sale_price,',P3:',p3_sale_price,',tax_account:',tax_account,',profit_sum:',profit_sum)\\n            #如果总的获利 < 手续费，则直接退出\\n            if profit_sum < tax_account:\\n                return 0\\n            p1_accout_receive = p1_buy_price * Q3 * (1 - tax) #卖出EOS得到",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t_receive = p1_buy_price * Q3 * (1 - tax) #卖出EOS得到usdt，同时减去税\\n            p3_accout_used = p3_sale_price * Q3 * (1 + tax)  #计算买入Q3 EOS的时候,需要的BTC\\n            p2_accout_used =  p2_sale_price *  p3_accout_used * (1 + tax) #计算买入的BTC 需要耗费的USDT数量\\n            #获利总量计算\\n            profit_obtain = p1_accout_receive - p2_accout_used  #卖EOS得到的usdt - 买入同样数量的EOS需要的USDT\\n            return profit_obtain\\n\\n        # 进行数据分析，逆向交易费率，P1:EOS_USDT,P2:BTC_USDT,P3:EOS_BTC,卖出EOS->BTC，卖出BTC，买入EOS（卖，卖，买）\\n        if p1_buy_price ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "->BTC，卖出BTC，买入EOS（卖，卖，买）\\n        if p1_buy_price / p2_sale_price < p3_sale_price:\\n            # 总的手续费计算\\n            tax_account = (p3_buy_price * p2_buy_price + p3_buy_price * p2_buy_price + p1_sale_price) * Q3 * tax\\n            # 总的获利计算\\n            profit_sum = (p3_sale_price - p1_buy_price / p2_sale_price) * Q3 * p2_buy_price\\n            Log('P1;', p1_buy_price, ',P2:', p2_sale_price, ',P3:', p3_sale_price, ',tax_account:', tax_account, ',profit_sum:', profit_sum)\\n            # 如果总的获利 < 手续费，则直接退出\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "', profit_sum)\\n            # 如果总的获利 < 手续费，则直接退出\\n            if profit_sum < tax_account:\\n                return 0\\n            p3_accout_receive = p3_buy_price * Q3 * (1 - tax)  # 卖出EOS得到BTC，同时减去税\\n            p1_accout_used = p1_sale_price * Q3 * (1 + tax)  # 计算买入Q3 EOS的时候,需要的USDT\\n            p2_accout_receive = p2_buy_price * p3_accout_receive * (1 - tax)  # 计算卖出的BTC 得到的USDT数量\\n            # 获利总量计算\\n            profit_obtain = p2_accout_receive - p1_accout_used   #卖出的BTC得到的usdt - 买入EOS锁需要消耗的usdt\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cout_used   #卖出的BTC得到的usdt - 买入EOS锁需要消耗的usdt\\n            return profit_obtain\\n\\n        return 0\\n\\n    #循环计算\\n    def profit_calculation_cycle(self):\\n        usdt_remain = 0\\n        for i in range(10000):\\n            profit_obtain = self.profit_calculation()\\n            usdt_remain = usdt_remain + profit_obtain\\n            if profit_obtain > 0:\\n                Log(u'EOS:',Q3,u'.....USDT:',usdt_remain)\\n\\n\\n\\ndef main():\\n    Log(exchange.GetAccount())\\n    Log(\\\"测试\\\")\\n    fmz_market_instances = fm",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "))\\n    Log(\\\"测试\\\")\\n    fmz_market_instances = fmz_market()\\n    fmz_market_instances.profit_calculation_cycle()\\n    # fmz_market_instances.basic_data_handle(0)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/151145\\n\\n> Last Modified\\n\\n2019-06-11 14:24:17\"\n \n\n    \"strategy_58\",\n    \"python\\nimport json\\n\\n# 对合约进行止盈止损   cangType=0默认逐仓  =1全仓\\ndef zhiyingzhisun(ex, amount, directionStr, zhiying, zhisun, cangType = 0):\\n    if ex.GetName().find('OK') >= 0 :\\n        # okex\\n        return okexSwap(ex, amou",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        # okex\\n        return okexSwap(ex, amount, directionStr, zhiying, zhisun)\\n    elif ex.GetName().find('Huobi') >= 0 :\\n        # huobi\\n        return huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType)\\n    elif ex.GetName().find('Binance') >= 0 :\\n        # bian\\n        return bianSwap(ex, amount, directionStr, zhiying, zhisun)\\n    else:\\n        return False\\n\\n# 发送请求\\ndef AsynIo(ex, paramList):\\n        if (len(paramList) == 3):\\n            arrRoutine = ex.Go(\\\"IO\\\", paramList[0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            arrRoutine = ex.Go(\\\"IO\\\", paramList[0], paramList[1], paramList[2])\\n        elif (len(paramList) == 4):\\n            arrRoutine = ex.Go(\\\"IO\\\", paramList[0], paramList[1], paramList[2], paramList[3])\\n        elif (len(paramList) == 5):\\n            arrRoutine = ex.Go(\\\"IO\\\", paramList[0], paramList[1], paramList[2], paramList[3], paramList[4])\\n        data, ok = arrRoutine.wait()\\n        return data\\n# 火币合约\\ndef huobiSwap(ex, amount, directionStr, zhiying, zhisun, cangType):\\n    instrument",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "onStr, zhiying, zhisun, cangType):\\n    instrument_id = ex.GetCurrency().replace('_',\\\"-\\\")\\n    # 根据全仓或逐仓 与 U本位或币本位，设置请求url\\n    if instrument_id.find('USDT') >= 0 :\\n        if cangType == 0:\\n            url = \\\"/linear-swap-api/v1/swap_tpsl_order\\\"\\n        elif cangType == 1:\\n            url = '/linear-swap-api/v1/swap_cross_tpsl_order'\\n        else:\\n            return False\\n    elif instrument_id.find('USD') >= 0 :\\n        url = \\\"/swap-api/v1/swap_tpsl_order\\\"\\n    else:\\n        return False\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "p_tpsl_order\\\"\\n    else:\\n        return False\\n    # 发送请求\\n    data = AsynIo(ex, ['api', 'POST', url, '', json.dumps({\\n        \\\"contract_code\\\": instrument_id,\\n        \\\"direction\\\": directionStr,\\n        \\\"volume\\\" : amount,\\n        \\\"tp_order_price\\\": zhiying,\\n        \\\"tp_trigger_price\\\": zhiying,\\n        \\\"sl_trigger_price\\\": zhisun,\\n        \\\"sl_order_price\\\": zhisun,\\n    })])\\n    if data[\\\"status\\\"] == 'ok':\\n        return True\\n    else:\\n        return False\\n\\n# 币安合约\\ndef bianSwap(ex, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        return False\\n\\n# 币安合约\\ndef bianSwap(ex, amount, directionStr, zhiying, zhisun):\\n    instrument_id = ex.GetCurrency().replace('_',\\\"\\\")\\n    # U本位或币本位，设置请求url\\n    if instrument_id.find('USDT') >= 0 :\\n        url = \\\"/fapi/v1/order\\\"\\n    elif instrument_id.find('USD') >= 0 :\\n        url = '/dapi/v1/order'\\n    else:\\n        return False\\n    # 止损\\n    zhisunData = AsynIo(ex, ['api', 'POST', url , '', json.dumps({\\n        \\\"symbol\\\": instrument_id,\\n        \\\"side\\\": directionStr,\\n        \\\"t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_id,\\n        \\\"side\\\": directionStr,\\n        \\\"type\\\": \\\"STOP\\\",\\n        \\\"quantity\\\": amount,\\n        \\\"price\\\": zhisun,\\n        \\\"stopPrice\\\": zhisun,\\n        \\\"timestamp\\\": str(int(round(time.time() * 1000)))\\n    })])\\n    if int(zhisunData['stopPrice']) != int(zhisun):\\n        return False\\n    # 止盈\\n    zhiyingData = AsynIo(ex, ['api', 'POST', url , '', json.dumps({\\n        \\\"symbol\\\": instrument_id,\\n        \\\"side\\\": direction,\\n        \\\"type\\\": \\\"TAKE_PROFIT\\\",\\n        \\\"quantity\\\": amoun",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\\": \\\"TAKE_PROFIT\\\",\\n        \\\"quantity\\\": amount,\\n        \\\"price\\\": zhiying,\\n        \\\"stopPrice\\\": zhiying,\\n        \\\"timestamp\\\": str(int(round(time.time() * 1000)))\\n    })])\\n    if int(zhiyingData['stopPrice']) != int(zhiying):\\n        return False\\n    return True\\n\\n\\n# 欧易合约\\ndef okexSwap(ex, amount, directionStr, zhiying, zhisun):\\n    instrument_id = ex.GetCurrency().replace('_',\\\"-\\\") + '-SWAP'\\n    # 获取仓位方向\\n    if directionStr == 'buy':\\n        direction = '4'\\n    elif directionStr == ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        direction = '4'\\n    elif directionStr == 'sell':\\n        direction = '3'\\n    else:\\n        return False\\n    data =  AsynIo(ex, ['api', 'POST', '/v1/order/orders/place', '', json.dumps({\\n        \\\"instrument_id\\\": instrument_id,\\n        \\\"type\\\": direction,\\n        \\\"order_type\\\": '5',\\n        \\\"size\\\": amount,\\n        \\\"tp_trigger_price\\\": zhiying,\\n        \\\"tp_price\\\": zhiying,\\n        \\\"sl_trigger_price\\\": zhisun,\\n        \\\"sl_price\\\": zhisun\\n    })])\\n    if data[\\\"error_code\\\"] == ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " zhisun\\n    })])\\n    if data[\\\"error_code\\\"] == \\\"0\\\":\\n        return True\\n    else:\\n        return False\\n    \\next.zhiyingzhisun = zhiyingzhisun\",\n    \"策略名称: 三大交易所止盈止损集成类库\\n\\ndef zhiyingzhisun(ex, amount, directionStr, zhiying, zhisun, cangType = 0):\\n    if ex.GetName().find('OK') >= 0 :\\n        # okex\\n        return okexSwap(ex, amount, directionStr, zhiying, zhisun)\\n    elif ex.GetName().find('Huobi') >= 0 :\\n        # huobi\\n        return huobiSwap(ex, amount, directionStr, zhiying, zhisun, c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "iSwap(ex, amount, directionStr, zhiying, zhisun, cangType)\\n    elif ex.GetName().find('Binance') >= 0 :\\n        # bian\\n        return bianSwap(ex, amount, directionStr, zhiying, zhisun)\\n    else:\\n        return False\"\n \n\n    \"strategy_59\",\n    \"python\\ndef main():\\n    # 设置交易所地址\\n    exchanges[0].SetBase(\\\"\\\")\\n    exchanges[1].SetBase(\\\"\\\")\\n    Log(\\\"等待指令\\\")\\n    while True:\\n        LogStatus(_D())\\n        cmd = GetCommand()\\n        if cmd:\\n            arr = cmd.split(\\\":\\\")\\n            # 交易次数\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      arr = cmd.split(\\\":\\\")\\n            # 交易次数\\n            for i in range(trade_num):\\n                Account0 = exchanges[0].GetAccount()\\n                Account1 = exchanges[1].GetAccount()\\n                # Log(\\\"Account0-usdt\\\", Account0[\\\"Balance\\\"], \\\"Account0-DEC\\\", Account0[\\\"Stocks\\\"])\\n                # Log(\\\"Account 1-usdt\\\", Account1[\\\"Balance\\\"], \\\"Account1-DEC\\\", Account1[\\\"Stocks\\\"])\\n                # 获取A0和A1的币\\n                A0_stocks = Account0[\\\"Stocks\\\"]\\n                A1_stock",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s = Account0[\\\"Stocks\\\"]\\n                A1_stocks = Account1[\\\"Stocks\\\"]\\n                error = 0\\n                if A0_stocks > A1_stocks:\\n                    Log(\\\"Account0有币\\\")\\n                    # 重置索引\\n                    ex_chang = [exchanges[0], exchanges[1]]\\n                    if abstest(A0_stocks, A1_stocks) == 1:\\n                        break\\n                    else:\\n                        # Log(\\\"可继续交易\\\")\\n                        pass\\n                else:\\n                    Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ss\\n                else:\\n                    Log(\\\"Account1有dec\\\")\\n                    # 重置索引\\n                    ex_chang = [exchanges[1], exchanges[0]]\\n                    if abstest(A0_stocks, A1_stocks) == 1:\\n                        break\\n                    else:\\n                        # Log(\\\"可继续交易\\\")\\n                        pass\\n                # 0索引永远卖出    \\n                ex_chang[0].Sell(pprice, nnum)\\n                # 1索引永远卖出  \\n                ex_chang[1].Buy(pprice, nnum)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           ex_chang[1].Buy(pprice, nnum)\\n                Log(\\\"交易完成\\\",i)\\n                Sleep(5)\\n            if abstest(A0_stocks, A1_stocks) == 1:\\n                break\\n            else:\\n                # Log(\\\"可继续交易\\\")\\n                pass\\n    Log(\\\"运行结束\\\")\\n\\ndef abstest(a, b):\\n    # 简单判断\\n    abs_value = abs(a - b)\\n    # Log(\\\"币种差值:\\\" + str(abs_value))\\n    if abs_value == 0:\\n        Log(\\\"币种不够，请检查\\\")\\n        error = 1\\n    else:\\n        # Log(\\\"可继续交易\\\")\\n        error = 0\\n    return erro",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Log(\\\"可继续交易\\\")\\n        error = 0\\n    return error\",\n    \"策略名称: 交易所对倒刷量对敲互刷\\n\\nexchanges[0].SetBase(\\\"\\\")\\n    exchanges[1].SetBase(\\\"\\\")\\n    Log(\\\"等待指令\\\")\\n    while True:\\n        LogStatus(_D())\\n        cmd = GetCommand()\\n        if cmd:\\n            arr = cmd.split(\\\":\\\")\\n            # 交易次数\\n            for i in range(trade_num):\\n                Account0 = exchanges[0].GetAccount()\\n                Account1 = exchanges[1].GetAccount()\\n                # Log(\\\"Account0-usdt\\\", Account0[\\\"Balance\\\"]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    # Log(\\\"Account0-usdt\\\", Account0[\\\"Balance\\\"], \\\"Account0-DEC\\\", Account0[\\\"Stocks\\\"])\\n                # Log(\\\"Account 1-usdt\\\", Account1[\\\"Balance\\\"], \\\"Account1-DEC\\\", Account1[\\\"Stocks\\\"])\\n                # 获取A0和A1的币\\n                A0_stocks = Account0[\\\"Stocks\\\"]\\n                A1_stocks = Account1[\\\"Stocks\\\"]\\n                error = 0\\n                if A0_stocks > A1_stocks:\\n                    Log(\\\"Account0有币\\\")\\n                    # 重置索引\\n                    ex_chang = [exchanges[0],",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "置索引\\n                    ex_chang = [exchanges[0], exchanges[1]]\\n                    if abstest(A0_stocks, A1_stocks) == 1:\\n                        break\\n                    else:\\n                        # Log(\\\"可继续交易\\\")\\n                        pass\\n                else:\\n                    Log(\\\"Account1有dec\\\")\\n                    # 重置索引\\n                    ex_chang = [exchanges[1], exchanges[0]]\\n                    if abstest(A0_stocks, A1_stocks) == 1:\\n                        break\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ") == 1:\\n                        break\\n                    else:\\n                        # Log(\\\"可继续交易\\\")\\n                        pass\\n                # 0索引永远卖出    \\n                ex_chang[0].Sell(pprice, nnum)\\n                # 1索引永远卖出  \\n                ex_chang[1].Buy(pprice, nnum)\\n                Log(\\\"交易完成\\\",i)\\n                Sleep(5)\\n            if abstest(A0_stocks, A1_stocks) == 1:\\n                break\\n            else:\\n                # Log(\\\"可继续交易\\\")\\n                pass\\n    Log(\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " # Log(\\\"可继续交易\\\")\\n                pass\\n    Log(\\\"运行结束\\\")\\n\\ndef abstest(a, b):\\n    # 简单判断\\n    abs_value = abs(a - b)\\n    # Log(\\\"币种差值:\\\" + str(abs_value))\\n    if abs_value == 0:\\n        Log(\\\"币种不够，请检查\\\")\\n        error = 1\\n    else:\\n        # Log(\\\"可继续交易\\\")\\n        error = 0\\n    return error\\n\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/226845\\n\\n> Last Modified\\n\\n2021-07-14 15:44:40\"\n \n\n    \"strategy_60\",\n    \"python\\n'''backtest\\nstart: 2017-06-26 00:00:00\\nend: 2022-04-6 00:00:00\\nperi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "2017-06-26 00:00:00\\nend: 2022-04-6 00:00:00\\nperiod: 1d\\nbasePeriod: 1h\\nexchanges: [{\\\"eid\\\":\\\"Futures_Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\"}]\\n'''\\ndef main():\\n    exchange.SetMarginLevel(20)\\n    exchange.SetContractType(\\\"swap\\\")\\n    exchange.SetDirection(\\\"buy\\\")\\n    exchange.SetDirection(\\\"sell\\\")\\n    ticker = exchange.GetTicker()\\n    Log(ticker)\\n    \\n    exchange.SetDirection(\\\"buy\\\")\\n    exchange.Buy(ticker[\\\"Last\\\"] /1, 0.001)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.1, 0.001)\\n    exchange.Buy",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "uy(ticker[\\\"Last\\\"] /1.1, 0.001)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.2, 0.002)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.3, 0.002)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.4, 0.003)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.5, 0.003)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.6, 0.003)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.7, 0.005)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.8, 0.005)\\n    exchange.Buy(ticker[\\\"Last\\\"] /1.9, 0.005)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2, 0.005)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.1, 0.008)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.1, 0.008)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.2, 0.008)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.3, 0.008)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.4, 0.008)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.5, 0.008)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.6, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.7, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.8, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /2.9, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st\\\"] /3, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.1, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.2, 0.013)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.3, 0.021)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.4, 0.021)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.5, 0.021) \\n    exchange.Buy(ticker[\\\"Last\\\"] /3.6, 0.021)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.7, 0.021)\\n    exchange.Buy(ticker[\\\"Last\\\"] /3.8, 0.021) \\n    exchange.Buy(ticker[\\\"Last\\\"] /3.9, 0.021) \\n    exchange.Buy(ticker[\\\"Last\\\"] /4.0, 0.034) \\n    exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nge.Buy(ticker[\\\"Last\\\"] /4.0, 0.034) \\n    exchange.Buy(ticker[\\\"Last\\\"] /4.1, 0.034) \\n    exchange.Buy(ticker[\\\"Last\\\"] /4.2, 0.034)\\n    exchange.Buy(ticker[\\\"Last\\\"] /4.3, 0.034) \\n    exchange.Buy(ticker[\\\"Last\\\"] /4.4, 0.034)\\n    exchange.Buy(ticker[\\\"Last\\\"] /4.5, 0.034) \\n    exchange.Buy(ticker[\\\"Last\\\"] /4.6, 0.034)\\n    exchange.Buy(ticker[\\\"Last\\\"] /4.7, 0.034)  \\n    exchange.SetDirection(\\\"sell\\\")\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1, 0.001)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.1, 0.00",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.1, 0.002)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.2, 0.002)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.3, 0.003)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.4, 0.003)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.5, 0.003)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.6, 0.005)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.7, 0.005)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.8, 0.005)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 1.9, 0.005)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2, 0.008)\\n    exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.Sell(ticker[\\\"Last\\\"] * 2, 0.008)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.1, 0.008)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.2, 0.008)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.3, 0.008)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.4, 0.008)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.5, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.6, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.7, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.8, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 2.9, 0.013)\\n    exchange.Sell(tick",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "er[\\\"Last\\\"] * 2.9, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3, 0.013)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.1, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.2, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.3, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.4, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.5, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.6, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.7, 0.021)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.8, 0.034)\\n    exchange.Sell(ticker[\\\"Last\\\"] *",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 3.8, 0.034)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 3.9, 0.034) \\n    exchange.Sell(ticker[\\\"Last\\\"] * 4.0, 0.034)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 4.1, 0.034)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 4.2, 0.034) \\n    exchange.Sell(ticker[\\\"Last\\\"] * 4.3, 0.034)  \\n    exchange.Sell(ticker[\\\"Last\\\"] * 4.4, 0.034)\\n    exchange.Sell(ticker[\\\"Last\\\"] * 4.5, 0.034)  \\n    Log(\\\"orders\\\", exchange.GetOrders())\\n    Sleep(1000)\",\n    \"策略名称: 仓位管理配置思路\\n\\n未找到描述\"\n \n\n    \"strategy_61\",\n    \"python\\n#!Python3\\n\\n\\\"\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\n\n    \"strategy_61\",\n    \"python\\n#!Python3\\n\\n\\\"\\\"\\\"\\n《策略代写》 与 （此程序帮助），致信QQ：35787501\\n\\n企业微信消息推送，用于群自定义机器人\\n同理：修改 data，也可以接入其他软件的 webhook\\n\\\"\\\"\\\"\\n\\nimport requests\\n\\n\\ndef send(text):\\n    headers = {\\n        \\\"Content-Type\\\": \\\"application/json\\\"\\n    }\\n    data = {\\n        \\\"msgtype\\\": \\\"text\\\",\\n        \\\"text\\\": {\\n            \\\"content\\\": text,\\n        }\\n    }\\n    response = requests.post(webhook, headers=headers, json=data)\\n    records = response.json()\\n    return records\\n\\n\\ndef LogQYWX(*",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "onse.json()\\n    return records\\n\\n\\ndef LogQYWX(*args):\\n    text = \\\" \\\".join(args)\\n    Log(text, send(text))\\n\\n\\next.LogQYWX = LogQYWX\",\n    \"策略名称: 企业微信群机器人消息推送\\n\\n未找到描述\"\n \n\n    \"strategy_62\",\n    \"python\\nimport random\\n\\n\\ndef main():\\n    # 获取账户所有未成交订单\\n    Log(\\\"取消所有未成交订单\\\")\\n    orders = _C(exchange.GetOrders)\\n    if len(orders) > 0:\\n        for i in range(len(orders)):\\n            exchange.CancelOrder(orders[i][\\\"Id\\\"])\\n            Sleep(priceInterval*1000)\\n\\n    # 对比账户余额\\n    Log(\\\"获取用户初始化账",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Interval*1000)\\n\\n    # 对比账户余额\\n    Log(\\\"获取用户初始化账户\\\")\\n    initAccount = _C(exchange.GetAccount)\\n    if initAccount[\\\"Balance\\\"] < buyAmount:\\n        Log(\\\"账户余额不足\\\")\\n        return\\n    \\n    #比较单笔购买数量均值*市场买一价是否大于账户余额\\n    ticker = _C(exchange.GetTicker)\\n    if (ticker['Last'] * buyNum) > initAccount['Balance']:\\n        Log(\\\"单次购买均值价格大于账户余额，请调整参数\\\")\\n        return\\n\\n    lastBuyPrice = 0\\n\\n    while (True):\\n        Sleep(priceInterval*1000)\\n        #获取账户信息\\n        account = _C(exchange.GetAccount",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " #获取账户信息\\n        account = _C(exchange.GetAccount)\\n        #获取当下行情\\n        ticker = _C(exchange.GetTicker)\\n        # 上次购买价格不为空，查看订单是否完成，没有完成则取消\\n        if lastBuyPrice > 0:\\n            orders1 = exchange.GetOrders()\\n            if len(orders1) > 0:\\n                for j in range(len(orders1)):\\n                    #计算实际市场委托深度\\n                    if ticker[\\\"Last\\\"] > lastBuyPrice and ((ticker[\\\"Last\\\"] - lastBuyPrice)/lastBuyPrice) > (2* (depthStatus/100)):\\n                        Log(\\\"委托价格偏离过多，最",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s/100)):\\n                        Log(\\\"委托价格偏离过多，最新成交价:\\\",ticker[\\\"Last\\\"],\\\"委托价\\\",lastBuyPrice)\\n                        exchange.CancelOrder(orders1[j][\\\"Id\\\"])\\n                        lastBuyPrice = 0\\n                continue\\n            else:\\n                Log(\\\"买单完成, 累计花费:\\\", _N(initAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]), \\\"平均买入价:\\\", _N((initAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]) / (account[\\\"Stocks\\\"] - initAccount[\\\"Stocks\\\"])))\\n                lastBuyPrice = 0\\n                con",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             lastBuyPrice = 0\\n                continue     \\n        else:\\n            Log(\\\"剩余余额:\\\",account[\\\"Balance\\\"])\\n            #委托价格 = 最新买一价*（1-委托深度/100）\\n            entrustPrice = _N(ticker[\\\"Buy\\\"]*(1-depthStatus/100))\\n            Log(\\\"委托价格：\\\",entrustPrice)\\n            #判断委托价格是否大于最高价格限定\\n            if entrustPrice > highPrice:\\n                continue\\n            #随机购买数量 = 单次购买数量均值 * ((100-单次均值浮点数)/100)+(单次均值浮点数*2 /100* 单次购买数量均值 *随机数0~1)  \\n            randomBuyNum = (buyNum*((100-buyOnc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n            randomBuyNum = (buyNum*((100-buyOncePoint)/100))+(buyOncePoint*2/100 *buyNum*random.random())\\n            #可用数量金额 \\n            useMoney = min(account[\\\"Balance\\\"],randomBuyNum,buyAmount - (initAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]))\\n            #购买数量\\n            orderBuyNum = _N(useMoney/entrustPrice)\\n            Log(\\\"交易数量：\\\",orderBuyNum)\\n            #判断是否小于最小交易量\\n            if orderBuyNum < minBuyNum:\\n                break\\n            #因为要扣手续费，所以大概为账户99.7%\\n            if (en",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         #因为要扣手续费，所以大概为账户99.7%\\n            if (entrustPrice*orderBuyNum)>(account[\\\"Balance\\\"]*0.997):\\n                Log(\\\"金额为\\\",(entrustPrice*orderBuyNum))\\n                Log(\\\"账户余额为\\\",(account[\\\"Balance\\\"]))\\n                continue\\n            #更新上次购买价格\\n            lastBuyPrice = entrustPrice\\n            #下单\\n            exchange.Buy(entrustPrice,orderBuyNum)\\n            \\n    account = _C(exchange.GetAccount)  \\n    Log(\\\"冰山委托买单完成,共计花费：\\\",_N(initAccount[\\\"Balance\\\"]-account[\\\"Balance\\\"]),\\\"平均",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nitAccount[\\\"Balance\\\"]-account[\\\"Balance\\\"]),\\\"平均单价为:\\\",_N((initAccount[\\\"Balance\\\"]-account[\\\"Balance\\\"])/(account[\\\"Stocks\\\"]-initAccount[\\\"Stocks\\\"])))\",\n    \"策略名称: 冰山委托买入-Jason\\n\\nLog(\\\"取消所有未成交订单\\\")\\n    orders = _C(exchange.GetOrders)\\n    if len(orders) > 0:\\n        for i in range(len(orders)):\\n            exchange.CancelOrder(orders[i][\\\"Id\\\"])\\n            Sleep(priceInterval*1000)\\n\\n    # 对比账户余额\\n    Log(\\\"获取用户初始化账户\\\")\\n    initAccount = _C(exchange.GetAccount)\\n    if initAccount[\\\"Balance\\\"] ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.GetAccount)\\n    if initAccount[\\\"Balance\\\"] < buyAmount:\\n        Log(\\\"账户余额不足\\\")\\n        return\\n    \\n    #比较单笔购买数量均值*市场买一价是否大于账户余额\\n    ticker = _C(exchange.GetTicker)\\n    if (ticker['Last'] * buyNum) > initAccount['Balance']:\\n        Log(\\\"单次购买均值价格大于账户余额，请调整参数\\\")\\n        return\\n\\n    lastBuyPrice = 0\\n\\n    while (True):\\n        Sleep(priceInterval*1000)\\n        #获取账户信息\\n        account = _C(exchange.GetAccount)\\n        #获取当下行情\\n        ticker = _C(exchange.GetTicker)\\n        # 上次购买价格不为空，",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ker = _C(exchange.GetTicker)\\n        # 上次购买价格不为空，查看订单是否完成，没有完成则取消\\n        if lastBuyPrice > 0:\\n            orders1 = exchange.GetOrders()\\n            if len(orders1) > 0:\\n                for j in range(len(orders1)):\\n                    #计算实际市场委托深度\\n                    if ticker[\\\"Last\\\"] > lastBuyPrice and ((ticker[\\\"Last\\\"] - lastBuyPrice)/lastBuyPrice) > (2* (depthStatus/100)):\\n                        Log(\\\"委托价格偏离过多，最新成交价:\\\",ticker[\\\"Last\\\"],\\\"委托价\\\",lastBuyPrice)\\n                        exchange.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\",lastBuyPrice)\\n                        exchange.CancelOrder(orders1[j][\\\"Id\\\"])\\n                        lastBuyPrice = 0\\n                continue\\n            else:\\n                Log(\\\"买单完成, 累计花费:\\\", _N(initAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]), \\\"平均买入价:\\\", _N((initAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]) / (account[\\\"Stocks\\\"] - initAccount[\\\"Stocks\\\"])))\\n                lastBuyPrice = 0\\n                continue     \\n        else:\\n            Log(\\\"剩余余额:\\\",account[\\\"Balance\\\"])\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        Log(\\\"剩余余额:\\\",account[\\\"Balance\\\"])\\n            #委托价格 = 最新买一价*（1-委托深度/100）\\n            entrustPrice = _N(ticker[\\\"Buy\\\"]*(1-depthStatus/100))\\n            Log(\\\"委托价格：\\\",entrustPrice)\\n            #判断委托价格是否大于最高价格限定\\n            if entrustPrice > highPrice:\\n                continue\\n            #随机购买数量 = 单次购买数量均值 * ((100-单次均值浮点数)/100)+(单次均值浮点数*2 /100* 单次购买数量均值 *随机数0~1)  \\n            randomBuyNum = (buyNum*((100-buyOncePoint)/100))+(buyOncePoint*2/100 *buyNum*random.random())\\n            #可用数量金额 \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "00 *buyNum*random.random())\\n            #可用数量金额 \\n            useMoney = min(account[\\\"Balance\\\"],randomBuyNum,buyAmount - (initAccount[\\\"Balance\\\"] - account[\\\"Balance\\\"]))\\n            #购买数量\\n            orderBuyNum = _N(useMoney/entrustPrice)\\n            Log(\\\"交易数量：\\\",orderBuyNum)\\n            #判断是否小于最小交易量\\n            if orderBuyNum < minBuyNum:\\n                break\\n            #因为要扣手续费，所以大概为账户99.7%\\n            if (entrustPrice*orderBuyNum)>(account[\\\"Balance\\\"]*0.997):\\n                Log(\\\"金额为\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t[\\\"Balance\\\"]*0.997):\\n                Log(\\\"金额为\\\",(entrustPrice*orderBuyNum))\\n                Log(\\\"账户余额为\\\",(account[\\\"Balance\\\"]))\\n                continue\\n            #更新上次购买价格\\n            lastBuyPrice = entrustPrice\\n            #下单\\n            exchange.Buy(entrustPrice,orderBuyNum)\\n            \\n    account = _C(exchange.GetAccount)  \\n    Log(\\\"冰山委托买单完成,共计花费：\\\",_N(initAccount[\\\"Balance\\\"]-account[\\\"Balance\\\"]),\\\"平均单价为:\\\",_N((initAccount[\\\"Balance\\\"]-account[\\\"Balance\\\"])/(account[\\\"Stocks\\\"]-in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\\"]-account[\\\"Balance\\\"])/(account[\\\"Stocks\\\"]-initAccount[\\\"Stocks\\\"])))        \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/271475\\n\\n> Last Modified\\n\\n2021-04-16 10:26:23\"\n \n\n    \"strategy_63\",\n    \"python\\ndef main():\\n    Log(exchange.GetAccount())\\n    Log(exchange.GetCurrency())\\n    while True:\\n        ticker = exchange.GetTicker()\\n        if ticker:\\n            Log(\\\"开盘了，冲啊！！！@\\\")\\n            exchange.SetPrecision(1,0)\\n            amount = XX/ticker['Last']\\n            exchange.Buy(-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt = XX/ticker['Last']\\n            exchange.Buy(-1, amount)\\n            exchange.Buy(-1, amount/2)\\n            exchange.Buy(-1, amount/4)\\n            exchange.Buy(-1, amount/8)\\n            exchange.Buy(-1, amount/16)\\n            Sleep(15*1000)\\n            while True:\\n                try:\\n                    _ticker = exchange.GetTicker()\\n                    if _ticker['Last'] > ticker['Last']:\\n                        exchange.Sell(-1, amount/3)\\n                        Log(\\\"已经卖出三分之一@\\\")\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                       Log(\\\"已经卖出三分之一@\\\")\\n                        return\\n                    else:\\n                        Sleep(30)\\n                        continue\\n                except:\\n                    Sleep(30)\\n                    continue\\n        else:\\n            Sleep(20)\",\n    \"策略名称: 冲币安新上币开盘\\n\\n未找到描述\"\n \n\n    \"strategy_64\",\n    \"python\\nimport time\\n\\n# 初始化策略参数\\nsymbol = 'huobip/btc_usdt'\\nperiod = '1m'\\namount = 0.01\\nmartingale_factor = 2\\nmax_martingale_times = 5\\nstop_loss = 0.05\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = 2\\nmax_martingale_times = 5\\nstop_loss = 0.05\\nstop_profit = 0.1\\nlast_buy_price = 0\\nmartingale_times = 0\\n\\n# 连接API\\nexchange = Exchange()\\nexchange.SetContractType(symbol)\\nexchange.SetPeriod(period)\\n\\n# 主循环\\nwhile True:\\n    # 获取K线数据\\n    klines = exchange.GetRecords()\\n    if not klines:\\n        continue\\n\\n    # 获取当前价格\\n    current_price = float(klines[-1]['Close'])\\n\\n    # 判断是否需要加仓\\n    if last_buy_price != 0 and current_price < last_buy_price * (1 - stop_loss):\\n        # 止损，卖出所有持仓\\n        se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " (1 - stop_loss):\\n        # 止损，卖出所有持仓\\n        sell_price = current_price\\n        sell_amount = exchange.GetPosition()['Amount']\\n        exchange.Sell(sell_price, sell_amount)\\n        last_buy_price = 0\\n        martingale_times = 0\\n        print('止损，卖出所有持仓，价格', sell_price)\\n    elif last_buy_price != 0 and current_price > last_buy_price * (1 + stop_profit):\\n        # 止盈，卖出所有持仓\\n        sell_price = current_price\\n        sell_amount = exchange.GetPosition()['Amount']\\n        exchange.Sell(sell_price",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tion()['Amount']\\n        exchange.Sell(sell_price, sell_amount)\\n        last_buy_price = 0\\n        martingale_times = 0\\n        print('止盈，卖出所有持仓，价格', sell_price)\\n    elif last_buy_price == 0:\\n        # 买入一份初始仓位\\n        buy_price = current_price\\n        buy_amount = amount / buy_price\\n        exchange.Buy(buy_price, buy_amount)\\n        last_buy_price = buy_price\\n        martingale_times = 0\\n        print('买入初始仓位，价格', buy_price)\\n    elif martingale_times < max_martingale_times:\\n        # 加仓\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e_times < max_martingale_times:\\n        # 加仓\\n        buy_price = current_price * martingale_factor\\n        buy_amount = amount / buy_price\\n        exchange.Buy(buy_price, buy_amount)\\n        last_buy_price = (last_buy_price * martingale_times + buy_price) / (martingale_times + 1)\\n        martingale_times += 1\\n        print('加仓，价格', buy_price)\\n\\n    # 等待下一次循环\\n    time.sleep(60)\",\n    \"策略名称: 分享-赌徒策略-马丁策略\\n\\nsymbol = 'huobip/btc_usdt'\\nperiod = '1m'\\namount = 0.01\\nmartingale_factor = 2\\nmax_martingal",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mount = 0.01\\nmartingale_factor = 2\\nmax_martingale_times = 5\\nstop_loss = 0.05\\nstop_profit = 0.1\\nlast_buy_price = 0\\nmartingale_times = 0\"\n \n\n    \"strategy_65\",\n    \"python\\nimport talib\\nimport numpy as np\\nimport time\\n\\n# 初始化策略参数\\nsymbol = 'huobip/btc_usdt'\\nperiod = '1m'\\nrsi_period = 14\\nrsi_buy = 30\\nrsi_sell = 70\\namount = 0.01\\nlast_buy_price = 0\\n\\n# 连接API\\nexchange = Exchange()\\nexchange.SetContractType(symbol)\\nexchange.SetPeriod(period)\\n\\n# 主循环\\nwhile True:\\n    # 获取K线数据\\n    klines = exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "循环\\nwhile True:\\n    # 获取K线数据\\n    klines = exchange.GetRecords()\\n    if not klines:\\n        continue\\n\\n    # 计算RSI指标\\n    close_prices = np.array([float(k['Close']) for k in klines])\\n    rsi = talib.RSI(close_prices, rsi_period)\\n\\n    # 获取当前价格\\n    current_price = float(klines[-1]['Close'])\\n\\n    # 判断是否超买或超卖\\n    if rsi[-1] < rsi_buy and last_buy_price == 0:\\n        # 超卖，买入\\n        buy_price = current_price\\n        buy_amount = amount / buy_price\\n        exchange.Buy(buy_price, buy_amount)\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        exchange.Buy(buy_price, buy_amount)\\n        last_buy_price = buy_price\\n        print('买入', buy_amount, 'BTC，价格', buy_price)\\n    elif rsi[-1] > rsi_sell and last_buy_price != 0:\\n        # 超买，卖出\\n        sell_price = current_price\\n        sell_amount = amount / sell_price\\n        exchange.Sell(sell_price, sell_amount)\\n        last_buy_price = 0\\n        print('卖出', sell_amount, 'BTC，价格', sell_price)\\n\\n    # 等待下一次循环\\n    time.sleep(60)\",\n    \"策略名称: 分享RSI超买超卖策略\\n\\nsymbol = 'huobip/btc_usdt'\\nper",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "名称: 分享RSI超买超卖策略\\n\\nsymbol = 'huobip/btc_usdt'\\nperiod = '1m'\\nrsi_period = 14\\nrsi_buy = 30\\nrsi_sell = 70\\namount = 0.01\\nlast_buy_price = 0\"\n \n\n    \"strategy_66\",\n    \"python\\nimport time\\n\\n# 初始化策略参数\\nsymbol = 'huobip/ht_usdt'\\namount = 10\\nmax_price = 1.5\\nmin_price = 0.5\\ninterval = 0.1\\n\\n# 连接API\\nexchange = Exchange()\\nexchange.SetContractType(symbol)\\n\\n# 主循环\\nwhile True:\\n    # 获取当前市场深度\\n    depth = exchange.GetDepth()\\n\\n    # 获取当前买一和卖一价格\\n    buy_price = float(depth['Bids'][0]['Price'])\\n    sell",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "price = float(depth['Bids'][0]['Price'])\\n    sell_price = float(depth['Asks'][0]['Price'])\\n\\n    # 判断是否满足条件\\n    if buy_price <= max_price and sell_price >= min_price:\\n        # 满足条件，进行买入操作\\n        buy_amount = amount / buy_price\\n        exchange.Buy(buy_price, buy_amount)\\n        print('买入', buy_amount, 'HT，价格', buy_price)\\n\\n        # 等待一段时间后进行卖出操作\\n        time.sleep(interval)\\n        sell_price = float(depth['Asks'][0]['Price'])\\n        sell_amount = amount / sell_price\\n        exchange.Sell(se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt = amount / sell_price\\n        exchange.Sell(sell_price, sell_amount)\\n        print('卖出', sell_amount, 'HT，价格', sell_price)\\n\\n    # 等待下一次循环\\n    time.sleep(1)\\n\\n\\n#该策略使用了FMZ平台提供的Exchange API来进行交易。在主循环中，首先获取当前市场深度，然后获取当前买一和卖一价格。如果买一价格小于等于设定的最大价格且卖一价格大于等于设定的最小价格，则进行买入操作。等待一段时间后再获取当前卖一价格进行卖出操作。最后等待下一次循环。需要注意的是，抢新现货策略存在一定的风险，需要谨慎操作。\",\n    \"策略名称: 分享抢新现货策略\\n\\nsymbol = 'huobip/ht_usdt'\\namount = 10\\nmax_price = 1.5\\nmin_price = 0.5\\ninterval = 0.1\"\n \n\n    \"strategy_67\",\n    \"python\\n\\n# !usr/bin/ python3\\n# ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rategy_67\",\n    \"python\\n\\n# !usr/bin/ python3\\n# *_* coding:utf-8 *_*\\n#学会python后写的第一个动态平衡策略\\n# QQ：5325049 不足之处欢迎指正\\n\\nimport time\\n\\n#定义获取行情及账户信息函数\\ndef nowinfo(): \\n    global NowTicker,NowAsset,NowCoinValue,AssetDiff\\n    NowTicker = exchange.GetTicker() #获取行情信息\\n    NowAsset = exchange.GetAccount() # 获取账户信息\\n    NowCoinValue =NowTicker.Last * NowAsset.Stocks #计算币资产净值\\n    AssetDiff = NowCoinValue-NowAsset.Balance #计算币资产与现金差额\\n\\n# 定义交易执行函数\\ndef trade():\\n    if AssetDiff > NowAsset.Balance*0.05: # 判断币值是",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    if AssetDiff > NowAsset.Balance*0.05: # 判断币值是否超过资金5%\\n        Log(\\\"交易将被执行，以\\\",NowTicker.Buy,\\\"卖出\\\",AssetDiff/2/NowTicker.Buy,\\\"个币\\\")\\n        exchange.SetPrecision(5,5) #设置计价精度\\n        exchange.Sell(NowTicker.Buy,AssetDiff/2/NowTicker.Buy) #执行币卖出交易\\n    elif AssetDiff < NowAsset.Balance*(-0.05): #判断币值是否低于资金5%\\n        Log(\\\"交易将被执行，以\\\",NowTicker.Sell,\\\"买入\\\",AssetDiff/-2/NowTicker.Sell,\\\"个币\\\")\\n        exchange.SetPrecision(5,5) #设置计价精度\\n        exchange.Buy(NowTicker.Sell,AssetDiff/-2/NowTicker.Sell) ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e.Buy(NowTicker.Sell,AssetDiff/-2/NowTicker.Sell) #执行币买入交易\\n    else:\\n        Log(\\\"未触发交易条件\\\")\\n\\n# 入口函数，只要定义了系统就会自动执行该函数，不需要调用啊\\ndef main():\\n    i = 0\\n    while i < 1000: #设置执行总次数\\n        nowinfo() # 调用获取行情资产函数\\n        Log(NowTicker) # 打印行情信息\\n        Log(NowAsset) # 打印账户信息\\n        Log(\\\"当前币余额：\\\",NowAsset.Stocks)\\n        Log(\\\"当前资金余额：\\\",NowAsset.Balance)\\n        Log(\\\"当前币市值：\\\", NowCoinValue)\\n        Log(\\\"币市值与资金差额：\\\",AssetDiff)\\n        trade() #调用 交易执行函数\\n        i+=1 # 条件迭代\\n        Log(\\\"第\\\", i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 交易执行函数\\n        i+=1 # 条件迭代\\n        Log(\\\"第\\\", i, \\\"轮循环结束\\\")\\n        time.sleep(60) # 等待60秒\",\n    \"策略名称: 动态平衡策略-python-版\\n\\n# *_* coding:utf-8 *_*\"\n \n\n    \"strategy_68\",\n    \"python\\nimport time\\nimport numpy as np\\n\\ndef reject_outliers(arr, m=2):\\n    final_list = [x for x in arr if (x > np.mean(arr) - 2 * np.std(arr))]\\n    final_list = [x for x in final_list if (x < np.mean(arr) + 2 * np.std(arr))]\\n    return final_list\\n\\ndef main():\\n    '''SetErrorFilter(\\\"canceled\\\")'''\\n     \\n    LogReset()\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rFilter(\\\"canceled\\\")'''\\n     \\n    LogReset()\\n    LogProfitReset()\\n    \\n    global sellTrue \\n    global buyTrue \\n    sellTrue = 0 \\n    buyTrue = 0\\n    initStocks = 0.0\\n    initBalance = 0.0\\n    lastTradeTime = 0\\n    lastTradeErrExchange = ''\\n    accountsCache = []\\n    depthCache=[]\\n    names = []\\n    buyPrice=0\\n    sellPrice=0\\n    dealtransactioned = False\\n\\n    for e in exchanges:\\n        names.append(e.GetName())\\n        account = _C(e.GetAccount)\\n        initStocks += account.Stocks",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".GetAccount)\\n        initStocks += account.Stocks\\n        initBalance += account.Balance\\n        Log(\\\"Switch\\\", e.GetLabel(), \\\"To\\\", e.IO(\\\"websocket\\\"))\\n        \\n    Log(\\\"Total Currency:\\\", _N(initBalance), \\\"Total Asset\\\", _N(initStocks), 'Python:', __import__('sys').version)\\n    while (True):\\n        LogStatus(_D())\\n        if not accountsCache:\\n            accountsCache = [_C(e.GetAccount) for e in exchanges]\\n        Sleep(LoopInterval)\\n        depthA = exchanges[0].GetDepth()\\n        dep",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     depthA = exchanges[0].GetDepth()\\n        depthCache.append(depthA)\\n        if not depthA:\\n            continue\\n        depthB = exchanges[1].GetDepth()\\n        depthCache.append(depthB)\\n        if not depthB:\\n            continue\\n        \\n                \\n        '''trade part'''\\n        \\n        diffA = _N(depthA.Bids[0].Price - depthB.Asks[0].Price, 3)\\n        diffB = _N(depthB.Bids[0].Price - depthA.Asks[0].Price, 3)\\n        LogStatus(\\\"A平台币\\\",exchanges[0].GetAccount().Stocks,\\\"A平台钱\\\",",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"A平台币\\\",exchanges[0].GetAccount().Stocks,\\\"A平台钱\\\",exchanges[0].GetAccount().Balance,\\\"B平台币\\\",exchanges[1].GetAccount().Stocks,\\\"B平台钱\\\",exchanges[1].GetAccount().Balance)\\n        \\n        if diffA > 0:\\n            buytarget = depthB.Asks[0]\\n            opAmount=min(depthA.Bids[0].Amount,buytarget.Amount)\\n            buyAmount=min(opAmount,exchanges[1].GetAccount().Balance/buytarget.Price)\\n            sellAmount=min(buyAmount,exchanges[0].GetAccount().Stocks)\\n            \\n            if diffA > (buyAm",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ocks)\\n            \\n            if diffA > (buyAmount*depthB.Asks[0].Price*0.2/100+sellAmount*depthA.Bids[0].Price*0.2/100)*p:\\n                Log('buy from B sell at A')\\n                Log(\\\"A平台币\\\",exchanges[0].GetAccount().Stocks,\\\"A平台钱\\\",exchanges[0].GetAccount().Balance,\\\"B平台币\\\",exchanges[1].GetAccount().Stocks,\\\"B平台钱\\\",exchanges[1].GetAccount().Balance)\\n                tradeAmount=min(buyAmount,sellAmount)     \\n                buyorder =exchanges[1].Buy(buytarget.Price,tradeAmount)\\n             ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1].Buy(buytarget.Price,tradeAmount)\\n                sellorder = exchanges[0].Sell(depthA.Bids[0].Price,tradeAmount)\\n                canceller = 0\\n                    \\n                    \\n                while True:\\n             \\n                    \\n                    \\n                    if (exchanges[1].GetOrder(buyorder).Status == 2) and (exchanges[0].GetOrder(sellorder).Status == 2):\\n                        Log('deal transactioned')\\n                        buyPrice = exchanges[1].GetOrder(b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                buyPrice = exchanges[1].GetOrder(buyorder).Price\\n                        sellPrice = exchanges[0].GetOrder(sellorder).Price\\n                        LogProfit(exchanges[0].GetOrder(sellorder).Amount*exchanges[0].GetOrder(sellorder).Price-exchanges[1].GetOrder(buyorder).Amount*exchanges[1].GetOrder(buyorder).Price)\\n                        dealtransactioned = True\\n                        break\\n                    elif ((exchanges[1].GetOrder(buyorder).Status == 1) or (exchanges[0].GetOrder",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r(buyorder).Status == 1) or (exchanges[0].GetOrder(sellorder).Status == 1)):\\n                        buyPrice = exchanges[1].GetOrder(buyorder).Price\\n                        sellPrice = exchanges[0].GetOrder(sellorder).Price\\n                        canceller += 1\\n                        dealtransactioned = True\\n                        Sleep(200)\\n                    elif ((exchanges[1].GetOrder(buyorder).Status == 0) and (exchanges[0].GetOrder(sellorder).Status == 0)):\\n                        Sleep(20",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ").Status == 0)):\\n                        Sleep(200)\\n                        canceller += 1\\n                    if canceller == 5:        \\n                        exchanges[1].CancelOrder(buyorder)\\n                        exchanges[0].CancelOrder(sellorder)\\n                        Log('deal cancelled')       \\n                        break    \\n                \\n                    \\n\\n        elif diffB > 0:\\n            \\n            opAmount=min(depthB.Bids[0].Amount,depthA.Asks[0].Amount)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hB.Bids[0].Amount,depthA.Asks[0].Amount)\\n            buyAmount=min(opAmount,exchanges[0].GetAccount().Balance/depthA.Asks[0].Price)\\n            sellAmount=min(buyAmount,exchanges[1].GetAccount().Stocks)\\n            canceller = 0\\n            if diffB > (buyAmount*depthA.Asks[0].Price*0.2/100+sellAmount*depthB.Bids[0].Price*0.2/100)*p:\\n                Log('buy from A sell at B')\\n                \\n                tradeAmount=min(buyAmount,sellAmount)\\n                buyorder=exchanges[0].Buy(depthA.Asks",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             buyorder=exchanges[0].Buy(depthA.Asks[0].Price,tradeAmount)\\n                sellorder=exchanges[1].Sell(depthB.Bids[0].Price,tradeAmount)\\n                canceller =0\\n                \\n                while True:\\n                       \\n                    if (exchanges[0].GetOrder(buyorder).Status == 2) and (exchanges[1].GetOrder(sellorder).Status == 2):\\n                        Log('deal transactioned')\\n                        buyPrice=exchanges[0].GetOrder(buyorder).Price\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchanges[0].GetOrder(buyorder).Price\\n                        sellPrice=exchanges[1].GetOrder(sellorder).Price\\n                        LogProfit(exchanges[1].GetOrder(sellorder).Amount*exchanges[1].GetOrder(sellorder).Price-exchanges[0].GetOrder(buyorder).Amount*exchanges[0].GetOrder(buyorder).Price)\\n                        dealtransactioned = True\\n                        break\\n                    elif ((exchanges[0].GetOrder(buyorder).Status == 1) or (exchanges[1].GetOrder(sellorder).Status == 1)):\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchanges[1].GetOrder(sellorder).Status == 1)):\\n                        \\n                        buyPrice=exchanges[0].GetOrder(buyorder).Price\\n                        sellPrice=exchanges[1].GetOrder(sellorder).Price\\n                        canceller += 1\\n                        dealtransactioned = True\\n                        Sleep(200)\\n                    elif ((exchanges[0].GetOrder(buyorder).Status == 0) and (exchanges[1].GetOrder(sellorder).Status == 0)):\\n                        Sleep(200)\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == 0)):\\n                        Sleep(200)\\n                        canceller += 1\\n                    if canceller == 5:        \\n                        exchanges[0].CancelOrder(buyorder)\\n                        exchanges[1].CancelOrder(sellorder)\\n                        Log('deal cancelled')       \\n                        break \\n              \\n        '''balance part'''\\n        for i in [0,1]:\\n            if dealtransactioned:\\n                if(exchanges[i].GetAccount().Stocks > (initStocks/2",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f(exchanges[i].GetAccount().Stocks > (initStocks/2)* q and exchanges[i].GetAccount().Balance < (initBalance/2)*q):           \\n                    sellwait = 1\\n                    Log('ready to sell')\\n                    loopbreaker = 0\\n                    while (sellwait):\\n                        \\n                        if (_N(depthCache[i].Bids[0].Price,3)> buyPrice*r):\\n                            sellwait = 0\\n\\n                            break\\n                        else:\\n                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                       else:\\n                            Sleep(1000)\\n                            Log('sellwait')\\n                            loopbreaker += 1\\n                        if loopbreaker == 600:\\n                            '''break'''\\n                        \\n                    \\n\\n                    sellTrue = 1\\n\\n                    while(sellTrue):\\n                        dealprice = depthCache[i].Bids[0].Price\\n                        Log('insufficient money, sell some')\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  Log('insufficient money, sell some')\\n                        idealamount = initBalance/8\\n                        availamount = exchanges[i].GetAccount().Stocks/2\\n                        dealamount = min(idealamount,availamount)\\n                        balancesell = exchanges[i].Sell(depthCache[i].Bids[0].Price, dealamount)\\n                        Sleep(200)\\n                        while( exchanges[i].GetOrder(balancesell).Status not in [1,2] ):\\n                            exchanges[i].CancelOrder(b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                        exchanges[i].CancelOrder(balancesell)\\n                            if( dealprice > buyPrice):\\n                                dealprice -= 1\\n                            balancesell = exchanges[i].Sell(dealprice,dealamount)\\n                            Sleep(200)\\n                        '''buyPrice=[]'''\\n                        Log(\\\"Sell Balance finished\\\")\\n                        sellTrue=0\\n\\n\\n                if(exchanges[i].GetAccount().Balance > (initBalance/2)*q and exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "etAccount().Balance > (initBalance/2)*q and exchanges[i].GetAccount().Stocks < (initStocks/2)*q):\\n                    buywait = 1\\n                    loopbreaker = 0\\n                    while (buywait):\\n                        \\n                        if(_N(depthCache[i].Asks[0].Price,3)< sellPrice*r):\\n\\n                            buywait=0\\n\\n                            break\\n                        else:\\n                            Sleep(1000)\\n                            Log(_N(depthCache[i].Ask",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                          Log(_N(depthCache[i].Asks[0].Price,3),sellPrice*r)\\n                            loopbreaker +=1\\n                        if loopbreaker == 600:\\n                            '''break\\n                        break'''\\n                            \\n\\n\\n\\n                    buyTrue = 1\\n                    while(buyTrue):\\n                        Log('buyTrue started')\\n                        dealprice = depthCache[i].Asks[0].Price\\n                        Log('insufficient stocks, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                        Log('insufficient stocks, buy some')\\n                        idealamount = initStocks/8\\n                        availamount = exchanges[i].GetAccount().Balance/dealprice/2\\n                        dealamount = min(idealamount,availamount)\\n                        balancebuy = exchanges[i].Buy(dealprice,dealamount)\\n                        Sleep(200)\\n                        while(exchanges[i].GetOrder(balancebuy).Status not in [1,2]):\\n\\n                            exchanges[i].Can",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "):\\n\\n                            exchanges[i].CancelOrder(balancebuy)\\n                            if (dealprice < sellPrice):\\n                                dealprice += 1\\n                            balancebuy = exchanges[i].Buy(dealprice,dealamount)\\n                            Sleep(200)\\n                        '''sellPrice=[]'''\\n                        Log(\\\"Buy Balance finished\\\")\\n                        buyTrue = 0\\n                        break\\n                else:         \\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k\\n                else:         \\n                    continue\\n                break\\n            else:\\n                break\",\n    \"策略名称: 双平台对冲-练习用-求交流求指点\\n\\n未找到描述\"\n \n\n    \"strategy_69\",\n    \"python\\n'''backtest\\nstart: 2024-11-19 00:00:00\\nend: 2024-12-18 08:00:00\\nperiod: 1d\\nbasePeriod: 1d\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"TRB_USDT\\\"},{\\\"eid\\\":\\\"OKX\\\",\\\"currency\\\":\\\"TRB_USDT\\\"}]\\n'''\\n\\nimport time\\nimport json\\n\\n# 全局变量定义\\ndepthA = depthB = None\\ntimeBegin = timeEnd = None\\naskPriceA ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "thB = None\\ntimeBegin = timeEnd = None\\naskPriceA = bidPriceA = askAmountA = bidAmountA = 0\\naskPriceB = bidPriceB = askAmountB = bidAmountB = 0\\nminAmount = 20  # 最小下单量\\nfeeA = 0.0020  # Huobi 手续费   \\nfeeB = 0.0010  # Binance 手续费\\nfees = None\\nminProfit = 0.0002  # 最小利润\\nnotDealAmountA = notDealAmountB = None\\naccountA = accountB = None\\ninitAccountA = initAccountB = None\\nmaxDeltaAmount = 100  # 最大可容忍币偏差\\ndealAmountA = 0\\ndealAmountB = 0\\nsafeAmount = 800  # 安全最大成交量\\nprofit = None\\nmaxTime = 150  # 最大延迟过滤",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " # 安全最大成交量\\nprofit = None\\nmaxTime = 150  # 最大延迟过滤\\naccountBNB = None\\nreload = False\\n\\n# 初始化函数\\ndef init():\\n    global fees, initAccountA, initAccountB, accountA, accountB\\n\\n    try:\\n        fees = feeA + feeB\\n\\n        initAccountA = _G(\\\"initAccountA\\\")\\n        initAccountB = _G(\\\"initAccountB\\\")\\n        \\n        if initAccountA is None or initAccountB is None:\\n            initAccountA = _C(exchanges[0].GetAccount)\\n            initAccountB = _C(exchanges[1].GetAccount)\\n            _G(\\\"initAcc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "exchanges[1].GetAccount)\\n            _G(\\\"initAccountA\\\", initAccountA)\\n            _G(\\\"initAccountB\\\", initAccountB)\\n            Log(\\\"账号初值初始化成功\\\")\\n        else:\\n            Log(\\\"继承初值数据成功\\\")\\n        \\n        accountA = initAccountA\\n        accountB = initAccountB\\n\\n    except Exception as e:\\n        Log(\\\"初始化失败 请重启:\\\", e)\\n\\n# 规范化深度数据\\ndef legalize_depth(depthA, depthB):\\n    global askPriceA, bidPriceA, askAmountA, bidAmountA\\n    global askPriceB, bidPriceB, askAmountB, bidAmountB\\n\\n    askP",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ceB, bidPriceB, askAmountB, bidAmountB\\n\\n    askPriceA = bidPriceA = askAmountA = bidAmountA = 0\\n    askPriceB = bidPriceB = askAmountB = bidAmountB = 0\\n\\n    for ask in depthA[0][\\\"Asks\\\"]:\\n        askPriceA = ask[\\\"Price\\\"]\\n        askAmountA += ask[\\\"Amount\\\"]\\n        if askAmountA >= minAmount:\\n            break\\n\\n    for bid in depthA[0][\\\"Bids\\\"]:\\n        bidPriceA = bid[\\\"Price\\\"]\\n        bidAmountA += bid[\\\"Amount\\\"]\\n        if bidAmountA >= minAmount:\\n            break\\n\\n    for ask in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ">= minAmount:\\n            break\\n\\n    for ask in depthB[0][\\\"Asks\\\"]:\\n        askPriceB = ask[\\\"Price\\\"]\\n        askAmountB += ask[\\\"Amount\\\"]\\n        if askAmountB >= minAmount:\\n            break\\n\\n    for bid in depthB[0][\\\"Bids\\\"]:\\n        bidPriceB = bid[\\\"Price\\\"]\\n        bidAmountB += bid[\\\"Amount\\\"]\\n        if bidAmountB >= minAmount:\\n            break\\n\\n# 取消所有挂单\\ndef cancel_all_orders():\\n    global dealAmountA, dealAmountB\\n\\n    orders = _C(exchanges[0].GetOrders)\\n    for order in ord",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= _C(exchanges[0].GetOrders)\\n    for order in orders:\\n        exchanges[0].CancelOrder(order[\\\"Id\\\"])\\n        Log(\\\"成交:\\\", order[\\\"DealAmount\\\"], \\\"未成交:\\\", order[\\\"Amount\\\"] - order[\\\"DealAmount\\\"])\\n        dealAmountA -= order[\\\"Amount\\\"] - order[\\\"DealAmount\\\"]\\n\\n    orders = _C(exchanges[1].GetOrders)\\n    for order in orders:\\n        exchanges[1].CancelOrder(order[\\\"Id\\\"])\\n        Log(\\\"成交:\\\", order[\\\"DealAmount\\\"], \\\"未成交:\\\", order[\\\"Amount\\\"] - order[\\\"DealAmount\\\"])\\n        dealAmountB -= orde",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rder[\\\"DealAmount\\\"])\\n        dealAmountB -= order[\\\"Amount\\\"] - order[\\\"DealAmount\\\"]\\n\\n# 检查余额\\ndef check_balance():\\n    global accountA, accountB, dealAmountA, dealAmountB\\n\\n    cancel_all_orders()\\n    deltaStocks = (initAccountA[\\\"Stocks\\\"] + initAccountA[\\\"FrozenStocks\\\"] + initAccountB[\\\"Stocks\\\"] + initAccountB[\\\"FrozenStocks\\\"]\\n        - accountA[\\\"Stocks\\\"] - accountA[\\\"FrozenStocks\\\"] - accountB[\\\"Stocks\\\"] - accountB[\\\"FrozenStocks\\\"])\\n\\n    deltaStocks = round(deltaStocks, 0)\\n\\n    if del",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " deltaStocks = round(deltaStocks, 0)\\n\\n    if deltaStocks < -maxDeltaAmount:  # 仓位过重\\n        if askPriceA > askPriceB and accountA[\\\"Stocks\\\"] > -deltaStocks:\\n            exchanges[0].Sell(askPriceA, -deltaStocks)\\n            dealAmountA += -deltaStocks\\n        else:\\n            exchanges[1].Sell(askPriceB, -deltaStocks)\\n            dealAmountB += -deltaStocks\\n        return True\\n\\n    if deltaStocks > maxDeltaAmount:  # 仓位过轻\\n        if bidPriceA < bidPriceB and accountA[\\\"Balance\\\"] * 0.999 / bid",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " bidPriceB and accountA[\\\"Balance\\\"] * 0.999 / bidPriceA > deltaStocks:\\n            exchanges[0].Buy(bidPriceA, deltaStocks)\\n            dealAmountA += deltaStocks\\n        else:\\n            exchanges[1].Buy(bidPriceB, deltaStocks)\\n            dealAmountB += deltaStocks\\n        return True\\n\\n    return False\\n\\n# 更新利润\\ndef update_profit():\\n    global profit\\n\\n    profit = (\\n        accountA[\\\"Balance\\\"] + accountB[\\\"Balance\\\"] + accountA[\\\"FrozenBalance\\\"] + accountB[\\\"FrozenBalance\\\"]\\n        + (",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ance\\\"] + accountB[\\\"FrozenBalance\\\"]\\n        + (accountA[\\\"Stocks\\\"] + accountA[\\\"FrozenStocks\\\"] + accountB[\\\"Stocks\\\"] + accountB[\\\"FrozenStocks\\\"]\\n        - initAccountA[\\\"Stocks\\\"] - initAccountA[\\\"FrozenStocks\\\"] - initAccountB[\\\"Stocks\\\"] - initAccountB[\\\"FrozenStocks\\\"]) * askPriceA\\n        - (initAccountA[\\\"Balance\\\"] + initAccountA[\\\"FrozenBalance\\\"] + initAccountB[\\\"Balance\\\"] + initAccountB[\\\"FrozenBalance\\\"]))\\n\\n    return profit\\n\\n# 检查套利机会\\ndef check_opportunity():\\n    global dealAmountA",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\ndef check_opportunity():\\n    global dealAmountA, dealAmountB, accountA, accountB, diff_A, diff_B \\n\\n    diff_A = bidPriceB - askPriceA  # A交易所买 -> B交易所卖\\n    diff_B = bidPriceA - askPriceB  # B交易所买 -> A交易所卖\\n\\n    if diff_A > 0 and diff_A > (minProfit + fees) * askPriceA:\\n        maxBuyAmount = min(accountA[\\\"Balance\\\"] / askPriceA * 0.98, askAmountA)\\n        maxSellAmount = min(accountB[\\\"Stocks\\\"], bidAmountB)\\n        amount = min(maxBuyAmount, maxSellAmount, safeAmount)\\n        amount = round(amo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ellAmount, safeAmount)\\n        amount = round(amount, 0)\\n\\n        if amount >= minAmount:\\n            Log(\\\"huobi -> binance\\\", amount)\\n            exchanges[0].Buy(askPriceA, amount)\\n            exchanges[1].Sell(bidPriceB, amount)\\n            time.sleep(3)\\n            dealAmountA += amount\\n            dealAmountB += amount\\n            accountA = _C(exchanges[0].GetAccount)\\n            accountB = _C(exchanges[1].GetAccount)\\n            Log(\\\"利润更新:\\\", update_profit())\\n\\n    if diff_B > 0 and di",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "新:\\\", update_profit())\\n\\n    if diff_B > 0 and diff_B > (minProfit + fees) * askPriceB:\\n        maxBuyAmount = min(accountB[\\\"Balance\\\"] / askPriceB * 0.98, askAmountB)\\n        maxSellAmount = min(accountA[\\\"Stocks\\\"], bidAmountA)\\n        amount = min(maxBuyAmount, maxSellAmount, safeAmount)\\n        amount = round(amount, 0)\\n\\n        if amount >= minAmount:\\n            Log(\\\"binance -> huobi\\\", amount)\\n            exchanges[1].Buy(askPriceB, amount)\\n            exchanges[0].Sell(bidPriceA, amount)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            exchanges[0].Sell(bidPriceA, amount)\\n            time.sleep(3)\\n            dealAmountA += amount\\n            dealAmountB += amount\\n            accountA = _C(exchanges[0].GetAccount)\\n            accountB = _C(exchanges[1].GetAccount)\\n            Log(\\\"利润更新:\\\", update_profit())\\n\\ndef main():\\n    global initAccountA, initAccountB\\n    if reload == True:\\n        initAccountA = _C(exchanges[0].GetAccount)\\n        initAccountB = _C(exchanges[1].GetAccount)\\n        _G(\\\"initAccountA\\\", ini",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s[1].GetAccount)\\n        _G(\\\"initAccountA\\\", initAccountA)\\n        _G(\\\"initAccountB\\\", initAccountB)\\n\\n    init()\\n\\n    checkBalanceCount = 60\\n    \\n    while True:\\n        accountA = exchanges[0].GetAccount()\\n        accountB = exchanges[1].GetAccount()\\n        timeBegin = int(time.time() * 1000)\\n        depthA = exchanges[0].Go(\\\"GetDepth\\\")\\n        depthB = exchanges[1].Go(\\\"GetDepth\\\")\\n        depthA = depthA.wait()\\n        depthB = depthB.wait()\\n        \\n        timeEnd = int(time.time(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "wait()\\n        \\n        timeEnd = int(time.time() * 1000)\\n        # 真实交易，去除205-208注释\\n        #if timeEnd - timeBegin > maxTime:\\n        #    continue  # 延迟超过 maxTime 毫秒就放弃当组数据\\n        #if depthA is None or depthB is None or accountA is None or accountB is None:\\n        #    continue\\n\\n        legalize_depth(depthA, depthB)\\n\\n        if checkBalanceCount >= 60:\\n            checkBalanceCount = 0\\n            if check_balance():\\n                continue\\n        else:\\n            checkBalanceCount ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nue\\n        else:\\n            checkBalanceCount += 1\\n        \\n        check_opportunity()\\n        \\n        # 数据可视化操作\\n        table = {\\n            'type': 'table',\\n            'title': '持仓操作',\\n            'cols': ['交易所', '初始余额', '初始币数', '当前余额', '当前币数', '成交量'],\\n            'rows': [\\n                ['huobi', initAccountA.Balance + initAccountA.FrozenBalance, initAccountA.Stocks + initAccountA.FrozenStocks,\\n                    accountA.Balance + accountA.FrozenBalance, accountA.Stocks + accountA.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ccountA.FrozenBalance, accountA.Stocks + accountA.FrozenStocks, dealAmountA],\\n                ['binance', initAccountB.Balance + initAccountB.FrozenBalance, initAccountB.Stocks + initAccountB.FrozenStocks,\\n                    accountB.Balance + accountB.FrozenBalance, accountB.Stocks + accountB.FrozenStocks, dealAmountB],\\n                ['合计', initAccountA.Balance + initAccountB.Balance, initAccountA.Stocks + initAccountB.Stocks,\\n                    accountA.Balance + accountA.FrozenBalance + accountB.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ountA.Balance + accountA.FrozenBalance + accountB.Balance + accountB.FrozenBalance,\\n                    accountA.Stocks + accountA.FrozenStocks + accountB.Stocks + accountB.FrozenStocks, dealAmountA + dealAmountB],\\n                ['huobi盘口', askPriceA, askAmountA, bidPriceA, bidAmountA, ''],\\n                ['binance盘口', askPriceB, askAmountB, bidPriceB, bidAmountB, ''],\\n                ['收益:', str(_N(update_profit(), 8)) + '#FF0000',  '', '', ''],\\n                ['收益率', str(_N(100 * profit / (initAc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             ['收益率', str(_N(100 * profit / (initAccountA.Balance + initAccountA.FrozenBalance + initAccountB.Balance + initAccountB.FrozenBalance), 6)) + '%' + '#FF0000', '', '', '', ''],\\n                ['总延迟', timeEnd - timeBegin, '', '', '', ''],\\n                ['最后更新时间', _D(), '', '', '', ''],\\n            ]\\n        }\\n        LogStatus('`' + json.dumps(table) + '`')\\n\\n        time.sleep(10)\",\n    \"策略名称: 双平台对冲平衡策略\\n\\ndepthA = depthB = None\\ntimeBegin = timeEnd = None\\naskPriceA = bidPriceA = askAmo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n = timeEnd = None\\naskPriceA = bidPriceA = askAmountA = bidAmountA = 0\\naskPriceB = bidPriceB = askAmountB = bidAmountB = 0\\nminAmount = 20  # 最小下单量\\nfeeA = 0.0020  # Huobi 手续费   \\nfeeB = 0.0010  # Binance 手续费\\nfees = None\\nminProfit = 0.0002  # 最小利润\\nnotDealAmountA = notDealAmountB = None\\naccountA = accountB = None\\ninitAccountA = initAccountB = None\\nmaxDeltaAmount = 100  # 最大可容忍币偏差\\ndealAmountA = 0\\ndealAmountB = 0\\nsafeAmount = 800  # 安全最大成交量\\nprofit = None\\nmaxTime = 150  # 最大延迟过滤\\naccountBNB = None\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " None\\nmaxTime = 150  # 最大延迟过滤\\naccountBNB = None\\nreload = False\"\n \n\n    \"strategy_70\",\n    \"python\\nPS = ext.PersistentStorage()\\nALPHA = 0.0008\\nclass GraphManager:\\n\\n    diffs_chart = {\\n        '__isStock': False,\\n        'extension': {\\n            'layout': 'single',\\n            'height': 300,\\n            'col': 6\\n       \\n        'chart': {\\n            'zoomType': 'x'\\n       \\n        'title': {\\n            'text': '各币种价格与指数的偏离值'\\n       \\n        'subtitle': {\\n            'text': 'Alpha: %",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      'subtitle': {\\n            'text': 'Alpha: %s' % ALPHA\\n       \\n        'xAxis': {\\n            'type': 'datetime'\\n       \\n        'series': []\\n    }\\n    index_chart = {\\n        '__isStock': False,\\n        'extension': {\\n            'layout': 'single',\\n            'height': 300,\\n            'col': 6\\n       \\n        'chart': {\\n            'zoomType': 'x'\\n       \\n        'title': {\\n            'text': '基准指数值'\\n       \\n        'xAxis': {\\n            'type': 'datetime'\\n       \\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            'type': 'datetime'\\n       \\n        'series': [{\\n            'type': 'line',\\n            'name': 'INDEX',\\n            'data': []\\n        }]\\n    }\\n    pos_chart = {\\n        '__isStock': False,\\n        'extension': {\\n            'layout': 'single',\\n            'height': 300,\\n            'col': 6\\n       \\n        'chart': {\\n            'zoomType': 'x'\\n       \\n        'title': {\\n            'text': '各币种当前持仓价值'\\n       \\n        'subtitle': {\\n            'text': '以USDT计算'\\n       \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "title': {\\n            'text': '以USDT计算'\\n       \\n        'xAxis': {\\n            'type': 'datetime'\\n       \\n        'series': []\\n    }\\n    upnl_chart = {\\n        '__isStock': False,\\n        'extension': {\\n            'layout': 'single',\\n            'height': 300,\\n            'col': 6\\n       \\n        'chart': {\\n            'zoomType': 'x'\\n       \\n        'title': {\\n            'text': '各币种当前未实现盈亏'\\n       \\n        'subtitle': {\\n            'text': '以USDT计算'\\n       \\n        'xAxis': {\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'text': '以USDT计算'\\n       \\n        'xAxis': {\\n            'type': 'datetime'\\n       \\n        'series': []\\n    }\\n\\n    def __init__(self, reset: bool):\\n        self.indices = {}\\n        self.diffs_data = {}\\n        self.pos_data = {}\\n        self.upnl_data = {}\\n        self.index = 1\\n        self.not_manual_reset = True\\n        if PS['symbols'] is None or reset:\\n            echo('图表管理器第一次初始化')\\n            if reset:\\n                PS['symbols'] = None\\n                self.not_manual_reset = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "] = None\\n                self.not_manual_reset = False\\n\\n    def initialize(self, symbols):\\n        self.symbols = symbols\\n        self.create_chart()\\n        if self.symbols != PS['symbols']:\\n            if self.not_manual_reset:\\n                echo('币种出现更改，图表重新初始化')\\n            self.reset_graph()\\n        PS['symbols'] = self.symbols\\n\\n    def reset_graph(self):\\n        self.chart.reset(0)\\n\\n    def create_chart(self):\\n        i = 0\\n        for symbol in self.symbols:\\n            # DIFF Cha",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "or symbol in self.symbols:\\n            # DIFF Chart\\n            self.diffs_chart['series'].append({\\n                'type': 'line',\\n                'name': symbol,\\n                'data': []\\n            })\\n            self.indices[symbol+'_diff'] = i\\n            i+=1\\n        # INDEX Chart\\n        self.indices['INDEX_CHART'] = i\\n        i+=1\\n        for symbol in self.symbols:\\n            # POS Chart\\n            self.pos_chart['series'].append({\\n                'type': 'line',\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                'type': 'line',\\n                'name': symbol,\\n                'data': []\\n            })\\n            self.indices[symbol+'_pos'] = i\\n            i+=1\\n        for symbol in self.symbols:\\n            # UPNL Chart\\n            self.upnl_chart['series'].append({\\n                'type': 'line',\\n                'name': symbol,\\n                'data': []\\n            })\\n            self.indices[symbol+'_upnl'] = i\\n            i+=1\\n        self.chart = Chart([self.diffs_chart, self.i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      self.chart = Chart([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\\n\\n    def add_diff_data(self, symbol, diff):\\n        self.diffs_data[symbol] = diff\\n\\n    def add_pos_data(self, symbol, pos):\\n        self.pos_data[symbol] = pos\\n\\n    def add_upnl_data(self, symbol, upnl):\\n        self.upnl_data[symbol] = upnl\\n\\n    def add_index_data(self, index):\\n        self.index = index\\n\\n    def update_chart(self, timestamp):\\n        for symbol in self.diffs_data.keys():\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     for symbol in self.diffs_data.keys():\\n            index = self.indices[symbol+'_diff']\\n            data = self.diffs_data[symbol]\\n            self.chart.add(index, [timestamp, data])\\n\\n        for symbol in self.pos_data.keys():\\n            index = self.indices[symbol+'_pos']\\n            data = self.pos_data[symbol]\\n            self.chart.add(index, [timestamp, data])\\n\\n        for symbol in self.upnl_data.keys():\\n            index = self.indices[symbol+'_upnl']\\n            data = self.upnl_d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "es[symbol+'_upnl']\\n            data = self.upnl_data[symbol]\\n            self.chart.add(index, [timestamp, data])\\n\\n        index = self.indices['INDEX_CHART']\\n        self.chart.add(index, [timestamp, self.index])\\n        self.chart.update([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\",\n    \"策略名称: 可变图表示例\\n\\nself.diffs_chart['series'].append({\\n                'type': 'line',\\n                'name': symbol,\\n                'data': []\\n            })\\n            self.indices[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ta': []\\n            })\\n            self.indices[symbol+'_diff'] = i\\n            i+=1\\n        # INDEX Chart\\n        self.indices['INDEX_CHART'] = i\\n        i+=1\\n        for symbol in self.symbols:\\n            # POS Chart\\n            self.pos_chart['series'].append({\\n                'type': 'line',\\n                'name': symbol,\\n                'data': []\\n            })\\n            self.indices[symbol+'_pos'] = i\\n            i+=1\\n        for symbol in self.symbols:\\n            # UPNL Chart\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ymbol in self.symbols:\\n            # UPNL Chart\\n            self.upnl_chart['series'].append({\\n                'type': 'line',\\n                'name': symbol,\\n                'data': []\\n            })\\n            self.indices[symbol+'_upnl'] = i\\n            i+=1\\n        self.chart = Chart([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\\n\\n    def add_diff_data(self, symbol, diff):\\n        self.diffs_data[symbol] = diff\\n\\n    def add_pos_data(self, symbol, pos):\\n        sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " def add_pos_data(self, symbol, pos):\\n        self.pos_data[symbol] = pos\\n\\n    def add_upnl_data(self, symbol, upnl):\\n        self.upnl_data[symbol] = upnl\\n\\n    def add_index_data(self, index):\\n        self.index = index\\n\\n    def update_chart(self, timestamp):\\n        for symbol in self.diffs_data.keys():\\n            index = self.indices[symbol+'_diff']\\n            data = self.diffs_data[symbol]\\n            self.chart.add(index, [timestamp, data])\\n\\n        for symbol in self.pos_data.keys():\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "])\\n\\n        for symbol in self.pos_data.keys():\\n            index = self.indices[symbol+'_pos']\\n            data = self.pos_data[symbol]\\n            self.chart.add(index, [timestamp, data])\\n\\n        for symbol in self.upnl_data.keys():\\n            index = self.indices[symbol+'_upnl']\\n            data = self.upnl_data[symbol]\\n            self.chart.add(index, [timestamp, data])\\n\\n        index = self.indices['INDEX_CHART']\\n        self.chart.add(index, [timestamp, self.index])\\n        self.chart",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ndex, [timestamp, self.index])\\n        self.chart.update([self.diffs_chart, self.index_chart, self.pos_chart, self.upnl_chart])\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/214723\\n\\n> Last Modified\\n\\n2020-06-17 11:27:43\"\n \n\n    \"strategy_71\",\n    \"python\\ndef main():\\n    Log(exchange.GetAccount())\",\n    \"策略名称: 各平台策略代写区块链5年专业经验低价高质量-薇芯bov1107\\n\\n未找到描述\"\n \n\n    \"strategy_72\",\n    \"python\\ndef main():\\n    Log(exchange.GetAccount())\",\n    \"策略名称: 各平台策略代写区块链5年专业经验低价高质量薇芯bov1107\\n\\n未找到描述\"\n \n\n    \"strateg",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "写区块链5年专业经验低价高质量薇芯bov1107\\n\\n未找到描述\"\n \n\n    \"strategy_73\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n# \\n# Candlestick merger.\\n#\\n# Copyright 2018 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n# Do What the Fuck You Want To Public License\\n#\\n\\nfrom math import *\\nfrom datetime import datetime\\n\\ndef timeFilter(records, since, to=1000000000000000):\\n    bars = []\\n    for i in records:\\n        if i['Time'] >= since and i['Time'] <= to:\\n            bars.a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " >= since and i['Time'] <= to:\\n            bars.append(i)\\n\\n    return bars\\n\\ndef calcRecords(records, period=30, start=None):\\n    try:\\n        records[0]\\n    except IndexError:\\n        return []\\n    \\n    period_ms = period * 60000  # 以毫秒记的K线周期\\n    end_in = records[len(records)-1]['Time']  # K线的结束时间\\n    start_at = records[0]['Time']  # K线的开始时间\\n    \\n    # 获得可以用于计算目标K线的开始时间\\n    r_offest = start_at % period_ms\\n    start_at = start_at - r_offest + period_ms\\n    if start is not None:\\n        sta",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " period_ms\\n    if start is not None:\\n        start_at = start\\n    \\n    target_count = ceil((end_in-start_at)/period_ms) # 目标K线的数量\\n    \\n    n_records = []\\n    \\n    for i in range(0, target_count):\\n        bars = timeFilter(records, start_at+i*period_ms, start_at+(i+1)*period_ms-1000)\\n        try:\\n            bars[0]\\n        except IndexError:\\n            continue\\n        # 初始化新的Bar\\n        Time = bars[0]['Time']\\n        Open = bars[0]['Open']\\n        High = bars[0]['High']\\n        Low = bar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        High = bars[0]['High']\\n        Low = bars[0]['Low']\\n        Close = bars[0]['Close']\\n        Volume = 0\\n        for item in bars:\\n            High = max(High, item['High'])\\n            Low = min(Low, item['Low'])\\n            Close = item['Close']\\n            Volume+=item['Volume']\\n            \\n        # 将Bar添加添加到新的K线中\\n        n_records.append(dict({\\n            'Time' : Time,\\n            'Open' : Open,\\n            'High' : High,\\n            'Low' : Low,\\n            'Close' : Close,\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       'Low' : Low,\\n            'Close' : Close,\\n            'Volume' : Volume\\n        }))\\n        \\n    return n_records\\n\\ndef getRecords(exchange, period=30):\\n    records = exchange.GetRecords(PERIOD_M1)\\n        \\n    return calcRecords(records, period)\\n\\ndef calcRecordsWithOldRecords(records, old_records, period=30):\\n    try:\\n        start = old_records[len(old_records)-1]['Time']\\n        del old_records[len(old_records)-1]\\n    except IndexError:\\n        old_records = []\\n        start = Non",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "or:\\n        old_records = []\\n        start = None\\n        \\n    return old_records + calcRecords(records=records, period=period, start=start)\\n        \\next.calcRecords = calcRecords\\next.getRecords = getRecords\\next.calcRecordsWithOldRecords = calcRecordsWithOldRecords\\n\\n# Function Test\\ndef main():\\n    LogReset()\\n    M1 = exchange.GetRecords(PERIOD_M1)\\n    M15 = exchange.GetRecords(PERIOD_M15)\\n    M15_GEN = ext.calcRecords(M1, 15) # 使用ext.calcRecords函数 按照1分钟K线 计算出15分钟K线\\n    Log(M15[len(M15)-50:])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ds函数 按照1分钟K线 计算出15分钟K线\\n    Log(M15[len(M15)-50:])\\n    Log(M15_GEN[len(M15_GEN)-50:])\",\n    \"策略名称: 合成任意周期K线-使用请看源码最下面\\n\\n# encoding: utf-8\"\n \n\n    \"strategy_74\",\n    \"python\\n'''\\n/*backtest\\nstart: 2017-10-01        \\nend: 2017-11-16          \\nperiod: 1440\\nperiodBase: 15\\nmode: 0                 \\n*/\\n'''\\n\\n#需要用的pandas库，并且用自己的托管回测才能保存到本地\\n#import numpy as np\\nimport pandas as pd\\n\\n#保存路径\\npath = 'C:\\\\\\\\Users\\\\\\\\Public\\\\\\\\Documents\\\\\\\\'\\n\\ndef main():\\n    df=pd.DataFrame()\\n    while True:\\n        rec",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   df=pd.DataFrame()\\n    while True:\\n        records = _C(exchange.GetRecords)\\n        df_new = pd.DataFrame(records)  #把records转为dataframe\\n        df_new['Time'] = pd.to_datetime(df_new['Time'],unit='ms')+pd.Timedelta('8 h')\\n        df_new.index = df_new['Time']\\n        if df.empty or df_new['Time'].min() >= df['Time'].max():\\n            df=df.combine_first(df_new)\\n            Log(df['Time'].max())\\n        #确定最后一次时间，用于保存数据\\n        if df_new['Time'].max() == pd.Timestamp('2017-11-15 23:45:00'):\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "].max() == pd.Timestamp('2017-11-15 23:45:00'):\\n            Log('保存数据')\\n            df=df.combine_first(df_new)\\n            df.to_csv(path+'records15.csv',index=False)\\n            break\\n        #休眠时间是选择周期\\n        Sleep(15*60*1000)\",\n    \"策略名称: 回测保存K线到本地CSV\\n\\n未找到描述\"\n \n\n    \"strategy_75\",\n    \"python\\nimport _thread\\nimport json\\nimport math\\nimport csv\\nimport random\\nimport os\\nimport datetime as dt\\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\\nfrom urllib.parse import parse_qs, urlpar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Handler\\nfrom urllib.parse import parse_qs, urlparse\\n\\narrTrendType = [\\\"down\\\", \\\"slow_up\\\", \\\"sharp_down\\\", \\\"sharp_up\\\", \\\"narrow_range\\\", \\\"wide_range\\\", \\\"neutral_random\\\"]\\n\\ndef url2Dict(url):\\n    query = urlparse(url).query  \\n    params = parse_qs(query)  \\n    result = {key: params[key][0] for key in params}  \\n    return result\\n\\nclass Provider(BaseHTTPRequestHandler):\\n    def do_GET(self):\\n        global filePathForCSV, pround, vround, ct\\n        try:\\n            self.send_response(200)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       try:\\n            self.send_response(200)\\n            self.send_header(\\\"Content-type\\\", \\\"application/json\\\")\\n            self.end_headers()\\n\\n            dictParam = url2Dict(self.path)\\n            Log(\\\"自定义数据源服务接收到请求，self.path:\\\", self.path, \\\"query 参数：\\\", dictParam)            \\n            \\n            eid = dictParam[\\\"eid\\\"]\\n            symbol = dictParam[\\\"symbol\\\"]\\n            arrCurrency = symbol.split(\\\".\\\")[0].split(\\\"_\\\")\\n            baseCurrency = arrCurrency[0]\\n            quo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    baseCurrency = arrCurrency[0]\\n            quoteCurrency = arrCurrency[1]\\n            fromTS = int(dictParam[\\\"from\\\"]) * int(1000)\\n            toTS = int(dictParam[\\\"to\\\"]) * int(1000)\\n            priceRatio = math.pow(10, int(pround))\\n            amountRatio = math.pow(10, int(vround))\\n\\n            data = {\\n                \\\"detail\\\": {\\n                    \\\"eid\\\": eid,\\n                    \\\"symbol\\\": symbol,\\n                    \\\"alias\\\": symbol,\\n                    \\\"baseCurrency\\\": baseC",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mbol,\\n                    \\\"baseCurrency\\\": baseCurrency,\\n                    \\\"quoteCurrency\\\": quoteCurrency,\\n                    \\\"marginCurrency\\\": quoteCurrency,\\n                    \\\"basePrecision\\\": vround,\\n                    \\\"quotePrecision\\\": pround,\\n                    \\\"minQty\\\": 0.00001,\\n                    \\\"maxQty\\\": 9000,\\n                    \\\"minNotional\\\": 5,\\n                    \\\"maxNotional\\\": 9000000,\\n                    \\\"priceTick\\\": 10 ** -pround,\\n                    \\\"vo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ceTick\\\": 10 ** -pround,\\n                    \\\"volumeTick\\\": 10 ** -vround,\\n                    \\\"marginLevel\\\": 10,\\n                    \\\"contractType\\\": ct\\n               \\n                \\\"schema\\\" : [\\\"time\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"],\\n                \\\"data\\\" : []\\n            }\\n            \\n            listDataSequence = []\\n            with open(filePathForCSV, \\\"r\\\") as f:\\n                reader = csv.reader(f)\\n                header = next(reader)\\n                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           header = next(reader)\\n                headerIsNoneCount = 0\\n                if len(header) != len(data[\\\"schema\\\"]):\\n                    Log(\\\"CSV文件格式有误，列数不同，请检查！\\\", \\\"#FF0000\\\")\\n                    return \\n                for ele in header:\\n                    for i in range(len(data[\\\"schema\\\"])):\\n                        if data[\\\"schema\\\"][i] == ele or ele == \\\"\\\":\\n                            if ele == \\\"\\\":\\n                                headerIsNoneCount += 1\\n                     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     headerIsNoneCount += 1\\n                            if headerIsNoneCount > 1:\\n                                Log(\\\"CSV文件格式有误，请检查！\\\", \\\"#FF0000\\\")\\n                                return \\n                            listDataSequence.append(i)\\n                            break\\n                \\n                while True:\\n                    record = next(reader, -1)\\n                    if record == -1:\\n                        break\\n                    index = 0\\n                    arr = [0, 0,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       index = 0\\n                    arr = [0, 0, 0, 0, 0, 0]\\n                    for ele in record:\\n                        arr[listDataSequence[index]] = int(ele) if listDataSequence[index] == 0 else (int(float(ele) * amountRatio) if listDataSequence[index] == 5 else int(float(ele) * priceRatio))\\n                        index += 1\\n                    data[\\\"data\\\"].append(arr)            \\n            Log(\\\"数据data.detail：\\\", data[\\\"detail\\\"], \\\"响应回测系统请求。\\\")\\n            self.wfile.write(json.dumps(da",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "请求。\\\")\\n            self.wfile.write(json.dumps(data).encode())\\n        except BaseException as e:\\n            Log(\\\"Provider do_GET error, e:\\\", e)\\n        return \\n\\ndef createServer(host):\\n    try:\\n        server = HTTPServer(host, Provider)\\n        Log(\\\"Starting server, listen at: %s:%s\\\" % host)\\n        server.serve_forever()\\n    except BaseException as e:\\n        Log(\\\"createServer error, e:\\\", e)\\n        raise Exception(\\\"stop\\\")\\n\\nclass KlineGenerator:\\n    def __init__(self, start_time,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lineGenerator:\\n    def __init__(self, start_time, end_time, interval):\\n        self.start_time = dt.datetime.strptime(start_time, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        self.end_time = dt.datetime.strptime(end_time, \\\"%Y-%m-%d %H:%M:%S\\\")\\n        self.interval = self._parse_interval(interval)\\n        self.timestamps = self._generate_time_series()\\n\\n    def _parse_interval(self, interval):\\n        unit = interval[-1]\\n        value = int(interval[:-1])\\n\\n        if unit == \\\"m\\\":\\n            return value * ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    if unit == \\\"m\\\":\\n            return value * 60\\n        elif unit == \\\"h\\\":\\n            return value * 3600\\n        elif unit == \\\"d\\\":\\n            return value * 86400\\n        else:\\n            raise ValueError(\\\"不支持的K线周期，请使用 'm', 'h', 或 'd'.\\\")\\n\\n    def _generate_time_series(self):\\n        timestamps = []\\n        current_time = self.start_time\\n        while current_time <= self.end_time:\\n            timestamps.append(int(current_time.timestamp() * 1000))\\n            current_time += dt.ti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tamp() * 1000))\\n            current_time += dt.timedelta(seconds=self.interval)\\n        return timestamps\\n\\n    def generate(self, initPrice, trend_type=\\\"neutral\\\", volatility=1):\\n        data = []\\n        current_price = initPrice\\n        angle = 0\\n        for timestamp in self.timestamps:\\n            angle_radians = math.radians((angle + random.uniform(0, 360)) % 360)\\n            cos_value = math.cos(angle_radians)   #  -1 ~ 1\\n\\n            if trend_type == \\\"down\\\":\\n                change = r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rend_type == \\\"down\\\":\\n                change = random.uniform(-0.5, 0.4) * volatility * abs(cos_value) \\n            elif trend_type == \\\"slow_up\\\":\\n                change = random.uniform(-0.4, 0.5) * volatility * abs(cos_value) \\n            elif trend_type == \\\"sharp_down\\\":\\n                change = random.uniform(-10, 7) * volatility * abs(cos_value) \\n            elif trend_type == \\\"sharp_up\\\":\\n                change = random.uniform(-7, 10) * volatility * abs(cos_value) \\n            elif trend_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "atility * abs(cos_value) \\n            elif trend_type == \\\"narrow_range\\\":\\n                change = random.uniform(-0.2, 0.2) * volatility * abs(cos_value) \\n            elif trend_type == \\\"wide_range\\\":\\n                change = random.uniform(-20, 20) * volatility * abs(cos_value) \\n            else:\\n                change = random.uniform(-1, 1) * volatility * abs(cos_value) \\n            \\n            open_price = current_price\\n            close_price = open_price + change\\n            high_price =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ce = open_price + change\\n            high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\\n            low_price = close_price - random.uniform(0, abs(change)) if open_price > close_price else open_price - random.uniform(0, abs(change))\\n\\n            if low_price <= 0:\\n                change = random.uniform(1, 5) * volatility * abs(cos_value) \\n                close_price = open_price + change\\n                high_price =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " open_price + change\\n                high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price + random.uniform(0, abs(change))\\n                low_price = open_price * random.uniform(0.8, 1)\\n\\n\\n            if (high_price >= open_price and open_price >= close_price and close_price >= low_price) or (high_price >= close_price and close_price >= open_price and open_price >= low_price):\\n                pass\\n            else:\\n                Log(\\\"异常数据：\\\", high_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       else:\\n                Log(\\\"异常数据：\\\", high_price, open_price, low_price, close_price, \\\"#FF0000\\\")\\n\\n            base_volume = random.uniform(1000, 5000)\\n            volume = base_volume * (1 + abs(change) * 0.2)\\n\\n            kline = {\\n                \\\"Time\\\": timestamp,\\n                \\\"Open\\\": round(open_price, 2),\\n                \\\"High\\\": round(high_price, 2),\\n                \\\"Low\\\": round(low_price, 2),\\n                \\\"Close\\\": round(close_price, 2),\\n                \\\"Volume\\\": ro",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d(close_price, 2),\\n                \\\"Volume\\\": round(volume, 2),\\n            }\\n            data.append(kline)\\n            current_price = close_price\\n            angle += 1\\n        return data\\n\\n    def save_to_csv(self, filename, data):\\n        with open(filename, mode=\\\"w\\\", newline=\\\"\\\") as csvfile:\\n            writer = csv.writer(csvfile)\\n            writer.writerow([\\\"\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"])\\n            for idx, kline in enumerate(data):\\n                writer.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "kline in enumerate(data):\\n                writer.writerow(\\n                    [kline[\\\"Time\\\"], kline[\\\"Open\\\"], kline[\\\"High\\\"], kline[\\\"Low\\\"], kline[\\\"Close\\\"], kline[\\\"Volume\\\"]]\\n                )\\n        \\n        Log(\\\"当前路径：\\\", os.getcwd())\\n        with open(\\\"data.csv\\\", \\\"r\\\") as file:\\n            lines = file.readlines()\\n            if len(lines) > 1:\\n                Log(\\\"文件写入成功，以下是文件内容的一部分：\\\")\\n                Log(\\\"\\\".join(lines[:5]))\\n            else:\\n                Log(\\\"文件写入失败，文件为",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           else:\\n                Log(\\\"文件写入失败，文件为空！\\\")\\n\\ndef main():\\n    Chart({})\\n    LogReset(1)\\n    \\n    try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))\\n        Log(\\\"开启自定义数据源服务线程，数据由CSV文件提供。\\\", \\\", 地址/端口：0.0.0.0:9090\\\", \\\"#FF0000\\\")\\n    except BaseException as e:\\n        Log(\\\"启动自定义数据源服务失败！\\\")\\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")\\n    \\n    while True:\\n        cmd",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tion(\\\"stop\\\")\\n    \\n    while True:\\n        cmd = GetCommand()\\n        if cmd:\\n            if cmd == \\\"createRecords\\\":\\n                Log(\\\"生成器参数：\\\", \\\"起始时间：\\\", startTime, \\\"结束时间：\\\", endTime, \\\"K线周期：\\\", KLinePeriod, \\\"初始价格：\\\", firstPrice, \\\"波动类型：\\\", arrTrendType[trendType], \\\"波动性系数：\\\", ratio)\\n                generator = KlineGenerator(\\n                    start_time=startTime,\\n                    end_time=endTime,\\n                    interval=KLinePeriod,\\n                )\\n                klin",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nePeriod,\\n                )\\n                kline_data = generator.generate(firstPrice, trend_type=arrTrendType[trendType], volatility=ratio)\\n                generator.save_to_csv(\\\"data.csv\\\", kline_data)\\n                ext.PlotRecords(kline_data, \\\"%s_%s\\\" % (\\\"records\\\", KLinePeriod))\\n        LogStatus(_D())\\n        Sleep(2000)\",\n    \"策略名称: 回测系统随机行情生成器\\n\\nif trend_type == \\\"down\\\":\\n                change = random.uniform(-0.5, 0.4) * volatility * abs(cos_value) \\n            elif trend_type == \\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "abs(cos_value) \\n            elif trend_type == \\\"slow_up\\\":\\n                change = random.uniform(-0.4, 0.5) * volatility * abs(cos_value) \\n            elif trend_type == \\\"sharp_down\\\":\\n                change = random.uniform(-10, 7) * volatility * abs(cos_value) \\n            elif trend_type == \\\"sharp_up\\\":\\n                change = random.uniform(-7, 10) * volatility * abs(cos_value) \\n            elif trend_type == \\\"narrow_range\\\":\\n                change = random.uniform(-0.2, 0.2) * volatility",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   change = random.uniform(-0.2, 0.2) * volatility * abs(cos_value) \\n            elif trend_type == \\\"wide_range\\\":\\n                change = random.uniform(-20, 20) * volatility * abs(cos_value) \\n            else:\\n                change = random.uniform(-1, 1) * volatility * abs(cos_value) \\n            \\n            open_price = current_price\\n            close_price = open_price + change\\n            high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ge)) if open_price > close_price else close_price + random.uniform(0, abs(change))\\n            low_price = close_price - random.uniform(0, abs(change)) if open_price > close_price else open_price - random.uniform(0, abs(change))\\n\\n            if low_price <= 0:\\n                change = random.uniform(1, 5) * volatility * abs(cos_value) \\n                close_price = open_price + change\\n                high_price = open_price + random.uniform(0, abs(change)) if open_price > close_price else close_price ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ge)) if open_price > close_price else close_price + random.uniform(0, abs(change))\\n                low_price = open_price * random.uniform(0.8, 1)\\n\\n\\n            if (high_price >= open_price and open_price >= close_price and close_price >= low_price) or (high_price >= close_price and close_price >= open_price and open_price >= low_price):\\n                pass\\n            else:\\n                Log(\\\"异常数据：\\\", high_price, open_price, low_price, close_price, \\\"#FF0000\\\")\\n\\n            base_volume = rando",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e, \\\"#FF0000\\\")\\n\\n            base_volume = random.uniform(1000, 5000)\\n            volume = base_volume * (1 + abs(change) * 0.2)\\n\\n            kline = {\\n                \\\"Time\\\": timestamp,\\n                \\\"Open\\\": round(open_price, 2),\\n                \\\"High\\\": round(high_price, 2),\\n                \\\"Low\\\": round(low_price, 2),\\n                \\\"Close\\\": round(close_price, 2),\\n                \\\"Volume\\\": round(volume, 2),\\n            }\\n            data.append(kline)\\n            current_price ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    data.append(kline)\\n            current_price = close_price\\n            angle += 1\\n        return data\\n\\n    def save_to_csv(self, filename, data):\\n        with open(filename, mode=\\\"w\\\", newline=\\\"\\\") as csvfile:\\n            writer = csv.writer(csvfile)\\n            writer.writerow([\\\"\\\", \\\"open\\\", \\\"high\\\", \\\"low\\\", \\\"close\\\", \\\"vol\\\"])\\n            for idx, kline in enumerate(data):\\n                writer.writerow(\\n                    [kline[\\\"Time\\\"], kline[\\\"Open\\\"], kline[\\\"High\\\"], kline[\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Time\\\"], kline[\\\"Open\\\"], kline[\\\"High\\\"], kline[\\\"Low\\\"], kline[\\\"Close\\\"], kline[\\\"Volume\\\"]]\\n                )\\n        \\n        Log(\\\"当前路径：\\\", os.getcwd())\\n        with open(\\\"data.csv\\\", \\\"r\\\") as file:\\n            lines = file.readlines()\\n            if len(lines) > 1:\\n                Log(\\\"文件写入成功，以下是文件内容的一部分：\\\")\\n                Log(\\\"\\\".join(lines[:5]))\\n            else:\\n                Log(\\\"文件写入失败，文件为空！\\\")\\n\\ndef main():\\n    Chart({})\\n    LogReset(1)\\n    \\n    try:\\n        # _thread.st",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " LogReset(1)\\n    \\n    try:\\n        # _thread.start_new_thread(createServer, ((\\\"localhost\\\", 9090), ))\\n        _thread.start_new_thread(createServer, ((\\\"0.0.0.0\\\", 9090), ))\\n        Log(\\\"开启自定义数据源服务线程，数据由CSV文件提供。\\\", \\\", 地址/端口：0.0.0.0:9090\\\", \\\"#FF0000\\\")\\n    except BaseException as e:\\n        Log(\\\"启动自定义数据源服务失败！\\\")\\n        Log(\\\"错误信息：\\\", e)\\n        raise Exception(\\\"stop\\\")\\n    \\n    while True:\\n        cmd = GetCommand()\\n        if cmd:\\n            if cmd == \\\"createRecords\\\":\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if cmd == \\\"createRecords\\\":\\n                Log(\\\"生成器参数：\\\", \\\"起始时间：\\\", startTime, \\\"结束时间：\\\", endTime, \\\"K线周期：\\\", KLinePeriod, \\\"初始价格：\\\", firstPrice, \\\"波动类型：\\\", arrTrendType[trendType], \\\"波动性系数：\\\", ratio)\\n                generator = KlineGenerator(\\n                    start_time=startTime,\\n                    end_time=endTime,\\n                    interval=KLinePeriod,\\n                )\\n                kline_data = generator.generate(firstPrice, trend_type=arrTrendType[trendType], volatility=rat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "trend_type=arrTrendType[trendType], volatility=ratio)\\n                generator.save_to_csv(\\\"data.csv\\\", kline_data)\\n                ext.PlotRecords(kline_data, \\\"%s_%s\\\" % (\\\"records\\\", KLinePeriod))\\n        LogStatus(_D())\\n        Sleep(2000)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/473286\\n\\n> Last Modified\\n\\n2024-12-07 18:32:50\"\n \n\n    \"strategy_76\",\n    \"python\\n'''backtest\\nstart: 2020-04-03 00:00:00\\nend: 2021-04-02 23:59:00\\nperiod: 1h\\nbasePeriod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nbasePeriod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":0}]\\n'''\\n\\nimport time\\nclass juncang_strategy():  \\n    def __init__(self,exchange):\\n        self.p = 0.5\\n        self.account = None\\n        self.cny = 0\\n        self.btc = 0\\n        self.exchange =exchange\\n        #以上都是self对象的属性\\n\\n    def cancelAllOrders(self):\\n        orders = _C(self.exchange.GetOrders)\\n        for order in orders:\\n            exchange.CancelOrder(order['Id'], order)\\n        return True\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "celOrder(order['Id'], order)\\n        return True\\n\\n\\n    def balanceAccount(self):\\n        self.cancelAllOrders()\\n\\n        kr =  _C(self.exchange.GetRecords,PERIOD_M1)\\n        account = _C(self.exchange.GetAccount)\\n        if account is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n\\n        #赋值\\n        self.btc = account.Stocks+account.FrozenStocks\\n        self.cny = account.Balance+account.FrozenBalance\\n        \\n        accountmoney=self.btc * kr[-1].Close + self.cny",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   accountmoney=self.btc * kr[-1].Close + self.cny\\n        self.p = self.btc * kr[-1].Close / accountmoney\\n        # Log(self.p)\\n        tradenum=accountmoney/kr[-1].Close/100\\n        if tradenum<0.001:\\n            tradenum=0.001\\n        #判断self.p的值是否小于0.48\\n        Log(self.p)\\n        if (0.45<self.p < 0.49):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #判断self.p的值是否大于0.52\\n        elif (0.55 > self.p > 0.51):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            #调用Sell函数并传入相应的参数\\n            self.exchange.Sell(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p >= 0.55):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡,快速平仓\\\", self.p)\\n\\n            self.exchange.Sell(kr[-1].Close, trade",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            self.exchange.Sell(kr[-1].Close, tradenum*10)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p <= 0.45):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡，快速建仓\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, tradenum*10)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n\\n\\n\\n#函数main\\ndef main():\\n    #reaper 是构造函数的实例\\n    reaper = juncang_strategy(exchange)\\n    while (True):\\n        #通过实例调用poll方法\\n        reaper.balanceAccount()",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #通过实例调用poll方法\\n        reaper.balanceAccount()\\n        Sleep(1000*10)\",\n    \"策略名称: 均仓策略\\n\\ntradenum=accountmoney/kr[-1].Close/100\\n        if tradenum<0.001:\\n            tradenum=0.001\\n        #判断self.p的值是否小于0.48\\n        Log(self.p)\\n        if (0.45<self.p < 0.49):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #判断self.p的值是否大于0.52\\n        el",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ny)\\n\\n            #判断self.p的值是否大于0.52\\n        elif (0.55 > self.p > 0.51):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            #调用Sell函数并传入相应的参数\\n            self.exchange.Sell(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p >= 0.55):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡,快速平仓\\\", self.p)\\n\\n            self.exchange.Sell(kr[-1].Close, tradenum*10)\\n\\n            Log(\\\"持币数:\\\",self.btc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " tradenum*10)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p <= 0.45):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡，快速建仓\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, tradenum*10)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\"\n \n\n    \"strategy_77\",\n    \"python\\n#!/usr/local/bin/python\\n#-*- coding: UTF-8 -*-\\n#均线/趋势  策略\\n#通过判断  在死叉下底后回弹多少买入\\n#在金叉上扬至顶后下降多少卖出\\n\\n\\n# FastPeriod=3 #开仓快线周期\\n# SlowPeriod=7 #开仓慢线周期\\n# EnterPeriod=1       #开",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n# SlowPeriod=7 #开仓慢线周期\\n# EnterPeriod=1       #开仓观察期\\n# ExitFastPeriod=3 #平仓线周期\\n# ExitSlowPeriod=7 #平仓慢线周期\\n# ExitPeriod=2        #平仓观察期\\n# PositionRatio=0.5 #仓位比例\\n# Interval=10 #轮询周期\\n# MAType=0 #均线类型 TA.EMA|TA.MA\\n\\n\\nimport types\\narray = [TA.EMA,TA.MA]\\n_MACalcMethod = array[MAType]\\ndef Cross(a,b):   #计算均线方法\\n    crossNum = 0\\n    arr1 = []\\n    arr2 = []\\n    if(type(a) == types.ListType and type(b) == types.ListType):\\n        arr1 = a\\n        arr2 = b\\n    else:\\n        records = null\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r2 = b\\n    else:\\n        records = null\\n        while True:\\n            records = exchange.GetRecords()\\n            if(records and len(records) > a and len(records) > b):\\n                break\\n            Sleep(Interval)\\n        arr1 = _MACalcMethod(records,a)\\n        arr2 = _MACalcMethod(records,b)\\n    if(len(arr1) != len(arr2)):\\n        raise Exception(\\\"array length not equal\\\")\\n    for i in range(len(arr1) - 1,-1,-1):\\n        if((type(arr1[i]) != types.IntType and type(arr1[i]) != types.Flo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]) != types.IntType and type(arr1[i]) != types.FloatType) or (type(arr2[i]) != types.IntType and type(arr2[i]) != types.FloatType) ):\\n            break\\n        if(arr1[i] < arr2[i]):\\n            if(crossNum > 0):\\n                break\\n            crossNum -= 1\\n        elif(arr1[i] > arr2[i]):\\n            if(crossNum < 0):\\n                break\\n            crossNum += 1\\n        else:\\n            break\\n    return crossNum\\n\\nimport datetime\\ndef Caltime(date1,date2):\\n    try:\\n        date1=time.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ltime(date1,date2):\\n    try:\\n        date1=time.strptime(date1,\\\"%Y-%m-%d %H:%M:%S\\\")\\n        date2=time.strptime(date2,\\\"%Y-%m-%d %H:%M:%S\\\")\\n        date1=datetime.datetime(date1[0],date1[1],date1[2],date1[3],date1[4],date1[5])\\n        date2=datetime.datetime(date2[0],date2[1],date2[2],date2[3],date2[4],date2[5])\\n        return date2-date1\\n    except Exception,ex:\\n        Log('except Exception Caltime:',ex)\\n        return \\\"except Exception\\\"\\n\\nimport time\\nstart_timexx =time.localtime(time.time",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mport time\\nstart_timexx =time.localtime(time.time()) #time.clock()\\nstart_time=time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",start_timexx)\\nbuy_price=0 #买入价格\\nbuy_qty=0  #买入数量\\ngains=0  #盈利\\n\\ndef my_buy(): #开仓\\n    try:\\n        global buy_price,buy_qty\\n        initAccount = ext.GetAccount()  #交易模板的导出函数， 获得账户状态，保存策略运行前账户初始状态\\n        opAmount=1\\n        #开仓之前判断有币没有没有先进行买入\\n        if int(initAccount.Stocks)>1:\\n            if buy_price<1:\\n                buy_price=_C(exchange.GetTicker).Last\\n                buy_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=_C(exchange.GetTicker).Last\\n                buy_qty=initAccount.Stocks\\n            Log('开仓信息1 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\\n            return 1\\n        if int(initAccount.Stocks)<1:\\n            if int(str(initAccount.Stocks).replace('0.',''))>=1:\\n                if buy_price<1:\\n                    buy_price=_C(exchange.GetTicker).Last\\n                    buy_qty=initAccount.Stocks\\n                Log('开仓信息2 仓内还有比:',initAccount.Stocks,'进行清空','--开仓详情:',initAccount)\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ccount.Stocks,'进行清空','--开仓详情:',initAccount)\\n                return 1\\n\\n        #if int(initAccount.Stocks)<1:\\n        if int(str(initAccount.Stocks).replace('0.',''))==0:\\n            #opAmount=1\\n            opAmount = _N(initAccount.Balance*PositionRatio,3)  #买入数量\\n            Log(\\\"开仓没有币先进行 开仓买入%s元\\\"%(str(opAmount)))   #生成LOG日志\\n        #     else:\\n        #         opAmount = _N(initAccount.Stocks * PositionRatio,3)  #获取交易数量\\n        # else:\\n        #     opAmount = _N(initAccount.Stocks * Position",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " #     opAmount = _N(initAccount.Stocks * PositionRatio,3)  #获取交易数量\\n        Dict = ext.Buy(opAmount)  #买入ext.Buy\\n        if(Dict):#确认开仓成功\\n            buy_price=Dict['price'] #买入价格   #{'price': 4046.446, 'amount': 1.5}\\n            buy_qty=Dict['amount']  #买入数量\\n            print_log(1,initAccount,Dict)\\n            return 1\\n        return 0\\n\\n    except Exception,ex:\\n        Log('except Exception my_buy:',ex)\\n        return 0\\n\\noutAccount = ext.GetAccount()  #初始化信息\\ndef print_log(k_p,Account,Dict):\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "count()  #初始化信息\\ndef print_log(k_p,Account,Dict):\\n    try:\\n        global outAccount\\n        name=\\\"\\\"\\n        if k_p:\\n            LogProfit(_N(gains,4),'开仓信息 钱:',Account.Balance,'--币:',Account.Stocks,'--开仓详情:',Dict)\\n            name=\\\"开仓\\\"\\n        else:\\n            LogProfit(_N(gains,4),'平仓信息 钱:',Account.Balance,'--币:',Account.Stocks,'--平仓详情:',Dict)\\n            name=\\\"平仓\\\"\\n        endAccount = ext.GetAccount()  #初始化信息\\n        date1=time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",time.localtime(time.time()))",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"%Y-%m-%d %H:%M:%S\\\",time.localtime(time.time()))\\n        LogStatus(\\\"初始化投入2016/9/16  投入资金2000元\\\\r\\\\n\\\",\\n                  \\\"本次初始化状态:\\\",outAccount,\\n                  \\\"\\\\r\\\\n当前运  行状态:\\\",endAccount,\\n                  \\\"\\\\r\\\\n本次开始运行时间:%s  已运行:%s\\\\r\\\\n\\\"%(start_time,Caltime(start_time,date1)),\\n                  \\\"本次盈利:%s\\\\r\\\\n\\\"%(str(gains)),\\n                  \\\"当前状态:%s--钱:%s--币:%s\\\\r\\\\n\\\"%(str(name),str(Account.Balance),str(Account.Stocks)),\\n                  \\\"更新时间:%s\\\"%(date1)\\n                  ) #",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        \\\"更新时间:%s\\\"%(date1)\\n                  ) # 测试\\n    except Exception,ex:\\n        Log('except Exception print_log:',ex)\\n\\n\\ndef my_sell(): #平仓\\n    try:\\n        global buy_price,buy_qty,gains,start_time\\n        nowAccount = ext.GetAccount()  #交易模板的导出函数  获取账户信息\\n        if _C(exchange.GetTicker).Last>buy_price+4:   #当前价格一定要大于  开仓价格\\n            Dict = ext.Sell(nowAccount.Stocks)\\n            if(Dict):\\n                sell_gains=(Dict['price']-buy_price)*Dict['amount']\\n                gains=gains+",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rice)*Dict['amount']\\n                gains=gains+sell_gains\\n                buy_price=0 #买入价格\\n                buy_qty=0  #买入数量\\n                print_log(0,nowAccount,Dict)\\n                return 1\\n        return 0\\n    except Exception,ex:\\n        Log('except Exception my_sell:',ex)\\n        return 0\\n\\ndef main():\\n    global outAccount\\n    STATE_IDLE = -1  #空闲状态\\n    state = STATE_IDLE  #初始化  状态 为 空闲\\n\\n    Log(\\\"run  \\\",outAccount)  #输出初始账户信息\\n    SetErrorFilter(\\\"GetAccount|GetRecords|GetTicker\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " SetErrorFilter(\\\"GetAccount|GetRecords|GetTicker\\\")  #屏蔽错误内容\\n\\n    b=0  #开仓\\n    b1=0  #检测次数\\n    a=0  #平仓\\n    a1=0  #检测次数\\n    while True:\\n        if(state == STATE_IDLE):   #判断状态是否 为空闲 触发开仓\\n            #开仓\\n            n = Cross(FastPeriod,SlowPeriod) #模板函数获取EMA指标快线、慢线交叉结果\\n            if n<0:  #确定当前为死叉\\n                b1+=1\\n                if b>=int(n): #说明现在还是在下跌涨趋势\\n                    b=int(n)\\n                else: #开始下跌  开仓\\n                    if(int(n)>=int(b)+int(EnterPeriod)):  #确认上行走势 至自",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  if(int(n)>=int(b)+int(EnterPeriod)):  #确认上行走势 至自己定义的点\\n                        if my_buy():  #开仓\\n                            b=0\\n                            b1=0\\n                            state = PD_SHORT\\n                            # if(b1>=10):#小波动操作开仓\\n                            #     b1=0\\n                            #     if my_buy():\\n                            #         b=0\\n                            #         state = PD_SHORT\\n        else:#平仓\\n            n = Cross(ExitFastPeriod,ExitSl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e:#平仓\\n            n = Cross(ExitFastPeriod,ExitSlowPeriod) #模板函数获取EMA指标快线、慢线交叉结果\\n            if n>0:  #确定当前为金叉\\n                a1+=1\\n                if a<=int(n): #说明现在还是在上涨趋势\\n                    a=int(n)\\n                else: #开始下跌  平仓\\n                    if(int(n)<=int(a)-int(ExitPeriod)):  #确认下行走势 至自己定义的点\\n                        if my_sell(): #平仓\\n                            a=0\\n                            a1=0\\n                            state = STATE_IDLE   #更改状态  为空闲 触发开仓\\n                  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= STATE_IDLE   #更改状态  为空闲 触发开仓\\n                            # if(a1>=10): #小波动操作平仓\\n                            #     a1=0\\n                            #     if my_sell():\\n                            #         a=0\\n                            #         state = STATE_IDLE   #更改状态  为空闲 触发开仓\\n        Sleep(Interval * 1000)\",\n    \"策略名称: 均线-趋势_数字货币策略V02\\n\\n# SlowPeriod=7 #开仓慢线周期\"\n \n\n    \"strategy_78\",\n    \"python\\nimport types\\ndef main():\\n    STATE_IDLE = -1\\n    state = STATE_IDLE\\n    initAccount = ext.GetA",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    state = STATE_IDLE\\n    initAccount = ext.GetAccount()\\n    while True:\\n        if state == STATE_IDLE :\\n            n = ext.Cross(FastPeriod,SlowPeriod) # 指标交叉函数\\n            if abs(n) >= EnterPeriod :\\n                opAmount = _N(initAccount.Stocks * PositionRatio,3)\\n                Dict = ext.Buy(opAmount) if n > 0 else ext.Sell(opAmount)\\n                if Dict :\\n                    opAmount = Dict['amount']\\n                    state = PD_LONG if n > 0 else PD_SHORT\\n                    Log(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "G if n > 0 else PD_SHORT\\n                    Log(\\\"开仓详情\\\",Dict,\\\"交叉周期\\\",n)\\n        else:\\n            n = ext.Cross(ExitFastPeriod,ExitSlowPeriod) # 指标交叉函数\\n            if abs(n) >= ExitPeriod and ((state == PD_LONG and n < 0) or (state == PD_SHORT and n > 0)) :\\n                nowAccount = ext.GetAccount()\\n                Dict2 = ext.Sell(nowAccount.Stocks - initAccount.Stocks) if state == PD_LONG else ext.Buy(initAccount.Stocks - nowAccount.Stocks)\\n                state = STATE_IDLE\\n                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "              state = STATE_IDLE\\n                nowAccount = ext.GetAccount()\\n                LogProfit(nowAccount.Balance - initAccount.Balance,'钱：',nowAccount.Balance,'币：',nowAccount.Stocks,'平仓详情：',Dict2,'交叉周期：',n)\\n        Sleep(Interval * 1000)\",\n    \"策略名称: 均线策略python版\\n\\nif abs(n) >= EnterPeriod :\\n                opAmount = _N(initAccount.Stocks * PositionRatio,3)\\n                Dict = ext.Buy(opAmount) if n > 0 else ext.Sell(opAmount)\\n                if Dict :\\n                    opAmount = Di",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if Dict :\\n                    opAmount = Dict['amount']\\n                    state = PD_LONG if n > 0 else PD_SHORT\\n                    Log(\\\"开仓详情\\\",Dict,\\\"交叉周期\\\",n)\\n        else:\\n            n = ext.Cross(ExitFastPeriod,ExitSlowPeriod) # 指标交叉函数\\n            if abs(n) >= ExitPeriod and ((state == PD_LONG and n < 0) or (state == PD_SHORT and n > 0)) :\\n                nowAccount = ext.GetAccount()\\n                Dict2 = ext.Sell(nowAccount.Stocks - initAccount.Stocks) if state == PD_LONG else ext",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "- initAccount.Stocks) if state == PD_LONG else ext.Buy(initAccount.Stocks - nowAccount.Stocks)\\n                state = STATE_IDLE\\n                nowAccount = ext.GetAccount()\\n                LogProfit(nowAccount.Balance - initAccount.Balance,'钱：',nowAccount.Balance,'币：',nowAccount.Stocks,'平仓详情：',Dict2,'交叉周期：',n)\\n        Sleep(Interval * 1000)\\n\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/21157\\n\\n> Last Modified\\n\\n2016-09-30 23:25:18\"\n \n\n    \"strategy_79\",\n    \"python\\n'''backtest\\nstart: 2019-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rategy_79\",\n    \"python\\n'''backtest\\nstart: 2019-02-09 00:00:00\\nend: 2019-03-11 00:00:00\\nperiod: 1h\\nbasePeriod: 15m\\nexchanges: [{\\\"eid\\\":\\\"Bitfinex\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\n\\nimport itertools\\nfrom collections import deque\\n\\nimport numpy as np\\nfrom sklearn.ensemble import RandomForestClassifier\\n\\ndef main():\\n    initAccount = _C(exchange.GetAccount)\\n    position = 0\\n    classifier = RandomForestClassifier()\\n    win_len = 8\\n    input = deque(maxlen=300)\\n    output = deque(maxlen=300)\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "deque(maxlen=300)\\n    output = deque(maxlen=300)\\n    recent_prices = deque(maxlen=win_len + 2)\\n    interval = 3600000 # 一小时采样一次\\n    \\n    while True:\\n        ticker = _C(exchange.GetTicker)\\n        recent_prices.append(ticker.Last)\\n        \\n        if len(recent_prices) > 0:\\n            Sleep(interval)\\n            \\n        if len(recent_prices) < recent_prices.maxlen:\\n            continue\\n        # 计算波动率\\n        price_list = list(itertools.islice(recent_prices, 0, recent_prices.maxlen - 1))\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ce(recent_prices, 0, recent_prices.maxlen - 1))\\n        volt_list = np.divide(np.diff(recent_prices), price_list)\\n        # 根据波动范围，将其分类标记为: 上涨(>+0.5%)、下跌(<-0.5%)、平稳(-0.5%~+0.5%)\\n        trend_list = []\\n        for volt in volt_list:\\n            if 0.005 > volt > -0.005:\\n                trend_list.append(0)\\n            elif volt >= 0.005:\\n                trend_list.append(1)\\n            else:\\n                trend_list.append(-1)\\n\\n        # 添加波动数据到训练集\\n        input.append(trend_list[:-1])\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "到训练集\\n        input.append(trend_list[:-1])\\n        output.append(trend_list[-1])\\n\\n        # 当训练集个数包含 200 组数据时，认为可以拟合随机森林\\n        if len(input) < 200:\\n            continue\\n        classifier.fit(input, output)            # 拟合\\n        prediction = classifier.predict([trend_list[1:]])  # 预测\\n        if position == 0:\\n            if prediction == 1:\\n                exchange.Buy(-1, _C(exchange.GetAccount).Balance)\\n                position = 1\\n        else:\\n            if prediction == -1:\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " else:\\n            if prediction == -1:\\n                exchange.Sell(-1, _C(exchange.GetAccount).Stocks - initAccount.Stocks)\\n                position = 0\",\n    \"策略名称: 基于随机森林的趋势策略\\n\\nwhile True:\\n        ticker = _C(exchange.GetTicker)\\n        recent_prices.append(ticker.Last)\\n        \\n        if len(recent_prices) > 0:\\n            Sleep(interval)\\n            \\n        if len(recent_prices) < recent_prices.maxlen:\\n            continue\\n        # 计算波动率\\n        price_list = list(itertools.islice(re",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "波动率\\n        price_list = list(itertools.islice(recent_prices, 0, recent_prices.maxlen - 1))\\n        volt_list = np.divide(np.diff(recent_prices), price_list)\\n        # 根据波动范围，将其分类标记为: 上涨(>+0.5%)、下跌(<-0.5%)、平稳(-0.5%~+0.5%)\\n        trend_list = []\\n        for volt in volt_list:\\n            if 0.005 > volt > -0.005:\\n                trend_list.append(0)\\n            elif volt >= 0.005:\\n                trend_list.append(1)\\n            else:\\n                trend_list.append(-1)\\n\\n        # 添加波动数据到训练集\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    trend_list.append(-1)\\n\\n        # 添加波动数据到训练集\\n        input.append(trend_list[:-1])\\n        output.append(trend_list[-1])\\n\\n        # 当训练集个数包含 200 组数据时，认为可以拟合随机森林\\n        if len(input) < 200:\\n            continue\\n        classifier.fit(input, output)            # 拟合\\n        prediction = classifier.predict([trend_list[1:]])  # 预测\\n        if position == 0:\\n            if prediction == 1:\\n                exchange.Buy(-1, _C(exchange.GetAccount).Balance)\\n                position = 1\\n        else",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lance)\\n                position = 1\\n        else:\\n            if prediction == -1:\\n                exchange.Sell(-1, _C(exchange.GetAccount).Stocks - initAccount.Stocks)\\n                position = 0\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/140199\\n\\n> Last Modified\\n\\n2022-05-20 01:16:44\"\n \n\n    \"strategy_80\",\n    \"python\\n'''backtest\\nstart: 2021-08-01 00:00:00\\nend: 2021-09-01 00:00:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"balance\\\":1000000,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"balance\\\":1000000,\\\"stocks\\\":0,\\\"fee\\\":[0.06,0.075]}]\\nargs: [[\\\"lower_price\\\",30000],[\\\"upper_price\\\",50000],[\\\"grid_num\\\",200],[\\\"trading_per_grid\\\",0.1]]\\n'''\\n\\ngrid = dict()\\ninterval = 0\\n\\n\\nclass GridItem:\\n    def __init__(self, order_id, status, price):\\n        self.order_id = order_id\\n        self.status = status  # -1：此点为空白点; -2：此点未下过单\\n        self.side = 0  # 1：买入；2：卖出；0：未知\\n        self.price = price\\n\\n\\ndef create_grid(ticker_price):\\n    global grid\\n    g",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "create_grid(ticker_price):\\n    global grid\\n    global interval\\n\\n    exchange.SetCurrency(trading_pair)\\n    exchange.SetPrecision(price_precision, amount_precision)\\n\\n    interval = _N((upper_price - lower_price) / grid_num, price_precision)\\n    \\n    grid[lower_price] = GridItem(-1, -2, lower_price)\\n    grid[upper_price] = GridItem(-1, -2, upper_price)\\n    for i in range(1, grid_num):\\n        price = lower_price + interval * i\\n        grid[price] = GridItem(-1, -2, price)\\n        \\n    buy_stock",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= GridItem(-1, -2, price)\\n        \\n    buy_stocks = (grid_num - int((ticker_price - lower_price) / interval) - 1) * trading_per_grid\\n    buy_2_sell(buy_stocks)\\n    \\n    \\ndef buy_2_sell(buy_stocks):\\n    while True:\\n        account = exchange.GetAccount()\\n        stocks = _N(account['Stocks'], amount_precision)\\n        if stocks < buy_stocks:\\n            depth = exchange.GetDepth()\\n            price = depth['Asks'][0]['Price']\\n            vol = _N(price * trading_per_grid, price_precision)\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(price * trading_per_grid, price_precision)\\n            min_vol = 1.0 / (10 ** price_precision)\\n            exchange.Buy(-1, vol if vol > min_vol else min_vol)\\n        else:\\n            break\\n        Sleep(1000)\\n\\n\\ndef set_blank(price):\\n    grid[price].order_id = -1\\n    grid[price].status = -1\\n    grid[price].side = 0\\n\\n\\ndef update_order():\\n    last_blank_price = -1\\n    close_price_list = set()\\n\\n    for grid_item in grid.values():\\n        if grid_item.status == -1:\\n            last_blank_p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " grid_item.status == -1:\\n            last_blank_price = grid_item.price\\n        elif grid_item.status == -2:\\n            close_price_list.add(grid_item.price)\\n        else:\\n            order = exchange.GetOrder(grid_item.order_id)\\n            grid_item.status = order[\\\"Status\\\"]\\n            if grid_item.status == 1:\\n                close_price_list.add(grid_item.price)\\n    return close_price_list, last_blank_price\\n\\n\\ndef remove_blank(close_price_list, last_blank_price):\\n    if last_blank_price !",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ist, last_blank_price):\\n    if last_blank_price != -1:\\n        close_price_list.discard(last_blank_price)\\n\\n\\ndef set_left_blank(close_price_list, left_side_grid, last_blank_price):\\n    set_blank(left_side_grid)\\n    close_price_list.discard(left_side_grid)\\n    if last_blank_price != -1:\\n        close_price_list.add(last_blank_price)\\n    \\n    \\ndef set_right_blank(close_price_list, right_side_grid, last_blank_price):\\n    set_blank(right_side_grid)\\n    close_price_list.discard(right_side_grid)\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    close_price_list.discard(right_side_grid)\\n    if last_blank_price != -1:\\n        close_price_list.add(last_blank_price)\\n\\n\\ndef trace():\\n    close_price_list, last_blank_price = update_order()\\n    \\n    has_buy_order = False\\n    for price in close_price_list:\\n        if grid[price].side == 1:\\n            has_buy_order = True\\n            break\\n    \\n    if has_buy_order:\\n        ticker_price = min(close_price_list) - interval / 2.0\\n    else:\\n        ticker = exchange.GetTicker()\\n        tic",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        ticker = exchange.GetTicker()\\n        ticker_price = ticker['Last']\\n    \\n    if not grid:\\n        create_grid(ticker_price)\\n\\n    left_side_grid = int((ticker_price - lower_price) / interval) * interval + lower_price\\n    right_side_grid = left_side_grid + interval\\n\\n    # 设置空白点\\n    # 当前价格左侧未成交，当前价格右侧未成交，不存在\\n    # 当前价格左侧空白点，当前价格右侧空白点，不存在\\n    # 左侧和右侧任何一个为空白点，不需要更新空白点\\n    if left_side_grid >= upper_price or right_side_grid <= lower_price:\\n        # 在区间外，不需要空白点\\n        remove_blank(close_pr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      # 在区间外，不需要空白点\\n        remove_blank(close_price_list, last_blank_price)\\n    elif grid[left_side_grid].status == 0 and grid[right_side_grid].status == 1:\\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 0:\\n        set_left_blank(close_price_list, left_side_grid, last_blank_price)\\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 1:\\n        set_right_blank(close_pri",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d].status == 1:\\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\\n    elif grid[left_side_grid].status == -2 and grid[right_side_grid].status == -2:\\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\\n\\n    # 重新下单\\n    for price in close_price_list:            \\n        if price <= ticker_price:\\n            order_id = exchange.Buy(price, trading_per_grid)\\n            side = 1\\n        else:\\n            buy_2_sell(trading_per_grid)\\n            order",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   buy_2_sell(trading_per_grid)\\n            order_id = exchange.Sell(price, trading_per_grid)\\n            side = 2\\n\\n        if order_id:\\n            grid[price].order_id = order_id\\n            grid[price].status = 0\\n            grid[price].side = side\\n\\n\\ndef main():\\n    while True:\\n        trace()\\n        Sleep(1000)\",\n    \"策略名称: 基础网格交易策略\\n\\nself.side = 0  # 1：买入；2：卖出；0：未知\\n        self.price = price\\n\\n\\ndef create_grid(ticker_price):\\n    global grid\\n    global interval\\n\\n    exchange.SetCur",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l grid\\n    global interval\\n\\n    exchange.SetCurrency(trading_pair)\\n    exchange.SetPrecision(price_precision, amount_precision)\\n\\n    interval = _N((upper_price - lower_price) / grid_num, price_precision)\\n    \\n    grid[lower_price] = GridItem(-1, -2, lower_price)\\n    grid[upper_price] = GridItem(-1, -2, upper_price)\\n    for i in range(1, grid_num):\\n        price = lower_price + interval * i\\n        grid[price] = GridItem(-1, -2, price)\\n        \\n    buy_stocks = (grid_num - int((ticker_price - l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    buy_stocks = (grid_num - int((ticker_price - lower_price) / interval) - 1) * trading_per_grid\\n    buy_2_sell(buy_stocks)\\n    \\n    \\ndef buy_2_sell(buy_stocks):\\n    while True:\\n        account = exchange.GetAccount()\\n        stocks = _N(account['Stocks'], amount_precision)\\n        if stocks < buy_stocks:\\n            depth = exchange.GetDepth()\\n            price = depth['Asks'][0]['Price']\\n            vol = _N(price * trading_per_grid, price_precision)\\n            min_vol = 1.0 / (10 ** price_p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ision)\\n            min_vol = 1.0 / (10 ** price_precision)\\n            exchange.Buy(-1, vol if vol > min_vol else min_vol)\\n        else:\\n            break\\n        Sleep(1000)\\n\\n\\ndef set_blank(price):\\n    grid[price].order_id = -1\\n    grid[price].status = -1\\n    grid[price].side = 0\\n\\n\\ndef update_order():\\n    last_blank_price = -1\\n    close_price_list = set()\\n\\n    for grid_item in grid.values():\\n        if grid_item.status == -1:\\n            last_blank_price = grid_item.price\\n        elif ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " last_blank_price = grid_item.price\\n        elif grid_item.status == -2:\\n            close_price_list.add(grid_item.price)\\n        else:\\n            order = exchange.GetOrder(grid_item.order_id)\\n            grid_item.status = order[\\\"Status\\\"]\\n            if grid_item.status == 1:\\n                close_price_list.add(grid_item.price)\\n    return close_price_list, last_blank_price\\n\\n\\ndef remove_blank(close_price_list, last_blank_price):\\n    if last_blank_price != -1:\\n        close_price_list.disca",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "blank_price != -1:\\n        close_price_list.discard(last_blank_price)\\n\\n\\ndef set_left_blank(close_price_list, left_side_grid, last_blank_price):\\n    set_blank(left_side_grid)\\n    close_price_list.discard(left_side_grid)\\n    if last_blank_price != -1:\\n        close_price_list.add(last_blank_price)\\n    \\n    \\ndef set_right_blank(close_price_list, right_side_grid, last_blank_price):\\n    set_blank(right_side_grid)\\n    close_price_list.discard(right_side_grid)\\n    if last_blank_price != -1:\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de_grid)\\n    if last_blank_price != -1:\\n        close_price_list.add(last_blank_price)\\n\\n\\ndef trace():\\n    close_price_list, last_blank_price = update_order()\\n    \\n    has_buy_order = False\\n    for price in close_price_list:\\n        if grid[price].side == 1:\\n            has_buy_order = True\\n            break\\n    \\n    if has_buy_order:\\n        ticker_price = min(close_price_list) - interval / 2.0\\n    else:\\n        ticker = exchange.GetTicker()\\n        ticker_price = ticker['Last']\\n    \\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        ticker_price = ticker['Last']\\n    \\n    if not grid:\\n        create_grid(ticker_price)\\n\\n    left_side_grid = int((ticker_price - lower_price) / interval) * interval + lower_price\\n    right_side_grid = left_side_grid + interval\\n\\n    # 设置空白点\\n    # 当前价格左侧未成交，当前价格右侧未成交，不存在\\n    # 当前价格左侧空白点，当前价格右侧空白点，不存在\\n    # 左侧和右侧任何一个为空白点，不需要更新空白点\\n    if left_side_grid >= upper_price or right_side_grid <= lower_price:\\n        # 在区间外，不需要空白点\\n        remove_blank(close_price_list, last_blank_price)\\n    elif",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lank(close_price_list, last_blank_price)\\n    elif grid[left_side_grid].status == 0 and grid[right_side_grid].status == 1:\\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 0:\\n        set_left_blank(close_price_list, left_side_grid, last_blank_price)\\n    elif grid[left_side_grid].status == 1 and grid[right_side_grid].status == 1:\\n        set_right_blank(close_price_list, right_side_grid, last_blank_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ank(close_price_list, right_side_grid, last_blank_price)\\n    elif grid[left_side_grid].status == -2 and grid[right_side_grid].status == -2:\\n        set_right_blank(close_price_list, right_side_grid, last_blank_price)\\n\\n    # 重新下单\\n    for price in close_price_list:            \\n        if price <= ticker_price:\\n            order_id = exchange.Buy(price, trading_per_grid)\\n            side = 1\\n        else:\\n            buy_2_sell(trading_per_grid)\\n            order_id = exchange.Sell(price, trading_pe",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        order_id = exchange.Sell(price, trading_per_grid)\\n            side = 2\\n\\n        if order_id:\\n            grid[price].order_id = order_id\\n            grid[price].status = 0\\n            grid[price].side = side\\n\\n\\ndef main():\\n    while True:\\n        trace()\\n        Sleep(1000)\\n\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/316809\\n\\n> Last Modified\\n\\n2021-09-27 11:59:39\"\n \n\n    \"strategy_81\",\n    \"python\\n\\n'''backtest\\nstart: 2020-03-11 00:00:00\\nend: 2020-04-09 23:59:00\\nperiod: 1d\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "11 00:00:00\\nend: 2020-04-09 23:59:00\\nperiod: 1d\\nexchanges: [{\\\"eid\\\":\\\"Bitfinex\\\",\\\"currency\\\":\\\"BTC_USD\\\"}]\\n'''\\nimport pandas as pd\\nimport numpy as np\\nimport re\\npreBarTime_1=0\\n'''\\nshortChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\",  #single不参于分组，单独显示, 默认为分组 'group'\\n        \\\"height\\\" : 300, \\n   \\n    \\\"title\\\" : {\\\"text\\\": 'rb888' + '__15M交易信号图'},\\n    \\\"xAxis\\\" : {\\\"type\\\" : \\\"datetime\\\"}, # 时间序列轴\\n    \\\"yAxis\\\" : [{\\\"labels\\\": {\\n        \\\"align\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    \\\"yAxis\\\" : [{\\\"labels\\\": {\\n        \\\"align\\\": 'right',\\n        \\\"x\\\": -3\\n   \\n                \\\"title\\\": {\\n                    \\\"text\\\": '盘口'\\n               \\n                \\\"height\\\": \\\"45%\\\",  # 相对宽度大小\\n                \\\"resize\\\": {\\n                    \\\"enabled\\\": True  # 是否启用重置宽度  \\n               \\n                \\\"opposite\\\": True,  # 是否将轴显示在对面 默认左\\n                \\\"offset\\\": 0,  # 坐标轴偏移 正右 负左\\n                \\\"lineWidth\\\": 2  # 线宽\\n             \\\"labels\\\": {\\n        \\\"align\\\": 'right",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          \\\"labels\\\": {\\n        \\\"align\\\": 'right',\\n        \\\"x\\\": -3\\n   \\n                   \\\"title\\\": {\\n                       \\\"text\\\": 'RSI'\\n                  \\n                   \\\"top\\\": '45%',\\n                   \\\"height\\\": '25%',\\n                   \\\"opposite\\\": True,\\n                   \\\"offset\\\": 0,\\n                   \\\"lineWidth\\\": 2\\n                \\\"labels\\\": {\\n        \\\"align\\\": 'right',\\n        \\\"x\\\": -3\\n   \\n                      \\\"title\\\": {\\n                          \\\"text\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\\"title\\\": {\\n                          \\\"text\\\": 'MACD_5'\\n                     \\n                      \\\"top\\\": '70%',\\n                      \\\"height\\\": '30%',\\n                      \\\"opposite\\\": True,\\n                      \\\"offset\\\": 0,\\n                      \\\"lineWidth\\\": 2\\n                     }    \\n              ],\\n    \\\"tooltip\\\":{\\n        \\\"split\\\": False,  # 原生js？？\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\"\\n   \\n    \\\"series\\\" : [{'type': 'candlestick',\\n                 'name",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": [{'type': 'candlestick',\\n                 'name': 'k线',\\n                 #'color': 'green',\\n                 #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\\n                 #'upColor': 'red',\\n                 #'upLineColor': 'red',\\n                 \\\"data\\\" : [],\\n              \\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"rsi\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 1  # 相对位置\\n        }\\n        , {\\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"dif",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"diff\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 2  # 相对位置\\n      \\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"dea\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 2  # 相对位置\\n      \\n            \\\"type\\\" : \\\"column\\\",\\n            \\\"name\\\" : \\\"macd\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 2  # 相对位置\\n        }\\n    ]\\n}\\n'''\\n\\\"\\\"\\\"\\nshortChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"single\\\",  #single不参于分组，单独显示, 默认为分组 'group'\\n        \\\"height\\\" : 300, \\n   \\n    \\\"title\\\" : {\\\"text\\\": 'rb888' + '__15M交易信号图'},\\n    \\\"xAxis\\\" : {\\\"type\\\" : \\\"datetime\\\"}, # 时间序列轴\\n    \\\"yAxis\\\" : {\\\"labels\\\": {\\n                    \\\"align\\\": 'right',\\n                    \\\"x\\\": -3\\n               \\n                \\\"title\\\": {\\n                    \\\"text\\\": '盘口'\\n               \\n                #\\\"height\\\": \\\"45%\\\",  # 相对宽度大小\\n                #\\\"r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "height\\\": \\\"45%\\\",  # 相对宽度大小\\n                #\\\"resize\\\": {\\n                #    \\\"enabled\\\": True  # 是否启用重置宽度  \\n                \\\"opposite\\\": True,  # 是否将轴显示在对面 默认左\\n                \\\"offset\\\": 0,  # 坐标轴偏移 正右 负左\\n                \\\"lineWidth\\\": 2  # 线宽\\n   \\n    \\\"tooltip\\\" : {\\n        \\\"split\\\": false,  # 原生js？？\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\"\\n   \\n    \\\"series\\\" : {'type': 'candlestick',\\n                'name': 'k线',\\n                #'color': 'green',\\n                #'lineCol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     #'color': 'green',\\n                #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\\n                #'upColor': 'red',\\n                #'upLineColor': 'red',\\n                \\\"data\\\" : [],\\n            }\\n}\\n\\\"\\\"\\\"\\nshortChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n    \\\"layout\\\" : \\\"single\\\",  #single不参于分组，单独显示, 默认为分组 'group'\\n    #\\\"height\\\" : 500, \\n   \\n    'legend': {\\n        'enabled': true  # 图例 true开启\\n   \\n    'title' : {\\n        'text' : '柱形K线'\\n   \\n    \\\"xAxis\\\" ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " : {\\n        'text' : '柱形K线'\\n   \\n    \\\"xAxis\\\" : {\\n        \\\"type\\\" : \\\"datetime\\\",\\n        #'dashStyle': 'dash'  # 准心线样式 虚线\\n    # 时间序列轴\\n    'yAxis' : [{\\n        'labels':{\\n            'align':'right',\\n            'x':-3\\n       \\n        'height':\\\"40%\\\",\\n        'lineWidth':2,\\n        #'crosshair': true,  # 准心线\\n        'resize':{\\n            'enabled':true\\n        }\\n \\n        'labels':{\\n            'align':'right',\\n            'x':-3\\n       \\n        'title':{\\n            'text' : 'Vo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     \\n        'title':{\\n            'text' : 'Volume'\\n       \\n        'top':'40%',\\n        'height':'15%',\\n        'offset':0,\\n        #'crosshair': true,\\n        'lineWidth':2\\n \\\"labels\\\": {\\n            \\\"align\\\": 'right',\\n            \\\"x\\\":-3\\n       \\n        \\\"title\\\": {\\n            \\\"text\\\": 'RSI'\\n       \\n        \\\"top\\\": '55%',\\n        \\\"height\\\": '20%',\\n        \\\"opposite\\\": True,\\n        \\\"offset\\\": 0,\\n        #'crosshair': true,\\n        \\\"lineWidth\\\": 2,\\n        'plotLines': [{\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       \\\"lineWidth\\\": 2,\\n        'plotLines': [{\\n                'value': 75,  # 值大小\\n                'color': 'green',  # 颜色\\n                'dashStyle': 'shortdash', # 线条样式\\n                'width': 0.5,\\n                #'label': {\\n                #    'text': '多头止盈线'\\n                #}\\n     \\n                'value': 25,\\n                'color': 'red',\\n                'dashStyle': 'shortdash',\\n                'width': 0.5,\\n                #'label': {\\n                #    'text': '空头止盈线'\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "el': {\\n                #    'text': '空头止盈线'\\n                #}\\n        }\\n        ]\\n  \\\"labels\\\": {\\n            \\\"align\\\": 'right',\\n            \\\"x\\\":-3\\n   \\n        \\\"title\\\": {\\n            \\\"text\\\": 'MACD'\\n       \\n        \\\"top\\\": '75%',\\n        \\\"height\\\": '25%',\\n        \\\"opposite\\\": True,\\n        \\\"offset\\\": 0,\\n        \\\"lineWidth\\\": 2\\n    }\\n    ],\\n    'tooltip':{\\n        #'shared': true,  # 是否开启提示标签共享,多图下效果基本等同split\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\",\\n        'shar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rmat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\",\\n        'shared': true,\\n\\t\\t'crosshairs': true,\\n        'valueDecimals':2, # 保留小数\\n        #'split':true, # 提示框分开\\n        #'distance': 30,\\n\\t\\t#'padding': 5\\n        #'positioner': {\\n        #    'x':150,\\n        #    'y':150\\n        #},\\n        #'shadow': false,\\n        #'borderWidth': 0,\\n        #'backgroundColor': 'rgba(255,255,255,0.8)'\\n   \\n    'series':[{\\n        'type':'candlestick',\\n        'animationLimit':'Infinity',\\n        'color': 'green',\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Limit':'Infinity',\\n        'color': 'green',\\n        'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\\n        'upColor': 'red',\\n        'upLineColor': 'red',\\n        'name':'appl',\\n        'data':[]\\n \\n        'type':'column',\\n        'name':'Volume',\\n        'data':[],\\n        'yAxis':1\\n \\n        \\\"type\\\" : \\\"line\\\",\\n        \\\"name\\\" : \\\"rsi\\\",\\n        \\\"data\\\" : [],\\n        \\\"yAxis\\\": 2  # 相对位置\\n \\n        \\\"type\\\" : \\\"line\\\",\\n        \\\"name\\\" : \\\"diff\\\",\\n        \\\"data\\\" : [],\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"name\\\" : \\\"diff\\\",\\n        \\\"data\\\" : [],\\n        \\\"yAxis\\\": 3  # 相对位置\\n \\n        \\\"type\\\" : \\\"line\\\",\\n        \\\"name\\\" : \\\"dea\\\",\\n        \\\"data\\\" : [],\\n        \\\"yAxis\\\": 3  # 相对位置\\n \\n        \\\"type\\\" : \\\"column\\\",\\n        \\\"name\\\" : \\\"macd\\\",\\n        \\\"data\\\" : [],\\n        'maxPointWidth':2,  # 量柱最大宽度\\n        \\\"yAxis\\\": 3  # 相对位置\\n    }\\n\\n    ]\\n}\\n    \\n\\nlongChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n    'rangeSelector':{\\n        'selected' : 0 \\n   \\n    'chart': {  # 主配置项\\n        #'height': 630,  # 高度，平台不支持配置\\n        'type': 'line',\\n        'zoomType': 'x',  # 缩放\\n        #'selectionMarkerFill':'rgba(51,92,223,0.25)',  # 缩放框背景色\\n        #'panning': true,  # 开启平移\\n        #'panKey': 'shift'  # 平移\\n        'borderColor': '#EBBA95', # 外框配置项\\n        'borderWidth': 2,  ##\\n        'borderRadius': 10, ##\\n   \\n    \\\"rangeSelector\\\" : {\\n        \\\"buttons\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\n    \\\"rangeSelector\\\" : {\\n        \\\"buttons\\\" : [{\\n            \\\"type\\\" : \\\"hour\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1h\\\",\\n      \\n            \\\"type\\\" : 'hour',\\n            \\\"count\\\" : 3,\\n            \\\"text\\\" : \\\"3h\\\"\\n      \\n            \\\"type\\\" : \\\"day\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1d\\\"\\n      \\n            \\\"type\\\" : \\\"week\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1w\\\"\\n      \\n            \\\"type\\\" : \\\"year\\\",\\n            \\\"count",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         \\\"type\\\" : \\\"year\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1Y\\\"\\n      \\n            \\\"type\\\" : \\\"all\\\",\\n            \\\"text\\\" : \\\"All\\\"\\n        }],\\n        \\\"selected\\\" : 1,\\n        \\\"inputEnabled\\\" : True\\n   \\n    'legend': {\\n        'enabled': true  # 图例 true开启\\n   \\n    'title' : {\\n        'text' : '15'\\n   \\n    'subtitle': {\\n        'text': '湘水看盘图表',  #'当前价格:'+str(records_5[-1]['Close'] if records_5[-1]['Close'] is not None else **)+' || '+'当前时间:'+str(Time_5 if Time_5 i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "one else **)+' || '+'当前时间:'+str(Time_5 if Time_5 is not None else **)\\n   \\n    \\\"xAxis\\\" : {\\n        \\\"type\\\" : \\\"datetime\\\",\\n        #'dashStyle': 'dash'  # 准心线样式 虚线\\n    # 时间序列轴\\n    \\\"xAxis\\\" : {\\\"type\\\" : \\\"datetime\\\"},\\n    \\\"yAxis\\\" : [{\\n            \\\"title\\\": {\\n                \\\"text\\\": 'Kline'\\n           \\n            \\\"height\\\": \\\"60%\\\",  # 相对宽度大小\\n            \\\"offset\\\": 0,  # 坐标轴偏移 正右 负左\\n            \\\"lineWidth\\\": 2  # 线宽\\n     \\n            \\\"title\\\": {\\n                \\\"text\\\": 'MACD'\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\\"title\\\": {\\n                \\\"text\\\": 'MACD'\\n           \\n            \\\"top\\\": '62%',\\n            \\\"height\\\": '38%',\\n            \\\"offset\\\": 0,\\n            \\\"lineWidth\\\": 2\\n        }    \\n    ],\\n    \\\"series\\\" : [\\n      \\n            \\\"type\\\" : \\\"candlestick\\\", \\n            \\\"name\\\" : \\\"k_15\\\",\\n            \\\"id\\\" : \\\"k\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 0  # 相对位置\\n     \\n            \\\"type\\\" : \\\"column\\\",\\n            \\\"name\\\" : \\\"macd_15\\\",\\n            \\\"data\\\" : [],  \\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\" : \\\"macd_15\\\",\\n            \\\"data\\\" : [],  \\n            \\\"yAxis\\\": 1  # 相对位置\\n        }\\n    ]\\n}\\n\\nchart0 = {                                        \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n\\n    'title' : { 'text' : '日K线图'},                       \\n    'xAxis': { 'type': 'datetime'},            \\n    'series' : [                                          \\n                                            \\n            'type': 'c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                          \\n            'type': 'candlestick',                         \\n            'name': 'r',   \\n            'id': 'r',                                     \\n            'data': []                                           \\n                                            \\n            'type': 'column',           \\n            'name': 'vol',          \\n            'data': [],               \\n        }\\n    ]\\n}\\n\\nchart1 = {  \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"lay",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ck\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n                                      \\n    'title' : { 'text' : 'ris'},                       \\n    'xAxis': { 'type': 'datetime'},                       \\n    'yAxis' : {                                           \\n            'title': {'text': 'rsi'},                           \\n            'opposite': false                                 \\n   \\n    'series' :                                      \\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "series' :                                      \\n       \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'rsi',\\n            'data': []\\n   \\n}\\n\\n\\nchart2 = {  \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n                                      \\n    'title' : { 'text' : 'macd'},                       \\n    'xAxis': { 'type': 'datetime'},                       \\n    'yAxis' : {                             ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    \\n    'yAxis' : {                                           \\n            'title': {'text': 'macd'},                           \\n            'opposite': false                                 \\n   \\n    'series' :  [           \\n       \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'dif',\\n            'data': []\\n  \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'eda',\\n            'data': []\\n  \\n            'type': 'line',\\n            #'yAxi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'macd',\\n            'data': []\\n   \\n    ]\\n}\\n\\n\\nhart1 = {                                        \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n\\n    'title' : { 'text' : 'MACD_5'},                       \\n    'xAxis': { 'type': 'datetime'},             \\n    'series' : [                                          \\n                                        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        \\n                                            \\n            'type': 'candlestick',                             \\n            'name': 'k',   \\n            'id': 'r1',                                     \\n            'data': []                                           \\n                                            \\n            'type': 'column',           \\n            'name': 'macd_15',          \\n            'data': [],               \\n        }\\n    ]\\n}\\n\\n\\n\\n\\nmacd_15 = []\\nrunTime = {}\\nrunTim",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  ]\\n}\\n\\n\\n\\n\\nmacd_15 = []\\nrunTime = {}\\nrunTime['preBarTime_1'] = [0,0]\\nrunTime['arrKIndex'] = []\\n_5_lengh = 50\\n_15_lengh = 50\\ndef ticks_(records, k):\\n    if len(records) == 0:\\n        return []\\n    if isinstance(records[0], int) or isinstance(records[0], float):\\n        return records\\n\\n    ticks = [None] * len(records)\\n    for i in range(len(records)):\\n        ticks[i] = records[i][k]\\n        return ticks\\n\\n\\ndef plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart):\\n    for x,symbol in enu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "h,index_2,runTime,chart):\\n    for x,symbol in enumerate(arr):\\n        #Log(symbol,_D(),)\\n        runTime['arrKIndex'] = [index_2[x],index_2[x]+7]   # [0,7] [8,15]\\n        #Log(symbol)\\n        exchange.SetContractType(symbol)\\n        #Log(symbol,_D())\\n        records_5 = _C(exchange.GetRecords,PERIOD_M5)  # 返回列表型字典\\n        records_15 = _C(exchange.GetRecords,PERIOD_M15)\\n        r = records_5\\n        m = records_15\\n        Time_5 = records_5[-1]['Time']\\n        Time_5_list = pd.Series(ticks_(recor",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "me']\\n        Time_5_list = pd.Series(ticks_(records_5,'Time'))  # 小周期开盘时间数组\\n        #Open_5 = records_5['Open']\\n        #High_5 = records_5['High']\\n        #Low_5 = records_5['Low']\\n        Close_5 = pd.Series(ticks_(records_5,'Close'))  # 小周期收盘价数组\\n\\n        Time_15 = records_15[-1]['Time']\\n        Time_15_list = pd.Series(ticks_(records_15,'Time'))  # 小周期开盘时间数组\\n        #Open_5 = records_5['Open']\\n        #High_5 = records_5['High']\\n        #Low_5 = records_5['Low']\\n        Close_15 = pd.Series(t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= records_5['Low']\\n        Close_15 = pd.Series(ticks_(records_15,'Close'))  # 小周期收盘价数组\\n\\n        #Log(2)\\n        '''\\n        nowdea_15 = dea_15[-1]\\n        nowdiff_15 = diff_15[-1]\\n        nowmacd_15 = macd_15[-1]\\n        '''\\n\\n        '''\\n        predea_15 = dea_15[-2]\\n        prediff_15 = diff_15[-2]\\n        premacd_15 = macd_15[-2]\\n        '''\\n        #index_1 += 5\\n        if not r or not m:\\n            return\\n        #Log(3,len(r))\\n\\n        if len(r) < _5_lengh:  # 过滤K线过短情况\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if len(r) < _5_lengh:  # 过滤K线过短情况\\n            return\\n\\n        #Log(4)\\n        Macd_5 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\\n        diff_5 = Macd_5[0]\\n        dea_5 = Macd_5[1]\\n        macd_5 = pd.Series(Macd_5[2]).fillna(0)\\n        macd_5 = macd_5.values*2  # TA的macd算法未乘以2\\n\\n        Macd_15 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\\n        diff_15 = Macd_15[0]\\n        dea_15 = Macd_15[1]\\n        macd_15 = pd.Series(Macd_15[2]).fil",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "15[1]\\n        macd_15 = pd.Series(Macd_15[2]).fillna(0)\\n        macd_15 = macd_15.values*2  # TA的macd算法未乘以2\\n\\n        RSI = TA.RSI(records_5, period = rsi_period)\\n        nowdea_5 = dea_5[-1]\\n        nowdiff_5 = diff_5[-1]\\n        nowmacd_5 = macd_5[-1]\\n        if len(macd_15) > 2:\\n            nowmacd_15 = macd_15[-1]\\n        nowrsi = RSI[-1]\\n        \\n        predea_5 = dea_5[-2]\\n        prediff_5 = diff_5[-2]\\n        premacd_5 = macd_5[-2]\\n        if len(macd_15) > 2:\\n            premacd_15 ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     if len(macd_15) > 2:\\n            premacd_15 = macd_15[-2]\\n        prersi = RSI[-2]\\n        #Log('K线长度',len(r),'dea_5',len(dea_5),'rsi',len(RSI),preBarTime_1)\\n            \\n            \\n\\n        if len(macd_15)>0:        \\n            #Log(time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",  time.localtime(int(records_5[-1]['Time'])/1000)),_D(),macd_15[-1])\\n            pass\\n        \\n        #r = records_5\\n        #m = records_15\\n        arr_ = [r,m]        \\n\\n        #Log(index_2)\\n        index_2 = index_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n        #Log(index_2)\\n        index_2 = index_2.copy()\\n        #index_2 = index_2.tolist()\\n        for i in range(len(arr_)):  # i 是k线周期循环\\n\\n            #Log(runTime['arrKIndex'])\\n            for j in range(len(arr_[i])):  # 时间周期循环\\n                #Log(arr_[i][j][\\\"Time\\\"],runTime['preBarTime_1'][i])\\n                if arr_[i][j][\\\"Time\\\"] == runTime['preBarTime_1'][i]:  # preBarTime初始为0\\n                    if i == 0:  #5分钟 #index_2 0 8\\n                        chart.add(int(index_2[x]), [arr_[i]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               chart.add(int(index_2[x]), [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Open\\\"], arr_[i][j][\\\"High\\\"], arr_[i][j][\\\"Low\\\"], arr_[i][j][\\\"Close\\\"]], -1)  # 选出不同周期K线的index\\n                        #Log(1,int(index_2[i]))\\n                    if i == 0 and len(arr_[i]) > _5_lengh:\\n                        #Log(2)\\n                        if j == len(arr_[i]) - 2:\\n                            #Log(3)\\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]],-1)  \\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\\\"Time\\\"], prersi], -1)    # 快线\\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], prediff_5], -1)    # 慢线\\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\\\"Time\\\"], predea_5], -1)\\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\\\"Time\\\"], premacd_5], -1)\\n                        elif j == len(arr_[i])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1)\\n                        elif j == len(arr_[i]) - 1:\\n                            #Log(4,int(index_2[i]))\\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]],-1)  \\n                            #Log(4.1)\\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\\\"Time\\\"], nowrsi], -1)    # 快线\\n                            #Log(4.2)\\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], nowdiff_5], -1)    # 慢线\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", [arr_[i][j][\\\"Time\\\"], nowdiff_5], -1)    # 慢线\\n                            #Log(4.3)\\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\\\"Time\\\"], nowdea_5], -1)\\n                            #Log(4.4)\\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\\\"Time\\\"], nowmacd_5], -1)\\n                            #Log(4.5)\\n                    '''\\n                    if i == 1 and len(arr_[i]) > _15_lengh:\\n                        if j == len(arr_[i]) - 2:\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            if j == len(arr_[i]) - 2:\\n                            chart.add(index_2 + 8, [arr_[i][j][\\\"Time\\\"], premacd_15], -1)    # 快线\\n                        elif j == len(arr_[i]) - 2:\\n                            chart.add(index_2 + 8, [arr_[i][j][\\\"Time\\\"], nowmacd_15], -1)    # 快线\\n                    '''\\n                elif arr_[i][j][\\\"Time\\\"] > runTime['preBarTime_1'][i]:  # 初始运行此处  每个5，15分钟运行两次\\n                    \\n                    if i ==1:\\n                        pass\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=1:\\n                        pass\\n                        \\n                        #Log(time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",  time.localtime(int(arr_[i][j][\\\"Time\\\"])/1000)),time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",  time.localtime(int(runTime['preBarTime_1'][i])/1000)),'//',i)\\n                    runTime['preBarTime_1'][i] = arr_[i][j][\\\"Time\\\"]  # K线时间赋值给preBarTime\\n                    Log(runTime['preBarTime_1'][0],runTime['preBarTime_1'][1])\\n                    # 0 7 8 15\\n                    chart.add(i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       # 0 7 8 15\\n                    chart.add(int(runTime['arrKIndex'][x]), [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Open\\\"], arr_[i][j][\\\"High\\\"], arr_[i][j][\\\"Low\\\"], arr_[i][j][\\\"Close\\\"]])\\n                    if i ==0 and len(arr_[i]) > _5_lengh:\\n                        #Log('i=0',int(runTime['arrKIndex'][x]))\\n                        if j == len(arr_[i]) - 1:\\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]])\\n                            chart.ad",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"Volume\\\"]])\\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\\\"Time\\\"], nowrsi])\\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], nowdiff_5])\\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\\\"Time\\\"], nowdea_5])\\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\\\"Time\\\"], nowmacd_5])\\n                    \\n                    if i == 1 and len(arr_[i]) > _15_lengh:\\n                        Log('i=1',int(i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "15_lengh:\\n                        Log('i=1',int(index_2[x]) + 7)\\n                        if j == len(arr_[i]) - 1:\\n                            chart.add(int(index_2[x]) + 7, [arr_[i][j][\\\"Time\\\"], nowmacd_5])\\n\\ndef main():\\n    \\\"\\\"\\\"\\n    \\\"\\\"\\\"\\n    global preBarTime_1,macd_15,runTime,_5_lengh,_15_lengh,shortChart,longChart,chart0,chart1,chart2,hart1\\n    if exchange.GetName().find(\\\"CTP\\\") == -1:\\n        raise Exception(\\\"只支持商品期货CTP\\\")\\n    SetErrorFilter(\\\"login|ready|流控|连接失败|初始|Timeout\\\")\\n    mod",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ilter(\\\"login|ready|流控|连接失败|初始|Timeout\\\")\\n    mode = exchange.IO(\\\"mode\\\", 0)\\n    if mode is None:\\n        raise Exception(\\\"切换模式失败，请更新到最新托管者！\\\")\\n    while not exchange.IO(\\\"status\\\"):\\n        Sleep(3000)\\n        LogStatus(\\\"正在等待与交易服务器连接，\\\" + _D())\\n    positions = _C(exchange.GetPosition)  # 获取当前持仓信息字典\\n    if len(positions) > 0:\\n        Log(\\\"检测到当前持有仓位，系统将开始尝试恢复进度...\\\")\\n        Log(\\\"持仓信息：\\\", positions)\\n\\n\\n    tts = []  # \\n    arrChart_1 = []  # 图表数组\\n    arrChart_2 = []\\n    index_ = 0  # \\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 图表数组\\n    arrChart_2 = []\\n    index_ = 0  # \\n    index_2 = []\\n    arrKIndex = []\\n    a = []\\n    b = []\\n    c = []\\n    d = []\\n\\n    #while True:\\n    #Log(1)\\n    symbolFilter = {}  # 过滤用数组\\n    arr = Instruments.split(\\\",\\\")  # 合约列表\\n    for i in range(len(arr)):  # 遍历合约列表\\n        symbol = re.sub(r'/\\\\s+$/g', \\\"\\\", re.sub(r'/^\\\\s+/g', \\\"\\\", arr[i]))  # 规整合约字符串\\n        if symbol in symbolFilter.keys():  # 如果 在过滤数组中 存在 名为 symbol的属性，则显示信息 并跳过。\\n            raise Exception(symbol + \\\"已经存在，请检查参数！\\\")\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       raise Exception(symbol + \\\"已经存在，请检查参数！\\\")\\n        symbolFilter[symbol] = True  # 给过滤数组 添加 名为 symbol 的 keys，下次 同样的 合约代码 会被过滤 保证每个合约只对Manager类方法传入一次参数\\n        hasPosition = False  # 初始化 hasPosition 变量 false 代表没有持仓 \\n        for j in range(len(positions)):  # 遍历 获取到的持仓信息\\n            if positions[j][\\\"ContractType\\\"] == symbol:  # 如果持仓中有合约名等于symbol\\n                Log('cc')\\n                hasPosition = True  # 标记 True 持仓\\n                break  # 跳出\\n        #fastPeriod = int(arrFastPeriod[i])  # 规",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        #fastPeriod = int(arrFastPeriod[i])  # 规整为数值型\\n        #slowPeriod = int(arrSlowPeriod[i])\\n        Log(123)\\n        obj_1 = shortChart #  实例化Manager类\\n        obj_2 = longChart\\n        index_2.append(index_)  # 0 8\\n        index_ += 8 # 长周期的图表index\\n        \\n        #tts.append(obj)  # tts列表传入 最终根据合约列表 ，生成了若干个品种的 控制对象储存在tts数组 \\n        #Log(obj)\\n        arrChart_1.append(obj_1)   # 在for循环中 依次把图表信息字典传入图表数组\\n        #arrChart_2.append(obj_2)\\n        a.append(chart0)\\n        b.append(chart1)\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       a.append(chart0)\\n        b.append(chart1)\\n        c.append(chart2)\\n        d.append(hart1)\\n        Log(len(arrChart_1))\\n        Log(111 if arrChart_1[0]==shortChart else 000)\\n        #arrChart_2.append(obj.longChart)\\n    # 创建图表对象\\n    #chart = Chart([arrChart_1, arrChart_2])  # __isStock\\\" : True表示是highstock图，False表示是highcharts图 使用多图表对象，转为二维数组\\n    #chart = Chart([arrChart_1,arrChart_2])\\n    chart = Chart([a,b,c,d])\\n    #Log(len(arrChart_1),len(arrChart_2))\\n    index_2 = np.array(index_2)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "en(arrChart_2))\\n    index_2 = np.array(index_2)\\n    chart.reset()  # 清空上次轮询的图表数据\\n\\n    while True:\\n        #c = Chart(shortChart)\\n        preTicker = None\\n        #while True:\\n        #Log(1)\\n        if exchange.IO('status'):\\n            LogStatus(_D(),'已经连接')\\n            #t = exchange.GetTicker()\\n            plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart)\\n        Sleep(1000)                      \\n        ''' \\n        if i ==0:\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==1:\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if signals['buy_sell_sig'+str(trueSymbol)] ==1:\\n                Log(1)\\n                #ext.PlotFlag(r[-2]['Time'],'开多','L','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'L','text':'开多'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==2:\\n                Log(2)\\n                #ext.PlotFlag(r[-2]['Time'],'开空','S','circlepin','K')\\n                chart.add(index_2 + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "clepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'S','text':'开空'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==3:\\n                Log(3)\\n                #ext.PlotFlag(r[-2]['Time'],'平多','UL','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'UL','text':'平多'}])\\n                signals['buy_sell_sig'+str(trueS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==4:\\n                Log(4)\\n                #ext.PlotFlag(r[-2]['Time'],'平空','US','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'US','text':'平空'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n\\n        '''\\n\\n                    #index_1 += 9  # 短周期的图表index\",\n    \"策略名称: 复杂看盘图表测试版\\n\\n\\\"yAxis\\\" : [{\\\"labels\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",\n    \"策略名称: 复杂看盘图表测试版\\n\\n\\\"yAxis\\\" : [{\\\"labels\\\": {\\n        \\\"align\\\": 'right',\\n        \\\"x\\\": -3\\n   \\n                \\\"title\\\": {\\n                    \\\"text\\\": '盘口'\\n               \\n                \\\"height\\\": \\\"45%\\\",  # 相对宽度大小\\n                \\\"resize\\\": {\\n                    \\\"enabled\\\": True  # 是否启用重置宽度  \\n               \\n                \\\"opposite\\\": True,  # 是否将轴显示在对面 默认左\\n                \\\"offset\\\": 0,  # 坐标轴偏移 正右 负左\\n                \\\"lineWidth\\\": 2  # 线宽\\n             \\\"labels\\\": {\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eWidth\\\": 2  # 线宽\\n             \\\"labels\\\": {\\n        \\\"align\\\": 'right',\\n        \\\"x\\\": -3\\n   \\n                   \\\"title\\\": {\\n                       \\\"text\\\": 'RSI'\\n                  \\n                   \\\"top\\\": '45%',\\n                   \\\"height\\\": '25%',\\n                   \\\"opposite\\\": True,\\n                   \\\"offset\\\": 0,\\n                   \\\"lineWidth\\\": 2\\n                \\\"labels\\\": {\\n        \\\"align\\\": 'right',\\n        \\\"x\\\": -3\\n   \\n                      \\\"title\\\": {\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                      \\\"title\\\": {\\n                          \\\"text\\\": 'MACD_5'\\n                     \\n                      \\\"top\\\": '70%',\\n                      \\\"height\\\": '30%',\\n                      \\\"opposite\\\": True,\\n                      \\\"offset\\\": 0,\\n                      \\\"lineWidth\\\": 2\\n                     }    \\n              ],\\n    \\\"tooltip\\\":{\\n        \\\"split\\\": False,  # 原生js？？\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\"\\n   \\n    \\\"series\\\" : [{'type': 'candlestick',\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n   \\n    \\\"series\\\" : [{'type': 'candlestick',\\n                 'name': 'k线',\\n                 #'color': 'green',\\n                 #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\\n                 #'upColor': 'red',\\n                 #'upLineColor': 'red',\\n                 \\\"data\\\" : [],\\n              \\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"rsi\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 1  # 相对位置\\n        }\\n        , {\\n            \\\"type\\\" : \\\"line\\\",\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     , {\\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"diff\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 2  # 相对位置\\n      \\n            \\\"type\\\" : \\\"line\\\",\\n            \\\"name\\\" : \\\"dea\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 2  # 相对位置\\n      \\n            \\\"type\\\" : \\\"column\\\",\\n            \\\"name\\\" : \\\"macd\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 2  # 相对位置\\n        }\\n    ]\\n}\\n'''\\n\\\"\\\"\\\"\\nshortChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"single\\\",  #single不参于分组，单独显示, 默认为分组 'group'\\n        \\\"height\\\" : 300, \\n   \\n    \\\"title\\\" : {\\\"text\\\": 'rb888' + '__15M交易信号图'},\\n    \\\"xAxis\\\" : {\\\"type\\\" : \\\"datetime\\\"}, # 时间序列轴\\n    \\\"yAxis\\\" : {\\\"labels\\\": {\\n                    \\\"align\\\": 'right',\\n                    \\\"x\\\": -3\\n               \\n                \\\"title\\\": {\\n                    \\\"text\\\": '盘口'\\n               \\n                #\\\"height\\\": \\\"45%\\\",  # 相对宽度大小",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n                #\\\"height\\\": \\\"45%\\\",  # 相对宽度大小\\n                #\\\"resize\\\": {\\n                #    \\\"enabled\\\": True  # 是否启用重置宽度  \\n                \\\"opposite\\\": True,  # 是否将轴显示在对面 默认左\\n                \\\"offset\\\": 0,  # 坐标轴偏移 正右 负左\\n                \\\"lineWidth\\\": 2  # 线宽\\n   \\n    \\\"tooltip\\\" : {\\n        \\\"split\\\": false,  # 原生js？？\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\"\\n   \\n    \\\"series\\\" : {'type': 'candlestick',\\n                'name': 'k线',\\n                #'color': 'green',\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e': 'k线',\\n                #'color': 'green',\\n                #'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\\n                #'upColor': 'red',\\n                #'upLineColor': 'red',\\n                \\\"data\\\" : [],\\n            }\\n}\\n\\\"\\\"\\\"\\nshortChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n    \\\"layout\\\" : \\\"single\\\",  #single不参于分组，单独显示, 默认为分组 'group'\\n    #\\\"height\\\" : 500, \\n   \\n    'legend': {\\n        'enabled': true  # 图例 true开启\\n   \\n    'title' : {\\n        'text' : '柱形K线",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ue开启\\n   \\n    'title' : {\\n        'text' : '柱形K线'\\n   \\n    \\\"xAxis\\\" : {\\n        \\\"type\\\" : \\\"datetime\\\",\\n        #'dashStyle': 'dash'  # 准心线样式 虚线\\n    # 时间序列轴\\n    'yAxis' : [{\\n        'labels':{\\n            'align':'right',\\n            'x':-3\\n       \\n        'height':\\\"40%\\\",\\n        'lineWidth':2,\\n        #'crosshair': true,  # 准心线\\n        'resize':{\\n            'enabled':true\\n        }\\n \\n        'labels':{\\n            'align':'right',\\n            'x':-3\\n       \\n        'title':{\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            'x':-3\\n       \\n        'title':{\\n            'text' : 'Volume'\\n       \\n        'top':'40%',\\n        'height':'15%',\\n        'offset':0,\\n        #'crosshair': true,\\n        'lineWidth':2\\n \\\"labels\\\": {\\n            \\\"align\\\": 'right',\\n            \\\"x\\\":-3\\n       \\n        \\\"title\\\": {\\n            \\\"text\\\": 'RSI'\\n       \\n        \\\"top\\\": '55%',\\n        \\\"height\\\": '20%',\\n        \\\"opposite\\\": True,\\n        \\\"offset\\\": 0,\\n        #'crosshair': true,\\n        \\\"lineWidth\\\": 2,\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#'crosshair': true,\\n        \\\"lineWidth\\\": 2,\\n        'plotLines': [{\\n                'value': 75,  # 值大小\\n                'color': 'green',  # 颜色\\n                'dashStyle': 'shortdash', # 线条样式\\n                'width': 0.5,\\n                #'label': {\\n                #    'text': '多头止盈线'\\n                #}\\n     \\n                'value': 25,\\n                'color': 'red',\\n                'dashStyle': 'shortdash',\\n                'width': 0.5,\\n                #'label': {\\n                #   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                #'label': {\\n                #    'text': '空头止盈线'\\n                #}\\n        }\\n        ]\\n  \\\"labels\\\": {\\n            \\\"align\\\": 'right',\\n            \\\"x\\\":-3\\n   \\n        \\\"title\\\": {\\n            \\\"text\\\": 'MACD'\\n       \\n        \\\"top\\\": '75%',\\n        \\\"height\\\": '25%',\\n        \\\"opposite\\\": True,\\n        \\\"offset\\\": 0,\\n        \\\"lineWidth\\\": 2\\n    }\\n    ],\\n    'tooltip':{\\n        #'shared': true,  # 是否开启提示标签共享,多图下效果基本等同split\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lit\\n        \\\"xDateFormat\\\" : \\\"%Y-%m-%d %H:%M:%S, %A\\\",\\n        'shared': true,\\n\\t\\t'crosshairs': true,\\n        'valueDecimals':2, # 保留小数\\n        #'split':true, # 提示框分开\\n        #'distance': 30,\\n\\t\\t#'padding': 5\\n        #'positioner': {\\n        #    'x':150,\\n        #    'y':150\\n        #},\\n        #'shadow': false,\\n        #'borderWidth': 0,\\n        #'backgroundColor': 'rgba(255,255,255,0.8)'\\n   \\n    'series':[{\\n        'type':'candlestick',\\n        'animationLimit':'Infinity',\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "',\\n        'animationLimit':'Infinity',\\n        'color': 'green',\\n        'lineColor': 'green',  # 默认显示color的设置，非null这按照这里的设置显示\\n        'upColor': 'red',\\n        'upLineColor': 'red',\\n        'name':'appl',\\n        'data':[]\\n \\n        'type':'column',\\n        'name':'Volume',\\n        'data':[],\\n        'yAxis':1\\n \\n        \\\"type\\\" : \\\"line\\\",\\n        \\\"name\\\" : \\\"rsi\\\",\\n        \\\"data\\\" : [],\\n        \\\"yAxis\\\": 2  # 相对位置\\n \\n        \\\"type\\\" : \\\"line\\\",\\n        \\\"name\\\" : \\\"diff\\\",\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " : \\\"line\\\",\\n        \\\"name\\\" : \\\"diff\\\",\\n        \\\"data\\\" : [],\\n        \\\"yAxis\\\": 3  # 相对位置\\n \\n        \\\"type\\\" : \\\"line\\\",\\n        \\\"name\\\" : \\\"dea\\\",\\n        \\\"data\\\" : [],\\n        \\\"yAxis\\\": 3  # 相对位置\\n \\n        \\\"type\\\" : \\\"column\\\",\\n        \\\"name\\\" : \\\"macd\\\",\\n        \\\"data\\\" : [],\\n        'maxPointWidth':2,  # 量柱最大宽度\\n        \\\"yAxis\\\": 3  # 相对位置\\n    }\\n\\n    ]\\n}\\n    \\n\\nlongChart = {\\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"heig",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n    'rangeSelector':{\\n        'selected' : 0 \\n   \\n    'chart': {  # 主配置项\\n        #'height': 630,  # 高度，平台不支持配置\\n        'type': 'line',\\n        'zoomType': 'x',  # 缩放\\n        #'selectionMarkerFill':'rgba(51,92,223,0.25)',  # 缩放框背景色\\n        #'panning': true,  # 开启平移\\n        #'panKey': 'shift'  # 平移\\n        'borderColor': '#EBBA95', # 外框配置项\\n        'borderWidth': 2,  ##\\n        'borderRadius': 10, ##\\n   \\n    \\\"rangeSelector\\\" : ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rderRadius': 10, ##\\n   \\n    \\\"rangeSelector\\\" : {\\n        \\\"buttons\\\" : [{\\n            \\\"type\\\" : \\\"hour\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1h\\\",\\n      \\n            \\\"type\\\" : 'hour',\\n            \\\"count\\\" : 3,\\n            \\\"text\\\" : \\\"3h\\\"\\n      \\n            \\\"type\\\" : \\\"day\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1d\\\"\\n      \\n            \\\"type\\\" : \\\"week\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1w\\\"\\n      \\n            \\\"type\\\" : \\\"year\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " : \\\"1w\\\"\\n      \\n            \\\"type\\\" : \\\"year\\\",\\n            \\\"count\\\" : 1,\\n            \\\"text\\\" : \\\"1Y\\\"\\n      \\n            \\\"type\\\" : \\\"all\\\",\\n            \\\"text\\\" : \\\"All\\\"\\n        }],\\n        \\\"selected\\\" : 1,\\n        \\\"inputEnabled\\\" : True\\n   \\n    'legend': {\\n        'enabled': true  # 图例 true开启\\n   \\n    'title' : {\\n        'text' : '15'\\n   \\n    'subtitle': {\\n        'text': '湘水看盘图表',  #'当前价格:'+str(records_5[-1]['Close'] if records_5[-1]['Close'] is not None else **)+' || '+'当前时间:'+",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[-1]['Close'] is not None else **)+' || '+'当前时间:'+str(Time_5 if Time_5 is not None else **)\\n   \\n    \\\"xAxis\\\" : {\\n        \\\"type\\\" : \\\"datetime\\\",\\n        #'dashStyle': 'dash'  # 准心线样式 虚线\\n    # 时间序列轴\\n    \\\"xAxis\\\" : {\\\"type\\\" : \\\"datetime\\\"},\\n    \\\"yAxis\\\" : [{\\n            \\\"title\\\": {\\n                \\\"text\\\": 'Kline'\\n           \\n            \\\"height\\\": \\\"60%\\\",  # 相对宽度大小\\n            \\\"offset\\\": 0,  # 坐标轴偏移 正右 负左\\n            \\\"lineWidth\\\": 2  # 线宽\\n     \\n            \\\"title\\\": {\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 线宽\\n     \\n            \\\"title\\\": {\\n                \\\"text\\\": 'MACD'\\n           \\n            \\\"top\\\": '62%',\\n            \\\"height\\\": '38%',\\n            \\\"offset\\\": 0,\\n            \\\"lineWidth\\\": 2\\n        }    \\n    ],\\n    \\\"series\\\" : [\\n      \\n            \\\"type\\\" : \\\"candlestick\\\", \\n            \\\"name\\\" : \\\"k_15\\\",\\n            \\\"id\\\" : \\\"k\\\",\\n            \\\"data\\\" : [],\\n            \\\"yAxis\\\": 0  # 相对位置\\n     \\n            \\\"type\\\" : \\\"column\\\",\\n            \\\"name\\\" : \\\"macd_15\\\",\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",\\n            \\\"name\\\" : \\\"macd_15\\\",\\n            \\\"data\\\" : [],  \\n            \\\"yAxis\\\": 1  # 相对位置\\n        }\\n    ]\\n}\\n\\nchart0 = {                                        \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n\\n    'title' : { 'text' : '日K线图'},                       \\n    'xAxis': { 'type': 'datetime'},            \\n    'series' : [                                          \\n                                            \\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\n                                            \\n            'type': 'candlestick',                         \\n            'name': 'r',   \\n            'id': 'r',                                     \\n            'data': []                                           \\n                                            \\n            'type': 'column',           \\n            'name': 'vol',          \\n            'data': [],               \\n        }\\n    ]\\n}\\n\\nchart1 = {  \\n    \\\"__isStock\\\" : True,\\n    \\\"extensio",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1 = {  \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n                                      \\n    'title' : { 'text' : 'ris'},                       \\n    'xAxis': { 'type': 'datetime'},                       \\n    'yAxis' : {                                           \\n            'title': {'text': 'rsi'},                           \\n            'opposite': false                                 \\n   \\n    'series' :                   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          \\n   \\n    'series' :                                      \\n       \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'rsi',\\n            'data': []\\n   \\n}\\n\\n\\nchart2 = {  \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n                                      \\n    'title' : { 'text' : 'macd'},                       \\n    'xAxis': { 'type': 'datetime'},                       \\n    'yAxis' : {       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'},                       \\n    'yAxis' : {                                           \\n            'title': {'text': 'macd'},                           \\n            'opposite': false                                 \\n   \\n    'series' :  [           \\n       \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'dif',\\n            'data': []\\n  \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'eda',\\n            'data': []\\n  \\n            'type': 'line",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         'data': []\\n  \\n            'type': 'line',\\n            #'yAxis': 1, \\n            'name': 'macd',\\n            'data': []\\n   \\n    ]\\n}\\n\\n\\nhart1 = {                                        \\n    \\\"__isStock\\\" : True,\\n    \\\"extension\\\" : {\\n        \\\"layout\\\" : \\\"group\\\", \\n        #\\\"height\\\" : 300, \\n   \\n\\n    'title' : { 'text' : 'MACD_5'},                       \\n    'xAxis': { 'type': 'datetime'},             \\n    'series' : [                                          \\n                  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                              \\n                                            \\n            'type': 'candlestick',                             \\n            'name': 'k',   \\n            'id': 'r1',                                     \\n            'data': []                                           \\n                                            \\n            'type': 'column',           \\n            'name': 'macd_15',          \\n            'data': [],               \\n        }\\n    ]\\n}\\n\\n\\n\\n\\nmacd_15 = []",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       \\n        }\\n    ]\\n}\\n\\n\\n\\n\\nmacd_15 = []\\nrunTime = {}\\nrunTime['preBarTime_1'] = [0,0]\\nrunTime['arrKIndex'] = []\\n_5_lengh = 50\\n_15_lengh = 50\\ndef ticks_(records, k):\\n    if len(records) == 0:\\n        return []\\n    if isinstance(records[0], int) or isinstance(records[0], float):\\n        return records\\n\\n    ticks = [None] * len(records)\\n    for i in range(len(records)):\\n        ticks[i] = records[i][k]\\n        return ticks\\n\\n\\ndef plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart):\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(arr,_5_lengh,_15_lengh,index_2,runTime,chart):\\n    for x,symbol in enumerate(arr):\\n        #Log(symbol,_D(),)\\n        runTime['arrKIndex'] = [index_2[x],index_2[x]+7]   # [0,7] [8,15]\\n        #Log(symbol)\\n        exchange.SetContractType(symbol)\\n        #Log(symbol,_D())\\n        records_5 = _C(exchange.GetRecords,PERIOD_M5)  # 返回列表型字典\\n        records_15 = _C(exchange.GetRecords,PERIOD_M15)\\n        r = records_5\\n        m = records_15\\n        Time_5 = records_5[-1]['Time']\\n        Time_5_list = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_5 = records_5[-1]['Time']\\n        Time_5_list = pd.Series(ticks_(records_5,'Time'))  # 小周期开盘时间数组\\n        #Open_5 = records_5['Open']\\n        #High_5 = records_5['High']\\n        #Low_5 = records_5['Low']\\n        Close_5 = pd.Series(ticks_(records_5,'Close'))  # 小周期收盘价数组\\n\\n        Time_15 = records_15[-1]['Time']\\n        Time_15_list = pd.Series(ticks_(records_15,'Time'))  # 小周期开盘时间数组\\n        #Open_5 = records_5['Open']\\n        #High_5 = records_5['High']\\n        #Low_5 = records_5['Low']\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "igh']\\n        #Low_5 = records_5['Low']\\n        Close_15 = pd.Series(ticks_(records_15,'Close'))  # 小周期收盘价数组\\n\\n        #Log(2)\\n        '''\\n        nowdea_15 = dea_15[-1]\\n        nowdiff_15 = diff_15[-1]\\n        nowmacd_15 = macd_15[-1]\\n        '''\\n\\n        '''\\n        predea_15 = dea_15[-2]\\n        prediff_15 = diff_15[-2]\\n        premacd_15 = macd_15[-2]\\n        '''\\n        #index_1 += 5\\n        if not r or not m:\\n            return\\n        #Log(3,len(r))\\n\\n        if len(r) < _5_lengh: ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  #Log(3,len(r))\\n\\n        if len(r) < _5_lengh:  # 过滤K线过短情况\\n            return\\n\\n        #Log(4)\\n        Macd_5 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\\n        diff_5 = Macd_5[0]\\n        dea_5 = Macd_5[1]\\n        macd_5 = pd.Series(Macd_5[2]).fillna(0)\\n        macd_5 = macd_5.values*2  # TA的macd算法未乘以2\\n\\n        Macd_15 = TA.MACD(r, fastEMA = fastEMA, slowEMA=slowEMA, signalEMA=signalEMA)\\n        diff_15 = Macd_15[0]\\n        dea_15 = Macd_15[1]\\n        macd_15 = pd.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        dea_15 = Macd_15[1]\\n        macd_15 = pd.Series(Macd_15[2]).fillna(0)\\n        macd_15 = macd_15.values*2  # TA的macd算法未乘以2\\n\\n        RSI = TA.RSI(records_5, period = rsi_period)\\n        nowdea_5 = dea_5[-1]\\n        nowdiff_5 = diff_5[-1]\\n        nowmacd_5 = macd_5[-1]\\n        if len(macd_15) > 2:\\n            nowmacd_15 = macd_15[-1]\\n        nowrsi = RSI[-1]\\n        \\n        predea_5 = dea_5[-2]\\n        prediff_5 = diff_5[-2]\\n        premacd_5 = macd_5[-2]\\n        if len(macd_15) > 2:\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cd_5 = macd_5[-2]\\n        if len(macd_15) > 2:\\n            premacd_15 = macd_15[-2]\\n        prersi = RSI[-2]\\n        #Log('K线长度',len(r),'dea_5',len(dea_5),'rsi',len(RSI),preBarTime_1)\\n            \\n            \\n\\n        if len(macd_15)>0:        \\n            #Log(time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",  time.localtime(int(records_5[-1]['Time'])/1000)),_D(),macd_15[-1])\\n            pass\\n        \\n        #r = records_5\\n        #m = records_15\\n        arr_ = [r,m]        \\n\\n        #Log(index_2)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " arr_ = [r,m]        \\n\\n        #Log(index_2)\\n        index_2 = index_2.copy()\\n        #index_2 = index_2.tolist()\\n        for i in range(len(arr_)):  # i 是k线周期循环\\n\\n            #Log(runTime['arrKIndex'])\\n            for j in range(len(arr_[i])):  # 时间周期循环\\n                #Log(arr_[i][j][\\\"Time\\\"],runTime['preBarTime_1'][i])\\n                if arr_[i][j][\\\"Time\\\"] == runTime['preBarTime_1'][i]:  # preBarTime初始为0\\n                    if i == 0:  #5分钟 #index_2 0 8\\n                        chart.add(int",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "index_2 0 8\\n                        chart.add(int(index_2[x]), [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Open\\\"], arr_[i][j][\\\"High\\\"], arr_[i][j][\\\"Low\\\"], arr_[i][j][\\\"Close\\\"]], -1)  # 选出不同周期K线的index\\n                        #Log(1,int(index_2[i]))\\n                    if i == 0 and len(arr_[i]) > _5_lengh:\\n                        #Log(2)\\n                        if j == len(arr_[i]) - 2:\\n                            #Log(3)\\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]],-1)  \\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\\\"Time\\\"], prersi], -1)    # 快线\\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], prediff_5], -1)    # 慢线\\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\\\"Time\\\"], predea_5], -1)\\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\\\"Time\\\"], premacd_5], -1)\\n                        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Time\\\"], premacd_5], -1)\\n                        elif j == len(arr_[i]) - 1:\\n                            #Log(4,int(index_2[i]))\\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]],-1)  \\n                            #Log(4.1)\\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\\\"Time\\\"], nowrsi], -1)    # 快线\\n                            #Log(4.2)\\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], now",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dd(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], nowdiff_5], -1)    # 慢线\\n                            #Log(4.3)\\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\\\"Time\\\"], nowdea_5], -1)\\n                            #Log(4.4)\\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\\\"Time\\\"], nowmacd_5], -1)\\n                            #Log(4.5)\\n                    '''\\n                    if i == 1 and len(arr_[i]) > _15_lengh:\\n                        if j == len(arr_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "5_lengh:\\n                        if j == len(arr_[i]) - 2:\\n                            chart.add(index_2 + 8, [arr_[i][j][\\\"Time\\\"], premacd_15], -1)    # 快线\\n                        elif j == len(arr_[i]) - 2:\\n                            chart.add(index_2 + 8, [arr_[i][j][\\\"Time\\\"], nowmacd_15], -1)    # 快线\\n                    '''\\n                elif arr_[i][j][\\\"Time\\\"] > runTime['preBarTime_1'][i]:  # 初始运行此处  每个5，15分钟运行两次\\n                    \\n                    if i ==1:\\n                       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                if i ==1:\\n                        pass\\n                        \\n                        #Log(time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",  time.localtime(int(arr_[i][j][\\\"Time\\\"])/1000)),time.strftime(\\\"%Y-%m-%d %H:%M:%S\\\",  time.localtime(int(runTime['preBarTime_1'][i])/1000)),'//',i)\\n                    runTime['preBarTime_1'][i] = arr_[i][j][\\\"Time\\\"]  # K线时间赋值给preBarTime\\n                    Log(runTime['preBarTime_1'][0],runTime['preBarTime_1'][1])\\n                    # 0 7 8 15\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1'][1])\\n                    # 0 7 8 15\\n                    chart.add(int(runTime['arrKIndex'][x]), [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Open\\\"], arr_[i][j][\\\"High\\\"], arr_[i][j][\\\"Low\\\"], arr_[i][j][\\\"Close\\\"]])\\n                    if i ==0 and len(arr_[i]) > _5_lengh:\\n                        #Log('i=0',int(runTime['arrKIndex'][x]))\\n                        if j == len(arr_[i]) - 1:\\n                            chart.add(int(index_2[x]) + 1, [arr_[i][j][\\\"Time\\\"], arr_[i][j][\\\"Volume\\\"]])\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"Time\\\"], arr_[i][j][\\\"Volume\\\"]])\\n                            chart.add(int(index_2[x]) + 2, [arr_[i][j][\\\"Time\\\"], nowrsi])\\n                            chart.add(int(index_2[x]) + 3, [arr_[i][j][\\\"Time\\\"], nowdiff_5])\\n                            chart.add(int(index_2[x]) + 4, [arr_[i][j][\\\"Time\\\"], nowdea_5])\\n                            chart.add(int(index_2[x]) + 5, [arr_[i][j][\\\"Time\\\"], nowmacd_5])\\n                    \\n                    if i == 1 and len(arr_[i]) > _15_lengh:\\n                 ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1 and len(arr_[i]) > _15_lengh:\\n                        Log('i=1',int(index_2[x]) + 7)\\n                        if j == len(arr_[i]) - 1:\\n                            chart.add(int(index_2[x]) + 7, [arr_[i][j][\\\"Time\\\"], nowmacd_5])\\n\\ndef main():\\n    \\\"\\\"\\\"\\n    \\\"\\\"\\\"\\n    global preBarTime_1,macd_15,runTime,_5_lengh,_15_lengh,shortChart,longChart,chart0,chart1,chart2,hart1\\n    if exchange.GetName().find(\\\"CTP\\\") == -1:\\n        raise Exception(\\\"只支持商品期货CTP\\\")\\n    SetErrorFilter(\\\"login|ready|流控|连接失败|",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "货CTP\\\")\\n    SetErrorFilter(\\\"login|ready|流控|连接失败|初始|Timeout\\\")\\n    mode = exchange.IO(\\\"mode\\\", 0)\\n    if mode is None:\\n        raise Exception(\\\"切换模式失败，请更新到最新托管者！\\\")\\n    while not exchange.IO(\\\"status\\\"):\\n        Sleep(3000)\\n        LogStatus(\\\"正在等待与交易服务器连接，\\\" + _D())\\n    positions = _C(exchange.GetPosition)  # 获取当前持仓信息字典\\n    if len(positions) > 0:\\n        Log(\\\"检测到当前持有仓位，系统将开始尝试恢复进度...\\\")\\n        Log(\\\"持仓信息：\\\", positions)\\n\\n\\n    tts = []  # \\n    arrChart_1 = []  # 图表数组\\n    arrChart_2 = []\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    arrChart_1 = []  # 图表数组\\n    arrChart_2 = []\\n    index_ = 0  # \\n    index_2 = []\\n    arrKIndex = []\\n    a = []\\n    b = []\\n    c = []\\n    d = []\\n\\n    #while True:\\n    #Log(1)\\n    symbolFilter = {}  # 过滤用数组\\n    arr = Instruments.split(\\\",\\\")  # 合约列表\\n    for i in range(len(arr)):  # 遍历合约列表\\n        symbol = re.sub(r'/\\\\s+$/g', \\\"\\\", re.sub(r'/^\\\\s+/g', \\\"\\\", arr[i]))  # 规整合约字符串\\n        if symbol in symbolFilter.keys():  # 如果 在过滤数组中 存在 名为 symbol的属性，则显示信息 并跳过。\\n            raise Exception(symbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l的属性，则显示信息 并跳过。\\n            raise Exception(symbol + \\\"已经存在，请检查参数！\\\")\\n        symbolFilter[symbol] = True  # 给过滤数组 添加 名为 symbol 的 keys，下次 同样的 合约代码 会被过滤 保证每个合约只对Manager类方法传入一次参数\\n        hasPosition = False  # 初始化 hasPosition 变量 false 代表没有持仓 \\n        for j in range(len(positions)):  # 遍历 获取到的持仓信息\\n            if positions[j][\\\"ContractType\\\"] == symbol:  # 如果持仓中有合约名等于symbol\\n                Log('cc')\\n                hasPosition = True  # 标记 True 持仓\\n                break  # 跳出\\n        #fastPeriod = int(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           break  # 跳出\\n        #fastPeriod = int(arrFastPeriod[i])  # 规整为数值型\\n        #slowPeriod = int(arrSlowPeriod[i])\\n        Log(123)\\n        obj_1 = shortChart #  实例化Manager类\\n        obj_2 = longChart\\n        index_2.append(index_)  # 0 8\\n        index_ += 8 # 长周期的图表index\\n        \\n        #tts.append(obj)  # tts列表传入 最终根据合约列表 ，生成了若干个品种的 控制对象储存在tts数组 \\n        #Log(obj)\\n        arrChart_1.append(obj_1)   # 在for循环中 依次把图表信息字典传入图表数组\\n        #arrChart_2.append(obj_2)\\n        a.append(chart0)\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "art_2.append(obj_2)\\n        a.append(chart0)\\n        b.append(chart1)\\n        c.append(chart2)\\n        d.append(hart1)\\n        Log(len(arrChart_1))\\n        Log(111 if arrChart_1[0]==shortChart else 000)\\n        #arrChart_2.append(obj.longChart)\\n    # 创建图表对象\\n    #chart = Chart([arrChart_1, arrChart_2])  # __isStock\\\" : True表示是highstock图，False表示是highcharts图 使用多图表对象，转为二维数组\\n    #chart = Chart([arrChart_1,arrChart_2])\\n    chart = Chart([a,b,c,d])\\n    #Log(len(arrChart_1),len(arrChart_2))\\n    index_2",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#Log(len(arrChart_1),len(arrChart_2))\\n    index_2 = np.array(index_2)\\n    chart.reset()  # 清空上次轮询的图表数据\\n\\n    while True:\\n        #c = Chart(shortChart)\\n        preTicker = None\\n        #while True:\\n        #Log(1)\\n        if exchange.IO('status'):\\n            LogStatus(_D(),'已经连接')\\n            #t = exchange.GetTicker()\\n            plot(arr,_5_lengh,_15_lengh,index_2,runTime,chart)\\n        Sleep(1000)                      \\n        ''' \\n        if i ==0:\\n            if signals['buy_sell_sig'+st",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f i ==0:\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==1:\\n                Log(1)\\n                #ext.PlotFlag(r[-2]['Time'],'开多','L','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'L','text':'开多'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==2:\\n                Log(2)\\n                #ext.PlotFlag(r[-2]['Time'],'开空','S','circlepin','K')\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "['Time'],'开空','S','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'S','text':'开空'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==3:\\n                Log(3)\\n                #ext.PlotFlag(r[-2]['Time'],'平多','UL','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'UL','text':'平多'}])\\n                signals['b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e':'UL','text':'平多'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n            if signals['buy_sell_sig'+str(trueSymbol)] ==4:\\n                Log(4)\\n                #ext.PlotFlag(r[-2]['Time'],'平空','US','circlepin','K')\\n                chart.add(index_2 + 6, [arr_[i][j][\\\"Time\\\"], {'X':arr_[i][j][\\\"Time\\\"],'title':'US','text':'平空'}])\\n                signals['buy_sell_sig'+str(trueSymbol)] =0\\n\\n        '''\\n\\n                    #index_1 += 9  # 短周期的图表index\\n\\n        \\n```\\n\\n> Detail",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1 += 9  # 短周期的图表index\\n\\n        \\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/216948\\n\\n> Last Modified\\n\\n2020-07-07 13:53:18\"\n \n\n    \"strategy_82\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\nimport json\\nimport time\\n\\nfrom kumex.client import Trade\\n\\n\\nclass Aip(object):\\n\\n    def __init__(self):\\n        # read configuration from json file\\n        with open('config.json', 'r') as file:\\n            config = json.load(file)\\n\\n        self.api_key = config['api_key']\\n        s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       self.api_key = config['api_key']\\n        self.api_secret = config['api_secret']\\n        self.api_passphrase = config['api_passphrase']\\n        self.sandbox = config['is_sandbox']\\n        self.symbol = config['symbol']\\n        self.timer = int(config['timer'])\\n        self.size = int(config['size'])\\n        self.side = config['side']\\n        self.leverage = config['leverage']\\n        self.rate = float(config['rate'])\\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\\n        if self.side == 'sell':\\n            self.close = 'buy'\\n        else:\\n            self.close = 'sell'\\n\\n    def get_position_pcnt(self):\\n        position = self.trade.get_position_details(self.symbol)\\n        return float(position['unrealisedPnlPcnt'])\\n\\n\\nif __name__ == '__main__':\\n    aip = Aip()\\n    market_order = aip.trade.create_market_order(aip.symbol, aip.side, aip.leverage, type='market', size=aip.size)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ide, aip.leverage, type='market', size=aip.size)\\n    print('create a market %s order, order id = %s' % (aip.side, market_order['orderId']))\\n    while 1:\\n        time.sleep(aip.timer * 60)\\n        pcnt = aip.get_position_pcnt()\\n        if pcnt < 0 and abs(pcnt) > aip.rate:\\n            market_order = aip.trade.create_market_order(aip.symbol, aip.side, aip.leverage,\\n                                                         type='market', size=aip.size)\\n            print('create a market %s order, order ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           print('create a market %s order, order id = %s' % (aip.side, market_order['orderId']))\\n        elif pcnt > 0 and pcnt > aip.rate:\\n            market_order = aip.trade.create_market_order(aip.symbol, aip.close, aip.leverage,\\n                                                         type='market', size=(aip.size*2))\\n            print('create a market %s order, order id = %s' % (aip.close, market_order['orderId']))\",\n    \"策略名称: 定投策略\\n\\n股语有云：新手死于追高，老手死于抄底。讲究的是一个择时问题，一不小心就被套牢了，所以很多策略都会去做一些趋势预测，根据趋势",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "，老手死于抄底。讲究的是一个择时问题，一不小心就被套牢了，所以很多策略都会去做一些趋势预测，根据趋势进行调整持仓情况。\\n\\n而对于定投策略，即定期定额的投资策略，根本核心是——低买高卖，越跌越买，而不是追涨杀跌。所以对于定投策略，可以认为随时都可以买。\\n\\n制定一份有效的定投策略，能够大幅提高定投的收益，我们在定投前都应该把自己的计划落于纸上，按照计划执行，减少人为的干预，坚持下去，止盈不止损，才能真正体会到定投的价值所在。\\n\\n在这里我们为控制风险对操作范围加以限制，拟定了如下策略规则：\\n\\n每分钟定投1手空单，20倍杠杆。\\n未平的仓位，如果亏损超过3%，继续定投。如果盈利超过3%，每分钟平仓2手\\n其中，在测试脚本中，定投周期、定投数量、杠杆倍数、盈亏率、仓位方向为可配置项。\"\n \n\n    \"strategy_83\",\n    \"python\\n##\\n# 无限网格交易策略（公开版）\\n# Author: 子辰量化\\n# Last Modified: 2024-1-4\\n##\\n\\nimport time\\n\\nassetRatio = 0.5 # 资产投资比例\\n\\noriginalTota",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " time\\n\\nassetRatio = 0.5 # 资产投资比例\\n\\noriginalTotalMoney = totalInvestment # 基准投资额，总投资额+盈亏后的全部权益\\noriginalAssetMoney = totalInvestment * assetRatio # 基准资产价值\\noriginalCashMoney = totalInvestment * (1 - assetRatio) # 基准现金\\n\\nremainCashMoney = originalTotalMoney # 当前剩余现金\\ninvestAssetMoney = 0 # 当前资产价值\\ninverstAssetAmount = 0 # 当前资产数量\\n\\nboolInited = False # 是否完成了首次建仓\\n\\ni = 0 # tick计算\\n\\ndef num_cut(num, c):\\n    str_num = str(num)\\n    return float(str_num[:str_num.index('.') + 1 + c])\\n\\ndef onTick():\\n    g",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r_num.index('.') + 1 + c])\\n\\ndef onTick():\\n    global assetRatio\\n    global originalTotalMoney\\n    global originalAssetMoney\\n    global originalCashMoney\\n    global remainCashMoney\\n    global investAssetMoney\\n    global inverstAssetAmount\\n    global boolInited\\n    global i\\n\\n    ticker = exchange.GetTicker()\\n    # Log(ticker)\\n    openTime = time.localtime(ticker.Time / 1000) # ticker time\\n    openTimeStr = time.strftime(\\\"%Y-%m-%dT%H:%M:%S\\\", openTime) \\n    price = ticker.Last\\n\\n    # 初始建仓\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "penTime) \\n    price = ticker.Last\\n\\n    # 初始建仓\\n    if not boolInited:\\n        money = originalAssetMoney\\n        id = exchange.Buy(-1, money) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"buy money:\\\", money)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        money = order[\\\"Amount\\\"] # 成交的money\\n        dealAmount = order[\\\"DealAmount\\\"] # 已扣除手续费的资产数量\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n        remainCashMoney = originalCashMoney\\n        investAssetMoney = originalAssetMoney\\n        inverstAssetAmount = dealAmount        \\n        boolInited = True\\n        Log(f\\\"use ${investAssetMoney} buy {inverstAssetAmount} asset at price ${price} at time {openTimeStr}\\\")\\n\\n        Log(f\\\"{i} summary:\\\")\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eStr}\\\")\\n\\n        Log(f\\\"{i} summary:\\\")\\n        originalTotalMoney = originalAssetMoney + originalCashMoney\\n        investAssetMoney = inverstAssetAmount * price\\n        currentTotalMoney = investAssetMoney + remainCashMoney\\n        Log(f\\\"originalAssetMoney: ${originalAssetMoney}\\\")\\n        Log(f\\\"originalCashMoney: ${originalCashMoney}\\\")\\n        Log(f\\\"originalTotalMoney: ${originalTotalMoney}\\\")\\n        Log(f\\\"inverstAssetAmount: ${inverstAssetAmount}\\\")\\n        Log(f\\\"investAssetMoney: ${inv",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Amount}\\\")\\n        Log(f\\\"investAssetMoney: ${investAssetMoney}\\\")\\n        Log(f\\\"remainCashMoney: ${remainCashMoney}\\\")\\n        Log(f\\\"currentTotalMoney: ${currentTotalMoney}\\\")\\n        # account = exchange.GetAccount()\\n        # Log(\\\"Balance:\\\", account[\\\"Balance\\\"], \\\"FrozenBalance:\\\", account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\\"Stocks\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])\\n\\n    # 买入\\n    money = inverstAssetAmount * price # pirce\\n    if money < originalAssetMoney * (1 - buyRat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\n    if money < originalAssetMoney * (1 - buyRatio):\\n        money = originalAssetMoney * buyRatio # 买入金额\\n        account = exchange.GetAccount()\\n        if remainCashMoney > money and account[\\\"Balance\\\"] > money: # 判断是否还有足够的现金，双重检查 \\n            # amount = money / price\\n            id = exchange.Buy(-1, money) # 市价单\\n            # Log(\\\"order id:\\\", id)\\n            order = exchange.GetOrder(id)\\n            Log(\\\"buy money:\\\", money)\\n            Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n            money = order[\\\"Amount\\\"] # 成交的money\\n            dealAmount = order[\\\"DealAmount\\\"] # 已扣除手续费的资产数量\\n            price = order[\\\"AvgPrice\\\"] # 成交均价  \\n            remainCashMoney -= money\\n            inverstAssetAmount = inverstAssetAmount + dealAmount\\n            Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= inverstAssetAmount + dealAmount\\n            Log(f\\\"bull/bear buy {dealAmount} asset at ${price} at time {openTimeStr}\\\")\\n\\n            Log(f\\\"{i} summary:\\\")\\n            originalTotalMoney = originalAssetMoney + originalCashMoney\\n            investAssetMoney = inverstAssetAmount * price\\n            currentTotalMoney = investAssetMoney + remainCashMoney\\n            Log(f\\\"originalAssetMoney: ${originalAssetMoney}\\\")\\n            Log(f\\\"originalCashMoney: ${originalCashMoney}\\\")\\n            Log(f\\\"or",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ey: ${originalCashMoney}\\\")\\n            Log(f\\\"originalTotalMoney: ${originalTotalMoney}\\\")\\n            Log(f\\\"inverstAssetAmount: ${inverstAssetAmount}\\\")\\n            Log(f\\\"investAssetMoney: ${investAssetMoney}\\\")\\n            Log(f\\\"remainCashMoney: ${remainCashMoney}\\\")\\n            Log(f\\\"currentTotalMoney: ${currentTotalMoney}\\\")\\n            # account = exchange.GetAccount()\\n            #Log(\\\"Balance:\\\", account[\\\"Balance\\\"], \\\"FrozenBalance:\\\", account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\\"Stocks\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])\\n\\n    # 卖出\\n    money = inverstAssetAmount * price # pirce\\n    if money > (originalAssetMoney * (1 + sellRatio)):\\n        money = originalAssetMoney * sellRatio # 卖出金额\\n        amount = money / price\\n        id = exchange.Sell(-1, amount) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"sell money:\\\", money)\\n        Log(\\\"sell amount:\\\", amount) \\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ney)\\n        Log(\\\"sell amount:\\\", amount) \\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        amount = order[\\\"Amount\\\"] # 计划卖出资产数量\\n        dealAmount = order[\\\"DealAmount\\\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n        dealMoney = dealAmount * price # 未扣除手续费\\n        remainCashMoney += dealMoney # 这里需要减去手续费\\n        inverstAssetAmount = inverstAssetAmount - dealAmount\\n        Log(f\\\"bull/bear sell {amount} asset at ${price} at time {openTimeStr}\\\")\\n\\n        Log(f\\\"{i} summary:\\\")\\n        originalTotalMoney = originalAssetMoney + originalCashMoney\\n        investAssetMoney = inverstAssetAmount * price\\n        currentTotalMoney = investAssetMoney + remainCashMoney\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tTotalMoney = investAssetMoney + remainCashMoney\\n        Log(f\\\"originalAssetMoney: ${originalAssetMoney}\\\")\\n        Log(f\\\"originalCashMoney: ${originalCashMoney}\\\")\\n        Log(f\\\"originalTotalMoney: ${originalTotalMoney}\\\")\\n        Log(f\\\"inverstAssetAmount: ${inverstAssetAmount}\\\")\\n        Log(f\\\"investAssetMoney: ${investAssetMoney}\\\")\\n        Log(f\\\"remainCashMoney: ${remainCashMoney}\\\")\\n        Log(f\\\"currentTotalMoney: ${currentTotalMoney}\\\")\\n        # account = exchange.GetAccount()\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        # account = exchange.GetAccount()\\n        # Log(\\\"Balance:\\\", account[\\\"Balance\\\"], \\\"FrozenBalance:\\\", account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\\"Stocks\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])\\n\\n    ##\\n    # 仓位调整\\n    ##\\n    # 当remainCashMoney超过originalCashMoney的10%时，加大投资基准\\n    if remainCashMoney >= originalCashMoney * 1.1:\\n        money = (remainCashMoney - originalCashMoney) / 2 # 买入金额\\n        # amount = money / price\\n        id = exchange.Buy(-1, money) # 市价单\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      id = exchange.Buy(-1, money) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"buy money:\\\", money)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        money = order[\\\"Amount\\\"] # 成交的money\\n        dealAmount = order[\\\"DealAmount\\\"] # 已扣除手续费\\n        price = order",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "er[\\\"DealAmount\\\"] # 已扣除手续费\\n        price = order[\\\"AvgPrice\\\"] # 成交均价  \\n        remainCashMoney -= money\\n        inverstAssetAmount = inverstAssetAmount + dealAmount\\n        originalAssetMoney += money # 增加投资基准\\n        originalCashMoney += money # 增加投资基准\\n        Log(f\\\"bull/bear add original invest at time {openTimeStr}\\\")\\n\\n    # 当remainCashMoney低于originalCashMoney的90%时，减少投资基准\\n    if remainCashMoney <= originalCashMoney * 0.9:\\n        money = (originalCashMoney - remainCashMoney) / 2 # 卖出金额\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ginalCashMoney - remainCashMoney) / 2 # 卖出金额\\n        amount = money / price\\n        id = exchange.Sell(-1, amount) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"sell money:\\\", money)\\n        Log(\\\"sell amount:\\\", amount)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        amount = order[\\\"Amount\\\"] # 计划卖出资产数量\\n        dealAmount = order[\\\"DealAmount\\\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n        dealMoney = dealAmount * price # 未扣除手续费\\n        dealMoney = dealAmount * price # 未扣除手续费\\n        remainCashMoney += dealMoney # 这里需要减去手续费\\n        inverstAssetAmount = inverstAssetAmount - dealAmount\\n        originalAssetMoney -=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Amount - dealAmount\\n        originalAssetMoney -= money # 减少投资基准\\n        originalCashMoney -= money # 减少投资基准\\n        Log(f\\\"bull/bear reduce original invest at time {openTimeStr}\\\")\\n\\n    # tick计算\\n    i = i + 1\\n\\ndef main():\\n    Log(totalInvestment, buyRatio, sellRatio)\\n\\n    while True:\\n        onTick()\\n        Sleep(1000) # 1秒\\n\\ndef onexit():\\n    global inverstAssetAmount\\n\\n    # 清仓\\n    Log(\\\"清仓\\\")\\n    if inverstAssetAmount > 0:\\n        amount = num_cut(inverstAssetAmount * (1-0.0001), 8) ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "unt = num_cut(inverstAssetAmount * (1-0.0001), 8) # 留0.01%一丢丢，小数位控制\\n        id = exchange.Sell(-1, amount) # 市价单\\n        Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])        \\n    # 倒计时\\n    beginTime = time.time() * 1000\\n    while True:\\n        ts = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time.time() * 1000\\n    while True:\\n        ts = time.time() * 1000\\n        Log(\\\"程序停止倒计时...，已经过去：\\\", (ts - beginTime) / 1000, \\\"秒！\\\")\\n        Sleep(1000) # 1秒\",\n    \"策略名称: 子辰量化无限网格交易策略\\n\\n# Author: 子辰量化\"\n \n\n    \"strategy_84\",\n    \"python\\n##\\n# 香农网格交易策略（公开版）\\n# Author: 子辰量化\\n# Last Modified: 2024-1-4\\n##\\n\\nimport time\\n\\nassetRatio = 0.5 # 资产投资比例\\n\\noriginalTotalMoney = totalInvestment # 基准投资额，总投资额+盈亏后的全部权益\\noriginalAssetMoney = totalInvestment * assetRatio # 基准资产价值\\noriginalCashMoney = totalInvestment",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "atio # 基准资产价值\\noriginalCashMoney = totalInvestment * (1 - assetRatio) # 基准现金\\n\\nremainCashMoney = originalCashMoney # 当前剩余现金\\ninvestAssetMoney = 0 # 当前资产价值\\ninverstAssetAmount = 0 # 当前资产数量\\n\\nboolInited = False # 是否完成了首次建仓\\n\\ni = 0 # tick计算\\n\\ndef num_cut(num, c):\\n    str_num = str(num)\\n    return float(str_num[:str_num.index('.') + 1 + c])\\n\\ndef onTick():\\n    global assetRatio\\n    global originalTotalMoney\\n    global originalAssetMoney\\n    global originalCashMoney\\n    global remainCashMoney\\n    gl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ginalCashMoney\\n    global remainCashMoney\\n    global investAssetMoney\\n    global inverstAssetAmount\\n    global boolInited\\n    global i\\n\\n    ticker = exchange.GetTicker()\\n    # Log(ticker)\\n    openTime = time.localtime(ticker.Time / 1000) # ticker time\\n    openTimeStr = time.strftime(\\\"%Y-%m-%dT%H:%M:%S\\\", openTime) \\n    price = ticker.Last\\n\\n    # 初始建仓\\n    if not boolInited:\\n        money = originalAssetMoney\\n        id = exchange.Buy(-1, money) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"buy money:\\\", money)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        money = order[\\\"Amount\\\"] # 成交的money\\n        dealAmount = order[\\\"DealAmount\\\"] # 已扣除手续费的资产数量\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n        investAssetMoney = originalAssetMoney\\n        remainCashMoney = originalCashMoney\\n        inverstAssetAmount = dealAmount       \\n        boolInited = True\\n        Log(f\\\"use ${investAssetMoney} buy {inverstAssetAmount} asset at price ${price} at time {openTimeStr}\\\")\\n\\n        Log(f\\\"{i} summary:\\\")\\n        originalTotalMoney = originalAssetMoney + originalCashMoney\\n        investAssetMoney = inverstAssetAmount * price\\n        currentTotalMoney =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "stAssetAmount * price\\n        currentTotalMoney = investAssetMoney + remainCashMoney\\n        Log(f\\\"originalAssetMoney: ${originalAssetMoney}\\\")\\n        Log(f\\\"originalCashMoney: ${originalCashMoney}\\\")\\n        Log(f\\\"originalTotalMoney: ${originalTotalMoney}\\\")\\n        Log(f\\\"inverstAssetAmount: ${inverstAssetAmount}\\\")\\n        Log(f\\\"investAssetMoney: ${investAssetMoney}\\\")\\n        Log(f\\\"remainCashMoney: ${remainCashMoney}\\\")\\n        Log(f\\\"currentTotalMoney: ${currentTotalMoney}\\\")\\n        # ac",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tTotalMoney: ${currentTotalMoney}\\\")\\n        # account = exchange.GetAccount()\\n        # Log(\\\"Balance:\\\", account[\\\"Balance\\\"], \\\"FrozenBalance:\\\", account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\\"Stocks\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])\\n\\n    # 买入\\n    money = inverstAssetAmount * price # pirce\\n    if money < originalAssetMoney * (1 - buyRatio):\\n        money = originalAssetMoney * buyRatio / 2 # 买入金额\\n        account = exchange.GetAccount()\\n        if remainCashMoney > money and a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ccount()\\n        if remainCashMoney > money and account[\\\"Balance\\\"] > money: # 判断是否还有足够的现金，双重检查\\n            # amount = money / price\\n            id = exchange.Buy(-1, money) # 市价单\\n            # Log(\\\"order id:\\\", id)\\n            order = exchange.GetOrder(id)\\n            Log(\\\"buy money:\\\", money)\\n            Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ce:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n            money = order[\\\"Amount\\\"] # 成交的money\\n            dealAmount = order[\\\"DealAmount\\\"] # 已扣除手续费的资产数量\\n            price = order[\\\"AvgPrice\\\"] # 成交均价  \\n            originalAssetMoney -= money #\\n            originalCashMoney -= money #\\n            remainCashMoney -= money\\n            inverstAssetAmount = inverstAssetAmount + dealAmount\\n            Log(f\\\"bull/bear buy {dealAmount} asset at ${price} at time ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l/bear buy {dealAmount} asset at ${price} at time {openTimeStr}\\\")\\n\\n            Log(f\\\"{i} summary:\\\")\\n            originalTotalMoney = originalAssetMoney + originalCashMoney\\n            investAssetMoney = inverstAssetAmount * price\\n            currentTotalMoney = investAssetMoney + remainCashMoney\\n            Log(f\\\"originalAssetMoney: ${originalAssetMoney}\\\")\\n            Log(f\\\"originalCashMoney: ${originalCashMoney}\\\")\\n            Log(f\\\"originalTotalMoney: ${originalTotalMoney}\\\")\\n            L",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "otalMoney: ${originalTotalMoney}\\\")\\n            Log(f\\\"inverstAssetAmount: ${inverstAssetAmount}\\\")\\n            Log(f\\\"investAssetMoney: ${investAssetMoney}\\\")\\n            Log(f\\\"remainCashMoney: ${remainCashMoney}\\\")\\n            Log(f\\\"currentTotalMoney: ${currentTotalMoney}\\\")\\n            # account = exchange.GetAccount()\\n            #Log(\\\"Balance:\\\", account[\\\"Balance\\\"], \\\"FrozenBalance:\\\", account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\\"Stocks\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])\\n\\n    # 卖出\\n    money = inverstAssetAmount * price # pirce\\n    if money > (originalAssetMoney * (1 + sellRatio)):\\n        money = originalAssetMoney * sellRatio / 2 # 卖出金额\\n        amount = money / price\\n        id = exchange.Sell(-1, amount) # 市价单\\n        # Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"sell money:\\\", money)\\n        Log(\\\"sell amount:\\\", amount)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", orde",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])\\n        amount = order[\\\"Amount\\\"] # 计划卖出资产数量\\n        dealAmount = order[\\\"DealAmount\\\"] # 成交资产数量，这里好像是从balance扣除的手续费吗?\\n        # 从日志来看amount == dealAmount,所以手续费是从balance扣除的\\n        price = order[\\\"AvgPrice\\\"] # 成交均价\\n        dealMoney = dealAmount * price # 未扣除手续费\\n        r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dealMoney = dealAmount * price # 未扣除手续费\\n        remainCashMoney += dealMoney # 这里需要减去手续费\\n        originalAssetMoney += money #\\n        originalCashMoney += money #\\n        inverstAssetAmount = inverstAssetAmount - dealAmount\\n        Log(f\\\"bull/bear sell {amount} asset at ${price} at time {openTimeStr}\\\")\\n\\n        Log(f\\\"{i} summary:\\\")\\n        originalTotalMoney = originalAssetMoney + originalCashMoney\\n        investAssetMoney = inverstAssetAmount * price\\n        currentTotalMoney = investAssetMo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "* price\\n        currentTotalMoney = investAssetMoney + remainCashMoney\\n        Log(f\\\"originalAssetMoney: ${originalAssetMoney}\\\")\\n        Log(f\\\"originalCashMoney: ${originalCashMoney}\\\")\\n        Log(f\\\"originalTotalMoney: ${originalTotalMoney}\\\")\\n        Log(f\\\"inverstAssetAmount: ${inverstAssetAmount}\\\")\\n        Log(f\\\"investAssetMoney: ${investAssetMoney}\\\")\\n        Log(f\\\"remainCashMoney: ${remainCashMoney}\\\")\\n        Log(f\\\"currentTotalMoney: ${currentTotalMoney}\\\")\\n        # account = exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "{currentTotalMoney}\\\")\\n        # account = exchange.GetAccount()\\n        # Log(\\\"Balance:\\\", account[\\\"Balance\\\"], \\\"FrozenBalance:\\\", account[\\\"FrozenBalance\\\"], \\\"Stocks:\\\", account[\\\"Stocks\\\"], \\\"FrozenStocks:\\\", account[\\\"FrozenStocks\\\"])\\n\\n    # tick计数\\n    i = i + 1\\n\\ndef main():\\n    Log(totalInvestment, buyRatio, sellRatio)\\n\\n    while True:\\n        onTick()\\n        Sleep(1000) # 1秒\\n\\ndef onexit():\\n    global inverstAssetAmount\\n\\n    # 清仓\\n    Log(\\\"清仓\\\")\\n    if inverstAssetAmount > 0:\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    Log(\\\"清仓\\\")\\n    if inverstAssetAmount > 0:\\n        amount = num_cut(inverstAssetAmount * (1-0.0001), 8) # 留0.01%一丢丢，小数位控制\\n        id = exchange.Sell(-1, amount) # 市价单\\n        Log(\\\"order id:\\\", id)\\n        order = exchange.GetOrder(id)\\n        Log(\\\"order id:\\\", order[\\\"Id\\\"], \\\"Price:\\\", order[\\\"Price\\\"], \\\"Amount:\\\", order[\\\"Amount\\\"], \\\"DealAmount:\\\", order[\\\"DealAmount\\\"], \\\"AvgPrice:\\\", order[\\\"AvgPrice\\\"], \\\"Status:\\\", order[\\\"Status\\\"], \\\"Type:\\\", order[\\\"Type\\\"])        \\n    # 倒计时\\n    be",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pe:\\\", order[\\\"Type\\\"])        \\n    # 倒计时\\n    beginTime = time.time() * 1000\\n    while True:\\n        ts = time.time() * 1000\\n        Log(\\\"程序停止倒计时...，已经过去：\\\", (ts - beginTime) / 1000, \\\"秒！\\\")\\n        Sleep(1000) # 1秒\",\n    \"策略名称: 子辰量化香农网格交易策略\\n\\n# Author: 子辰量化\"\n \n\n    \"strategy_85\",\n    \"python\\ndef main():\\n    amountAll = 0                                              #持有总量\\n    cost = 0                                                   #成本\\n    marketValueCurrent = 0                                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "etValueCurrent = 0                                     #当前持有总市值\\n    rateOfReturn = 0                                           #收益率\\n    while True:\\n        ticker = exchange.GetTicker()\\n        price = ticker['Last']                                 #获得当前价格\\n        amount = 100 / price                                   #计算本次买入量\\n        exchange.Buy(price,amount)                             #买入\\n        amountAll = amountAll + amount                         #计算持有总量\\n        cost = cost + 100            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #计算持有总量\\n        cost = cost + 100                                      #计算总成本\\n        marketValueCurrent = amountAll * price                 #计算当前持有总市值\\n        rateOfReturn = (marketValueCurrent - cost) / cost      #计算收益率        \\n        Log(\\\"此次投入金额：\\\", 100, \\\"本金：\\\", cost, \\\"当前总市值：\\\", marketValueCurrent, \\\"收益率:\\\", rateOfReturn * 100,\\\"%\\\",\\\"当前价格\\\",price)\\n        Sleep(7 * 24 * 60 * 60 * 1000)                         #等待一周\",\n    \"策略名称: 定投新手入门每周100USDT-定期定额-100USDT-Invested-Every-Week-Regular-Fixed-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "DT-定期定额-100USDT-Invested-Every-Week-Regular-Fixed-Investment\\n\\n未找到描述\"\n \n\n    \"strategy_86\",\n    \"python\\ndef main():\\n    amountAll = 0                                              #持有总量\\n    cost = 0                                                   #成本\\n    marketValueCurrent = 0                                     #当前持有总市值\\n    marketValueExpected = 0                                    #当前期望总市值\\n    rateOfReturn = 0                                           #收益率\\n    eachBuy = 100\\n    while True:\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #收益率\\n    eachBuy = 100\\n    while True:\\n        marketValueExpected = marketValueExpected + eachBuy        #计算当前期望总市值\\n        ticker = exchange.GetTicker()\\n        price = ticker['Last']                                 #获得当前价格\\n        amount = marketValueExpected / price - amountAll       #计算本次买入量\\n        if amount > 0:\\n            exchange.Buy(price,amount)                         #买入         \\n        else:\\n            amount = 0\\n        amountAll = amountAll + amount                         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tAll = amountAll + amount                         #计算持有总量\\n        cost = cost + amount * price                           #计算总成本\\n        marketValueCurrent = amountAll * price                 #计算当前持有总市值\\n        rateOfReturn = (marketValueCurrent - cost) / cost      #计算收益率\\n        Log(\\\"此次投入金额：\\\", amount * price, \\\"本金：\\\", cost,\\\"当前总持有量\\\", amountAll,\\\"当前总市值：\\\", marketValueCurrent, \\\"收益率:\\\", rateOfReturn * 100,\\\"%\\\" ,\\\"当前价格:\\\", price, )\\n        Sleep(7 * 24 * 60 * 60 * 1000)                         #等待一周\",",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " * 60 * 60 * 1000)                         #等待一周\",\n    \"策略名称: 定投新手入门每周100USDT左右-定期不定额-100USDT-Invested-Every-Week-Regular-Variable-Investment\\n\\n未找到描述\"\n \n\n    \"strategy_87\",\n    \"python\\n#!/usr/bin/env python\\n# -*- coding: utf-8 -*-coding\\nimport time\\nimport urllib2\\nimport json\\nimport pickle\\n            \\ndef updateTicker():\\n    global index,initPrice\\n    ticker = json.loads(urllib2.urlopen('https://api.binance.com/api/v3/ticker/price',timeout=10).read())\\n    change = []\\n    for t in ticker:\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d())\\n    change = []\\n    for t in ticker:\\n        if t['symbol'][-3:] == 'BTC':\\n            if t['symbol'][:-3] in initPrice.keys():\\n                change.append(float(t['price'])/initPrice[t['symbol'][:-3]])\\n            else:\\n                initPrice[t['symbol'][:-3]] = float(t['price'])\\n                f=open('price.pkl','w')\\n                pickle.dump(initPrice,f,0)\\n                f.close()\\n                Log(t['symbol'][:-3],' added')\\n    if len(change)>0:\\n        index = 1000*sum(chan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  if len(change)>0:\\n        index = 1000*sum(change)/len(change)\\n    \\n\\n\\ninitPrice = {}\\nprice = {}\\nindex = 1000\\ntry:\\n    f=open('price.pkl','r')  \\n    initPrice=pickle.load(f)  \\n    f.close()\\nexcept:\\n    initPrice = {}\\nLog('共计入山寨币:', len(initPrice))\\ndef main():\\n    while True:\\n        try:\\n            updateTicker()\\n            LogProfit(round(index,4))\\n        except Exception as e:\\n            pass\\n        Sleep(3600000)\",\n    \"策略名称: 山寨币指数20180222基点1000\\n\\nimport time\\nimport urllib2\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "寨币指数20180222基点1000\\n\\nimport time\\nimport urllib2\\nimport json\\nimport pickle\\n            \\ndef updateTicker():\\n    global index,initPrice\\n    ticker = json.loads(urllib2.urlopen('https://api.binance.com/api/v3/ticker/price',timeout=10).read())\\n    change = []\\n    for t in ticker:\\n        if t['symbol'][-3:] == 'BTC':\\n            if t['symbol'][:-3] in initPrice.keys():\\n                change.append(float(t['price'])/initPrice[t['symbol'][:-3]])\\n            else:\\n                initPrice[t['symbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         else:\\n                initPrice[t['symbol'][:-3]] = float(t['price'])\\n                f=open('price.pkl','w')\\n                pickle.dump(initPrice,f,0)\\n                f.close()\\n                Log(t['symbol'][:-3],' added')\\n    if len(change)>0:\\n        index = 1000*sum(change)/len(change)\\n    \\n\\n\\ninitPrice = {}\\nprice = {}\\nindex = 1000\\ntry:\\n    f=open('price.pkl','r')  \\n    initPrice=pickle.load(f)  \\n    f.close()\\nexcept:\\n    initPrice = {}\\nLog('共计入山寨币:', len(initPrice))\\ndef m",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tPrice = {}\\nLog('共计入山寨币:', len(initPrice))\\ndef main():\\n    while True:\\n        try:\\n            updateTicker()\\n            LogProfit(round(index,4))\\n        except Exception as e:\\n            pass\\n        Sleep(3600000)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/73461\\n\\n> Last Modified\\n\\n2019-07-03 16:46:08\"\n \n\n    \"strategy_88\",\n    \"python\\nimport json\\ndef main():\\n    LogStatus(\\\"正在连接...\\\")\\n    # client = Dial(\\\"wss://stream.binance.com:9443/stream?streams=btcusdt@aggTrade/ethusdt@ag",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "om:9443/stream?streams=btcusdt@aggTrade/ethusdt@aggTrade|reconnect=true\\\")    #多个交易对\\n    # client = Dial(\\\"wss://stream.binance.com:9443/ws/btcusdt@aggTrade|reconnect=true\\\")    #单个交易对\\n    # client = Dial(\\\"wss://dstream.binance.com/ws/btcusd_perp@aggTrade|reconnect=true\\\")    #币本位，ticker\\n    client = Dial(\\\"wss://fstream.binance.com/ws/btcusdt@aggTrade|reconnect=true\\\")\\n    if not client:    \\n        Log(\\\"连接失败, 程序退出\\\")\\n        return\\n    while True:\\n        buf = client.read(-2)\\n        Log('tt',",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        buf = client.read(-2)\\n        Log('tt',buf)\\n        if buf:\\n            obj = json.loads(buf)\\n            # Log(obj)\\n            # Log('交易对',obj['data']['s'], ' 价格', obj['data']['p'])    #多个交易对 \\n            Log(obj['p'])    #测试\\n        Sleep(5000)\\n    client.close()\",\n    \"策略名称: 币安websocket订阅永续合约行情信息\\n\\n# client = Dial(\\\"wss://stream.binance.com:9443/ws/btcusdt@aggTrade|reconnect=true\\\")    #单个交易对\\n    # client = Dial(\\\"wss://dstream.binance.com/ws/btcusd_perp@aggTrade|reconnect=true\\\")   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e.com/ws/btcusd_perp@aggTrade|reconnect=true\\\")    #币本位，ticker\\n    client = Dial(\\\"wss://fstream.binance.com/ws/btcusdt@aggTrade|reconnect=true\\\")\\n    if not client:    \\n        Log(\\\"连接失败, 程序退出\\\")\\n        return\\n    while True:\\n        buf = client.read(-2)\\n        Log('tt',buf)\\n        if buf:\\n            obj = json.loads(buf)\\n            # Log(obj)\\n            # Log('交易对',obj['data']['s'], ' 价格', obj['data']['p'])    #多个交易对 \\n            Log(obj['p'])    #测试\\n        Sleep(5000)\\n    client.cl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "j['p'])    #测试\\n        Sleep(5000)\\n    client.close()\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/327491\\n\\n> Last Modified\\n\\n2021-11-24 14:29:50\"\n \n\n    \"strategy_89\",\n    \"python\\n# Contact : ck@xueqiubot.com / WeChat@stay37\\n\\nimport time\\n\\n\\ndef supply_bnb(transfer_usdt,i):\\n    Log(\\\"当前BNB不足，补充BNB作为手续费抵扣\\\")\\n    #获取当前BNB_USDT价格\\n    depth = _C(exchanges[i].GetDepth)\\n    #转出transfer_usdt个USDT\\n    timestamp = time.time() * 1000\\n    transfer = exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/future",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/futures/transfer\\\",\\\"asset=USDT&amount=\\\"+str(transfer_usdt)+\\\"&type=2&timestamp=+\\\"+str(timestamp))\\n    time.sleep(1)\\n    #获取BNB深度 下单购买\\n    depth = _C(exchanges[i].GetDepth)\\n    buyamount = round(transfer_usdt / (depth.Asks[0].Price + 0.2) , 2)\\n    buyid = exchanges[i].Buy(round(depth.Asks[0].Price + 0.1 , 4) , buyamount)\\n    time.sleep(1)\\n    #查询购买结果 将购买后的BNB以及剩余的USDT转入合约账户\\n    acc = _C(exchanges[i].GetAccount)\\n    transfer_usdt = acc.Balance\\n    trans",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "count)\\n    transfer_usdt = acc.Balance\\n    transfer_bnb = acc.Stocks\\n    timestamp = time.time() * 1000\\n    transfer = exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/futures/transfer\\\",\\\"asset=USDT&amount=\\\"+str(transfer_usdt)+\\\"&type=1&timestamp=+\\\"+str(timestamp))\\n    transfer = exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/futures/transfer\\\",\\\"asset=BNB&amount=\\\"+str(transfer_bnb)+\\\"&type=1&timestamp=+\\\"+str(timestamp))\\n    Log(\\\"BNB补充完成\\\")\\n\\n\\n\\n\\ndef main():\\n    if '合约账户内BNB不足':\\n        #transfer_u",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "main():\\n    if '合约账户内BNB不足':\\n        #transfer_usdt: 需要购买的usdt金额\\n        #i: bnb_usdt现货交易对的序号\\n        supply_bnb(transfer_usdt,i)\",\n    \"策略名称: 币安合约BNB手续费抵扣-自动购买自动划转\\n\\nimport time\\n\\n\\ndef supply_bnb(transfer_usdt,i):\\n    Log(\\\"当前BNB不足，补充BNB作为手续费抵扣\\\")\\n    #获取当前BNB_USDT价格\\n    depth = _C(exchanges[i].GetDepth)\\n    #转出transfer_usdt个USDT\\n    timestamp = time.time() * 1000\\n    transfer = exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/futures/transfer\\\",\\\"asset=USDT&amount=\\\"+str(transfer_usdt)+\\\"&type=2&t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sset=USDT&amount=\\\"+str(transfer_usdt)+\\\"&type=2&timestamp=+\\\"+str(timestamp))\\n    time.sleep(1)\\n    #获取BNB深度 下单购买\\n    depth = _C(exchanges[i].GetDepth)\\n    buyamount = round(transfer_usdt / (depth.Asks[0].Price + 0.2) , 2)\\n    buyid = exchanges[i].Buy(round(depth.Asks[0].Price + 0.1 , 4) , buyamount)\\n    time.sleep(1)\\n    #查询购买结果 将购买后的BNB以及剩余的USDT转入合约账户\\n    acc = _C(exchanges[i].GetAccount)\\n    transfer_usdt = acc.Balance\\n    transfer_bnb = acc.Stocks\\n    timestamp = time.time() * 1000\\n    tran",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ocks\\n    timestamp = time.time() * 1000\\n    transfer = exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/futures/transfer\\\",\\\"asset=USDT&amount=\\\"+str(transfer_usdt)+\\\"&type=1&timestamp=+\\\"+str(timestamp))\\n    transfer = exchanges[i].IO(\\\"api\\\",\\\"POST\\\",\\\"/sapi/v1/futures/transfer\\\",\\\"asset=BNB&amount=\\\"+str(transfer_bnb)+\\\"&type=1&timestamp=+\\\"+str(timestamp))\\n    Log(\\\"BNB补充完成\\\")\\n\\n\\n\\n\\ndef main():\\n    if '合约账户内BNB不足':\\n        #transfer_usdt: 需要购买的usdt金额\\n        #i: bnb_usdt现货交易对的序号\\n        supply_bnb",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        #i: bnb_usdt现货交易对的序号\\n        supply_bnb(transfer_usdt,i)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/236437\\n\\n> Last Modified\\n\\n2020-11-11 22:38:54\"\n \n\n    \"strategy_90\",\n    \"python\\n\\nimport time\\nimport requests\\nimport math\\n# import pandas as pd\\n\\nInitPrice = 0\\nupdateProfitTime = 0\\nassets = {}\\ntradeInfo = {}\\naccountAssets = {}\\nruntimeData = {}\\nFunding = 0   #账户资金  为0的时候自动获取\\nsymbol = ''\\nVersion = '0.0.1'\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningC",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\\n\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif exchange.GetName() != 'Futures_Binance':\\n    Log('只支持币安期货交易所！')\\n    exit()\\n\\ndef init():\\n    initData()\\n    CancelOrder()\\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s://fapi.binance.com/fapi/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法连接币安网络，需要海外托管者')\\n        exit()\\n    for i in range(len(exchangeInfo['symbols'])):\\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\\n            tradeInfo[symbol] =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dationPrice': 0 }\\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\\n\\ndef CancelOrder():\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    for x in range(len(orders)):\\n        if orders[x]['Info']['symbol'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n(orders)):\\n        if orders[x]['Info']['symbol'] == symbol :\\n            exchange.CancelOrder(orders[x]['Id'])\\n\\ndef UpdateStatus():\\n    global Funding,updateProfitTime\\n    if Funding == 0 :\\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\\n\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"保证金比率\\\",  \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍数][持仓模式]', '币种信息', '开仓方向','初始价格', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\\n        'rows': []\\n    }\\n\\n    profitColors = DangerColor\\n    totalProfit = assets['USDT']['total_balance'] - Funding\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ta['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday\\n    \\n    #Log('dayProfit:',dayProfit,'Funding:',Funding)\\n    dayRate = dayProfit / Funding * 100\\n\\n\\n    accountTable['rows'].append([\\n        runday,\\n        '$' + str(_N(Funding, 2)),\\n        '$' + str(assets['USDT']['total_balance']),\\n        '$' + str(assets['USDT']['margin_balance']),\\n        '$' + str(assets['USDT']['margin']),\\n        str",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " '$' + str(assets['USDT']['margin']),\\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\\n        str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n        str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n        str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n        str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n\\n    i = 1\\n    for x in lis",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "itColors)\\n    ])\\n\\n\\n    i = 1\\n    for x in list(symbol.split(',')):\\n        typestr = '多空持仓'\\n        if type == 1:\\n            typestr = '只持多仓'\\n        if type == 2:\\n            typestr = '只持空仓'\\n        direction = '空仓'\\n        margin = direction\\n        if assets[x]['amount'] != 0:\\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\\n        unrealised_profit_color = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "oss' else '逐仓'\\n        unrealised_profit_color = '#000000'\\n        if assets[symbol]['unrealised_profit'] > 0:\\n            unrealised_profit_color = SuccessColor\\n        if assets[symbol]['unrealised_profit'] < 0:\\n            unrealised_profit_color = DangerColor\\n\\n        infoList = [\\n        i,\\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']'+'['+typestr+']',\\n        x,\\n        direction,\\n        InitPrice,\\n        assets[x]['amount'],\\n        assets[x]['hold_price'],\\n        assets",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        assets[x]['hold_price'],\\n        assets[x]['price'],\\n        assets[x]['liquidationPrice'],\\n        float(assets[x]['amount']) * float(assets[x]['price']),\\n        assets[x]['positionInitialMargin'],\\n        assets[x]['unrealised_profit'],\\n        ]\\n        table['rows'].append(infoList)\\n\\n        retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n'\\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = assets['USDT']['total_balance']\\n        key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n        initialAccount = _G(key)\\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\\n        if Show:\\n            balance = assets['USDT']['total_balance'] - Funding\\n        LogProfit(_N(balance, 3))\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "unding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n        Profit = _N(balance,0)\\n\\n\\ndef UpdateAccount():\\n    # Log('UpdateAccount()')\\n    global accountAssets\\n    account = exchange.GetAccount()\\n    position = exchange.GetPosition()\\n    if account is None and position is None :\\n        Log('更新账户超时！！！')\\n        return\\n    accountAssets = account['Info']['assets']\\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\\n    for  i in ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e.time()) * 1000  #秒转毫秒   同步更新账户时间\\n    for  i in range(len(account['Info']['positions'])) :\\n        if account['Info']['positions'][i]['symbol'] == symbol :\\n            #计算持仓保证金                                           初始保证金                +            维持保证金\\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\\n            #未实现收益\\n            assets[symbol]['unrealised_profit'] = float(account['Info']['pos",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\\n\\n    #计算持仓保证金总额\\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e'] = float(account['Info']['totalMarginBalance'])\\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\\n\\n    ps = json.loads(exchange.GetRawJSON())\\n    if len(ps) > 0 :\\n        for x in range(len(ps)):\\n            if ps[x]['symbol'] == symbol:\\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "realised_profit'] = float(ps[x]['unRealizedProfit'])\\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\\n                assets[symbol]['marginType'] = ps[x]['marginType']\\n\\ndef UpdateTick():\\n    global InitPrice\\n    res = _C(exchange.GetTicker)\\n    if res is None:\\n        Log(\\\"行情更新异常！！！\\\")\\n\\n    if target:\\n        InitPrice = target_price\\n        _G('InitPrice',InitPrice)\\n    else:\\n        if  _G('InitPrice') is None :\\n            InitPrice = res.Last\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s None :\\n            InitPrice = res.Last\\n            _G('InitPrice',InitPrice)\\n        else:\\n            InitPrice = _G('InitPrice')\\n\\n    assets[symbol]['price'] = res.Last\\n\\ndef Trade(direction,price,amount):\\n    if amount < 0:\\n        amount = -amount\\n    Log('amount:',amount,'minQty:',tradeInfo[symbol]['minQty'])\\n    if amount < tradeInfo[symbol]['minQty']:\\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n    else:\\n        para = ''\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " price,4) + 1)\\n    else:\\n        para = ''\\n        url = '/fapi/v1/order'\\n        para += 'symbol='+ symbol\\n        para += '&side='+ direction\\n        para += '&type=LIMIT&timeInForce=GTC'\\n        para += '&quantity='+ str(amount)\\n        para += '&price='+ str(price)\\n        para += \\\"&timestamp=\\\"+str(time.time() * 1000);\\n        go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n        ret = go.wait()\\n        if ret  is not None:\\n            logType = LOG_TYPE_SELL\\n            if dire",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      logType = LOG_TYPE_SELL\\n            if direction == 'BUY':\\n                logType =LOG_TYPE_BUY\\n            exchange.Log(logType,price,amount,symbol)\\n\\ndef batch(buy_price,sell_price):\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    if len(orders) < 2 :\\n        return True\\n    return False\\n\\ndef Process():\\n    amount = (1 - float(assets[symbol]['price']) / float(InitPrice)) / float(pct) * float(value) / float(assets[symbol]['price'])\\n    if abs(a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ue) / float(assets[symbol]['price'])\\n    if abs(amount - assets[symbol]['amount']) > _N(value / float(assets[symbol]['price']), tradeInfo[symbol]['amountSize']):\\n        if amount > 0:\\n            if assets[symbol]['amount'] < amount:\\n                CancelOrder()\\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n            if assets[symbol]['amount'] > amount:\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  if assets[symbol]['amount'] > amount:\\n                CancelOrder()\\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n        if amount < 0:\\n            if assets[symbol]['amount'] < amount:\\n                CancelOrder()\\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n            if assets[symbol]['amount'] > amount:\\n                CancelOrder()\\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n\\n\\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n    sell_price = (value / pct + value) / ((value / pct) /",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n\\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\\n        CancelOrder()\\n        Trade('BUY', _N(buy_price, tradeInfo[symbol]['priceSize']), _N(value / buy_price, tradeInfo[symbol]['amountSize']))\\n        Trade('SELL', _N(sell_price, tradeInfo[symbol]['priceSize']), (_N(value / sell_price, tradeInfo[symbol]['amountSi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_N(value / sell_price, tradeInfo[symbol]['amountSize'])))\\n\\ndef FirstAccount():\\n    key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n    initialAccount = _G(key)\\n    if initialAccount is None:\\n        initialAccount = exchange.GetAccount()\\n        _G(key, initialAccount)\\n    return initialAccount\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTim",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Time\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "* 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef initData():\\n    global symbol\\n    if _G('symbol') is None:\\n        symbol = exchange.GetCurrency().replace('_','')\\n        _G('symbol',symbol)\\n        Log('初始化币种：',symbol)\\n    else:\\n        symbol = _G('symbol')\\n        Log('交易币种：',symbol)\\n\\ndef main():\\n    exchange.SetContractType('swap')\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f main():\\n    exchange.SetContractType('swap')\\n    exchange.SetMarginLevel(10)\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n\\n        Sleep(1000 * Interval)\",\n    \"策略名称: 币安合约网格-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       Sleep(1000 * Interval)\",\n    \"策略名称: 币安合约网格-002v\\n\\nInitPrice = 0\\nupdateProfitTime = 0\\nassets = {}\\ntradeInfo = {}\\naccountAssets = {}\\nruntimeData = {}\\nFunding = 0   #账户资金  为0的时候自动获取\\nsymbol = ''\\nVersion = '0.0.1'\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\\n\\n\\nif IsVirtual():\\n    L",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "balance':0,'profit':0}\\n\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif exchange.GetName() != 'Futures_Binance':\\n    Log('只支持币安期货交易所！')\\n    exit()\\n\\ndef init():\\n    initData()\\n    CancelOrder()\\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法连接币安网络，需要海外托管者')\\n        exit()\\n    for i in range(len(exchangeInfo['symbols'])):\\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\\n            assets[symbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[i]['symbol'] == symbol:\\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/f",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\\n\\ndef CancelOrder():\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    for x in range(len(orders)):\\n        if orders[x]['Info']['symbol'] == symbol :\\n            exchange.CancelOrder(orders[x]['Id'])\\n\\ndef UpdateStatus():\\n    global Funding,updateProfitTime\\n    if Funding == 0 :\\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\\n\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"保证金比率\\\",  \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍数][持仓模式]', '币种信息', '开仓方向','初始价格', '开仓数量'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "', '[模式][倍数][持仓模式]', '币种信息', '开仓方向','初始价格', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\\n        'rows': []\\n    }\\n\\n    profitColors = DangerColor\\n    totalProfit = assets['USDT']['total_balance'] - Funding\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday\\n    \\n    #Log('dayProfit:',dayProfit,'Funding:',Funding)\\n    dayRate = dayProfit / Funding * 100\\n\\n\\n    ac",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   dayRate = dayProfit / Funding * 100\\n\\n\\n    accountTable['rows'].append([\\n        runday,\\n        '$' + str(_N(Funding, 2)),\\n        '$' + str(assets['USDT']['total_balance']),\\n        '$' + str(assets['USDT']['margin_balance']),\\n        '$' + str(assets['USDT']['margin']),\\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\\n        str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n        str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n        str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n        str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n\\n    i = 1\\n    for x in list(symbol.split(',')):\\n        typestr = '多空持仓'\\n        if type == 1:\\n            typestr = '只持多仓'\\n        if type == 2:\\n            typestr = '只持空仓'\\n        direction = '空仓'\\n        margin = direction\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ection = '空仓'\\n        margin = direction\\n        if assets[x]['amount'] != 0:\\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\\n        unrealised_profit_color = '#000000'\\n        if assets[symbol]['unrealised_profit'] > 0:\\n            unrealised_profit_color = SuccessColor\\n        if assets[symbol]['unrealised_profit'] < 0:\\n            unrealised_profit_color = DangerCol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n            unrealised_profit_color = DangerColor\\n\\n        infoList = [\\n        i,\\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']'+'['+typestr+']',\\n        x,\\n        direction,\\n        InitPrice,\\n        assets[x]['amount'],\\n        assets[x]['hold_price'],\\n        assets[x]['price'],\\n        assets[x]['liquidationPrice'],\\n        float(assets[x]['amount']) * float(assets[x]['price']),\\n        assets[x]['positionInitialMargin'],\\n        assets[x]['unrealised_profit'],\\n        ]\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       assets[x]['unrealised_profit'],\\n        ]\\n        table['rows'].append(infoList)\\n\\n        retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n'\\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = assets['USDT']['total_balance']\\n        key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n        initialAccount = _G(k",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "exchange.GetLabel()\\n        initialAccount = _G(key)\\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\\n        if Show:\\n            balance = assets['USDT']['total_balance'] - Funding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n        Profit = _N(balance,0)\\n\\n\\ndef UpdateAccount():\\n    # Log('UpdateAccount()')\\n    global accountAssets\\n    account = exchange.GetAccount()\\n    position = exchang",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt = exchange.GetAccount()\\n    position = exchange.GetPosition()\\n    if account is None and position is None :\\n        Log('更新账户超时！！！')\\n        return\\n    accountAssets = account['Info']['assets']\\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\\n    for  i in range(len(account['Info']['positions'])) :\\n        if account['Info']['positions'][i]['symbol'] == symbol :\\n            #计算持仓保证金                                           初始保证金                +            维持保证金\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       初始保证金                +            维持保证金\\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\\n            #未实现收益\\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\\n            assets[symbol]['leverage'] = account['Info']['posit",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ssets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\\n\\n    #计算持仓保证金总额\\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\\n\\n    ps = json.loads(exchange.GetRawJSON())\\n    if len(ps) > 0 :\\n        for x in range(len(ps)):\\n            if ps[x]['symbol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "x in range(len(ps)):\\n            if ps[x]['symbol'] == symbol:\\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\\n                assets[symbol]['marginType'] = ps[x]['marginType']\\n\\ndef UpdateTick():\\n    global InitPrice\\n    res = _C(e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pdateTick():\\n    global InitPrice\\n    res = _C(exchange.GetTicker)\\n    if res is None:\\n        Log(\\\"行情更新异常！！！\\\")\\n\\n    if target:\\n        InitPrice = target_price\\n        _G('InitPrice',InitPrice)\\n    else:\\n        if  _G('InitPrice') is None :\\n            InitPrice = res.Last\\n            _G('InitPrice',InitPrice)\\n        else:\\n            InitPrice = _G('InitPrice')\\n\\n    assets[symbol]['price'] = res.Last\\n\\ndef Trade(direction,price,amount):\\n    if amount < 0:\\n        amount = -amount\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n    if amount < 0:\\n        amount = -amount\\n    Log('amount:',amount,'minQty:',tradeInfo[symbol]['minQty'])\\n    if amount < tradeInfo[symbol]['minQty']:\\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n    else:\\n        para = ''\\n        url = '/fapi/v1/order'\\n        para += 'symbol='+ symbol\\n        para += '&side='+ direction\\n        para += '&type=LIMIT&timeInForce=GTC'\\n        para += '&quantity='+ str(amount)\\n        para += '&price='+",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "uantity='+ str(amount)\\n        para += '&price='+ str(price)\\n        para += \\\"&timestamp=\\\"+str(time.time() * 1000);\\n        go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n        ret = go.wait()\\n        if ret  is not None:\\n            logType = LOG_TYPE_SELL\\n            if direction == 'BUY':\\n                logType =LOG_TYPE_BUY\\n            exchange.Log(logType,price,amount,symbol)\\n\\ndef batch(buy_price,sell_price):\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = ex",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    if len(orders) < 2 :\\n        return True\\n    return False\\n\\ndef Process():\\n    amount = (1 - float(assets[symbol]['price']) / float(InitPrice)) / float(pct) * float(value) / float(assets[symbol]['price'])\\n    if abs(amount - assets[symbol]['amount']) > _N(value / float(assets[symbol]['price']), tradeInfo[symbol]['amountSize']):\\n        if amount > 0:\\n            if assets[symbol]['amount'] < amount:\\n                CancelOrder",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]['amount'] < amount:\\n                CancelOrder()\\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n            if assets[symbol]['amount'] > amount:\\n                CancelOrder()\\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n        if",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t']),tradeInfo[symbol]['amountSize']))\\n        if amount < 0:\\n            if assets[symbol]['amount'] < amount:\\n                CancelOrder()\\n                Trade('BUY', round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n            if assets[symbol]['amount'] > amount:\\n                CancelOrder()\\n                Trade('SELL',  round(float(assets[symbol]['price']), tradeInfo[symbol]['priceSize']), ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mbol]['price']), tradeInfo[symbol]['priceSize']), round(amount - float(assets[symbol]['amount']),tradeInfo[symbol]['amountSize']))\\n\\n\\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n\\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\\n        CancelOrder()\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ch(buy_price,sell_price):\\n        CancelOrder()\\n        Trade('BUY', _N(buy_price, tradeInfo[symbol]['priceSize']), _N(value / buy_price, tradeInfo[symbol]['amountSize']))\\n        Trade('SELL', _N(sell_price, tradeInfo[symbol]['priceSize']), (_N(value / sell_price, tradeInfo[symbol]['amountSize'])))\\n\\ndef FirstAccount():\\n    key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n    initialAccount = _G(key)\\n    if initialAccount is None:\\n        initialAccount = exchange.GetAccount()\\n        _G(key, initi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "unt = exchange.GetAccount()\\n        _G(key, initialAccount)\\n    return initialAccount\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(date",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef initData():\\n    global symbol\\n    if _G('symbol') is No",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "a():\\n    global symbol\\n    if _G('symbol') is None:\\n        symbol = exchange.GetCurrency().replace('_','')\\n        _G('symbol',symbol)\\n        Log('初始化币种：',symbol)\\n    else:\\n        symbol = _G('symbol')\\n        Log('交易币种：',symbol)\\n\\ndef main():\\n    exchange.SetContractType('swap')\\n    exchange.SetMarginLevel(10)\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while T",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n\\n        Sleep(1000 * Interval)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/322284\\n\\n> Last Modified\\n\\n2021-11-19 10:29:27\"\n \n\n    \"strategy_91\",\n    \"python\\n# 刚开始学python，有不不合理的地方，见谅！！！\\nimport time\\nimport requests\\nimport math\\nimport pandas as pd\\n\\nInitP",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "equests\\nimport math\\nimport pandas as pd\\n\\nInitPrice = 0\\nupdateProfitTime = 0\\nassets = {}\\ntradeInfo = {}\\naccountAssets = {}\\nruntimeData = {}\\nFunding = 0   #账户资金  为0的时候自动获取\\nsymbol = ''\\nVersion = '0.0.1'\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\\n\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rofit':0}\\n\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif exchange.GetName() != 'Futures_Binance':\\n    Log('只支持币安期货交易所！')\\n    exit()\\n\\ndef init():\\n    initData()\\n    CancelOrder()\\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法连接币安网络，需要海外托管者')\\n        exit()\\n    for i in range(len(exchangeInfo['symbols'])):\\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\\n            assets[symbol] = {'amount",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == symbol:\\n            assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchange",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\\n\\ndef CancelOrder():\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    for x in range(len(orders)):\\n        if orders[x]['Info']['symbol'] == symbol :\\n            exchange.CancelOrder(orders[x]['Id'])\\n\\ndef UpdateStatus():\\n    global Funding,updateProfitTime\\n    if Funding == 0 :\\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ccount()['Info']['totalWalletBalance'])   #获取初始资金\\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\\n\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"保证金比率\\\",  \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\\n        'rows': []\\n    }\\n\\n    profitColors = DangerColor\\n    totalProfit = assets['USDT']['total_balance'] - Funding\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday\\n    dayRate = dayProfit / Funding * 100\\n\\n\\n    accountTable['rows'].append([\\n        runday,\\n        '$' + str(_N(Funding, 2)),\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  runday,\\n        '$' + str(_N(Funding, 2)),\\n        '$' + str(assets['USDT']['total_balance']),\\n        '$' + str(assets['USDT']['margin_balance']),\\n        '$' + str(assets['USDT']['margin']),\\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\\n        str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n        str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n        str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n        str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n\\n    i = 1\\n    for x in list(symbol.split(',')):\\n        \\n        direction = '空仓'\\n        margin = direction\\n        if assets[x]['amount'] != 0:\\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " if assets[symbol]['marginType'] == 'cross' else '逐仓'\\n        unrealised_profit_color = '#000000'\\n        if assets[symbol]['unrealised_profit'] > 0:\\n            unrealised_profit_color = SuccessColor\\n        if assets[symbol]['unrealised_profit'] < 0:\\n            unrealised_profit_color = DangerColor\\n\\n        infoList = [\\n        i,\\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']',\\n        x,\\n        direction,\\n        assets[x]['amount'],\\n        assets[x]['hold_price'],\\n        ass",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'],\\n        assets[x]['hold_price'],\\n        assets[x]['price'],\\n        assets[x]['liquidationPrice'],\\n        float(assets[x]['amount']) * float(assets[x]['price']),\\n        assets[x]['positionInitialMargin'],\\n        assets[x]['unrealised_profit'],\\n        ]\\n        table['rows'].append(infoList)\\n\\n        retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n'\\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = assets['USDT']['total_balance']\\n        key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n        initialAccount = _G(key)\\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\\n        if Show:\\n            balance = assets['USDT']['total_balance'] - Funding\\n        LogProfit(_N(balance, 3))\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "- Funding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n        Profit = _N(balance,0)\\n\\n\\ndef UpdateAccount():\\n    # Log('UpdateAccount()')\\n    global accountAssets\\n    account = exchange.GetAccount()\\n    position = exchange.GetPosition()\\n    if account is None and position is None :\\n        Log('更新账户超时！！！')\\n        return\\n    accountAssets = account['Info']['assets']\\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\\n    for  i ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time.time()) * 1000  #秒转毫秒   同步更新账户时间\\n    for  i in range(len(account['Info']['positions'])) :\\n        if account['Info']['positions'][i]['symbol'] == symbol :\\n            #计算持仓保证金                                           初始保证金                +            维持保证金\\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\\n            #未实现收益\\n            assets[symbol]['unrealised_profit'] = float(account['Info']['",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ol]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\\n\\n    #计算持仓保证金总额\\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ance'] = float(account['Info']['totalMarginBalance'])\\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\\n\\n    ps = json.loads(exchange.GetRawJSON())\\n    if len(ps) > 0 :\\n        for x in range(len(ps)):\\n            if ps[x]['symbol'] == symbol:\\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'unrealised_profit'] = float(ps[x]['unRealizedProfit'])\\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\\n                assets[symbol]['marginType'] = ps[x]['marginType']\\n\\ndef UpdateTick():\\n    global InitPrice\\n    try:\\n        res = requests.get(f'https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol}').json()\\n    except:\\n        Log('get ticker time out !')\\n        return\\n\\n    if target:\\n        InitPrice = target_price\\n        _G('InitPrice',Init",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tPrice = target_price\\n        _G('InitPrice',InitPrice)\\n    else:\\n        if  _G('InitPrice') is None :\\n            InitPrice = res['price']\\n            _G('InitPrice',InitPrice)\\n        else:\\n            InitPrice = _G('InitPrice')\\n\\n    assets[symbol]['price'] = res['price']\\n\\ndef Trade(direction,price,amount):\\n    if amount < tradeInfo[symbol]['minQty']:\\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n    else:\\n        para = ''\\n        u",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e,4) + 1)\\n    else:\\n        para = ''\\n        url = '/fapi/v1/order'\\n        para += 'symbol='+ symbol\\n        para += '&side='+ direction\\n        para += '&type=LIMIT&timeInForce=GTC'\\n        para += '&quantity='+ str(amount)\\n        para += '&price='+ str(price)\\n        para += \\\"&timestamp=\\\"+str(time.time() * 1000);\\n        go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n        ret = go.wait()\\n        if ret  is not None:\\n            logType = LOG_TYPE_SELL\\n            if direction",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " logType = LOG_TYPE_SELL\\n            if direction == 'BUY':\\n                logType =LOG_TYPE_BUY\\n            exchange.Log(logType,price,amount,symbol)\\n\\ndef batch(buy_price,sell_price):\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    if len(orders) < 2 :\\n        return True\\n    return False\\n\\ndef Process():\\n\\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n    sell_price = (value / pct + value) / ((",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt'])\\n    sell_price = (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n\\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\\n        CancelOrder()\\n        Trade('BUY', _N(buy_price, 5), _N(value / buy_price, 0))\\n        Trade('SELL', _N(sell_price, 5), _N(value / sell_price, 0))\\n\\ndef FirstAccount():\\n    key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n    initialAccount = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt_\\\" + exchange.GetLabel()\\n    initialAccount = _G(key)\\n    if initialAccount is None:\\n        initialAccount = exchange.GetAccount()\\n        _G(key, initialAccount)\\n    return initialAccount\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef initData():\\n    global symbol\\n    if _G('symbol') is None:\\n        symbol = exchange.GetCurrency().replace('_','')\\n        _G('symbol',symbol)\\n        Log('初始化币种：',symbol)\\n    else:\\n        symbol = _G('symbol')\\n        Log('交易币种：',symbol)\\n\\ndef main():\\n    exchange.SetContractType('swap')\\n    exchange.SetMarginLevel(10)\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n\\n        Sleep(1000 * Interval)\",\n    \"策略名称: 币安合约网格-基础版本-001\\n\\nimport time\\nimport requests\\nimport math\\nimport pandas as pd\\n\\nInitPrice = 0\\nupdateProfitT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mport pandas as pd\\n\\nInitPrice = 0\\nupdateProfitTime = 0\\nassets = {}\\ntradeInfo = {}\\naccountAssets = {}\\nruntimeData = {}\\nFunding = 0   #账户资金  为0的时候自动获取\\nsymbol = ''\\nVersion = '0.0.1'\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':0,'profit':0}\\n\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif excha",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif exchange.GetName() != 'Futures_Binance':\\n    Log('只支持币安期货交易所！')\\n    exit()\\n\\ndef init():\\n    initData()\\n    CancelOrder()\\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法连接币安网络，需要海外托管者')\\n        exit()\\n    for i in range(len(exchangeInfo['symbols'])):\\n        if exchangeInfo['symbols'][i]['symbol'] == symbol:\\n            assets[symbol] = {'amount': 0,'hold_price': 0,'v",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,\\n            'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\\n            tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\\n            'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['fil",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "th.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\\n\\ndef CancelOrder():\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    for x in range(len(orders)):\\n        if orders[x]['Info']['symbol'] == symbol :\\n            exchange.CancelOrder(orders[x]['Id'])\\n\\ndef UpdateStatus():\\n    global Funding,updateProfitTime\\n    if Funding == 0 :\\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])   #获取初始资金\\n    # totalProfit = as",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "WalletBalance'])   #获取初始资金\\n    # totalProfit = assets['USDT']['total_balance'] - Funding             #计算收益\\n\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"保证金比率\\\",  \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "', '持仓价格', '当前价格', '强平价格', '持仓价值', '保证金', '未实现盈亏'],\\n        'rows': []\\n    }\\n\\n    profitColors = DangerColor\\n    totalProfit = assets['USDT']['total_balance'] - Funding\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday\\n    dayRate = dayProfit / Funding * 100\\n\\n\\n    accountTable['rows'].append([\\n        runday,\\n        '$' + str(_N(Funding, 2)),\\n        '$' + str(assets['",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "+ str(_N(Funding, 2)),\\n        '$' + str(assets['USDT']['total_balance']),\\n        '$' + str(assets['USDT']['margin_balance']),\\n        '$' + str(assets['USDT']['margin']),\\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\\n        str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n        str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n        str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "0, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n        str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n\\n    i = 1\\n    for x in list(symbol.split(',')):\\n        \\n        direction = '空仓'\\n        margin = direction\\n        if assets[x]['amount'] != 0:\\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\\n        unrealised",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ginType'] == 'cross' else '逐仓'\\n        unrealised_profit_color = '#000000'\\n        if assets[symbol]['unrealised_profit'] > 0:\\n            unrealised_profit_color = SuccessColor\\n        if assets[symbol]['unrealised_profit'] < 0:\\n            unrealised_profit_color = DangerColor\\n\\n        infoList = [\\n        i,\\n        '['+margin+']'+'['+str(assets[x]['leverage'])+']',\\n        x,\\n        direction,\\n        assets[x]['amount'],\\n        assets[x]['hold_price'],\\n        assets[x]['price'],\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'hold_price'],\\n        assets[x]['price'],\\n        assets[x]['liquidationPrice'],\\n        float(assets[x]['amount']) * float(assets[x]['price']),\\n        assets[x]['positionInitialMargin'],\\n        assets[x]['unrealised_profit'],\\n        ]\\n        table['rows'].append(infoList)\\n\\n        retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n'\\n        LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = assets['USDT']['total_balance']\\n        key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n        initialAccount = _G(key)\\n        #Log('balance:',balance,'Funding:',Funding,'initialAccount:',initialAccount['Info']['totalWalletBalance'])\\n        if Show:\\n            balance = assets['USDT']['total_balance'] - Funding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rofit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n        Profit = _N(balance,0)\\n\\n\\ndef UpdateAccount():\\n    # Log('UpdateAccount()')\\n    global accountAssets\\n    account = exchange.GetAccount()\\n    position = exchange.GetPosition()\\n    if account is None and position is None :\\n        Log('更新账户超时！！！')\\n        return\\n    accountAssets = account['Info']['assets']\\n    assets['USDT']['update_time'] = int(time.time()) * 1000  #秒转毫秒   同步更新账户时间\\n    for  i in range(len(account['I",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "转毫秒   同步更新账户时间\\n    for  i in range(len(account['Info']['positions'])) :\\n        if account['Info']['positions'][i]['symbol'] == symbol :\\n            #计算持仓保证金                                           初始保证金                +            维持保证金\\n            assets[symbol]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\\n            #未实现收益\\n            assets[symbol]['unrealised_profit'] = float(account['Info']['positions'][i]['unreali",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "] = float(account['Info']['positions'][i]['unrealizedProfit'])\\n            assets[symbol]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\\n            assets[symbol]['leverage'] = account['Info']['positions'][i]['leverage']\\n\\n    #计算持仓保证金总额\\n    assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\\n    assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\\n    assets['USDT']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'Info']['totalMarginBalance'])\\n    assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\\n\\n    ps = json.loads(exchange.GetRawJSON())\\n    if len(ps) > 0 :\\n        for x in range(len(ps)):\\n            if ps[x]['symbol'] == symbol:\\n                assets[symbol]['hold_price'] = float(ps[x]['entryPrice'])\\n                assets[symbol]['amount'] = float(ps[x]['positionAmt'])\\n                assets[symbol]['unrealised_profit'] = float(ps[x]['unRealizedProfit'])\\n                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "float(ps[x]['unRealizedProfit'])\\n                assets[symbol]['liquidationPrice'] = float(ps[x]['liquidationPrice'])\\n                assets[symbol]['marginType'] = ps[x]['marginType']\\n\\ndef UpdateTick():\\n    global InitPrice\\n    try:\\n        res = requests.get(f'https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol}').json()\\n    except:\\n        Log('get ticker time out !')\\n        return\\n\\n    if target:\\n        InitPrice = target_price\\n        _G('InitPrice',InitPrice)\\n    else:\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        _G('InitPrice',InitPrice)\\n    else:\\n        if  _G('InitPrice') is None :\\n            InitPrice = res['price']\\n            _G('InitPrice',InitPrice)\\n        else:\\n            InitPrice = _G('InitPrice')\\n\\n    assets[symbol]['price'] = res['price']\\n\\ndef Trade(direction,price,amount):\\n    if amount < tradeInfo[symbol]['minQty']:\\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n    else:\\n        para = ''\\n        url = '/fapi/v1/order'\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       para = ''\\n        url = '/fapi/v1/order'\\n        para += 'symbol='+ symbol\\n        para += '&side='+ direction\\n        para += '&type=LIMIT&timeInForce=GTC'\\n        para += '&quantity='+ str(amount)\\n        para += '&price='+ str(price)\\n        para += \\\"&timestamp=\\\"+str(time.time() * 1000);\\n        go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n        ret = go.wait()\\n        if ret  is not None:\\n            logType = LOG_TYPE_SELL\\n            if direction == 'BUY':\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "L\\n            if direction == 'BUY':\\n                logType =LOG_TYPE_BUY\\n            exchange.Log(logType,price,amount,symbol)\\n\\ndef batch(buy_price,sell_price):\\n    exchange.SetContractType('swap')\\n    #撤销所有未成交订单\\n    orders = exchange.GetOrders()\\n    if len(orders) < 2 :\\n        return True\\n    return False\\n\\ndef Process():\\n\\n    buy_price = (value / pct - value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n    sell_price = (value / pct + value) / ((value / pct) / float(In",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " (value / pct + value) / ((value / pct) / float(InitPrice) + assets[symbol]['amount'])\\n\\n    if float(buy_price) > float(assets[symbol]['price']) or float(sell_price) < float(assets[symbol]['price']) or batch(buy_price,sell_price):\\n        CancelOrder()\\n        Trade('BUY', _N(buy_price, 5), _N(value / buy_price, 0))\\n        Trade('SELL', _N(sell_price, 5), _N(value / sell_price, 0))\\n\\ndef FirstAccount():\\n    key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n    initialAccount = _G(key)\\n    if initial",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "el()\\n    initialAccount = _G(key)\\n    if initialAccount is None:\\n        initialAccount = exchange.GetAccount()\\n        _G(key, initialAccount)\\n    return initialAccount\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef initData():\\n    global symbol\\n    if _G('symbol') is None:\\n        symbol = exchange.GetCurrency().replace('_','')\\n        _G('symbol',symbol)\\n        Log('初始化币种：',symbol)\\n    else:\\n        symbol = _G('symbol')\\n        Log('交易币种：',symbol)\\n\\ndef main():\\n    exchange.SetContractType('swap')\\n    exchange.SetMarginLevel(10)\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "expected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n\\n        Sleep(1000 * Interval)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/322060\\n\\n> Last Modified\\n\\n2021-10-09 12:58:38\"\n \n\n    \"strategy_92\",\n    \"python\\n#刚学python，希望指",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"\n \n\n    \"strategy_92\",\n    \"python\\n#刚学python，希望指正！共同学习！\\nimport time\\nimport requests\\nimport math\\nAlpha = 0.001 #指数移动平均的Alpha参数，设置的越大，基准价格跟踪越敏感，最终持仓也会越低，降低了杠杆，但会降低收益，具体需要根据回测结果自己权衡\\nUpdate_base_price_time_interval = 60 #多久更新一次基准价格, 单位秒，和Alpha参数相关,Alpha 设置的越小，这个间隔也可以设置的更小\\n#Stop_loss设置为0.8表示当资金达到低于初始资金的80%时，止损，清空所有仓位，停止策略。\\n#随着策略运行，Stop_loss可以设置大于1（重启生效），比如从1000赚到1500，Stop_loss设置为1.3，则回撤到1300元止损。不想止损可以把这个参数设置的很小。\\n#风险是大家都用这种止损会形成踩踏，加大亏损。\\n#初始资金在状态栏的init_balance字段，注意提现等操作会影响，别不小心止损了。\\n#如果还是怕黑天鹅事件，比如某个币归0等",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "alance字段，注意提现等操作会影响，别不小心止损了。\\n#如果还是怕黑天鹅事件，比如某个币归0等，可以手动提现出来。\\n\\nStop_loss = 0.8\\nMax_diff = 0.03 #当偏差diff大于0.4时，不继续加空仓, 自行设置\\nMin_diff = -0.03 #当diff小于-0.3时，不继续加多仓, 自行设置\\nVersion = '0.1.3'\\nShow = false #默认为false累计收益显示是账户余额,改为true累计收益显示为收益,如果之前是显示的账户余额,你使用LogProfitReset()来清空图表\\nFunding = 0 #账户初始金额,为0的时候,自动获取,非0为自定义\\nsuccess = '#5cb85c' #成功颜色\\ndanger = '#ff0000' #危险颜色\\nwarning = '#f0ad4e' #警告颜色\\nRunTime = {} #运行时间\\nSelfFee = 0.04 #https:#www.binance.com/cn/fee/futureFee\\nTotalLong = 0\\nTotalShort = 0\\nUpProf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e/futureFee\\nTotalLong = 0\\nTotalShort = 0\\nUpProfit = 0\\naccountAssets = [] #保存资产\\nWinRateData = {} #保存所有币种的胜率及开仓次数\\n\\nif IsVirtual():\\n    Log('不能回测，回测参考 https://www.fmz.com/digest-topic/5294 ')\\n    exit()\\nif exchange.GetName() != 'Futures_Binance':\\n    Log('只支持币安期货交易所，和现货交易所不同，需要单独添加，名称为Futures_Binance')\\n    exit()\\ntrade_symbols = Trade_symbols.split(',')\\nsymbols = trade_symbols + ['BTC']\\nindex = 1 #指数\\nupdate_profit_time = 0\\nupdate_base_price_time = int(time.time()*1000)\\nassets = {}\\ninit_price",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e = int(time.time()*1000)\\nassets = {}\\ninit_prices = {}\\ntrade_info = {}\\n\\ndef init():\\n    InitRateData()\\n    exchange_info = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\\n    if exchange_info is None:\\n        Log('无法连接币安网络，需要海外托管者')\\n        exit()    \\n    for i in range(len(exchange_info['symbols'])):\\n        if exchange_info['symbols'][i]['baseAsset'] in symbols:            \\n            assets[exchange_info['symbols'][i]['baseAsset']] = {'amount': 0,'hold_price': 0,'value'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "aseAsset']] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'btc_price': 0, 'btc_change': 1,'btc_diff': 0,'realised_profit': 0,'margin': 0,'unrealised_profit': 0,'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\\n            trade_info[exchange_info['symbols'][i]['baseAsset']] = {'minQty': float(exchange_info['symbols'][i]['filters'][1]['minQty']) , 'priceSize': int((math.log10(1.1/float(exchange_info['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((m",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchange_info['symbols'][i]['filters'][1]['stepSize']))))}\\n\\nassets['USDT'] = {\\n    'unrealised_profit': 0,\\n    'margin': 0,\\n    'margin_balance': 0,\\n    'total_balance': 0,\\n    'leverage': 0,\\n    'update_time': 0,\\n    'margin_ratio': 0,\\n    'init_balance': 0,\\n    'stop_balance': 0,\\n    'short_value': 0,\\n    'long_value': 0,\\n    'profit': 0\\n}\\n\\ndef updateAccount() : #更新账户和持仓\\n    global accountAssets\\n    account = exchange",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    global accountAssets\\n    account = exchange.GetAccount()\\n    pos = exchange.GetPosition()\\n    if account is None or pos is None:\\n        Log('update account time out')\\n        return    \\n    accountAssets = account['Info']['assets']\\n    assets['USDT']['update_time'] = int(time.time()*1000)\\n    for i in range(len(trade_symbols)):\\n        assets[trade_symbols[i]]['margin'] = 0\\n        assets[trade_symbols[i]]['unrealised_profit'] = 0\\n        assets[trade_symbols[i]]['hold_price'] = 0\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ssets[trade_symbols[i]]['hold_price'] = 0\\n        assets[trade_symbols[i]]['amount'] = 0\\n    \\n    for j in range(len(account['Info']['positions'])):        \\n        if account['Info']['positions'][j]['positionSide'] == 'BOTH':\\n            pair = account['Info']['positions'][j]['symbol']\\n            coin = pair[0:len(pair)-4]\\n            if coin not in trade_symbols:\\n                continue\\n            assets[coin]['margin'] = float(account['Info']['positions'][j]['initialMargin']) + float(account[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'positions'][j]['initialMargin']) + float(account['Info']['positions'][j]['maintMargin'])\\n            assets[coin]['unrealised_profit'] = float(account['Info']['positions'][j]['unrealizedProfit'])\\n            assets[coin]['positionInitialMargin'] = float(account['Info']['positions'][j]['positionInitialMargin'])\\n            assets[coin]['leverage'] = account['Info']['positions'][j]['leverage']\\n\\n    assets['USDT']['margin'] = _N(float(account['Info']['totalInitialMargin']) + float(account['Info']['totalM",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "alInitialMargin']) + float(account['Info']['totalMaintMargin']), 2)\\n    assets['USDT']['margin_balance'] = _N(float(account['Info']['totalMarginBalance']), 2)\\n    assets['USDT']['total_balance'] = _N(float(account['Info']['totalWalletBalance']), 2)\\n    if assets['USDT']['init_balance'] == 0:\\n        if _G('init_balance'):\\n            assets['USDT']['init_balance'] = _N(_G('init_balance'), 2)\\n        else:\\n            assets['USDT']['init_balance'] = assets['USDT']['total_balance']\\n            _G('in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ssets['USDT']['total_balance']\\n            _G('init_balance', assets['USDT']['init_balance'])\\n    assets['USDT']['profit'] = _N(assets['USDT']['margin_balance'] - assets['USDT']['init_balance'], 2)\\n    assets['USDT']['stop_balance'] = _N(Stop_loss * assets['USDT']['init_balance'], 2)\\n    assets['USDT']['total_balance'] = _N(float(account['Info']['totalWalletBalance']), 2)\\n    assets['USDT']['unrealised_profit'] = _N(float(account['Info']['totalUnrealizedProfit']), 2)\\n    assets['USDT']['leverage'] = _",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dProfit']), 2)\\n    assets['USDT']['leverage'] = _N(assets['USDT']['margin'] / assets['USDT']['total_balance'], 2)\\n    assets['USDT']['margin_ratio'] = float(account['Info']['totalMaintMargin']) / float(account['Info']['totalMarginBalance']) * 100\\n    pos = json.loads(exchange.GetRawJSON())\\n    if len(pos) > 0:\\n        for k in range(len(pos)):\\n            pair = pos[k]['symbol']\\n            coin = pair[0:len(pair)-4]\\n            if coin not in trade_symbols:\\n                continue            \\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "symbols:\\n                continue            \\n            if pos[k]['positionSide'] != 'BOTH':\\n                continue       \\n            assets[coin]['hold_price'] = float(pos[k]['entryPrice'])\\n            assets[coin]['amount'] = float(pos[k]['positionAmt'])\\n            assets[coin]['unrealised_profit'] = float(pos[k]['unRealizedProfit'])\\n            assets[coin]['liquidationPrice'] = float(pos[k]['liquidationPrice'])\\n            assets[coin]['marginType'] = pos[k]['marginType']\\n\\ndef updateInde",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ginType'] = pos[k]['marginType']\\n\\ndef updateIndex(): #更新指数\\n    global update_base_price_time,index,init_prices,Reset\\n    if _G('init_prices') is None or Reset:\\n        Reset = False\\n        for i in range(len(trade_symbols)):\\n            init_prices[trade_symbols[i]] = (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\\n        Log('保存启动时的价格')\\n        _G('init_prices', init_prices)\\n        _G(\\\"StartTime\\\", Non",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ices', init_prices)\\n        _G(\\\"StartTime\\\", None) #重置开始时间\\n        _G(\\\"initialAccount_\\\" + exchange.GetLabel(), None) #重置开始资金\\n        _G('tradeNumber', 0) #重置交易次数\\n        _G('tradeVolume', 0) #重置交易量\\n        _G('buyNumber', 0) #重置做多次数\\n        _G('sellNumber', 0) #重置做空次数\\n        _G('totalProfit', 0) #重置打印次数\\n        _G('profitNumber', 0) #重置盈利次数\\n    else:\\n        init_prices = _G('init_prices')\\n        if (int(time.time()*1000) - update_base_price_time > Update_base_price_time_interval * 1000):\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time > Update_base_price_time_interval * 1000):\\n            update_base_price_time = int(time.time()*1000)\\n            for i in range(len(trade_symbols)): #更新初始价格\\n                init_prices[trade_symbols[i]] = init_prices[trade_symbols[i]] * (1 - Alpha) + Alpha * (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\\n            _G('init_prices', init_prices)\\n        temp = 0\\n        for i in range(len(trade_symbols)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "emp = 0\\n        for i in range(len(trade_symbols)):\\n            assets[trade_symbols[i]]['btc_price'] = (assets[trade_symbols[i]]['ask_price'] + assets[trade_symbols[i]]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\\n            if trade_symbols[i] not in init_prices:\\n                Log('添加新的币种', trade_symbols[i])\\n                init_prices[trade_symbols[i]] = assets[trade_symbols[i]]['btc_price']\\n                _G('init_prices', init_prices)\\n            assets[trade_sym",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rices', init_prices)\\n            assets[trade_symbols[i]]['btc_change'] = _N(assets[trade_symbols[i]]['btc_price'] / init_prices[trade_symbols[i]], 4)\\n            temp += assets[trade_symbols[i]]['btc_change']        \\n        index = _N(temp / len(trade_symbols), 4)\\n\\ndef updateTick() : #更新行情\\n    try:\\n        ticker = requests.get('https://fapi.binance.com/fapi/v1/ticker/bookTicker').json()\\n    except Exception as e:\\n        Log('get ticker time out:',e)\\n        return\\n    assets['USDT']['short_va",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "',e)\\n        return\\n    assets['USDT']['short_value'] = 0\\n    assets['USDT']['long_value'] = 0\\n    for i in range(len(ticker)):\\n        pair = ticker[i]['symbol']\\n        coin = pair[0:len(pair)-4]\\n        if coin not in symbols:\\n            continue\\n        assets[coin]['ask_price'] = float(ticker[i]['askPrice'])\\n        assets[coin]['bid_price'] = float(ticker[i]['bidPrice'])\\n        assets[coin]['ask_value'] = _N(assets[coin]['amount'] * assets[coin]['ask_price'], 2)\\n        assets[coin]['bid",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[coin]['ask_price'], 2)\\n        assets[coin]['bid_value'] = _N(assets[coin]['amount'] * assets[coin]['bid_price'], 2)\\n        if coin not in trade_symbols:\\n            continue\\n        if assets[coin]['amount'] < 0 :\\n            assets['USDT']['short_value'] += abs((assets[coin]['ask_value'] + assets[coin]['bid_value']) / 2)\\n        else:\\n            assets['USDT']['long_value'] += abs((assets[coin]['ask_value'] + assets[coin]['bid_value']) / 2)        \\n        assets['USDT']['short_value'] = _N(ass",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\n        assets['USDT']['short_value'] = _N(assets['USDT']['short_value'], 0)\\n        assets['USDT']['long_value'] = _N(assets['USDT']['long_value'], 0)    \\n    updateIndex()\\n    for i in range(len(trade_symbols)):\\n        assets[trade_symbols[i]]['btc_diff'] = _N(assets[trade_symbols[i]]['btc_change'] - index, 4)\\n\\ndef trade(symbol, dirction, value) : #交易\\n    if (int(time.time()*1000) - assets['USDT']['update_time'] > 10 * 1000):\\n        Log('更新账户延时，不交易')\\n    else:\\n        price = assets[symbol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "延时，不交易')\\n    else:\\n        price = assets[symbol]['bid_price'] if dirction == 'sell' else assets[symbol]['ask_price']\\n        amount = _N(min(value, Ice_value) / price, trade_info[symbol]['amountSize'])\\n        if amount < trade_info[symbol]['minQty']:\\n            Log(symbol, '合约价值偏离或冰山委托订单的大小设置过小，达不到最小成交, 至少需要: ', _N(trade_info[symbol]['minQty'] * price, 0) + 1)\\n        else:\\n            exchange.IO(\\\"currency\\\", symbol + '_' + 'USDT')\\n            exchange.SetContractType('swap')\\n            excha",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchange.SetContractType('swap')\\n            exchange.SetDirection(dirction)\\n            #f = 'Buy' if dirction == 'buy' else 'Sell'\\n            place_order = getattr(exchange,'Buy' if dirction == 'buy' else 'Sell')\\n            id = place_order(price, amount, symbol)\\n            if id:\\n                exchange.CancelOrder(id) #订单会立即撤销\\n            tradingCounter('tradeVolume', price * amount) #保存交易量\\n            tradingCounter('tradeNumber', 1) #保存交易次数\\n            WinRateData[symbol]['tradeNumber'] +=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            WinRateData[symbol]['tradeNumber'] += 1\\n            if dirction == 'buy':\\n                tradingCounter('buyNumber', 1)\\n                WinRateData[symbol].buyNumber += 1\\n            else:\\n                tradingCounter('sellNumber', 1)\\n                WinRateData[symbol].sellNumber += 1            \\n            _G(\\\"WinRateData\\\", WinRateData) #保存各币种的交易数据\\n            return id\\n\\ndef InitRateData():\\n    global WinRateData\\n    if Reset :\\n        _G(\\\"WinRateData\\\", None)    \\n    if ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " :\\n        _G(\\\"WinRateData\\\", None)    \\n    if _G(\\\"WinRateData\\\"):\\n        WinRateData = _G(\\\"WinRateData\\\")    \\n    for i in range(len(symbols)):        \\n        if symbols[i] not in WinRateData:\\n            WinRateData[symbols[i]] = {'totalProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'buyNumber': 0, 'sellNumber': 0}\\n                                            #统计次数        #盈利次数          #交易次数       #做多次数        #做空次数\\n    _G(\\\"WinRateData\\\", WinRateData)\\n\\ndef RunCommand():\\n    str_cmd = GetC",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "RateData)\\n\\ndef RunCommand():\\n    str_cmd = GetCommand()\\n    if str_cmd:\\n        arrCmd = str_cmd.split(':')\\n        symbol = arrCmd[1]\\n        amount = float(arrCmd[2])\\n        if amount == 0:\\n            Log('亲,你还记得大明湖畔的乔碧萝吗?' + danger)\\n        else:\\n            #f = 'Buy' if amount < 0 else 'Sell'\\n            dirction = 'buy' if amount < 0 else 'sell'\\n            exchange.IO(\\\"currency\\\", symbol + '_' + 'USDT')\\n            exchange.SetContractType('swap')\\n            exchange.SetDirection(d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tType('swap')\\n            exchange.SetDirection(dirction)\\n            place_order = getattr(exchange,'Buy' if dirction == 'buy' else 'Sell')\\n            id = place_order(-1, abs(amount), symbol)\\n            #exchange[f](-1, abs(amount), symbol)\\n\\ndef FirstAccount():\\n    key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n    initialAccount = _G(key)\\n    if initialAccount is None:\\n        initialAccount = exchange.GetAccount()\\n        _G(key, initialAccount)    \\n    return initialAccount\\n\\ndef StartT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ount)    \\n    return initialAccount\\n\\ndef StartTime():\\n    StartTime = _G(\\\"StartTime\\\")\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G(\\\"StartTime\\\", StartTime)    \\n    return StartTime\\n\\ndef RuningTime():\\n    ret = {}    \\n    dateBegin = StartTime()\\n    dateEnd = _D()\\n    dateDiff = (time.mktime(time.strptime(dateEnd, '%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(dateBegin, '%Y-%m-%d %H:%M:%S'))) * 1000\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    leave1 = d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "oor(dateDiff / (24 * 3600 * 1000))\\n    leave1 = dateDiff % (24 * 3600 * 1000)\\n    hours = math.floor(leave1 / (3600 * 1000))\\n    leave2 = leave1 % (3600 * 1000)\\n    minutes = math.floor(leave2 / (60 * 1000))\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = \\\"运行时间: \\\" + str(dayDiff) + \\\" 天 \\\" + str(hours) + \\\" 小时 \\\" + str(minutes) + \\\" 分钟\\\"\\n    return ret\\n\\ndef AppendedStatus():\\n    global TotalLong , TotalShort,RunTime,Funding, accountAssets\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g , TotalShort,RunTime,Funding, accountAssets\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"保证金比率\\\", \\\"止损\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n    feeTable = {\\n        'type': 'table',\\n        'title': '交易统计',\\n        'cols': [\\\"策略指数\\\", '交易次数', '做多次数', '做空次数', '预估胜率', '预估成交额', '预估手续费', \\\"未实现盈利\\\", '持仓总值', '做多总值', '做空总值'],\\n        'rows': []\\n    }\\n    runday = RunTime",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",\\n        'rows': []\\n    }\\n    runday = RunTime['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if Funding == 0:\\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])\\n    profitColors = danger\\n    totalProfit = assets['USDT']['total_balance'] - Funding #总盈利\\n    if totalProfit > 0:\\n        profitColors = success\\n    dayProfit = totalProfit / runday #天盈利\\n    dayRate = dayProfit / Funding * 100\\n    accountTable['rows'].append([\\n        runday,\\n        '$' + str(_N(Funding,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "([\\n        runday,\\n        '$' + str(_N(Funding, 2)),\\n        '$' + str(assets['USDT']['total_balance']),\\n        '$' + str(assets['USDT']['margin_balance']),\\n        '$' + str(assets['USDT']['margin']),\\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\\n        str(_N(assets['USDT']['stop_balance'], 2)) + danger,\\n        str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n        str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "65, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n        str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n        str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n    vloume = _G('tradeVolume') if _G('tradeVolume') is not None else 0\\n    feeTable['rows'].append([\\n        index, #指数\\n        _G('tradeNumber') if _G('tradeNumber') is not None else 0, #交易次数\\n        _G('buyNumber') if _G('buyNumber') is not None else 0, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "uyNumber') if _G('buyNumber') is not None else 0, #做多次数\\n        _G('sellNumber') if _G('sellNumber') is not None else 0, #做空次数\\n        str(_N(_G('profitNumber') / _G('totalProfit') * 100, 2) if _G('totalProfit') > 0 else 0) + '%', #胜率\\n        '$' + str(_N(vloume, 2)) + ' ≈ ฿' + str(_N(vloume / ((assets['BTC']['bid_price'] + assets['BTC']['ask_price']) / 2), 6)), #成交金额\\n        '$' + str(_N(vloume * (SelfFee / 100), 4)), #手续费\\n        '$' + str(_N(assets['USDT']['unrealised_profit'], 2)) + (success if ass",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "USDT']['unrealised_profit'], 2)) + (success if assets['USDT']['unrealised_profit'] >= 0 else danger),\\n        '$' + str(_N(TotalLong + abs(TotalShort), 2)), #持仓总价值\\n        '$' + str(_N(TotalLong, 2)) + success, #做多总值\\n        '$' + str(_N(abs(TotalShort), 2)) + danger, #做空总值\\n    ])\\n    assetTable = {\\n        'type': 'table',\\n        'title': '账户资产信息',\\n        'cols': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可提款金额', '挂单起始保证金', '持仓起始保证金', '持仓未实现盈亏', '账户余额'],\\n        'rows': []\\n    }\\n    for i in ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'账户余额'],\\n        'rows': []\\n    }\\n    for i in range(len(accountAssets)):\\n        acc = accountAssets[i]\\n        assetTable['rows'].append([\\n            i + 1,\\n            acc['asset'], acc['initialMargin'], acc['maintMargin'], acc['marginBalance'],\\n            acc['maxWithdrawAmount'], acc['openOrderInitialMargin'], acc['positionInitialMargin'],\\n            acc['unrealizedProfit'], acc['walletBalance']\\n        ])\\n    indexTable = {\\n        'type': 'table',\\n        'title': '币指数信息',\\n        'c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "': 'table',\\n        'title': '币指数信息',\\n        'cols': ['编号', '币种信息', '当前价格', 'BTC计价', 'BTC计价变化(%)', '偏离平均', '交易次数', '做空次数', '做多次数', '预估胜率'],\\n        'rows': []\\n    }\\n    for i in range(len(symbols)) :\\n        price = _N((assets[symbols[i]]['ask_price'] + assets[symbols[i]]['bid_price']) / 2, trade_info[symbols[i]]['priceSize'])\\n        if symbols[i] not in symbols:\\n            indexTable['rows'].append([i + 1, symbols[i], price, assets[symbols[i]]['btc_price'], _N((1 - assets[symbols[i]]['btc_change",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tc_price'], _N((1 - assets[symbols[i]]['btc_change']) * 100), assets[symbols[i]]['btc_diff']], 0, 0, 0, '0%')\\n        else:\\n            rateData = _G(\\\"WinRateData\\\")\\n            winRate = _N(rateData[symbols[i]]['profitNumber'] / rateData[symbols[i]]['totalProfit'] * 100, 2) if rateData[symbols[i]]['totalProfit'] > 0 else 0\\n            indexTable['rows'].append([\\n                (i + 1),\\n                symbols[i] + warning,\\n                price,\\n                _N(assets[symbols[i]]['btc_price'],",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               _N(assets[symbols[i]]['btc_price'], 6),\\n                _N((1 - assets[symbols[i]]['btc_change']) * 100),\\n                str(assets[symbols[i]]['btc_diff']) + (success if assets[symbols[i]]['btc_diff'] >= 0 else danger),\\n                rateData[symbols[i]]['tradeNumber'],\\n                rateData[symbols[i]]['sellNumber'],\\n                rateData[symbols[i]]['buyNumber'],\\n                (str(winRate) if rateData[symbols[i]]['profitNumber'] > 0 and rateData[symbols[i]]['totalProfit']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mber'] > 0 and rateData[symbols[i]]['totalProfit'] > 0 else '0') + '%' + (success if winRate >= 50 else danger), #胜率\\n            ])    \\n    retData = {}\\n    retData['upTable'] = RunTime['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version + '\\\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\\\n' + '`' + json.dumps(feeTable) + '`\\\\n'\\n    retData['indexTable'] = indexTable\\n    return retData\\n\\n\\ndef WinRate():\\n    global WinRateData\\n    for i in range(len(symbols)) :\\n        unreal",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    for i in range(len(symbols)) :\\n        unrealised = assets[symbols[i]]['unrealised_profit']\\n        WinRateData[symbols[i]]['totalProfit'] += 1\\n        if unrealised != 0:\\n            if unrealised > 0:\\n                WinRateData[symbols[i]]['profitNumber'] += 1    \\n    _G(\\\"WinRateData\\\", WinRateData)\\n\\ndef tradingCounter(key, newValue):\\n    value = _G(key)\\n    if value is None:\\n        _G(key, newValue)\\n    else:\\n        _G(key, value + newValue)\\n\\ndef updateStatus() : #状态栏信息\\n    global",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "wValue)\\n\\ndef updateStatus() : #状态栏信息\\n    global TotalLong , TotalShort,Funding,update_profit_time,UpProfit\\n    TotalLong = 0\\n    TotalShort = 0\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '强平差价', '持仓价值', '保证金', '未实现盈亏', '投降'],\\n        'rows': []\\n    }\\n    \\n    for i in range(len(symbols)):        \\n        direction = '空仓'\\n        margin = direction\\n        if assets[symbols[i]]['amount'] !",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rection\\n        if assets[symbols[i]]['amount'] != 0:\\n            direction = '做多' + success if assets[symbols[i]]['amount'] > 0 else '做空' + danger\\n            margin = '全仓' if assets[symbols[i]]['marginType'] == 'cross' else '逐仓'\\n        price = _N((assets[symbols[i]]['ask_price'] + assets[symbols[i]]['bid_price']) / 2, trade_info[symbols[i]]['priceSize'])\\n        value = _N((assets[symbols[i]]['ask_value'] + assets[symbols[i]]['bid_value']) / 2, 2)\\n        if value != 0:\\n            if value > 0:\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       if value != 0:\\n            if value > 0:\\n                TotalLong += value\\n            else:\\n                TotalShort += value\\n        # rateData = _G(\\\"WinRateData\\\")\\n        infoList = [\\n            i + 1,\\n            \\\"[\\\" + margin + \\\"] [\\\" + str(assets[symbols[i]]['leverage']) + 'x] ',\\n            symbols[i],\\n            direction,\\n            abs(assets[symbols[i]]['amount']),\\n            assets[symbols[i]]['hold_price'],\\n            price,\\n            assets[symbols[i]]['liqui",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     price,\\n            assets[symbols[i]]['liquidationPrice'], #强平价格\\n            '0' if assets[symbols[i]]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbols[i]]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbols[i]]['liquidationPrice'] / price * 100, 2)) + '%' + warning, #强平价格\\n            abs(value),\\n            _N(assets[symbols[i]]['positionInitialMargin'], 2),\\n            # assets[symbols[i]]['btc_diff'],\\n            str(_N(assets[symbols[i]]['unrealised_profit'], 3)) + (succ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sets[symbols[i]]['unrealised_profit'], 3)) + (success if assets[symbols[i]]['unrealised_profit'] >= 0 else danger),\\n            # (rateData[symbols[i]]['profit']Number > 0 and rateData[symbols[i]].totalProfit > 0 ? _N(rateData[symbols[i]]['profit']Number / rateData[symbols[i]].totalProfit * 100, 2) : '0') + '%', #胜率\\n          \\n                'type': 'button',\\n                'cmd': '说好的没有撤退可言呢？？?:' + symbols[i] + ':' + str(assets[symbols[i]]['amount']) + ':',\\n                'name': symbols[i] + ' 投降'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "+ ':',\\n                'name': symbols[i] + ' 投降'\\n            }\\n        ]\\n        table['rows'].append(infoList)\\n    #del assets['USDT']['update_time'] #时间戳没什么用,不要了\\n    logString = json.dumps(assets['USDT']) + '\\\\n'\\n    StatusData = AppendedStatus()\\n    LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\\\n' + logString)\\n\\n    if int(time.time()*1000) - update_profit_time > Log_profit_interval * 1000:\\n        balance = assets['USDT']['margin_balance']\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "balance = assets['USDT']['margin_balance']\\n        if Show:\\n            balance = assets['USDT']['margin_balance'] - Funding\\n        LogProfit(_N(balance, 3), '&')\\n        update_profit_time = int(time.time()*1000)\\n        if UpProfit != 0 and (_N(balance, 0) != UpProfit): #第一次不计算,并且小数点面的不进行胜率计算\\n            tradingCounter(\\\"totalProfit\\\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\\n            if _N(balance, 0) > UpProfit:\\n                tradingCounter('profitNumber', 1) #盈利次数\\n            WinRate()\\n        UpPr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "er', 1) #盈利次数\\n            WinRate()\\n        UpProfit = _N(balance, 0)\\n\\ndef stopLoss() : #止损函数\\n    while True:\\n        if assets['USDT']['margin_balance'] < Stop_loss * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] > 0:\\n            Log('触发止损，当前资金：', assets['USDT']['margin_balance'], '初始资金：', assets['USDT']['init_balance'])\\n            Ice_value = 200 #止损的快一些，可修改\\n            updateAccount()\\n            updateTick()\\n            trading = False #是否正在交易\\n            for i in range(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ading = False #是否正在交易\\n            for i in range(len(trade_symbols)):\\n                symbol = trade_symbols[i]\\n                if assets[symbol]['ask_price'] == 0:\\n                    continue                \\n                if assets[symbol]['bid_value'] >= trade_info[symbol]['minQty'] * assets[symbol]['bid_price']:\\n                    trade(symbol, 'sell', assets[symbol]['bid_value'])\\n                    trading = True\\n                if assets[symbol]['ask_value'] <= -trade_info[symbol]['minQty'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mbol]['ask_value'] <= -trade_info[symbol]['minQty'] * assets[symbol]['ask_price']:\\n                    trade(symbol, 'buy', -assets[symbol]['ask_value'])\\n                    trading = True\\n            Sleep(1000)\\n            if not trading :\\n                Log('止损结束,如果需要重新运行策略，需要调低止损') \\n                exit()\\n        else : #不用止损\\n            return None\\n\\ndef onTick() : #策略逻辑部分\\n    for i in range(len(trade_symbols)) :\\n        symbol = trade_symbols[i]\\n        if assets[symbol]['ask_price'] == 0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ls[i]\\n        if assets[symbol]['ask_price'] == 0:\\n            continue        \\n        aim_value = -Trade_value * _N(assets[symbol]['btc_diff'] / 0.01, 3)        \\n        if aim_value - assets[symbol]['ask_value'] >= Adjust_value and assets[symbol]['btc_diff'] > Min_diff and assets['USDT']['long_value'] - assets['USDT']['short_value'] <= 1.1 * Trade_value:\\n            Log('做多',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \\n            trade(symbol, 'buy', aim_valu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       \\n            trade(symbol, 'buy', aim_value - assets[symbol]['ask_value'])\\n        if aim_value - assets[symbol]['bid_value'] <= -Adjust_value and assets[symbol]['btc_diff'] < Max_diff and assets['USDT']['short_value'] - assets['USDT']['long_value'] <= 1.1 * Trade_value:\\n            Log('做空',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \\n            trade(symbol, 'sell', -(aim_value - assets[symbol]['bid_value']))\\n\\ndef main():\\n    global RunTime\\n    SetErr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]))\\n\\ndef main():\\n    global RunTime\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    while True:\\n        RunTime = RuningTime()\\n        RunCommand() #捕获交互命令\\n        updateAccount() #更新账户和持仓\\n        updateTick() #行情\\n        stopLoss() #止损\\n        onTick() #策略逻辑部分\\n        updateStatus() #输出状态栏信息\\n        Sleep(Interval * 1000)\",\n    \"策略名称: 币安永续多币种对冲策略做多超跌做空超涨-张总python版\\n\\ninfoList = [\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "策略做多超跌做空超涨-张总python版\\n\\ninfoList = [\\n            i + 1,\\n            \\\"[\\\" + margin + \\\"] [\\\" + str(assets[symbols[i]]['leverage']) + 'x] ',\\n            symbols[i],\\n            direction,\\n            abs(assets[symbols[i]]['amount']),\\n            assets[symbols[i]]['hold_price'],\\n            price,\\n            assets[symbols[i]]['liquidationPrice'], #强平价格\\n            '0' if assets[symbols[i]]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbols[i]]['liquidationPrice'] - price, 5)) + ' ≈ ' + str",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "i]]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbols[i]]['liquidationPrice'] / price * 100, 2)) + '%' + warning, #强平价格\\n            abs(value),\\n            _N(assets[symbols[i]]['positionInitialMargin'], 2),\\n            # assets[symbols[i]]['btc_diff'],\\n            str(_N(assets[symbols[i]]['unrealised_profit'], 3)) + (success if assets[symbols[i]]['unrealised_profit'] >= 0 else danger),\\n            # (rateData[symbols[i]]['profit']Number > 0 and rateData[symbols[i]].totalProfit > 0 ? _N",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " > 0 and rateData[symbols[i]].totalProfit > 0 ? _N(rateData[symbols[i]]['profit']Number / rateData[symbols[i]].totalProfit * 100, 2) : '0') + '%', #胜率\\n          \\n                'type': 'button',\\n                'cmd': '说好的没有撤退可言呢？？?:' + symbols[i] + ':' + str(assets[symbols[i]]['amount']) + ':',\\n                'name': symbols[i] + ' 投降'\\n            }\\n        ]\\n        table['rows'].append(infoList)\\n    #del assets['USDT']['update_time'] #时间戳没什么用,不要了\\n    logString = json.dumps(assets['USDT']) + '\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "了\\n    logString = json.dumps(assets['USDT']) + '\\\\n'\\n    StatusData = AppendedStatus()\\n    LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\\\n' + logString)\\n\\n    if int(time.time()*1000) - update_profit_time > Log_profit_interval * 1000:\\n        balance = assets['USDT']['margin_balance']\\n        if Show:\\n            balance = assets['USDT']['margin_balance'] - Funding\\n        LogProfit(_N(balance, 3), '&')\\n        update_profit_time = int(time.time()*1000)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        update_profit_time = int(time.time()*1000)\\n        if UpProfit != 0 and (_N(balance, 0) != UpProfit): #第一次不计算,并且小数点面的不进行胜率计算\\n            tradingCounter(\\\"totalProfit\\\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\\n            if _N(balance, 0) > UpProfit:\\n                tradingCounter('profitNumber', 1) #盈利次数\\n            WinRate()\\n        UpProfit = _N(balance, 0)\\n\\ndef stopLoss() : #止损函数\\n    while True:\\n        if assets['USDT']['margin_balance'] < Stop_loss * assets['USDT']['init_balance'] and assets['U",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "oss * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] > 0:\\n            Log('触发止损，当前资金：', assets['USDT']['margin_balance'], '初始资金：', assets['USDT']['init_balance'])\\n            Ice_value = 200 #止损的快一些，可修改\\n            updateAccount()\\n            updateTick()\\n            trading = False #是否正在交易\\n            for i in range(len(trade_symbols)):\\n                symbol = trade_symbols[i]\\n                if assets[symbol]['ask_price'] == 0:\\n                    continue                \\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                    continue                \\n                if assets[symbol]['bid_value'] >= trade_info[symbol]['minQty'] * assets[symbol]['bid_price']:\\n                    trade(symbol, 'sell', assets[symbol]['bid_value'])\\n                    trading = True\\n                if assets[symbol]['ask_value'] <= -trade_info[symbol]['minQty'] * assets[symbol]['ask_price']:\\n                    trade(symbol, 'buy', -assets[symbol]['ask_value'])\\n                    trading = True\\n            Sleep(1000)\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        trading = True\\n            Sleep(1000)\\n            if not trading :\\n                Log('止损结束,如果需要重新运行策略，需要调低止损') \\n                exit()\\n        else : #不用止损\\n            return None\\n\\ndef onTick() : #策略逻辑部分\\n    for i in range(len(trade_symbols)) :\\n        symbol = trade_symbols[i]\\n        if assets[symbol]['ask_price'] == 0:\\n            continue        \\n        aim_value = -Trade_value * _N(assets[symbol]['btc_diff'] / 0.01, 3)        \\n        if aim_value - assets[symbol]['ask_value']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        if aim_value - assets[symbol]['ask_value'] >= Adjust_value and assets[symbol]['btc_diff'] > Min_diff and assets['USDT']['long_value'] - assets['USDT']['short_value'] <= 1.1 * Trade_value:\\n            Log('做多',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \\n            trade(symbol, 'buy', aim_value - assets[symbol]['ask_value'])\\n        if aim_value - assets[symbol]['bid_value'] <= -Adjust_value and assets[symbol]['btc_diff'] < Max_diff and assets['USDT']['shor",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l]['btc_diff'] < Max_diff and assets['USDT']['short_value'] - assets['USDT']['long_value'] <= 1.1 * Trade_value:\\n            Log('做空',symbol,'   aim_value:',aim_value,'   偏离平均:',assets[symbol]['btc_diff'])            \\n            trade(symbol, 'sell', -(aim_value - assets[symbol]['bid_value']))\\n\\ndef main():\\n    global RunTime\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    while True:\\n        RunTim",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "reused|Unknown\\\")\\n    while True:\\n        RunTime = RuningTime()\\n        RunCommand() #捕获交互命令\\n        updateAccount() #更新账户和持仓\\n        updateTick() #行情\\n        stopLoss() #止损\\n        onTick() #策略逻辑部分\\n        updateStatus() #输出状态栏信息\\n        Sleep(Interval * 1000)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/201963\\n\\n> Last Modified\\n\\n2020-05-02 23:34:14\"\n \n\n    \"strategy_93\",\n    \"python\\n'''\\n策略名称: BollingBreaker趋势策略\\n策略作者: ipqhjjybj\\n策略描述:  \\n           这是将 botvs的接口用 Vnpy 的写法 方式简单封装掉，便于后期的",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n           这是将 botvs的接口用 Vnpy 的写法 方式简单封装掉，便于后期的调用！\\n           这本来是期货的 策略， 直接改参数套在 比特币上。\\n           期货上要切换到分钟级别， 比特币期货则用小时级别的\\n           实盘时需要调整参数。\\n           如有策略改进，请多多与本人交流   250657661\\n\\n           bar.minute.hour  代表是小时级别 \\n           bar.minute.minute  代表是分钟级别\\n\\n           \\n------------------------------------------------------------------\\n\\n          当前只支持 比特币OKCOIN 期货， 如果要弄到 CTP期货，需要微调\\n\\n趋势跟踪策略\\n'''\\nimport time\\nfrom datetime import datetime\\nimport numpy as np\\nimport talib\\n\\nEMPTY_STRIN",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\nimport numpy as np\\nimport talib\\n\\nEMPTY_STRING = \\\"\\\"\\nEMPTY_INT = 0\\nEMPTY_FLOAT = 0.0\\nEMPTY_UNICODE = u''\\n\\nDIRECTION_LONG = u'long'\\nDIRECTION_SHORT = u'short'\\n\\nOFFSET_OPEN = u'kaicang'\\nOFFSET_CLOSE = u'pingcang'\\n\\n# CTA引擎中涉及到的交易方向类型\\nCTAORDER_BUY = \\\"buy\\\"\\nCTAORDER_SELL = \\\"closebuy\\\"\\nCTAORDER_SHORT = \\\"sell\\\"\\nCTAORDER_COVER = \\\"closesell\\\"\\n\\n\\n# 本地停止单状态\\nSTOPORDER_WAITING = u'waiting'\\nSTOPORDER_CANCELLED = u'canceled'\\nSTOPORDER_TRIGGERED = u'touched'\\n\\n# 本地停止单前缀\\nSTOPORDERPREFIX = 'Ct",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "D = u'touched'\\n\\n# 本地停止单前缀\\nSTOPORDERPREFIX = 'CtaStopOrder'\\n\\n\\n\\n########################################################################\\nclass VtBarData:\\n    \\\"\\\"\\\"K线数据\\\"\\\"\\\"\\n\\n    #----------------------------------------------------------------------\\n    def __init__(self):\\n        \\\"\\\"\\\"Constructor\\\"\\\"\\\"\\n        \\n        self.vtSymbol = EMPTY_STRING        # vt系统代码\\n        self.symbol = EMPTY_STRING          # 代码\\n        self.exchange = EMPTY_STRING        # 交易所\\n    \\n        self.open = E",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Y_STRING        # 交易所\\n    \\n        self.open = EMPTY_FLOAT             # OHLC\\n        self.high = EMPTY_FLOAT\\n        self.low = EMPTY_FLOAT\\n        self.close = EMPTY_FLOAT\\n        \\n        self.date = EMPTY_STRING            # bar开始的时间，日期\\n        self.time = EMPTY_STRING            # 时间\\n        self.datetime = None                # python的datetime时间对象\\n        \\n        self.volume = EMPTY_INT             # 成交量\\n        self.openInterest = EMPTY_INT       # 持仓量    \\n\\n############################",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "NT       # 持仓量    \\n\\n########################################################################\\nclass VtTickData:\\n    \\\"\\\"\\\"Tick行情数据类\\\"\\\"\\\"\\n\\n    #----------------------------------------------------------------------\\n    def __init__(self):\\n        \\\"\\\"\\\"Constructor\\\"\\\"\\\"\\n        \\n        # 代码相关\\n        self.exchange = EMPTY_STRING            # 交易所代码\\n        self.vtSymbol = EMPTY_STRING            # 合约在vt系统中的唯一代码，通常是 合约代码.交易所代码\\n        \\n        # 成交数据\\n        self.lastPrice = EMPTY_FLOAT        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "成交数据\\n        self.lastPrice = EMPTY_FLOAT            # 最新成交价\\n        self.lastVolume = EMPTY_INT             # 最新成交量\\n        self.volume = EMPTY_INT                 # 今天总成交量\\n        self.openInterest = EMPTY_INT           # 持仓量\\n        self.time = EMPTY_STRING                # 时间 11:20:56.5\\n        self.date = EMPTY_STRING                # 日期 20151009\\n        self.datetime = None                    # python的datetime时间对象\\n        \\n        # 常规行情\\n        self.openPrice = EMPTY_FLOAT            # 今日开盘",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    self.openPrice = EMPTY_FLOAT            # 今日开盘价\\n        self.highPrice = EMPTY_FLOAT            # 今日最高价\\n        self.lowPrice = EMPTY_FLOAT             # 今日最低价\\n        self.preClosePrice = EMPTY_FLOAT\\n        \\n        self.upperLimit = EMPTY_FLOAT           # 涨停价\\n        self.lowerLimit = EMPTY_FLOAT           # 跌停价\\n        \\n        # 五档行情\\n        self.bidPrice1 = EMPTY_FLOAT\\n        self.bidPrice2 = EMPTY_FLOAT\\n        self.bidPrice3 = EMPTY_FLOAT\\n        self.bidPrice4 = EMPTY_FLOAT\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "FLOAT\\n        self.bidPrice4 = EMPTY_FLOAT\\n        self.bidPrice5 = EMPTY_FLOAT\\n        \\n        self.askPrice1 = EMPTY_FLOAT\\n        self.askPrice2 = EMPTY_FLOAT\\n        self.askPrice3 = EMPTY_FLOAT\\n        self.askPrice4 = EMPTY_FLOAT\\n        self.askPrice5 = EMPTY_FLOAT        \\n        \\n        self.bidVolume1 = EMPTY_INT\\n        self.bidVolume2 = EMPTY_INT\\n        self.bidVolume3 = EMPTY_INT\\n        self.bidVolume4 = EMPTY_INT\\n        self.bidVolume5 = EMPTY_INT\\n        \\n        self.ask",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bidVolume5 = EMPTY_INT\\n        \\n        self.askVolume1 = EMPTY_INT\\n        self.askVolume2 = EMPTY_INT\\n        self.askVolume3 = EMPTY_INT\\n        self.askVolume4 = EMPTY_INT\\n        self.askVolume5 = EMPTY_INT         \\n\\n\\n########################################################################\\nclass StopOrder(object):\\n    \\\"\\\"\\\"本地停止单\\\"\\\"\\\"\\n\\n    #----------------------------------------------------------------------\\n    def __init__(self):\\n        \\\"\\\"\\\"Constructor\\\"\\\"\\\"\\n        self.vtSymbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     \\\"\\\"\\\"Constructor\\\"\\\"\\\"\\n        self.vtSymbol = EMPTY_STRING\\n        self.orderType = EMPTY_UNICODE\\n        self.direction = EMPTY_UNICODE\\n        self.offset = EMPTY_UNICODE\\n        self.price = EMPTY_FLOAT\\n        self.volume = EMPTY_INT\\n        \\n        self.strategy = None             # 下停止单的策略对象\\n        self.stopOrderID = EMPTY_STRING  # 停止单的本地编号 \\n        self.status = EMPTY_STRING       # 停止单状态\\n\\n\\nclass BollingerBreakerStrategy:\\n    #品种属性\\n    vtSymbol = EMPTY_STRING # 是什么品种\\n\\n    #",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "品种属性\\n    vtSymbol = EMPTY_STRING # 是什么品种\\n\\n    # 策略参数\\n    minute_use = 6              # 多少分钟级别的K线\\n\\n    bar = None                  # 1分钟K线对象\\n    fiveBar = None              # 1分钟K线对象\\n\\n    # 策略参数\\n    bollLength = 20         # 通道窗口数\\n    topDev = 1.3            # 开仓偏差\\n    trailingPrcnt = 2       # 移动止损百分比\\n    use_range = 10          # use_range天内有突破最高价\\n    N = 10                  # 多少天突破\\n\\n    bufferSize = 40                     # 需要缓存的数据的大小\\n    bufferCount = 0                     # 目前已经缓存了的数据的计",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bufferCount = 0                     # 目前已经缓存了的数据的计数\\n\\n\\n    realBuyCond = 0                     # 买卖的状态\\n    realSellCond = 0                    # 买卖的状态\\n    \\n    bollMid = 0                         # 布林带中轨\\n    bollStd = 0                         # 布林带宽度\\n    entryUp = 0                         # 开仓上轨\\n\\n    barMinute = EMPTY_STRING            # K线当前的分钟\\n\\n    fixedSize = 1\\n\\n    stopOrderCount = 0                  # 记录停止单的数量\\n\\n    pos = 0                             # 仓位\\n\\n    LastBarTime = None     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               # 仓位\\n\\n    LastBarTime = None                  # python 上一根Tick\\n\\n    currency = EMPTY_STRING\\n\\n    def __init__(self, _exchange , setting ):\\n        self.exchange = _exchange\\n        for key in setting.keys():\\n            if key == \\\"vtSymbol\\\":\\n                self.vtSymbol = setting[key]\\n            if key == \\\"currency\\\":\\n                self.currency = setting[key]\\n            if key == 'minute_use':\\n                self.minute_use = setting[key]\\n            if key == \\\"bollL",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_use = setting[key]\\n            if key == \\\"bollLength\\\":\\n                self.bollLength = setting[key]\\n            if key == \\\"topDev\\\":\\n                self.topDev = setting[key]\\n            if key == \\\"trailingPrcnt\\\":\\n                self.trailingPrcnt = setting[key]\\n            if key == \\\"use_range\\\":\\n                self.use_range = setting[key]\\n            if key == \\\"N\\\":\\n                self.N = setting[key]\\n        Log(setting)\\n\\n        self.pos = 0\\n        self.order_PreUse = {}  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    self.pos = 0\\n        self.order_PreUse = {}            # vtPreID , pushDealAmount  已经推送过的成交数据\\n        self.workingStopOrderDict = {}\\n        self.stopOrderDict = {}\\n        self.orderList = []               # 保存委托代码的列表\\n        self.fixedSize = 1\\n        ##################\\n        self.bufferSize = 40\\n        #################\\n        self.highArray = np.zeros(self.bufferSize) \\n        self.lowArray = np.zeros(self.bufferSize)\\n        self.closeArray = np.zeros(self.bufferSize)\\n        \\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eArray = np.zeros(self.bufferSize)\\n        \\n        self.buyValue = np.zeros(self.bufferSize)\\n\\n\\n    def onCall(self):\\n        try:\\n            #self.exchange.IO(\\\"currency\\\" , self.currency)\\n            need_remove = []\\n            for orderId in self.orderList:\\n                # 订单状态, 参考常量里的订单状态，以下是此键值的常量。\\n                # ORDER_STATE_PENDING  :未完成\\n                # ORDER_STATE_CLOSED   :已关闭   已完成\\n                # ORDER_STATE_CANCELED :已取消\\n                # STOPORDERPREFIX 是否是 系统内部的 停止单\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               # STOPORDERPREFIX 是否是 系统内部的 停止单\\n                if orderId != None and type(orderId) != type(1) and STOPORDERPREFIX in orderId:\\n                    continue\\n                botvsOrder = self.exchange.GetOrder(orderId)\\n                preAmount = 0.0\\n                if botvsOrder != None:\\n                    if botvsOrder[\\\"Status\\\"] in [ORDER_STATE_CLOSED,ORDER_STATE_CANCELED]:\\n                        try:\\n                            preAmount = self.order_PreUse[orderId]\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "reAmount = self.order_PreUse[orderId]\\n                        except Exception,ex:\\n                            Log(\\\"Error in preAmount\\\",ex)\\n                            preAmount = 0.0\\n                        Log(\\\"preAmount:\\\" , preAmount)\\n                        incAmount = botvsOrder[\\\"DealAmount\\\"] - preAmount\\n                        if incAmount > 0:\\n                            self.order_PreUse[orderId] = botvsOrder[\\\"DealAmount\\\"]\\n                            botvsOrder[\\\"preAmount\\\"] = preAm",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                 botvsOrder[\\\"preAmount\\\"] = preAmount\\n                            botvsOrder[\\\"incAmount\\\"] = incAmount\\n                            self.onTrade( botvsOrder )\\n\\n\\n                    if botvsOrder[\\\"Status\\\"] == ORDER_STATE_CLOSED:\\n                        need_remove.append(orderId)\\n                else:\\n                    Log(\\\"None order!\\\")\\n\\n            for orderId in need_remove:\\n                Log(\\\"remove order:\\\" , orderId)\\n                self.orderList.remove(orderId)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                self.orderList.remove(orderId)\\n\\n            \\n            # Log(\\\"currency\\\",self.currency)\\n            botvsTick = self.exchange.GetTicker()\\n\\n\\n            if self.LastBarTime != botvsTick[\\\"Time\\\"]:\\n                newTick = VtTickData()\\n                newTick.datetime = datetime.fromtimestamp(botvsTick[\\\"Time\\\"] / 1000.0)\\n                newTick.vtSymbol = self.vtSymbol\\n                newTick.lastPrice = float(botvsTick[\\\"Last\\\"])\\n                newTick.lastVolume = float(b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"])\\n                newTick.lastVolume = float(botvsTick[\\\"Volume\\\"])\\n                newTick.volume = float(botvsTick[\\\"Volume\\\"])\\n                newTick.highPrice = float(botvsTick[\\\"High\\\"])\\n                newTick.lowPrice = float(botvsTick[\\\"Low\\\"])\\n\\n                newTick.upperLimit = newTick.highPrice * 1.03\\n                newTick.lowerLimit = newTick.lowPrice * 0.97\\n\\n                newTick.exchange = self.exchange.GetName()\\n\\n                newTick.date = newTick.datetime.strftime(\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       newTick.date = newTick.datetime.strftime(\\\"%Y%m%d\\\")\\n                newTick.time = newTick.datetime.strftime(\\\"%Y:%m:%d\\\")\\n\\n                self.onTick(newTick)\\n\\n                self.processStopOrder(newTick)\\n        except Exception,ex:\\n            Log(ex , \\\"error in onCall , maybe getTicker wrong!\\\")\\n\\n    #----------------------------------------------------------------------\\n    def onTrade(self, trade):\\n        # 发出状态更新事件\\n        #'Type': 0           # 订单类型, 参考常量里的订单类型，以下是此键值的常量。\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ype': 0           # 订单类型, 参考常量里的订单类型，以下是此键值的常量。\\n                             # ORDER_TYPE_BUY   :买单\\n                             # ORDER_TYPE_SELL  :卖单\\n        try:\\n            Log(\\\"trade:\\\",trade)\\n            newPos = 0.0\\n            if trade[\\\"Type\\\"] == ORDER_TYPE_BUY:\\n                newPos += trade[\\\"incAmount\\\"]\\n            elif trade[\\\"Type\\\"] == ORDER_TYPE_SELL:\\n                newPos -= trade[\\\"incAmount\\\"]\\n            else:\\n                Log(\\\"What ? trade Type error!\\\")\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    Log(\\\"What ? trade Type error!\\\")\\n            self.pos += newPos\\n        except Exception,ex:\\n            print ex\\n    #----------------------------------------------------------------------\\n    def processStopOrder(self, tick):\\n        \\\"\\\"\\\"收到行情后处理本地停止单（检查是否要立即发出）\\\"\\\"\\\"\\n        vtSymbol = tick.vtSymbol\\n        \\n        # 遍历等待中的停止单，检查是否会被触发\\n        for so in self.workingStopOrderDict.values():\\n            if so.vtSymbol == vtSymbol:\\n                longTriggered = so.direction==DIRECTION_LO",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        longTriggered = so.direction==DIRECTION_LONG and tick.lastPrice>=so.price        # 多头停止单被触发\\n                shortTriggered = so.direction==DIRECTION_SHORT and tick.lastPrice<=so.price     # 空头停止单被触发\\n                \\n                if longTriggered or shortTriggered:\\n                    # 买入和卖出分别以涨停跌停价发单（模拟市价单）\\n                    if so.direction==DIRECTION_LONG:\\n                        price = tick.upperLimit\\n                    else:\\n                        price = tick.lowerLimit\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                  price = tick.lowerLimit\\n                    \\n                    so.status = STOPORDER_TRIGGERED\\n                    orderIDList = self.sendOrder(so.vtSymbol, so.orderType, price, so.volume, False ,so.strategy)\\n                    for orderID in orderIDList:\\n                        self.orderList.append(orderID)\\n                    del self.workingStopOrderDict[so.stopOrderID]\\n                    so.strategy.onStopOrder(so)\\n\\n    def onStopOrder(self, vtStopOrder):\\n        Log(\\\"s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f onStopOrder(self, vtStopOrder):\\n        Log(\\\"stopOrder Deal ID:\\\", vtStopOrder.stopOrderID , vtStopOrder.status )\\n\\n    def sendStopOrder(self, vtSymbol, orderType, price, volume, strategy ):\\n        \\\"\\\"\\\"发停止单（本地实现）\\\"\\\"\\\"\\n        self.stopOrderCount += 1\\n        stopOrderID = STOPORDERPREFIX + str(self.vtSymbol) + str(self.stopOrderCount)\\n\\n        so = StopOrder()\\n        so.vtSymbol = vtSymbol\\n        so.orderType = orderType\\n        so.price = price\\n        so.volume = volume\\n        so.st",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= price\\n        so.volume = volume\\n        so.strategy = strategy\\n        so.stopOrderID = stopOrderID\\n        so.status = STOPORDER_WAITING\\n\\n        if orderType == CTAORDER_BUY:\\n            so.direction = DIRECTION_LONG\\n            so.offset = OFFSET_OPEN\\n        elif orderType == CTAORDER_SELL:\\n            so.direction = DIRECTION_SHORT\\n            so.offset = OFFSET_CLOSE\\n        elif orderType == CTAORDER_SHORT:\\n            so.direction = DIRECTION_SHORT\\n            so.offset = OFFSET_OPE",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "IRECTION_SHORT\\n            so.offset = OFFSET_OPEN\\n        elif orderType == CTAORDER_COVER:\\n            so.direction = DIRECTION_LONG\\n            so.offset = OFFSET_CLOSE      \\n\\n        # 保存stopOrder对象到字典中\\n        self.stopOrderDict[stopOrderID] = so\\n        self.workingStopOrderDict[stopOrderID] = so\\n        \\n        # 推送停止单状态\\n        strategy.onStopOrder(so)\\n        return stopOrderID\\n\\n    def sendOrder(self , vtSymbol , orderType , price, volume , stop , strategy ):\\n        #   id1 = exch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "olume , stop , strategy ):\\n        #   id1 = exchange.Buy(4300,1)     # 日期                  平台    类型  价格     数量   信息\\n        #                                  # 2016-10-21 00:00:00  OKCoin  买入  4300     1\\n        #   id2 = exchange.Buy(-1, 8000)   # 市价单 的第二个参数的意义是  购买8000金额的 币数。\\n        #   id1 = exchange.Sell(4300,1)    #     日期                     平台        类型      价格      数量     信息\\n        #                                  #     2016-10-21 00:00:00     OKCoin      卖出      市价单     1    \\n        # ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     OKCoin      卖出      市价单     1    \\n        # id2 = exchange.Sell(-1, 1)       #     日期                     平台        类型      价格      数量     信息\\n                                           #     2016-10-21 00:00:00     OKCoin      卖出      4300      1\\n                                           # 一般错误提示： 小于允许的最小交易单位，大部分是这个原因（参数1是1块钱而不是1个币）。\\n        if stop == True:\\n            vtOrderID = self.sendStopOrder(self.vtSymbol, orderType, price, volume, self)\\n            return vtOrderID\\n        else:\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            return vtOrderID\\n        else:\\n            ret_order_list = []\\n            self.exchange.SetDirection( orderType )\\n            if orderType in [ CTAORDER_BUY , CTAORDER_COVER]:\\n                ret_order_list.append( self.exchange.Buy( price , volume ))\\n            elif orderType in [CTAORDER_SELL , CTAORDER_SHORT]:\\n                ret_order_list.append( self.exchange.Sell( price , volume ))\\n            return ret_order_list\\n\\n    def buy(self , price , volume , stop = False):\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y(self , price , volume , stop = False):\\n        Log(CTAORDER_BUY,price,volume)\\n        return self.sendOrder( self.vtSymbol , CTAORDER_BUY , price , volume , stop , self)\\n    def sell(self , price , volume , stop = False):\\n        Log(CTAORDER_SELL,price,volume)\\n        return self.sendOrder( self.vtSymbol , CTAORDER_SELL , price , volume , stop , self)\\n    def short(self , price , volume , stop = False):\\n        Log(CTAORDER_SELL,price,volume)\\n        return self.sendOrder( self.vtSymbol , CTAORDE",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    return self.sendOrder( self.vtSymbol , CTAORDER_SHORT , price , volume , stop , self)\\n    def cover(self , price , volume , stop = False):\\n        Log(\\\"cover\\\",price,volume)\\n        return self.sendOrder( self.vtSymbol , CTAORDER_COVER , price , volume , stop , self)\\n\\n    #----------------------------------------------------------------------\\n    def cancelStopOrder(self, stopOrderID):\\n        \\\"\\\"\\\"撤销停止单\\\"\\\"\\\"\\n        # 检查停止单是否存在\\n        if stopOrderID in self.workingStopOrderDict:\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "opOrderID in self.workingStopOrderDict:\\n            so = self.workingStopOrderDict[stopOrderID]\\n            so.status = STOPORDER_CANCELLED\\n            del self.workingStopOrderDict[stopOrderID]\\n            so.strategy.onStopOrder(so)\\n\\n        if stopOrderID in self.orderList:\\n            self.orderList.remove(stopOrderID)\\n\\n    def cancelOrder(self , vtOrderId):\\n        Log(\\\"cancelOrder:\\\",vtOrderId)\\n        if STOPORDERPREFIX in vtOrderId:\\n            self.cancelStopOrder(vtOrderId)\\n        e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        self.cancelStopOrder(vtOrderId)\\n        else:\\n            self.exchange.CancelOrder(vtOrderId)\\n\\n    def onTick(self, tick):\\n\\n        # self.orderList = []\\n        # orderIDList = self.buy(tick.lastPrice , abs(self.fixedSize))\\n        # #Log( str(self.vtSymbol) + \\\" cover 0 1 \\\" + str(self.fixedSize) +\\\" \\\" +str(','.join(orderIDList))  + \\\"\\\\n\\\")\\n        # #print str(self.vtSymbol) , \\\"cover 0 1\\\" , self.fixedSize , orderID\\n        # for orderID in orderIDList:\\n        #     self.orderList",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "erID in orderIDList:\\n        #     self.orderList.append(orderID)\\n\\n        # 聚合为1分钟K线\\n        tickMinute = tick.datetime.hour\\n\\n        if tickMinute != self.barMinute:  \\n            if self.bar:\\n                self.onBar(self.bar)\\n\\n            bar = VtBarData()              \\n            bar.vtSymbol = tick.vtSymbol\\n            bar.exchange = tick.exchange\\n\\n            bar.open = tick.lastPrice\\n            bar.high = tick.lastPrice\\n            bar.low = tick.lastPrice\\n            bar.close ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  bar.low = tick.lastPrice\\n            bar.close = tick.lastPrice\\n\\n            bar.date = tick.date\\n            bar.time = tick.time\\n            bar.datetime = tick.datetime    # K线的时间设为第一个Tick的时间\\n\\n            self.bar = bar                  # 这种写法为了减少一层访问，加快速度\\n            self.barMinute = tickMinute     # 更新当前的分钟\\n        else:                               # 否则继续累加新的K线\\n            bar = self.bar                  # 写法同样为了加快速度\\n\\n            bar.high = max(bar.high, tick.lastPrice)\\n            bar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "h = max(bar.high, tick.lastPrice)\\n            bar.low = min(bar.low, tick.lastPrice)\\n            bar.close = tick.lastPrice\\n\\n    def onBar(self , bar):\\n        \\n        if bar.datetime.hour  % self.minute_use == 0:         # bar.datetime.minute 则切换成分钟级别\\n            # 如果已经有聚合5分钟K线\\n            if self.fiveBar:\\n                # 将最新分钟的数据更新到目前5分钟线中\\n                fiveBar = self.fiveBar\\n                fiveBar.high = max(fiveBar.high, bar.high)\\n                fiveBar.low = min(fiveBar.low, bar.low)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           fiveBar.low = min(fiveBar.low, bar.low)\\n                fiveBar.close = bar.close\\n                \\n                # 推送5分钟线数据\\n                self.onFiveBar(fiveBar)\\n                \\n                # 清空5分钟线数据缓存\\n                self.fiveBar = None\\n        else:\\n            # 如果没有缓存则新建\\n            if not self.fiveBar:\\n                fiveBar = VtBarData()\\n                \\n                fiveBar.vtSymbol = bar.vtSymbol\\n                fiveBar.symbol = bar.symbol\\n                five",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " fiveBar.symbol = bar.symbol\\n                fiveBar.exchange = bar.exchange\\n            \\n                fiveBar.open = bar.open\\n                fiveBar.high = bar.high\\n                fiveBar.low = bar.low\\n                fiveBar.close = bar.close\\n            \\n                fiveBar.date = bar.date\\n                fiveBar.time = bar.time\\n                fiveBar.datetime = bar.datetime \\n                \\n                self.fiveBar = fiveBar\\n            else:\\n                fiveBar = self.f",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           else:\\n                fiveBar = self.fiveBar\\n                fiveBar.high = max(fiveBar.high, bar.high)\\n                fiveBar.low = min(fiveBar.low, bar.low)\\n                fiveBar.close = bar.close\\n\\n\\n    def onFiveBar(self , bar):\\n        #Log( self.currency , bar.close , self.pos , self.orderList)\\n\\n        for orderID in self.orderList:\\n            self.cancelOrder(orderID)\\n        self.orderList = []\\n    \\n        # 保存K线数据\\n        self.closeArray[0:self.bufferSize-1] = self.cl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    self.closeArray[0:self.bufferSize-1] = self.closeArray[1:self.bufferSize]\\n        self.highArray[0:self.bufferSize-1] = self.highArray[1:self.bufferSize]\\n        self.lowArray[0:self.bufferSize-1] = self.lowArray[1:self.bufferSize]\\n        self.buyValue[0:self.bufferSize-1] = self.buyValue[1:self.bufferSize]\\n\\n        self.closeArray[-1] = bar.close\\n        self.highArray[-1] = bar.high\\n        self.lowArray[-1] = bar.low\\n    \\n        # 计算指标数值\\n        self.bollMid = talib.MA(self.closeArray, se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       self.bollMid = talib.MA(self.closeArray, self.bollLength)[-1]\\n        self.bollStd = talib.STDDEV(self.closeArray, self.bollLength)[-1]\\n        self.entryUp = self.bollMid + self.bollStd * self.topDev\\n\\n        self.buyValue[-1] = self.entryUp\\n\\n        self.bufferCount += 1\\n        if self.bufferCount < self.bufferSize:\\n            return\\n\\n        # 判断是否要进行交易\\n        cond1 = 0\\n        for i in range(1 , self.use_range + 1):\\n            if self.highArray[-i] > self.buyValue[-i]:\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "self.highArray[-i] > self.buyValue[-i]:\\n                cond1 = 1\\n        cond2 = 0\\n\\n        # newHigh = [float(x) for x in self.highArray]\\n        # if bar.high >= max(newHigh[-self.N : ]) and self.highArray[-2] >= max(newHigh[-self.N-1 : -1]):\\n        #     cond2 = 1\\n        if self.pos == 0 and cond1 > 0:\\n            self.intraTradeHigh = bar.high\\n            newHigh = [float(x) for x in self.highArray]\\n            entryBuyPrice = max(newHigh[-self.N:])\\n            orderID = self.buy( entryBuy",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "elf.N:])\\n            orderID = self.buy( entryBuyPrice, self.fixedSize , stop=True)\\n            self.orderList.append(orderID)\\n\\n        elif self.pos > 0:\\n            self.intraTradeHigh = max(bar.high , self.intraTradeHigh)\\n            exitPrice = self.intraTradeHigh * (1 - self.trailingPrcnt / 100.0) \\n            orderID = self.sell( exitPrice , self.fixedSize , stop=True)\\n            self.orderList.append(orderID)\\n\\n'''\\nbollLength = 20         # 通道窗口数\\ntopDev = 1.3            # 开仓偏差\\ntrailingPr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 通道窗口数\\ntopDev = 1.3            # 开仓偏差\\ntrailingPrcnt = 2       # 移动止损百分比\\nuse_range = 10          # use_range天内有突破最高价\\nN = 10                  # 多少天突破\\n'''\\nrunning_key = {\\n    \\\"BTC\\\":{ \\\"bollLength\\\":20 , \\\"topDev\\\":1.3 , \\\"trailingPrcnt\\\": 2 , \\\"use_range\\\": 10 , \\\"N\\\":10 , \\\"minute_use\\\": 6},\\n    \\\"LTC\\\":{ \\\"bollLength\\\":20 , \\\"topDev\\\":1.3 , \\\"trailingPrcnt\\\": 2 , \\\"use_range\\\": 10 , \\\"N\\\":10 , \\\"minute_use\\\": 6}\\n}\\n\\ndef main():\\n    global LoopInterval \\n\\n    objs = []\\n    for e in exchanges:\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "erval \\n\\n    objs = []\\n    for e in exchanges:\\n        if e.GetName() != 'Futures_OKCoin':\\n            raise Error_noSupport\\n        e.SetRate(1)\\n        use_symbol = [\\\"this_week\\\",\\\"next_week\\\",\\\"quarter\\\"][ContractTypeIdx]\\n        e.SetContractType(use_symbol) \\n        e.SetMarginLevel([10,20][MarginLevelIdx])\\n\\n        e_currency = e.GetCurrency().upper()\\n        Log(e_currency)\\n        st = BollingerBreakerStrategy(e , {\\n        \\\"vtSymbol\\\":e.GetName() + \\\"_\\\" + use_symbol + \\\"_\\\" + e.GetC",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":e.GetName() + \\\"_\\\" + use_symbol + \\\"_\\\" + e.GetCurrency(), \\n        \\\"currency\\\":e_currency,\\n        \\\"minute_use\\\":running_key[e_currency][\\\"minute_use\\\"],\\n        \\\"bollLength\\\":running_key[e_currency][\\\"bollLength\\\"],\\n        \\\"topDev\\\": running_key[e_currency][\\\"topDev\\\"],\\n        \\\"trailingPrcnt\\\": running_key[e_currency][\\\"trailingPrcnt\\\"],\\n        \\\"use_range\\\": running_key[e_currency][\\\"use_range\\\"],\\n        \\\"N\\\": running_key[e_currency][\\\"N\\\"]\\n        })\\n\\n        objs.append(st)\\n\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "N\\\"]\\n        })\\n\\n        objs.append(st)\\n\\n    while True:\\n        for st in objs:\\n            st.onCall()\\n        Sleep(LoopInterval * 1000)\",\n    \"策略名称: 布林均线突破_vnpy_botvs实现版\\n\\nCTAORDER_BUY = \\\"buy\\\"\\nCTAORDER_SELL = \\\"closebuy\\\"\\nCTAORDER_SHORT = \\\"sell\\\"\\nCTAORDER_COVER = \\\"closesell\\\"\"\n \n\n    \"strategy_94\",\n    \"python\\nfrom collections import Counter\\ndef GetAmountPrecision():\\n    depth = _C(exchange.GetDepth)    \\n    amountPrecisions = []\\n    for ask in depth[\\\"Asks\\\"]:\\n        i = ask[\\\"A",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  for ask in depth[\\\"Asks\\\"]:\\n        i = ask[\\\"Amount\\\"]\\n        amountPrecision = 0\\n        if str(i).count('.') == 1:\\n            amountPrecision = len(str(i).split(\\\".\\\")[1])\\n        amountPrecisions.append(amountPrecision)\\n    amountPrecision = max(amountPrecisions)    \\n    return amountPrecision\\n\\ndef GetPricePrecision():\\n    depth = _C(exchange.GetDepth)    \\n    pricePrecisions = []\\n    for ask in depth[\\\"Asks\\\"]:\\n        j = ask[\\\"Price\\\"]\\n        pricePrecision = 0\\n        if str(j).c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]\\n        pricePrecision = 0\\n        if str(j).count('.') == 1:\\n            pricePrecision = len(str(j).split(\\\".\\\")[1])\\n        pricePrecisions.append(pricePrecision)\\n    pricePrecision = Counter(pricePrecisions).most_common(1)[0][0]\\n    return pricePrecision\",\n    \"策略名称: 干货-下单量精度和价格精度-适用各个交易所\\n\\n未找到描述\"\n \n\n    \"strategy_95\",\n    \"python\\nimport numpy as np\\nfrom scipy.stats import norm\\nfrom sklearn import preprocessing\\nimport json\\n\\n#计算波动率因子值\\ndef GetAtrFactorService(records):\\n    atrlength = 14\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "GetAtrFactorService(records):\\n    atrlength = 14\\n    atrs = TA.ATR(records, atrlength)\\n    acs = sorted(range(len(atrs)), key=lambda k: atrs[k])\\n    ac = acs[-1]\\n    arr_mean = np.mean(acs)\\n    arr_std = np.std(acs,ddof=1)\\n    p = norm.cdf(x=ac, loc=arr_mean, scale = arr_std)\\n    #P值越大，波动性越大\\n    atrFactor = _N(p,3)\\n    return atrFactor \\n\\n#计算机构的行为痕迹因子值        \\ndef GetITFactorService(records):\\n    #本福特定律分布频数\\n    PN = [301, 176, 125, 97, 79, 67, 58, 51, 46]\\n    FN = [0, 0, 0, 0, 0, 0, 0, 0, 0]\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "58, 51, 46]\\n    FN = [0, 0, 0, 0, 0, 0, 0, 0, 0]\\n    for i in range(len(records)):\\n        valume = records[i]['Volume']*10000\\n        strValume = str(valume)\\n        num = strValume[0]\\n        for j in range(len(FN)):\\n            key = j + 1\\n            if int(num) == key:\\n                FN[j] += 1\\n    if sum(FN) == 0:\\n        FN = PN\\n    X = 0\\n    for i in range(len(PN)):\\n        X += (FN[i] - PN[i])**2\\n    ITFactor = X\\n    #X 的数值越大，则成交量数据与本福特理想分布的偏离越大，机构的行为痕迹也越大\\n    return ITFactor\\n\\n#",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "与本福特理想分布的偏离越大，机构的行为痕迹也越大\\n    return ITFactor\\n\\n#计算价格因子值\\ndef GetPriceFactorService(records):\\n    record = records[-1]\\n    price = record[\\\"Close\\\"]\\n    PFactor = 1/price \\n    #PFactor数值越大，则价格越小 \\n    return PFactor \\n\\n#标准化处理   --计算出来的因子值因为数量级不同，要进行标准化处理。暂不处理空值、异常值\\ndef StandardizedService(factor):\\n    # 标准化处理\\n    factorArray = np.asarray(factor)\\n    factorArray = preprocessing.scale(factorArray)\\n    factor = factorArray.tolist()\\n\\next.GetAtrFactorService = GetArtFactorService \\next.GetITFactorSe",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rService = GetArtFactorService \\next.GetITFactorService = GetITFactorService \\next.GetPriceFactorService = GetPriceFactorService \\next.StandardizedService = StandardizedService\",\n    \"策略名称: 干货-选币系统-选币因子\\n\\nfactorArray = np.asarray(factor)\\n    factorArray = preprocessing.scale(factorArray)\\n    factor = factorArray.tolist()\\n\\next.GetAtrFactorService = GetArtFactorService \\next.GetITFactorService = GetITFactorService \\next.GetPriceFactorService = GetPriceFactorService \\next.StandardizedService = Standardize",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "torService \\next.StandardizedService = StandardizedService\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/344801\\n\\n> Last Modified\\n\\n2022-02-12 11:17:18\"\n \n\n    \"strategy_96\",\n    \"python\\nimport json\\nimport traceback\\n#SYMBOLS = ['1INCH_USDT','ADA_USDT','ALGO_USDT','ATOM_USDT','AVAX_USDT','AAVE_USDT','AXS_USDT',\\n#           'BAND_USDT','BCH_USDT','BTC_USDT','COMP_USDT','CHZ_USDT','CRV_USDT','CVC_USDT','DOGE_USDT'\\n#           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\\n#           'ETC_USDT','FIL_USDT','FTM_USDT','GALA_USDT','GRT_USDT','IOTA_USDT','ICP_USDT','KSM_USDT',\\n#           'LINK_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_USDT','NEAR_USDT','OMG_USDT','SAND_USDT',\\n #          'SC_USDT','1000SHIB_USDT','SOL_USDT','SRM_USDT','STORJ_USDT','SUSHI_USDT','THETA_USDT','TRX_USDT',\\n  #         'UNI_USDT','XRP_USDT','XLM_USDT','XMR_USDT','XTZ_USDT','YFI_USDT','ZEC_USDT','PEOPLE_USDT',\\n  #         'A",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "FI_USDT','ZEC_USDT','PEOPLE_USDT',\\n  #         'APE_USDT','GMT_USDT','ZIL_USDT','KNC_USDT']\\nSYMBOLS = ['1INCH_USDT','ALGO_USDT','ATOM_USDT','AVAX_USDT','AAVE_USDT','AXS_USDT',\\n           'BAND_USDT','BCH_USDT','BTC_USDT','COMP_USDT','CVC_USDT','DOGE_USDT'\\n           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\\n           'ETC_USDT','FTM_USDT','GALA_USDT','GRT_USDT','IOTA_USDT','KSM_USDT',\\n           'LINK_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_US",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_USDT','LRC_USDT','LTC_USDT','MANA_USDT','MATIC_USDT','NEAR_USDT','OMG_USDT','SAND_USDT',\\n           'SC_USDT','SOL_USDT','SRM_USDT','SUSHI_USDT','THETA_USDT','TRX_USDT',\\n           'UNI_USDT','XRP_USDT','XLM_USDT','XMR_USDT','XTZ_USDT','YFI_USDT','ZEC_USDT','PEOPLE_USDT',\\n           'APE_USDT','ZIL_USDT','KNC_USDT']\\n#主函数\\ndef main():\\n    try:\\n        while True:\\n            flage = ext.GetStopService()\\n            if flage == 1:\\n                break\\n            #策略交互\\n            ext.GetCommandS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ak\\n            #策略交互\\n            ext.GetCommandService()\\n            #选币功能\\n            ext.GetSymbolService()\\n            #下单信号 \\n            ext.FirstSignalService()\\n            #减仓信号\\n            ext.StopSurplusService()\\n            #展示数据\\n            ext.UpdateLogStatusService()\\n            Sleep(tickInterval)\\n    except Exception as e:\\n        Log(traceback.format_exc())\\n        Log(\\\"策略已停止，请及时查看@\\\")\\n    \\n#初始化函数        \\ndef init():\\n    Log(\\\"策略开始\\\")\\n    #设置合约永续\\n    if len(exchanges) != ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(\\\"策略开始\\\")\\n    #设置合约永续\\n    if len(exchanges) != 2:\\n        Log(\\\"需要设置两组交易对\\\")\\n        return\\n    symbolRecord = _G(\\\"symbolRecord\\\")\\n    Log(\\\"symbolRecord:\\\",symbolRecord)\\n    if symbolRecord is not None:\\n        symbol = symbolRecord['symbol']\\n        exchange.SetCurrency(symbol) \\n    _G(\\\"symbolRecord\\\",None)\\n    exchange.SetContractType(\\\"swap\\\")\\n    exchange.SetMarginLevel(leverage)\\n    exchanges[1].SetContractType(\\\"swap\\\")\\n    exchanges[1].SetMarginLevel(leverage)\\n    _G(\\\"orderValue\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1].SetMarginLevel(leverage)\\n    _G(\\\"orderValue\\\",orderValue)\\n    _G(\\\"leverage\\\",leverage)\\n    _G(\\\"bfCount\\\",bfCount)\\n    _G(\\\"symbols\\\",SYMBOLS)\\n    _G(\\\"isFlag\\\",isFlag)\\n    _G(\\\"isUpdate\\\",0)\\n    _G(\\\"stopSurplus\\\",stopSurplus)\\n    _G(\\\"stopSurplusCount\\\",stopSurplusCount)\\n    Log(\\\"所有交易标的：\\\",SYMBOLS)\\n    if _G(\\\"initialTotalMarginBalance\\\") is None:\\n        info = exchange.GetAccount().Info\\n        if info is None or info == {}:\\n            Log(\\\"获取不到期货数据，无法运行\\\")\\n            return\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  Log(\\\"获取不到期货数据，无法运行\\\")\\n            return\\n        _G(\\\"initialTotalMarginBalance\\\", round(float(info.totalMarginBalance),2))#初始金额\\n    if _G(\\\"drawIn\\\") is None:\\n        _G(\\\"drawIn\\\",0)\\n    if _G(\\\"drawOut\\\") is None:\\n        _G(\\\"drawOut\\\",0)\\n    ext.ClearAllService()\\n    \\n    \\n#扫尾函数   \\ndef onexit():\\n     #平仓\\n    #ext.ClearanceService()\\n    ext.UpdateLogStatusService()\\n    #Log(\\\"已全部平仓\\\")\\n    Log(\\\"策略已停止\\\")\",\n    \"策略名称: 幽灵趋势跟踪策略\\n\\n#           ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USD",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     ,'DOT_USDT','DYDX_USDT','DASH_USDT','EGLD_USDT','ENJ_USDT','ENS_USDT','EOS_USDT','ETH_USDT',\"\n \n\n    \"strategy_97\",\n    \"python\\n#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\nimport time,datetime\\nimport json\\nimport math\\nimport urllib.request\\nRECORDS = None\\nFLAGE = 0\\n#账户信息表格化，用于展示在状态信息上\\ndef TableAccountService(account):\\n    \\n    clos = [] #表头\\n    clos.append(\\\"初始余额\\\")\\n    clos.append(\\\"钱包余额\\\")\\n    clos.append(\\\"保证金余额\\\")\\n    clos.append(\\\"可用余额\\\")\\n    clos.append(\\\"已用保证金\\\")\\n    clos.append(\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\")\\n    clos.append(\\\"已用保证金\\\")\\n    clos.append(\\\"当前杠杆\\\")\\n    clos.append(\\\"总收益(收益率)\\\")\\n    \\n    initialTotalMarginBalance = \\\"$\\\" + str(_G(\\\"initialTotalMarginBalance\\\")) #初始余额\\n    totalWalletBalance = \\\"$\\\" + str(account.totalWalletBalance) #钱包余额\\n    totalMarginBalance = \\\"$\\\" + str(account.totalMarginBalance) #保证金余额\\n    availableBalance = \\\"$\\\" + str(account.availableBalance) #可用余额\\n    totalPositionInitialMargin = account.totalPositionInitialMargin#持仓保证金\\n    totalOpenOrderInitialMargin = account.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#持仓保证金\\n    totalOpenOrderInitialMargin = account.totalOpenOrderInitialMargin#当前挂单保证金\\n    #_C(FilterHandlService)\\n    drawOut = _N(_G(\\\"drawOut\\\"),2) #已划转资金\\n    if account.totalMarginBalance==0 :\\n        marginRate = \\\"0\\\"\\n        lever = 0\\n        Revenue = \\\"$0\\\"\\n    else :\\n        marginRate = (totalPositionInitialMargin+totalOpenOrderInitialMargin)/account.totalMarginBalance\\n        marginRate = \\\"(\\\"+str(_N(marginRate,2)) + \\\")\\\"#保证金率\\n        leverage = _G(\\\"leverage\\\")#杠杆 \\n        lever = _",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "leverage = _G(\\\"leverage\\\")#杠杆 \\n        lever = _N(totalPositionInitialMargin*leverage/account.totalMarginBalance,2)#当前杠杆\\n        drawIn = _G(\\\"drawIn\\\")\\n        drawOut = _G(\\\"drawOut\\\")\\n        totalRevenue = account.totalMarginBalance-_G(\\\"initialTotalMarginBalance\\\") + drawOut - drawIn#总收益\\n        initialTotalMarginBalance = _G(\\\"initialTotalMarginBalance\\\")\\n        totalYield = 0\\n        if initialTotalMarginBalance != 0:\\n            totalYield = totalRevenue/initialTotalMarginBalance\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= totalRevenue/initialTotalMarginBalance\\n        totalYield = \\\"(\\\" + str(_N(totalYield,2)) + \\\")\\\"#总收益率\\n        Revenue = \\\"$\\\" + str(_N(totalRevenue,2)) + totalYield\\n        #记录当前总收益\\n        _G(\\\"totalRevenue\\\",totalRevenue)\\n    totalInitialMargin = \\\"$\\\" + str(_N(totalPositionInitialMargin+totalOpenOrderInitialMargin,2))#已用保证金\\n    \\n    rows = [] #表内容\\n    row =[]\\n    row.append(initialTotalMarginBalance)\\n    row.append(totalWalletBalance)\\n    row.append(totalMarginBalance)\\n    row.append(avail",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "w.append(totalMarginBalance)\\n    row.append(availableBalance)\\n    row.append(totalInitialMargin+marginRate)\\n    row.append(lever)\\n    row.append(Revenue)\\n    rows.append(row)\\n    \\n    table = {\\n        \\\"type\\\" : \\\"table\\\",\\n        \\\"title\\\" : \\\"账户信息\\\",\\n        \\\"cols\\\" : clos,\\n        \\\"rows\\\" : rows\\n    }\\n    \\n    \\n    return table\\n    \\n#交易对表格化，用于展示在状态信息上    \\ndef TablePositionsService(positions):\\n    clos = [] #表头\\n    clos.append(\\\"币种\\\")\\n    clos.append(\\\"方向\\\")\\n    clos.append(\\\"数量\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n    clos.append(\\\"方向\\\")\\n    clos.append(\\\"数量\\\")\\n    clos.append(\\\"开仓价格\\\")\\n    clos.append(\\\"强平价格\\\")\\n    clos.append(\\\"现价\\\")\\n    clos.append(\\\"未实现盈亏\\\")\\n    rows = [] #表内容\\n    for position in positions:\\n        row = []\\n        symbol = position.symbol\\n        leverage = position.leverage\\n        row.append(symbol + \\\"[\\\" + leverage + \\\"X]\\\")\\n        \\n        positionAmt = position.positionAmt\\n        if float(positionAmt)>0:\\n            row.append(\\\"做多\\\")\\n        else:\\n            row.app",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "append(\\\"做多\\\")\\n        else:\\n            row.append(\\\"做空\\\")\\n        row.append(math.fabs(float(positionAmt)))\\n        row.append(position.entryPrice)\\n        row.append(position.liquidationPrice)\\n        row.append(position.markPrice)\\n        row.append(position.unRealizedProfit)\\n        rows.append(row)  \\n    table = {\\n        \\\"type\\\" : \\\"table\\\",\\n        \\\"title\\\" : \\\"交易对信息\\\",\\n        \\\"cols\\\" : clos,\\n        \\\"rows\\\" : rows\\n    }\\n    return table \\n\\n\\n\\n#跟新状态信息\\ndef UpdateLogStatusServic",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n table \\n\\n\\n\\n#跟新状态信息\\ndef UpdateLogStatusService():\\n    account = ext.GetAccountDao()\\n    positions = ext.GetPositionsDao()\\n    LogStatus(\\\"`\\\" + json.dumps(TableAccountService(account)) + \\\"`\\\\n\\\" +  \\\"`\\\" + json.dumps(TablePositionsService(positions)) +  \\\"`\\\")\\n\\n            \\n#根据当前价格和下单价值换算成合约数            \\ndef GetAmountByOrderValueService(price):\\n    ext.GetNumByAmountService()\\n    num = _G(\\\"num\\\")\\n    orderValue = _G(\\\"orderValue\\\")\\n    leverage = _G(\\\"leverage\\\")\\n    account = ext.GetAcco",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rage = _G(\\\"leverage\\\")\\n    account = ext.GetAccountDao()\\n    totalMarginBalance = account.totalMarginBalance\\n    orderValue = orderValue*totalMarginBalance*leverage*0.99/100\\n    amount = orderValue/price\\n    if orderValue < 5:\\n        amount = 5/price + 1\\n    amount = _N(amount,num)\\n    if price*amount > orderValue:\\n        amount = orderValue*0.99/price\\n        amount = _N(amount,num)\\n    exchange.SetMarginLevel(leverage)\\n    return amount   \\n\\n#平仓\\ndef ClearanceService():\\n    positions = ex",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n#平仓\\ndef ClearanceService():\\n    positions = ext.GetPositionsDao()\\n    for position in positions:\\n        positionAmt = position.positionAmt\\n        amt = math.fabs(float(positionAmt))\\n        totalRevenue = _G(\\\"totalRevenue\\\")\\n        ticker = ext.GetTickerDao(0)\\n        price = ticker.last\\n        symbol = position.symbol\\n        symbol = symbol.replace(\\\"USDT\\\",\\\"_USDT\\\")\\n        if float(positionAmt)>0:\\n            #持多仓，--卖出平仓\\n            ext.CreateOrderDao2(amt,3,\\\"{}币种平多单的当前成交价格：{}\\\".fo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ext.CreateOrderDao2(amt,3,\\\"{}币种平多单的当前成交价格：{}\\\".format(symbol,price))\\n            LogProfit(_N(totalRevenue,2))\\n        else:\\n            #持空仓，--买入平仓\\n            ext.CreateOrderDao2(amt,1,\\\"{}币种平空单的当前成交价格：{}\\\".format(symbol,price))\\n            LogProfit(_N(totalRevenue,2))\\n            \\n#获取合约数位数\\ndef GetNumByAmountService():\\n    ext.GetNumByAmountDao()            \\n\\n#计算出交易对最小下单量\\ndef GetMinOrderCountService():\\n    minCount = 1\\n    num = _G(\\\"num\\\")\\n    if num != 0:\\n        minCount = 1/(10**num)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    if num != 0:\\n        minCount = 1/(10**num)\\n    return minCount\\n \\n#获取标志 \\ndef GetStopService():\\n    return ext.GetStopDao()\\n\\n#获取交易对信息    \\ndef GetPositionsService():\\n    return ext.GetPositionsDao()\\n\\n#获取tick价格\\ndef GetPriceService(i):\\n    ticker = ext.GetTickerDao(i)\\n    price = ticker.last\\n    return price \\n\\n#选出涨跌幅最大的币种\\ndef GetSymbolService():\\n    global RECORDS \\n    #第一次获取所有币种的record数据，缓存起来 \\n    R = _G(\\\"RECORDS\\\")\\n    r = RECORDS\\n    if r is None:\\n        if R is None:\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    if r is None:\\n        if R is None:\\n            SetSymbolsRecordsService()\\n        else:\\n            RECORDS = R\\n        return\\n    #定期获取其中一个币种的最新record数据，和缓存数据比较，如果一样则，将数据更新标识记录为0并跳过\\n    #如果不同，则更新缓存中所有币种的record数据,并将数据更新标识记录为1\\n    isUpdate = UpdateRecordService()\\n    if isUpdate:\\n        return \\n    #计算所有币种涨跌幅的绝对值，选出数值最大的币种\\n    #根据选出来的币种的最新价格和bfCount的k线开盘价对比，判断出下单方向并记录起来\\n    GetMaxSymbolService()\\n    _G(\\\"RECORDS\\\",RECORDS)\\n\\n#下单信号\\ndef FirstSignalService():\\n    global FLAGE\\n    symbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "FirstSignalService():\\n    global FLAGE\\n    symbolRecord = _G(\\\"symbolRecord\\\")\\n    #检测是否已经筛选出币种，如果没有则跳出 \\n    if symbolRecord is None:\\n        return\\n    #检测数据更新标识是否为1，如果不是则跳出 \\n    isUpdate = _G(\\\"isUpdate\\\")\\n    if isUpdate == 0:\\n        return\\n    symbol = symbolRecord[\\\"symbol\\\"] \\n    #检测当前是否有持仓 \\n    positions = ext.GetPositionsDao()\\n    if len(positions) == 0:\\n        #如果没有则用筛选出的币种进行下单\\n        ext.SetCurrencyDao(symbol,0)\\n        leverage = _G(\\\"leverage\\\")\\n        exchange.SetMarginLeve",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= _G(\\\"leverage\\\")\\n        exchange.SetMarginLevel(leverage)\\n        side = symbolRecord[\\\"side\\\"]  \\n        if side == 1:#做多 \\n            price = symbolRecord[\\\"close\\\"]\\n            amount = GetAmountByOrderValueService(price)\\n            ext.CreateOrderDao2(amount,0,\\\"{}币种下多单的当前成交价格：{}\\\".format(symbol,price))\\n            _G(\\\"initPrice\\\",price)\\n            _G(\\\"initSide\\\",side)\\n        else:#做空\\n            price = symbolRecord[\\\"close\\\"]                      \\n            amount = GetAmountByOrd",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             \\n            amount = GetAmountByOrderValueService(price)\\n            ext.CreateOrderDao2(amount,2,\\\"{}币种下空单的当前成交价格：{}\\\".format(symbol,price))\\n            _G(\\\"initPrice\\\",price)\\n            _G(\\\"initSide\\\",side)\\n    elif len(positions) == 1:\\n        position = positions[0]\\n        positionAmt = float(position.positionAmt)\\n        nSymbol = position.symbol\\n        nSymbol = nSymbol.replace(\\\"USDT\\\",\\\"_USDT\\\")\\n        #判断筛选出来的币种和当前下单的币种是否一样\\n        if symbol == nSymbol:\\n            #",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "是否一样\\n        if symbol == nSymbol:\\n            #判断当前币种是否有浮亏，如果有则清仓，并反向下单\\n            isFlag = _G(\\\"isFlag\\\")\\n            if isFlag == 0:#使用反转信号,如果isFlag=0则不使用反转信号，则不处理当前的持仓\\n                firstPrice = _G(\\\"initPrice\\\")\\n                side = _G(\\\"initSide\\\")\\n                price = symbolRecord[\\\"close\\\"]\\n                if side == 1 and price <= firstPrice:#换币后首次下单方向是多，但是当前价格低于首次下单价格（浮亏），所以需要反转下单\\n                    Log(\\\"换币后当前持仓方向是多，但是当前价格{}低于等于首次下单价格{}（浮亏），所以需要反转下单\\\".format(price,firstPrice))\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "次下单价格{}（浮亏），所以需要反转下单\\\".format(price,firstPrice))\\n                    ClearanceService()\\n                    amount = GetAmountByOrderValueService(price)\\n                    if positionAmt > 0:#持有多单则清多单再下空单\\n                        ext.CreateOrderDao2(amount,2,\\\"{}币种下空单的当前成交价格：{}\\\".format(symbol,price))\\n                    else:\\n                        ext.CreateOrderDao2(amount,0,\\\"{}币种下多单的当前成交价格：{}\\\".format(symbol,price))\\n                    _G(\\\"initSide\\\",0)\\n                    FLAGE = 0\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Side\\\",0)\\n                    FLAGE = 0\\n                elif side == 0 and price >= firstPrice:#换币后首次下单方向是空，但是当前价格高于首次下单价格（浮亏），所以需要反转下单\\n                    Log(\\\"换币后当前持仓方向是空，但是当前价格{}高于等于首次下单价格{}（浮亏），所以需要反转下单\\\".format(price,firstPrice))\\n                    #清空仓，再下多单\\n                    ClearanceService()\\n                    amount = GetAmountByOrderValueService(price)\\n                    if positionAmt < 0:\\n                        ext.CreateOrderDao2(amount,0,\\\"{}币种下多单的当前成交价格：{}\\\".format(symbol,price",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "amount,0,\\\"{}币种下多单的当前成交价格：{}\\\".format(symbol,price))\\n                    else:\\n                        ext.CreateOrderDao2(amount,2,\\\"{}币种下空单的当前成交价格：{}\\\".format(symbol,price))\\n                    _G(\\\"initSide\\\",1)\\n                    FLAGE = 0\\n                else:\\n                    Log(\\\"当前价格{}，首次下单价格{}，不需要反转下单\\\".format(price,firstPrice))\\n            else:\\n                Log(\\\"策略参数已屏蔽反转信号功能\\\")\\n        else:\\n            #将当前持仓清仓，并更换为筛选出的币种进行下单\\n            ClearanceService()\\n            ext.S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            ClearanceService()\\n            ext.SetCurrencyDao(symbol,0)\\n            side = symbolRecord[\\\"side\\\"]  \\n            if side == 1:#做多 \\n                ticker = ext.GetTickerDao(0)\\n                price = ticker.last                          \\n                amount = GetAmountByOrderValueService(price)\\n                ext.CreateOrderDao2(amount,0,\\\"{}币种下多单的当前成交价格：{}\\\".format(symbol,price))\\n                _G(\\\"initPrice\\\",price)\\n                _G(\\\"initSide\\\",side)\\n                FLAG",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       _G(\\\"initSide\\\",side)\\n                FLAGE = 0\\n            else:#做空\\n                ticker = ext.GetTickerDao(0)\\n                price = ticker.last                          \\n                amount = GetAmountByOrderValueService(price)\\n                ext.CreateOrderDao2(amount,2,\\\"{}币种下空单的当前成交价格：{}\\\".format(symbol,price))\\n                _G(\\\"initPrice\\\",price)\\n                _G(\\\"initSide\\\",side)\\n                FLAGE = 0\\n        \\n    \\n    \\n#缓存record\\ndef SetSymbolsRecordsService():\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    \\n#缓存record\\ndef SetSymbolsRecordsService():\\n    global RECORDS \\n    symbols = _G(\\\"symbols\\\")\\n    recordss = {}\\n    for symbol in symbols:\\n        #Log(\\\"symbol:\\\",symbol)\\n        ext.SetCurrencyDao(symbol,1)\\n        if RECORDS is None:\\n            records =  ext.GetRecordsDao(-1,1)\\n            recordss[symbol] = records\\n        else:\\n            oldRecords = RECORDS[symbol]\\n            _CDelay(250)\\n            records = _C(CheckRecordService,oldRecords)\\n            recordss[symbol] = re",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ice,oldRecords)\\n            recordss[symbol] = records\\n    RECORDS = recordss\\n\\n#检查记录record数据是否更新\\ndef CheckRecordService(oldRecords):\\n    oldTime = oldRecords[-1][\\\"Time\\\"]\\n    records = ext.GetRecordsDao(-1,1)\\n    newTime = records[-1][\\\"Time\\\"]\\n    if oldTime == newTime:\\n        #Sleep(100)\\n        return False\\n    else:\\n        return records\\n\\n#更新所有symbol的record    \\ndef UpdateRecordService():\\n    global RECORDS \\n    symbols = _G(\\\"symbols\\\")\\n    symbol = symbols[0]\\n    ext.SetCurrencyD",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\")\\n    symbol = symbols[0]\\n    ext.SetCurrencyDao(symbol,1)\\n    newRecords = ext.GetRecordsDao(-1,1)\\n    newTime = newRecords[-1][\\\"Time\\\"]\\n    oldRecords = RECORDS[symbol]\\n    oldTime = oldRecords[-1][\\\"Time\\\"]\\n    if newTime == oldTime:\\n        _G(\\\"isUpdate\\\",0)\\n        return True\\n    else:\\n        Sleep(500)\\n        SetSymbolsRecordsService()\\n        _G(\\\"isUpdate\\\",1)\\n        Log(\\\"行情数据已更新\\\")\\n        return False\\n\\n#计算涨跌幅最大的币种\\ndef GetMaxSymbolService():\\n    symbols = _G(\\\"symbols\\\")",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "MaxSymbolService():\\n    symbols = _G(\\\"symbols\\\")\\n    bfCount = _G(\\\"bfCount\\\") + 1\\n    chgs = []\\n    symbolList = []\\n    tests = []\\n    tests2 = []\\n    for symbol in symbols:\\n        records = RECORDS[symbol]\\n        record = records[-1]\\n        close = record[\\\"Open\\\"]\\n        bfRecord = []\\n        if len(records) < bfCount:\\n            bfRecord = records[-len(records)]\\n            Log(\\\"{}数据过少{}\\\".format(symbol,len(records)))\\n        else:\\n            bfRecord = records[-bfCount]\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            bfRecord = records[-bfCount]\\n        bfOpen = bfRecord[\\\"Open\\\"]\\n        chg = 0\\n        if close >= bfOpen:\\n            chg = (close - bfOpen)/bfOpen \\n        else:\\n            chg = (bfOpen - close)/bfOpen\\n        chgs.append(chg)\\n        symbolList.append(symbol)\\n        tests.append([symbol,chg])\\n        tests2.append([symbol,bfOpen,close])\\n    Log(tests)\\n    Log(tests2)\\n    maxChg = max(chgs)\\n    maxSymbol = symbolList[chgs.index(maxChg)]\\n    maxRecords = RECORDS[maxSymbol]\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dex(maxChg)]\\n    maxRecords = RECORDS[maxSymbol]\\n    maxRecord = maxRecords[-1]\\n    maxClose = maxRecord[\\\"Open\\\"]\\n    maxBfRecord = maxRecords[-bfCount]\\n    maxBfOpen = maxBfRecord[\\\"Open\\\"] \\n    maxSide = GetSideService(maxSymbol,maxClose,maxBfOpen)\\n    symbolRecord = {}\\n    symbolRecord[\\\"symbol\\\"] = maxSymbol \\n    symbolRecord[\\\"initPrice\\\"] = maxBfOpen \\n    #symbolRecord[\\\"firstPrice\\\"] = price \\n    symbolRecord[\\\"close\\\"] = maxClose \\n    symbolRecord[\\\"side\\\"] = maxSide \\n    symbolRecord[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mbolRecord[\\\"side\\\"] = maxSide \\n    symbolRecord[\\\"chg\\\"] = maxChg\\n    _G(\\\"symbolRecord\\\",symbolRecord)\\n    Log(\\\"新symbolRecord:\\\",symbolRecord)\\n    #Log(\\\"最大涨跌幅的币种是：{}，涨跌幅为：{}\\\".format(maxSymbol,maxChg))\\n\\n#计算下单方向    \\ndef GetSideService(maxSymbol,maxClose,maxBfOpen):\\n    symbol = ext.GetCurrencyDao()\\n    records = RECORDS[symbol]\\n    price = records[-1][\\\"Open\\\"]\\n    #检测当前是否有持仓 \\n    positions = ext.GetPositionsDao()\\n    if len(positions) == 0:#没有持仓，则不使用继承模块 \\n        Log(\\\"首次下单，不使用继承模块\\\")\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "没有持仓，则不使用继承模块 \\n        Log(\\\"首次下单，不使用继承模块\\\")\\n        _G(\\\"oldClose\\\",maxClose)\\n        _G(\\\"oldBfOpen\\\",maxBfOpen)\\n        if maxClose > maxBfOpen:\\n            return 1 #做多方向\\n        else:\\n            return 0 #做空方向\\n    else:\\n        position = positions[0]\\n        nSymbol = position.symbol\\n        nSymbol = nSymbol.replace(\\\"USDT\\\",\\\"_USDT\\\")\\n        initPrice = _G(\\\"initPrice\\\")\\n        if nSymbol == maxSymbol:#相同币种不需要换币\\n            Log(\\\"筛选出来的币种和当前持仓的币种一样,不需要更换币种\\\")\\n            if price >=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "来的币种和当前持仓的币种一样,不需要更换币种\\\")\\n            if price >= initPrice:\\n                return 1 #做多方向\\n            else:\\n                return 0 #做空方向\\n        #使用继承模块\\n        Log(\\\"筛选出来的币种和当前持仓的币种不一样,需要更换币种，{}币种更换为{}币种\\\".format(nSymbol,maxSymbol))\\n        oldClose = _G(\\\"oldClose\\\")\\n        oldBfOpen =_G(\\\"oldBfOpen\\\")\\n        if (maxClose >= maxBfOpen and oldClose > oldBfOpen) or (maxClose <= maxBfOpen and oldClose < oldBfOpen):#继承上一个币的下单方向 \\n            _G(\\\"oldClose\\\",maxClose)\\n            _G(\\\"oldBfOpen",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"oldClose\\\",maxClose)\\n            _G(\\\"oldBfOpen\\\",maxBfOpen)\\n            Log(\\\"{}币种继承{}币种的下单方向\\\".format(maxSymbol,nSymbol))\\n            position =  positions[0]\\n            positionAmt = float(position.positionAmt)\\n            if positionAmt < 0:\\n                return 0\\n            else:\\n                return 1\\n        else:#不用使用继承\\n            Log(\\\"不使用继承模块\\\")\\n            _G(\\\"oldClose\\\",maxClose)\\n            _G(\\\"oldBfOpen\\\",maxBfOpen)\\n            if maxClose >= maxBfOpen:\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        if maxClose >= maxBfOpen:\\n                return 1 #做多方向\\n            else:\\n                return 0 #做空方向 \\n#清仓\\ndef ClearAllService():\\n    symbols = _G(\\\"symbols\\\")\\n    for symbol in symbols:\\n        ext.SetCurrencyDao(symbol,0)\\n        positions = ext.GetPositionsDao()\\n        if len(positions) != 0:\\n            Log(\\\"清理已有仓位\\\")\\n            ClearanceService()\\n    \\n        \\n#策略交互\\ndef GetCommandService():\\n    cmd = GetCommand()\\n    if cmd: \\n        arr = cmd.split(\\\":\\\")\\n        if ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cmd: \\n        arr = cmd.split(\\\":\\\")\\n        if arr[0] == \\\"一键清仓\\\": #清空所有交易对持仓\\n            ClearanceService()\\n            Log(\\\"全部清仓\\\")\\n        elif arr[0] == \\\"现货==》合约\\\": #从现货账户划转USDT到合约账户\\n            accountFunds = float(arr[1])\\n            ret = ext.SetTransferDao(accountFunds,\\\"MAIN_UMFUTURE\\\",\\\"USDT\\\")\\n            if ret is None:\\n                Log(\\\"现货==》合约,划转资金出错\\\")  \\n        elif arr[0] == \\\"合约==》现货\\\": #从合约账户划转USDT到现货账户\\n            accountFunds = float(arr[1])\\n            ret = ext.SetT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tFunds = float(arr[1])\\n            ret = ext.SetTransferDao(accountFunds,\\\"UMFUTURE_MAIN\\\",\\\"USDT\\\")\\n            if ret is None:\\n                Log(\\\"合约==》现货,划转资金出错\\\")\\n            drawOut = _G(\\\"drawOut\\\")\\n            _G(\\\"drawOut\\\",accountFunds + drawOut)\\n\\n#减仓信号\\ndef StopSurplusService():\\n    global FLAGE\\n    if FLAGE == 1:\\n        return \\n    positions = ext.GetPositionsDao() \\n    if len(positions) == 0:\\n        return \\n    position = positions[0]\\n    positionAmt = float(position.positionA",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ons[0]\\n    positionAmt = float(position.positionAmt)\\n    entryPrice = float(position.entryPrice)\\n    ticker = ext.GetTickerDao(0)\\n    price = ticker.last\\n    stopSurplus = _G(\\\"stopSurplus\\\")/100\\n    stopSurplusCount = _G(\\\"stopSurplusCount\\\")\\n    stopSurplusCount = float(stopSurplusCount)/100\\n    if positionAmt > 0:\\n        if (price - entryPrice)/entryPrice < stopSurplus:\\n            return \\n        positionAmt = stopSurplusCount*positionAmt\\n        num = _G(\\\"num\\\")\\n        positionAmt = _N(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      num = _G(\\\"num\\\")\\n        positionAmt = _N(positionAmt,num)\\n        Log(\\\"减多仓\\\")\\n        ext.CreateOrderDao2(positionAmt,3,\\\"当前成交价格：{}\\\".format(price))\\n        totalRevenue = _G(\\\"totalRevenue\\\")\\n        LogProfit(_N(totalRevenue,2))\\n        FLAGE = 1\\n    else:\\n        if (entryPrice - price)/entryPrice  < stopSurplus:\\n            return \\n        positionAmt = -positionAmt \\n        positionAmt = stopSurplusCount*positionAmt\\n        num = _G(\\\"num\\\")\\n        positionAmt = _N(positionAmt,nu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(\\\"num\\\")\\n        positionAmt = _N(positionAmt,num)\\n        Log(\\\"减空仓\\\")\\n        ext.CreateOrderDao2(positionAmt,1,\\\"当前成交价格：{}\\\".format(price))\\n        totalRevenue = _G(\\\"totalRevenue\\\")\\n        LogProfit(_N(totalRevenue,2))\\n        FLAGE = 1\\n    \\n#设置双向持仓           \\ndef SetDualService():\\n    ext.SetDualDao()\\n            \\next.TableAccountService = TableAccountService\\next.TablePositionsService = TablePositionsService\\next.UpdateLogStatusService = UpdateLogStatusService\\next.ClearanceService = Cl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " UpdateLogStatusService\\next.ClearanceService = ClearanceService\\next.GetNumByAmountService = GetNumByAmountService\\next.GetAmountByOrderValueService = GetAmountByOrderValueService\\next.GetStopService = GetStopService\\next.GetPositionsService = GetPositionsService\\next.GetPriceService = GetPriceService \\next.GetSymbolService = GetSymbolService\\next.FirstSignalService = FirstSignalService\\next.GetCommandService = GetCommandService\\next.SetDualService = SetDualService\\next.GetSymbolService = GetSymbolService\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lService\\next.GetSymbolService = GetSymbolService\\next.ClearAllService = ClearAllService\\next.StopSurplusService = StopSurplusService\",\n    \"策略名称: 幽灵趋势跟踪策略业务库\\n\\nimport time,datetime\\nimport json\\nimport math\\nimport urllib.request\\nRECORDS = None\\nFLAGE = 0\"\n \n\n    \"strategy_98\",\n    \"python\\n#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\nimport time,datetime\\nimport json\\nfrom collections import Counter\\nIFLAGE = 0\\nclass Account(object):\\n    #币安账户信息实体，封装了常用的账户信息\\n    #totalWalletBalance：钱包余额\\n    #totalMar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "的账户信息\\n    #totalWalletBalance：钱包余额\\n    #totalMarginBalance：保证金余额\\n    #totalPositionInitialMargin：持仓保证金\\n    #totalOpenOrderInitialMargin：当前挂单保证金\\n    #availableBalance: 可用余额（仅计算usdt资产）\\n    def __init__(self, totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance):\\n        self.totalWalletBalance = totalWalletBalance\\n        self.totalMarginBalance = totalMarginBalance\\n        self.totalPositionInitialMargin = totalPositionInitialMargin\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nInitialMargin = totalPositionInitialMargin\\n        self.totalOpenOrderInitialMargin = totalOpenOrderInitialMargin \\n        self.availableBalance = availableBalance\\n        \\nclass Position(object):\\n    #币安交易对实体，封装了常用的交易对信息\\n    #entryPrice：持仓成本价\\n    #leverage：杠杆倍率\\n    #liquidationPrice：强平价格\\n    #marginType：逐仓模式或全仓模式\\n    #markPrice：标记价格\\n    #positionAmt：头寸数量\\n    #symbol：交易对\\n    #unRealizedProfit：持仓未实现盈亏\\n    #positionSide：持仓方向\\n    def __init__(self, entryPrice, leverage, liquidationPrice, margin",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lf, entryPrice, leverage, liquidationPrice, marginType, markPrice, positionAmt, symbol, unRealizedProfit, positionSide):\\n        self.entryPrice = entryPrice\\n        self.leverage = leverage\\n        self.liquidationPrice = liquidationPrice\\n        self.marginType = marginType \\n        self.markPrice = markPrice\\n        self.positionAmt = positionAmt\\n        self.symbol = symbol\\n        self.unRealizedProfit = unRealizedProfit\\n        self.positionSide = positionSide\\n\\nclass Ticker(object):\\n    #s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de = positionSide\\n\\nclass Ticker(object):\\n    #sell: 卖一价\\n    #buy: 买一价\\n    #last: 最后成交价格\\n    def __init__(self, sell, buy, last):\\n        self.sell = sell \\n        self.buy = buy \\n        self.last = last \\n        \\n        \\n        \\nclass Order(object):\\n    #id:订单唯一标识 \\n    #price:下单价格 \\n    #amount:下单数量 \\n    #status:订单状态--0：未完成；1：已完成；2：已经取消；3：未知状态\\n    def __init__(self, id, price, amount, status):\\n        self.id = id \\n        self.price = price \\n        self.amount = amount \\n        sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "price \\n        self.amount = amount \\n        self.status = status \\n        \\n        \\n#获取账户信息        \\ndef GetAccountDao():\\n    account = _C(exchange.GetAccount)\\n    assets = account.Info.assets\\n    busd = {}\\n    usdt = {}\\n    for asset in assets:\\n        symbol = asset[\\\"asset\\\"]\\n        if symbol == \\\"BUSD\\\":\\n            busd = asset \\n        if symbol == \\\"USDT\\\":\\n            usdt = asset\\n            \\n    bTotalWalletBalance = float(busd[\\\"walletBalance\\\"])\\n    bTotalMarginBalance = floa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"walletBalance\\\"])\\n    bTotalMarginBalance = float(busd[\\\"marginBalance\\\"])\\n    bTotalPositionInitialMargin = float(busd[\\\"positionInitialMargin\\\"])\\n    bTotalOpenOrderInitialMargin = float(busd[\\\"openOrderInitialMargin\\\"])\\n    bAvailableBalance = float(busd[\\\"availableBalance\\\"])\\n    uTotalWalletBalance = float(usdt[\\\"walletBalance\\\"])\\n    uTotalMarginBalance = float(usdt[\\\"marginBalance\\\"])\\n    uTotalPositionInitialMargin = float(usdt[\\\"positionInitialMargin\\\"])\\n    uTotalOpenOrderInitialMargin = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ialMargin\\\"])\\n    uTotalOpenOrderInitialMargin = float(usdt[\\\"openOrderInitialMargin\\\"])\\n    uAvailableBalance = float(usdt[\\\"availableBalance\\\"])\\n    totalWalletBalance = _N(uTotalWalletBalance+bTotalWalletBalance,2)\\n    totalMarginBalance = _N(uTotalMarginBalance+bTotalMarginBalance,2)\\n    totalPositionInitialMargin = _N(uTotalPositionInitialMargin+bTotalPositionInitialMargin,2)\\n    totalOpenOrderInitialMargin = _N(uTotalOpenOrderInitialMargin+bTotalOpenOrderInitialMargin,2)\\n    availableBalance = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "OpenOrderInitialMargin,2)\\n    availableBalance = _N(uAvailableBalance+bAvailableBalance,2)\\n    account = Account(totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance)\\n    return account\\n\\n#获取账户所有交易对\\ndef GetPositionsDao():\\n    positions = [] \\n    num2 = _G(\\\"num2\\\")\\n    for i in _C(exchange.GetPosition):\\n        entryPrice = _N(float(i.Info.entryPrice),num2)\\n        leverage = i.Info.leverage \\n        liquidationPrice = _N(float(i.Info.l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "age \\n        liquidationPrice = _N(float(i.Info.liquidationPrice),num2)\\n        marginType = i.Info.marginType \\n        markPrice = _N(float(i.Info.markPrice),num2) \\n        positionAmt = i.Info.positionAmt \\n        symbol = i.Info.symbol \\n        unRealizedProfit = _N(float(i.Info.unRealizedProfit),3)  \\n        positionSide = i.Info.positionSide \\n        \\n        position = Position(entryPrice, leverage, liquidationPrice, marginType, markPrice,\\n                            positionAmt, symbol, unR",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                          positionAmt, symbol, unRealizedProfit, positionSide)\\n        positions.append(position)\\n    return positions\\n\\n#获取tick级别的行情数据\\ndef GetTickerDao(i):\\n    ticker = _C(exchanges[i].GetTicker)\\n    sell = ticker.Sell \\n    buy = ticker.Buy \\n    last = ticker.Last\\n    newTicker = Ticker(sell,buy,last)\\n    return newTicker\\n\\n#创建订单\\ndef CreateOrderDao(price,amount,flag):\\n    #price: 价格\\n    #amount: 合约数\\n    #flag: 0(买入开多仓);1(买入平空仓);2(卖出开空仓);3(卖出平多仓)\\n    num2 = _G(\\\"num2\\\")\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ");2(卖出开空仓);3(卖出平多仓)\\n    num2 = _G(\\\"num2\\\")\\n    price = _N(price,num2)\\n    id = 0\\n    if flag == 0:\\n        exchange.SetDirection(\\\"buy\\\")\\n        id = exchange.Buy(price,amount)\\n    elif  flag == 1:\\n        exchange.SetDirection(\\\"closesell\\\")\\n        id = exchange.Buy(price,amount)\\n    elif  flag == 2:\\n        exchange.SetDirection(\\\"sell\\\")\\n        id = exchange.Sell(price,amount) \\n    elif  flag == 3:\\n        exchange.SetDirection(\\\"closebuy\\\")\\n        id = exchange.Sell(price,amount)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y\\\")\\n        id = exchange.Sell(price,amount)\\n    return id\\n\\n#市价平仓\\ndef CreateOrderDao2(amount,flag,message):\\n    id = 0\\n    #flag: 0(买入开多仓);1(买入平空仓);2(卖出开空仓);3(卖出平多仓)\\n    if flag == 0:\\n        exchange.SetDirection(\\\"buy\\\")\\n        id = exchange.Buy(-1,amount,message)\\n    elif  flag == 1:\\n        exchange.SetDirection(\\\"closesell\\\")\\n        id = exchange.Buy(-1,amount,message)\\n    elif  flag == 2:\\n        exchange.SetDirection(\\\"sell\\\")\\n        id = exchange.Sell(-1,amount,message)\\n    elif",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   id = exchange.Sell(-1,amount,message)\\n    elif flag == 3:\\n        exchange.SetDirection(\\\"closebuy\\\")\\n        id = exchange.Sell(-1,amount,message)\\n    return id \\n\\n\\n#获取合约数位数\\ndef GetNumByAmountDao():\\n    depth = _C(exchange.GetDepth)\\n    nums = []\\n    num2s = []\\n    for ask in depth[\\\"Asks\\\"]:\\n        i = ask[\\\"Amount\\\"]\\n        num = 0\\n        if str(i).count('.') == 1:\\n            num = len(str(i).split(\\\".\\\")[1])\\n        nums.append(num)\\n        \\n        j = ask[\\\"Price\\\"]\\n        n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n        \\n        j = ask[\\\"Price\\\"]\\n        num2 = 0\\n        if str(j).count('.') == 1:\\n            num2 = len(str(j).split(\\\".\\\")[1])\\n        num2s.append(num2)\\n    num = max(nums)    \\n    _G(\\\"num\\\",num)\\n    num2 = Counter(num2s).most_common(1)[0][0]\\n    _G(\\\"num2\\\",num2)\\n    \\n    \\n    \\n#返回一个K线历史\\ndef GetRecordsDao(period,i):\\n    if period == -1:\\n        return _C(exchanges[i].GetRecords)\\n    else:\\n        return _C(exchanges[i].GetRecords,period)\\n\\n#设置币种\\ndef SetCurrencyDao(symbol,i)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rds,period)\\n\\n#设置币种\\ndef SetCurrencyDao(symbol,i):\\n    exchanges[i].SetCurrency(symbol)\\n\\n#划转资金\\ndef SetTransferDao(amount, typeEnum, symbol):\\n    exchange.SetBase(\\\"https://api.binance.com\\\")\\n    params = \\\"amount=\\\" + str(amount) + \\\"&type=\\\" + typeEnum + \\\"&asset=\\\" + symbol\\n    ret = exchange.IO(\\\"api\\\", \\\"POST\\\", \\\"/sapi/v1/asset/transfer\\\", params)\\n    Log(\\\"资金划转：划转数量为{}\\\".format(amount))\\n    exchange.SetBase(\\\"https://fapi.binance.com\\\")\\n    return ret\\n\\n\\n#获取当前未完成的所有订单\\ndef GetPendingOrder",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "return ret\\n\\n\\n#获取当前未完成的所有订单\\ndef GetPendingOrdersDao():\\n    orders = []\\n    for order in _C(exchange.GetOrders):\\n        id = order.Id\\n        price = order.Price\\n        amount = order.Amount\\n        status = order.Status\\n        newOrder = Order(id, price, amount, status)\\n        orders.append(newOrder)\\n    return orders \\n\\n#根据订单ID获取订单详情\\ndef GetOrderByIdDao(id):\\n    order = _C(exchange.GetOrder,id)\\n    id = order.Id\\n    price = order.Price\\n    amount = order.Amount\\n    status = order.Sta",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    amount = order.Amount\\n    status = order.Status\\n    newOrder = Order(id, price, amount, status)\\n    return newOrder    \\n\\n#取消某个订单\\ndef CancelOrderDao(id):\\n    if id == 0:\\n        return True\\n    flag = exchange.CancelOrder(id)\\n    if flag == True:\\n        return flag \\n    else:\\n        order =_C(exchange.GetOrder,id)\\n        if order[\\\"Status\\\"] == 0:\\n            flag = exchange.CancelOrder(id)\\n        else:\\n            flag = True\\n        return flag    \\n\\n#取消所有未完成的订单\\ndef AllCanelOrd",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   return flag    \\n\\n#取消所有未完成的订单\\ndef AllCanelOrderDao():\\n    orders = GetPendingOrdersDao()\\n    for order in orders:\\n        _C(CancelOrderDao,order.id)\\n\\n#定时器\\ndef TimerDao(m,key):\\n    value = _G(key)\\n    if value is None:\\n        value = time.time()\\n        _G(key,value)\\n        return True\\n    now = time.time()\\n    dnow = datetime.datetime.fromtimestamp(now)\\n    dvalue = datetime.datetime.fromtimestamp(int(value))\\n    c = (dnow - dvalue).total_seconds()\\n    if c - m > 0:\\n        _G(key,n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tal_seconds()\\n    if c - m > 0:\\n        _G(key,now)\\n        return True\\n    return False    \\n\\n#获取Period\\ndef GetPeriodDao():\\n    return exchange.GetPeriod()\\n\\n#获取Currency \\ndef GetCurrencyDao():\\n    return exchange.GetCurrency()\\n\\n#获取标志 \\ndef GetStopDao():\\n    i = IFLAGE\\n    return i\\n\\n#设置标志1\\ndef SetIFlageDao():\\n    global IFLAGE \\n    IFLAGE = 1  \\n\\n#定时器\\ndef TimerDao(m,key):\\n    value = _G(key)\\n    if value is None:\\n        value = time.time()\\n        _G(key,value)\\n        return True",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time()\\n        _G(key,value)\\n        return True\\n    now = time.time()\\n    dnow = datetime.datetime.fromtimestamp(now)\\n    dvalue = datetime.datetime.fromtimestamp(int(value))\\n    c = (dnow - dvalue).total_seconds()\\n    if c - m > 0:\\n        _G(key,now)\\n        return True\\n    return False        \\n#设置双向持仓\\ndef SetDualDao():\\n    dual = _C(exchange.IO,\\\"api\\\", \\\"GET\\\", \\\"/fapi/v1/positionSide/dual\\\", \\\"\\\")\\n    if dual.dualSidePosition:\\n        Log(\\\"当前账户为双向持仓模式，不需要转换持仓模式\\\")\\n    else:\\n        L",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g(\\\"当前账户为双向持仓模式，不需要转换持仓模式\\\")\\n    else:\\n        Log(\\\"当前账户为单向持仓模式，准备转双向持仓模式\\\")\\n        _C(exchange.IO,\\\"api\\\", \\\"POST\\\", \\\"/fapi/v1/positionSide/dual\\\", \\\"dualSidePosition=true\\\")\\n        Log(\\\"已转为双向持仓模式\\\")    \\n\\next.GetAccountDao = GetAccountDao\\next.GetPositionsDao = GetPositionsDao\\next.GetTickerDao = GetTickerDao\\next.CreateOrderDao = CreateOrderDao\\next.CreateOrderDao2 = CreateOrderDao2\\next.GetNumByAmountDao = GetNumByAmountDao\\next.GetRecordsDao = GetRecordsDao\\next.SetTransferDao = SetTransferDa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " GetRecordsDao\\next.SetTransferDao = SetTransferDao\\next.GetPendingOrdersDao = GetPendingOrdersDao\\next.GetOrderByIdDao = GetOrderByIdDao\\next.CancelOrderDao = CancelOrderDao\\next.TimerDao = TimerDao\\next.AllCanelOrderDao = AllCanelOrderDao\\next.GetPeriodDao = GetPeriodDao\\next.GetCurrencyDao = GetCurrencyDao\\next.GetStopDao = GetStopDao\\next.SetIFlageDao = SetIFlageDao\\next.TimerDao = TimerDao\\next.SetDualDao = SetDualDao\\next.SetCurrencyDao = SetCurrencyDao\",\n    \"策略名称: 幽灵趋势跟踪策略数据库\\n\\nimport time,datetime",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "o\",\n    \"策略名称: 幽灵趋势跟踪策略数据库\\n\\nimport time,datetime\\nimport json\\nfrom collections import Counter\\nIFLAGE = 0\\nclass Account(object):\\n    #币安账户信息实体，封装了常用的账户信息\\n    #totalWalletBalance：钱包余额\\n    #totalMarginBalance：保证金余额\\n    #totalPositionInitialMargin：持仓保证金\\n    #totalOpenOrderInitialMargin：当前挂单保证金\\n    #availableBalance: 可用余额（仅计算usdt资产）\\n    def __init__(self, totalWalletBalance, totalMarginBalance, totalPositionInitialMargin, totalOpenOrderInitialMargin, availableBalance):\\n        self.totalWalletBalanc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "availableBalance):\\n        self.totalWalletBalance = totalWalletBalance\\n        self.totalMarginBalance = totalMarginBalance\\n        self.totalPositionInitialMargin = totalPositionInitialMargin\\n        self.totalOpenOrderInitialMargin = totalOpenOrderInitialMargin \\n        self.availableBalance = availableBalance\\n        \\nclass Position(object):\\n    #币安交易对实体，封装了常用的交易对信息\\n    #entryPrice：持仓成本价\\n    #leverage：杠杆倍率\\n    #liquidationPrice：强平价格\\n    #marginType：逐仓模式或全仓模式\\n    #markPrice：标记价格\\n    #positi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "inType：逐仓模式或全仓模式\\n    #markPrice：标记价格\\n    #positionAmt：头寸数量\\n    #symbol：交易对\\n    #unRealizedProfit：持仓未实现盈亏\\n    #positionSide：持仓方向\\n    def __init__(self, entryPrice, leverage, liquidationPrice, marginType, markPrice, positionAmt, symbol, unRealizedProfit, positionSide):\\n        self.entryPrice = entryPrice\\n        self.leverage = leverage\\n        self.liquidationPrice = liquidationPrice\\n        self.marginType = marginType \\n        self.markPrice = markPrice\\n        self.positionAmt = positionAmt\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "arkPrice\\n        self.positionAmt = positionAmt\\n        self.symbol = symbol\\n        self.unRealizedProfit = unRealizedProfit\\n        self.positionSide = positionSide\\n\\nclass Ticker(object):\\n    #sell: 卖一价\\n    #buy: 买一价\\n    #last: 最后成交价格\\n    def __init__(self, sell, buy, last):\\n        self.sell = sell \\n        self.buy = buy \\n        self.last = last \\n        \\n        \\n        \\nclass Order(object):\\n    #id:订单唯一标识 \\n    #price:下单价格 \\n    #amount:下单数量 \\n    #status:订单状态--0：未完成；1：已完成；2：已经取消；3",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ount:下单数量 \\n    #status:订单状态--0：未完成；1：已完成；2：已经取消；3：未知状态\\n    def __init__(self, id, price, amount, status):\\n        self.id = id \\n        self.price = price \\n        self.amount = amount \\n        self.status = status\"\n \n\n    \"strategy_99\",\n    \"python\\n\\nimport time\\nimport requests\\nimport math\\nimport pandas as pd\\n\\nAlpha = 0.001  #指数移动平均的MA参数，设置的越大基准价格跟踪越敏感，最终持仓也会越低降低了杠杆，但会降低收益，具体根据自己需求权衡\\nUpdateBasePriceInterval = 60 #多久更新一次基准价格，单位位秒，跟Alpha相关，Alpha设置的越小，这个间隔也可以设置的更小\\nStopLossRate = 0.8 #表示当资金达到初始资金",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "置的越小，这个间隔也可以设置的更小\\nStopLossRate = 0.8 #表示当资金达到初始资金的80%时触发止损，停止策略，可以随着策略的盈利，动态设置止损位置\\nMaxDiff = 0.5  #当偏差diff大于这个值时停止加仓\\nMinDiff = -0.5  #当StopLossRate偏差Diff小于这个值时停止加仓\\nVersion = '0.0.1'\\nShow = True   #默认false 显示账户余额，true显示累计收益\\nFunding = 0    #账户资金，为0的时候自动获取，非0的时候自行设置\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\nSelfFee = 0.04   #手续费率   https:#www.binance.com/cn/fee/futureFee\\nTotalLong = 0    #做多总价值\\nTotalShort = 0   #做空总价值\\nProfit = 0       #收益\\nAccount =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hort = 0   #做空总价值\\nProfit = 0       #收益\\nAccount = {}     #保存账户信息\\nWinRateData = {}  # 存储胜率信息\\nassets = {}\\ntradeInfo = {}\\naccountAssets = {}\\nruntimeData = {}\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\ntradeSymbols = list(TradeSymbols.replace(' ','').split(','))\\nIndex = 1   #指数\\nUpdateBasePriceTime = 0\\nInitPrice = {}\\nupdateProfitTime = 0\\n\\n\\n#\\nassets['USDT'] = {'unrealised_profit':0,'margin':0,'margin_balance':0,'total_balance':0,'leverage':0,'update_time':0,'margin_ratio':0,'init_balance':",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "0,'update_time':0,'margin_ratio':0,'init_balance':0,'stop_balance':0,'short_value':0,'long_value':0,'profit':0}\\n\\nif exchange.GetName() != 'Futures_Binance':\\n    Log('只支持币安期货交易所！')\\n    exit()\\n\\ndef init():\\n    InitRateData()\\n    exchangeInfo = requests.get('https://fapi.binance.com/fapi/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法连接币安网络，需要海外托管者')\\n        exit()\\n    #Log(exchangeInfo)\\n    for i in range(len(exchangeInfo['symbols'])):\\n        if len(exchangeInfo['symbols']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mbols'])):\\n        if len(exchangeInfo['symbols'][i]['symbol'].split('_')) > 1 :continue\\n        sp = exchangeInfo['symbols'][i]['symbol'].split('_')[0]\\n        symbol = sp.replace('USDT','')\\n        #Log(sp)\\n        BUSD = sp[-4:len(sp)]\\n        if 'BUSD' != BUSD or symbol not in exchangeInfo['symbols'][i]['symbol']:   #排除BUSD交易对\\n            if symbol in tradeSymbols:\\n                assets[symbol] = {'amount': 0,'hold_price': 0,'value': 0,'bid_price': 0,'ask_price': 0,'btc_price': 0, 'btc_change':",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e': 0,'ask_price': 0,'btc_price': 0, 'btc_change': 1,'btc_diff': 0,\\n                'realised_profit': 0,'margin': 0,'unrealised_profit': 0,'leverage': 20, 'positionInitialMargin': 0,  'liquidationPrice': 0 }\\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][i]['filters'][1]['minQty']) ,\\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][i]['filters'][1][",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".1/float(exchangeInfo['symbols'][i]['filters'][1]['stepSize']))))}\\n\\n\\ndef UpdateAccount():\\n    global accountAssets ,StopLoss\\n    #判断当前是模拟交易还是实盘交易\\n    if MockTrading:\\n        Log('模拟交易更新账户')\\n\\n    else:\\n        #Log('实盘交易更新账户')\\n        account = exchange.GetAccount()\\n        ps = exchange.GetPosition()\\n        if account is None:\\n            Log('更新账户超时！')\\n            return\\n        accountAssets = account['Info']['assets']\\n        assets['USDT']['update_time'] = int(time.time() * 1000)\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "T']['update_time'] = int(time.time() * 1000)\\n        #Log(account['Info']['positions'])\\n        for i in range(len(account['Info']['positions'])):\\n            symbol = account['Info']['positions'][i]['symbol']\\n            if len(symbol.split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\\n            sp = symbol.split('_')[0]\\n            #排除掉BUSD交易对 和不在交易列表的交易对\\n            coin = sp.replace('USDT','')\\n            BUSD = sp[-4:len(sp)]\\n            if 'BUSD' == BUSD or coin not in tradeSymbols",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     if 'BUSD' == BUSD or coin not in tradeSymbols: continue\\n            #筛选单向持仓币种\\n            if account['Info']['positions'][i]['positionSide'] == 'BOTH':\\n                # if coin == 'ETH':\\n                #     Log(coin,account['Info']['positions'][i])\\n                #Log('symbol:',symbol)\\n                assets[coin]['margin'] = float(account['Info']['positions'][i]['initialMargin']) + float(account['Info']['positions'][i]['maintMargin'])\\n                assets[coin]['unrealised_profit'] = floa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          assets[coin]['unrealised_profit'] = float(account['Info']['positions'][i]['unrealizedProfit'])\\n                assets[coin]['positionInitialMargin'] = float(account['Info']['positions'][i]['positionInitialMargin'])\\n                assets[coin]['leverage'] = account['Info']['positions'][i]['leverage']\\n        #Log(assets)\\n        #计算持仓保证金总额\\n        assets['USDT']['margin'] = float(account['Info']['totalInitialMargin']) + float(account['Info']['totalMaintMargin'])\\n        assets['USDT']['margi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "totalMaintMargin'])\\n        assets['USDT']['margin_balance'] = float(account['Info']['totalMarginBalance'])\\n        assets['USDT']['total_balance'] = float(account['Info']['totalWalletBalance'])\\n        if assets['USDT']['init_balance'] == 0:\\n            if _G('init_balance'):\\n                assets['USDT']['init_balance'] = _N(_G('init_balance'),2)\\n            else:\\n                assets['USDT']['init_balance'] = assets['USDT']['total_balance']\\n                _G('init_balance',assets['USDT']['ini",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             _G('init_balance',assets['USDT']['init_balance'])\\n        #计算收益\\n        assets['USDT']['profit'] = _N(float(assets['USDT']['margin_balance']) - float(assets['USDT']['init_balance']),2)\\n        #计算止损位置\\n        assets['USDT']['stop_balance'] = _N(StopLossRate * assets['USDT']['init_balance'], 2)\\n        #计算未实现收益\\n        assets['USDT']['unrealised_profit'] = _N(float(account['Info']['totalUnrealizedProfit']),2)\\n        #计算杠杆\\n        assets['USDT']['leverage'] = _N(assets['USDT']['margin'] ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'USDT']['leverage'] = _N(assets['USDT']['margin'] / float(assets['USDT']['total_balance']))\\n        #计算保证金率\\n        assets['USDT']['margin_ratio'] = _N(float(account['Info']['totalMaintMargin']) / float(account['Info']['totalMarginBalance'])) * 100\\n        exchange.SetContractType('swap')\\n        ps = json.loads(exchange.GetRawJSON())\\n        # 更新持仓\\n        #Log('position:',ps)\\n        if len(ps) > 0:\\n            j = 1\\n            for i in range(len(ps)):\\n                #Log(ps[i])\\n             ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(ps)):\\n                #Log(ps[i])\\n                if len(ps[i]['symbol'].split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\\n                sp = ps[i]['symbol'].split('_')[0]\\n                BUSD = sp[-4:len(sp)]\\n                symbol = sp.replace('USDT','')\\n\\n\\n                if 'BUSD' == BUSD or symbol not in tradeSymbols : continue\\n                if ps[i]['positionSide'] != 'BOTH': continue\\n                assets[symbol]['hold_price'] = float(ps[i]['entryPrice'])\\n                as",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "] = float(ps[i]['entryPrice'])\\n                assets[symbol]['amount'] = float(ps[i]['positionAmt'])\\n                assets[symbol]['unrealised_profit'] = float(ps[i]['unRealizedProfit'])\\n                assets[symbol]['liquidationPrice'] = float(ps[i]['liquidationPrice'])\\n                assets[symbol]['marginType'] = ps[i]['marginType']\\n                #Log(j,assets[symbol])\\n                #j+=1\\n        #Log('实盘账户更新完毕！')\\n\\n\\ndef UpdateTick():\\n    try:\\n        ticker = requests.get('https://fap",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  try:\\n        ticker = requests.get('https://fapi.binance.com/fapi/v1/ticker/bookTicker').json()\\n    except Exception as e:\\n        Log('get ticker time out !')\\n        return\\n    assets['USDT']['long_value'] = 0\\n    assets['USDT']['short_value'] = 0\\n    for i in range(len(ticker)):\\n        sp = ticker[i]['symbol'].split('_')[0]\\n        if len(ticker[i]['symbol'].split('_')) > 1: continue   #过滤掉 例：symbol:ETHUSDT_211231  合约\\n        BUSD = sp[-4:len(sp)]\\n        symbol = sp.replace('USDT','')\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(sp)]\\n        symbol = sp.replace('USDT','')\\n        if 'BUSD' == BUSD or symbol not in tradeSymbols: continue\\n        # if symbol == 'BTCDOM':\\n        #     Log(symbol,ticker[i])\\n        #Log(ticker[i])\\n        assets[symbol]['ask_price'] = float(ticker[i]['askPrice'])\\n        assets[symbol]['bid_price'] = float(ticker[i]['bidPrice'])\\n        assets[symbol]['ask_value'] = _N(assets[symbol]['amount'] * assets[symbol]['ask_price'], 2)\\n        assets[symbol]['bid_value'] = _N(assets[symbol]['amount']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "symbol]['bid_value'] = _N(assets[symbol]['amount'] * assets[symbol]['bid_price'], 2)\\n\\n        # if symbol == 'BTCDOM':\\n        #     Log(symbol,assets[symbol])\\n        value = (assets[symbol]['ask_value'] + assets[symbol]['bid_value']) / 2\\n        if value != 0:\\n            if value > 0:\\n                assets['USDT']['long_value'] += value\\n            else:\\n                assets['USDT']['short_value'] += value\\n\\n        # if assets[symbol]['amount'] < 0:\\n        #     assets['USDT']['short_valu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t'] < 0:\\n        #     assets['USDT']['short_value'] += abs((assets[symbol]['ask_value'] + assets[symbol]['bid_price']) / 2)\\n        # else:\\n        #     assets['USDT']['long_value'] += abs((assets[symbol]['ask_value'] + assets[symbol]['bid_value']) / 2)\\n\\n        assets['USDT']['short_value']    = _N(assets['USDT']['short_value'], 2)\\n        assets['USDT']['long_value']     = _N(assets['USDT']['long_value'], 2)\\n\\n        #Log('UpdateTick:',symbol,assets[symbol])\\n    #更新指数\\n    UpdateIndex()\\n    fo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ets[symbol])\\n    #更新指数\\n    UpdateIndex()\\n    for symbol in  tradeSymbols:\\n        assets[symbol]['btc_diff'] = _N((assets[symbol]['btc_change'] - Index), 4)\\n\\n\\ndef UpdateIndex():\\n    global UpdateBasePriceTime,InitPrice,Index,Reset\\n\\n    if MockTrading:\\n        Log('模拟交易模式更新指数')\\n    else:\\n        #Log('实盘交易模式更新指数')\\n        if _G('InitPrice') is None or Reset:\\n            Reset = False\\n            for symbol in tradeSymbols:\\n                InitPrice[symbol] = (assets[symbol]['ask_price'] + as",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tPrice[symbol] = (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\\n            Log('保存启动时的价格')\\n            _G('InitPrice',InitPrice)\\n            _G('StartTime',None)\\n            _G('InitAccount_'+exchange.GetLabel(), None)\\n            _G('tradeNumber', 0) #重置交易次数\\n            _G('tradeVolume', 0) #重置交易量\\n            _G('buyNumber', 0) #重置做多次数\\n            _G('sellNumber', 0) #重置做空次数\\n            _G('totalProfit', 0) #重置打印次数\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            _G('totalProfit', 0) #重置打印次数\\n            _G('profitNumber', 0) #重置盈利次数\\n        else:\\n            InitPrice = _G('InitPrice')\\n            if int(time.time()*1000) - UpdateBasePriceTime > UpdateBasePriceInterval:\\n                UpdateBasePriceTime = int(time.time() * 1000)\\n                for symbol in tradeSymbols:\\n                    if symbol not in InitPrice: continue\\n                    InitPrice[symbol] = InitPrice[symbol] * (1 - Alpha) + Alpha * (assets[symbol]['ask_price'] + asset",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ha) + Alpha * (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\\n                    _G('InitPrice',InitPrice)\\n            temp = 0\\n            for symbol in tradeSymbols:\\n                assets[symbol]['btc_price'] = (assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / (assets['BTC']['ask_price'] + assets['BTC']['bid_price'])\\n                if symbol not in InitPrice:\\n                    Log('添加新的币种：',symbol)\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               Log('添加新的币种：',symbol)\\n                    InitPrice[symbol] = assets[symbol]['btc_price']\\n                    _G('InitPrice',InitPrice)\\n                #Log(symbol,assets[symbol]['btc_price'],InitPrice[symbol])\\n                assets[symbol]['btc_change'] = _N(assets[symbol]['btc_price'] / InitPrice[symbol], 4)\\n                temp += assets[symbol]['btc_change']\\n            Index = _N(temp / len(tradeSymbols), 4)\\n            #Log('最新指数：',Index)\\n\\n\\n#止损模块\\ndef StopLoss():\\n    if asse",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "：',Index)\\n\\n\\n#止损模块\\ndef StopLoss():\\n    if assets['USDT']['margin_balance'] < StopLossRate * assets['USDT']['init_balance'] and assets['USDT']['init_balance'] != 0:\\n        Log('出发止损！ 当前资金：',assets['USDT']['margin_balance'],'初始资金：',assets['USDT']['init_balance'])\\n        UpdateAccount()\\n        UpdateTick()\\n        Ice_value = 200 #止损的快一些，可修改\\n        trading = False\\n        for symbol in tradeSymbols:\\n            if assets[symbol]['bid_price'] == 0 : continue\\n            if assets[symbol]['bid_va",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " : continue\\n            if assets[symbol]['bid_value'] >= tradeInfo[symbol]['minQty'] * assets[symbol]['bid_price']:\\n                ## TODO: 卖出止损\\n                trading = True\\n                pass\\n            if assets[symbol]['ask_value'] <= tradeInfo[symbol]['minQty'] * assets[symbol]['ask_price']:\\n                # TODO: 买入止损\\n                trading = True\\n                pass\\n            Sleep(1000)\\n            if not trading:\\n                Log('止损结束，如果需要重新运行策略，请调低止损参数！')\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  Log('止损结束，如果需要重新运行策略，请调低止损参数！')\\n                exit()\\n    else:  # 不用止损\\n        return None\\n\\ndef Trade(symbol,direction,value):\\n    if int(time.time()) - assets['USDT']['update_time'] > 10 * 1000:\\n        Log('更新账户延迟，不进行交易！！！')\\n    else:\\n        price = assets[symbol]['bid_price'] if direction =='SELL' else assets[symbol]['ask_price']\\n        amount = _N(min(IceValue,value) / price,tradeInfo[symbol]['amountSize'])\\n        if amount < tradeInfo[symbol]['minQty']:\\n            Log(symbol,'合约价值偏离",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "symbol]['minQty']:\\n            Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n        else:\\n            # exchange.SetCurrency(symbol+'_USDT')\\n            # Log(direction)\\n            # exchange.SetDirection(direction)\\n            # f = 'Buy' if direction == 'Buy' else 'Sell'\\n            # Log(f)\\n            # place_order = getattr(exchange,direction) #获取交易对象\\n            # id = place_order(price,amount,symbol)\\n            para = ''\\n            url = '",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ymbol)\\n            para = ''\\n            url = '/fapi/v1/order'\\n            para += 'symbol='+ symbol + 'USDT'\\n            para += '&side='+ direction\\n            para += '&type=LIMIT&timeInForce=IOC'\\n            para += '&quantity='+ str(amount)\\n            para += '&price='+ str(price)\\n            para += \\\"&timestamp=\\\"+str(time.time() * 1000);\\n            go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n            ret = go.wait()\\n            if ret  is not None:\\n                logTyp",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      if ret  is not None:\\n                logType = LOG_TYPE_SELL\\n                if direction == 'BUY':\\n                    logType =LOG_TYPE_BUY\\n                exchange.Log(logType,price,amount,symbol)\\n\\n            TradingCounter('tradeVolume',amount * price)\\n            TradingCounter('tradeNumber',1)\\n            WinRateData[symbol]['tradeNumber'] += 1\\n            if direction == 'Buy':\\n                TradingCounter('buyNumber',1)\\n                WinRateData[symbol]['buyNumber'] += 1\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      WinRateData[symbol]['buyNumber'] += 1\\n            else:\\n                TradingCounter('sellNumber',1)\\n                WinRateData[symbol]['sellNumber'] += 1\\n            _G('WinRateData',WinRateData)\\n            return id\\n\\ndef FirstAccount():\\n    key = \\\"initialAccount_\\\" + exchange.GetLabel()\\n    initialAccount = _G(key)\\n    if initialAccount is None:\\n        initialAccount = exchange.GetAccount()\\n        _G(key, initialAccount)\\n    return initialAccount\\n\\ndef AppendedStatus():\\n    glo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n initialAccount\\n\\ndef AppendedStatus():\\n    global TotalLong,TotalShort,RunTime,Funding,Account\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"保证金余额\\\", \\\"已用保证金\\\", \\\"保证金比率\\\", \\\"止损\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n    feeTable = {\\n        'type': 'table',\\n        'title': '交易统计',\\n        'cols': [\\\"策略指数\\\", '交易次数', '做多次数', '做空次数', '预估胜率', '预估成交额', '预估手续费', \\\"未实现盈利\\\", '持仓总值', '做多总值', '做空总",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " '预估成交额', '预估手续费', \\\"未实现盈利\\\", '持仓总值', '做多总值', '做空总值'],\\n        'rows': []\\n    }\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if Funding == 0:\\n        Funding = float(FirstAccount()['Info']['totalWalletBalance'])\\n    profitColors = DangerColor\\n    totalProfit = assets['USDT']['total_balance'] - Funding\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday\\n    dayRate = dayProfit / Funding * 100\\n\\n    accountTable['rows",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ayProfit / Funding * 100\\n\\n    accountTable['rows'].append([\\n        runday,\\n        '$' + str(_N(Funding, 2)),\\n        '$' + str(assets['USDT']['total_balance']),\\n        '$' + str(assets['USDT']['margin_balance']),\\n        '$' + str(assets['USDT']['margin']),\\n        str(_N(assets['USDT']['margin_ratio'], 2)) + '%',\\n        str(_N(assets['USDT']['stop_balance'], 2)) + DangerColor,\\n        str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n        str(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "N(totalProfit, 2)) + (profitColors),\\n        str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n        str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n        str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n    vloume = _G('tradeVolume') if _G('tradeVolume') is not None else 0\\n\\n    feeTable['rows'].append([\\n        Index, #指数\\n        _G('tradeNumber') if _G('tradeNumber') is not None else 0, #交",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mber') if _G('tradeNumber') is not None else 0, #交易次数\\n        _G('buyNumber') if _G('buyNumber') is not None else 0, #做多次数\\n        _G('sellNumber') if _G('sellNumber') is not None else 0, #做空次数\\n        str(_N(_G('profitNumber') / _G('totalProfit') * 100, 2) if _G('totalProfit') > 0 else 0) + '%', #胜率\\n        '$' + str(_N(vloume, 2)) + ' ≈ ฿' + str(_N(vloume / ((assets['BTC']['bid_price'] + assets['BTC']['ask_price']) / 2), 6)), #成交金额\\n        '$' + str(_N(vloume * (SelfFee / 100), 4)), #手续费\\n        '$'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "N(vloume * (SelfFee / 100), 4)), #手续费\\n        '$' + str(_N(assets['USDT']['unrealised_profit'], 2)) + (SuccessColor if assets['USDT']['unrealised_profit'] >= 0 else DangerColor),\\n        '$' + str(_N(TotalLong + abs(TotalShort), 2)), #持仓总价值\\n        '$' + str(_N(TotalLong, 2)) + SuccessColor, #做多总值\\n        '$' + str(_N(abs(TotalShort), 2)) + DangerColor, #做空总值\\n    ])\\n\\n    assetTable = {\\n        'type': 'table',\\n        'title': '账户资产信息',\\n        'cols': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ls': ['编号', '资产名', '起始保证金', '维持保证金', '保证金余额', '最大可提款金额', '挂单起始保证金', '持仓起始保证金', '持仓未实现盈亏', '账户余额'],\\n        'rows': []\\n    }\\n    for i in range(len(accountAssets)):\\n        acc = accountAssets[i]\\n        assetTable['rows'].append([\\n            i + 1,\\n            acc['asset'], acc['initialMargin'], acc['maintMargin'], acc['marginBalance'],\\n            acc['maxWithdrawAmount'], acc['openOrderInitialMargin'], acc['positionInitialMargin'],\\n            acc['unrealizedProfit'], acc['walletBalance']\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "c['unrealizedProfit'], acc['walletBalance']\\n        ])\\n    indexTable = {\\n        'type': 'table',\\n        'title': '币指数信息',\\n        'cols': ['编号', '币种信息', '当前价格', 'BTC计价', 'BTC计价变化(%)', '偏离平均', '交易次数', '做空次数', '做多次数', '预估胜率'],\\n        'rows': []\\n    }\\n\\n    i = 0\\n    for symbol in tradeSymbols :\\n        price = _N((assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / 2, tradeInfo[symbol]['priceSize'])\\n        if symbol not in tradeSymbols:\\n            indexTable['rows'].append([i + 1, s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n            indexTable['rows'].append([i + 1, symbol, price, assets[symbol]['btc_price'], _N((1 - assets[symbol]['btc_change']) * 100), assets[symbol]['btc_diff']], 0, 0, 0, '0%')\\n        else:\\n            i += 1\\n            WinRateData = _G(\\\"WinRateData\\\")\\n            winRated = _N(WinRateData[symbol]['profitNumber'] / WinRateData[symbol]['totalProfit'] * 100, 2) if WinRateData[symbol]['totalProfit'] > 0 else 0\\n            indexTable['rows'].append([\\n                i,\\n                symbol + W",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "([\\n                i,\\n                symbol + WrningColor,\\n                price,\\n                _N(assets[symbol]['btc_price'], 6),\\n                _N((1 - assets[symbol]['btc_change']) * 100),\\n                str(assets[symbol]['btc_diff']) + (SuccessColor if assets[symbol]['btc_diff'] >= 0 else DangerColor),\\n                WinRateData[symbol]['tradeNumber'],\\n                WinRateData[symbol]['sellNumber'],\\n                WinRateData[symbol]['buyNumber'],\\n                (str(winRated) if ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "['buyNumber'],\\n                (str(winRated) if WinRateData[symbol]['profitNumber'] > 0 and WinRateData[symbol]['totalProfit'] > 0 else '0') + '%' + (SuccessColor if winRated >= 50 else DangerColor), #胜率\\n            ])\\n    retData = {}\\n    #Log(runtimeData['str'])\\n    #retData['upTable'] = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version + '\\\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\\\n' + '`' + json.dumps(feeTable) + '`\\\\n'\\n    retData['upTable'] = runtimeDa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "able) + '`\\\\n'\\n    retData['upTable'] = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n' + '`' + json.dumps([accountTable, assetTable]) + '`\\\\n' + '`' + json.dumps(feeTable) + '`\\\\n'\\n    retData['indexTable'] = indexTable\\n    return retData\\n\\n\\n\\ndef UpdateStatus():\\n    global TotalLong,TotalShort,updateProfitTime,Funding,Profit\\n    TotalLong = 0\\n    TotalShort = 0\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 'title': '交易对信息',\\n        'cols': ['编号', '[模式][倍数]', '币种信息', '开仓方向', '开仓数量', '持仓价格', '当前价格', '强平价格', '强平差价', '持仓价值', '保证金', '未实现盈亏', '投降'],\\n        'rows': []\\n    }\\n    i = 0\\n    for symbol in tradeSymbols:\\n        i += 1\\n        direction = '空仓'\\n        margin = direction\\n        if assets[symbol]['amount'] != 0:\\n            direction = '做多' + SuccessColor if assets[symbol]['amount'] > 0 else '做空' + DangerColor\\n            margin = '全仓' if assets[symbol]['marginType'] == 'cross' else '逐仓'\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s[symbol]['marginType'] == 'cross' else '逐仓'\\n        price = _N((assets[symbol]['ask_price'] + assets[symbol]['bid_price']) / 2 ,tradeInfo[symbol]['priceSize'])\\n        value = _N((assets[symbol]['ask_value'] + assets[symbol]['bid_value'])/2 , 2)\\n        if value != 0:\\n            if value > 0:\\n                TotalLong += value\\n            else:\\n                TotalShort += value\\n        unrealised_profit_color = '#000000'\\n        if assets[symbol]['unrealised_profit'] > 0:\\n            unrealise",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]['unrealised_profit'] > 0:\\n            unrealised_profit_color = SuccessColor\\n        if assets[symbol]['unrealised_profit'] < 0:\\n            unrealised_profit_color = DangerColor\\n        infoList = [\\n            i,\\n            '['+ margin +']' +'[' + str(assets[symbol]['leverage']) +'X]',\\n            symbol,\\n            direction,\\n            abs(assets[symbol]['amount']),\\n            assets[symbol]['hold_price'],\\n            price,\\n            assets[symbol]['liquidationPrice'],\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " assets[symbol]['liquidationPrice'],\\n            '0' if assets[symbol]['liquidationPrice'] == 0 else '$' + str(_N(assets[symbol]['liquidationPrice'] - price, 5)) + ' ≈ ' + str(_N(assets[symbol]['liquidationPrice'] / price * 100, 2)) + '%' + WrningColor, #强平价格\\n            abs(value),\\n            _N(assets[symbol]['positionInitialMargin'],2),\\n            str(_N(assets[symbol]['unrealised_profit'], 3)) + unrealised_profit_color,\\n          \\n                'type': 'button',\\n                'cmd': '说好的没有撤",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 'type': 'button',\\n                'cmd': '说好的没有撤退可言呢？？?:' + symbol + ':' + str(assets[symbol]['amount']) + ':',\\n                'name': symbol + ' 投降'\\n            }\\n\\n        ]\\n        table['rows'].append(infoList)\\n        logString = json.dumps(assets['USDT'])\\n\\n        StatusData = AppendedStatus()\\n        LogStatus(StatusData['upTable'] + '`' + json.dumps([table, StatusData['indexTable']]) + '`\\\\n' + logString)\\n        # LogStatus('`' + json.dumps([table, StatusData['indexTable']]) + '`\\\\n' + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mps([table, StatusData['indexTable']]) + '`\\\\n' + logString)\\n\\n        if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n            balance = assets['USDT']['total_balance']\\n            if Show:\\n                balance = assets['USDT']['total_balance'] - Funding\\n            LogProfit(_N(balance, 3), '&')\\n            updateProfitTime = int(time.time()*1000)\\n            if Profit != 0 and (_N(balance, 0) != Profit): #第一次不计算,并且小数点面的不进行胜率计算\\n                TradingCounter(\\\"totalProfit\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "计算\\n                TradingCounter(\\\"totalProfit\\\", 1) #统计打印次数, 胜率=盈利次数/打印次数*100\\n                if _N(balance, 0) > Profit:\\n                    TradingCounter('profitNumber', 1) #盈利次数\\n                WinRate()\\n            Profit = _N(balance,0)\\n\\n\\n# 策略主逻辑\\ndef Process():\\n    # UpdateTick()\\n    for symbol in tradeSymbols:\\n        if assets[symbol]['ask_price'] == 0 : continue\\n        aim_value = -TradeValue * _N(assets[symbol]['btc_diff'] / 0.01 ,3)  #计算偏离1%需要加的仓位\\n        #偏移仓位 - 持有仓位 > 偏离加仓阈值 并且",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")  #计算偏离1%需要加的仓位\\n        #偏移仓位 - 持有仓位 > 偏离加仓阈值 并且 diff > 预设最小加仓值 并且 多方仓位 - 空方仓位 小于等于 1.1倍的 偏离加仓  则进行开多仓\\n        # if symbol == 'IOTA':\\n        #     Log(symbol,aim_value - assets[symbol]['ask_value'])\\n        if (aim_value - assets[symbol]['ask_value']) >= DeviateValue and assets[symbol]['btc_diff'] > MinDiff :\\n            Log('做多',symbol,'   aim_value:',aim_value,'   ask_value:',assets[symbol]['ask_value'],'amount:',(aim_value - assets[symbol]['ask_value']), '   偏离平均:',assets[symbol]['btc_diff'])\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ue']), '   偏离平均:',assets[symbol]['btc_diff'])\\n            Trade(symbol,'BUY',aim_value - assets[symbol]['ask_value'])\\n        if (aim_value - assets[symbol]['bid_value']) <= -DeviateValue and assets[symbol]['btc_diff'] < MaxDiff:\\n            Log('做空',symbol,'   aim_value:',aim_value,'   ask_value:',assets[symbol]['ask_value'],'amount:',(aim_value - assets[symbol]['bid_value']),  '   偏离平均:',assets[symbol]['btc_diff'])\\n            Trade(symbol,'SELL',-(aim_value - assets[symbol]['bid_value']) )\\n\\n\\n# 保存交",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_value - assets[symbol]['bid_value']) )\\n\\n\\n# 保存交易量\\ndef TradingCounter(key,newValue):\\n    value = _G(key)\\n    if value is None:\\n        _G(key,newValue)\\n    else:\\n        _G(key,value + newValue)\\n\\n\\ndef WinRate():\\n    global WinRateData\\n    for symbol in tradeSymbols:\\n        unrealised = assets[symbol]['unrealised_profit']\\n        WinRateData[symbol]['totalProfit'] += 1\\n        if unrealised != 0:\\n            if unrealised > 0:\\n                WinRateData[symbol]['profitNumber'] += 1\\n    _",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   WinRateData[symbol]['profitNumber'] += 1\\n    _G(\\\"WinRateData\\\", WinRateData)\\n\\n#更新胜率信息\\ndef InitRateData():\\n    global WinRateData\\n    if Reset:\\n        _G('WinRateData',None)\\n    if _G('WinRateData'):\\n        WinRateData = _G('WinRateData')\\n    for symbols in tradeSymbols:\\n        if symbols not in WinRateData:\\n                                 #统计次数        #盈利次数          #交易次数       #做多次数        #做空次数\\n            WinRateData[symbols] = {'totalProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lProfit': 0, 'profitNumber': 0,'tradeNumber': 0,'buyNumber': 0, 'sellNumber': 0}\\n    _G('WinRateData',WinRateData)\\n #获取或创建策略第一次启动时间\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) *",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\n\\n\\ndef main():\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nutes) + '分钟'\\n    return ret\\n\\n\\n\\ndef main():\\n    exchange.SetContractType('swap')\\n    exchange.SetMarginLevel(20)\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #止损模块\\n        StopLoss()\\n        #策略逻辑\\n        Process()\\n        #输出状态栏信息\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   #策略逻辑\\n        Process()\\n        #输出状态栏信息\\n        UpdateStatus()\\n\\n        Sleep(Interval * 1000)\",\n    \"策略名称: 指数对冲修罗场-001\\n\\nassets = {}\\ntradeInfo = {}\\naccountAssets = {}\\nruntimeData = {}\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\ntradeSymbols = list(TradeSymbols.replace(' ','').split(','))\\nIndex = 1   #指数\\nUpdateBasePriceTime = 0\\nInitPrice = {}\\nupdateProfitTime = 0\"\n \n\n    \"strategy_100\",\n    \"python\\n# 0级：核心工具函数\\n# 1级：应用层函数(通过0级核心函数实现）\\n# 2级：技术指标函数(全部通过0级，1级函数实现）\\n\\nimport math\\nimp",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "现）\\n# 2级：技术指标函数(全部通过0级，1级函数实现）\\n\\nimport math\\nimport numpy as np\\nimport pandas as pd\\n\\n\\n#------------------ 0级：核心工具函数 --------------------------------------------      \\ndef RD(N,D=3):   return np.round(N,D)        #四舍五入取3位小数 \\ndef RET(S,N=1):  return np.array(S)[-N]      #返回序列倒数第N个值,默认返回最后一个\\ndef ABS(S):      return np.abs(S)            #返回N的绝对值\\ndef MAX(S1,S2):  return np.maximum(S1,S2)    #序列max\\ndef MIN(S1,S2):  return np.minimum(S1,S2)    #序列min\\n         \\ndef MA(S,N):              #求序列的N日平均值，返回序列",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       \\ndef MA(S,N):              #求序列的N日平均值，返回序列                    \\n    return pd.Series(S).rolling(N).mean().values    \\n\\n#引用X在N个周期前的值\\n#例如：REF(CLOSE,5)  #表示引用当前周期的前第5个周期的收盘价，如果是日线周期，即为第5个交易日前的收盘价\\ndef REF(S, N=1):          #对序列整体下移动N,返回序列(shift后会产生NAN)    \\n    return pd.Series(S).shift(N).values  \\n\\ndef DIFF(S, N=1):         #前一个值减后一个值,前面会产生nan \\n    return pd.Series(S).diff(N)  #np.diff(S)直接删除nan，会少一行\\n\\ndef STD(S,N):             #求序列的N日标准差，返回序列    \\n    return  pd.Series(S).rolling(N).std(ddof=0)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n    return  pd.Series(S).rolling(N).std(ddof=0).values     \\n\\ndef IF(S_BOOL,S_TRUE,S_FALSE):   #序列布尔判断 return=S_TRUE if S_BOOL==True  else  S_FALSE\\n    return np.where(S_BOOL, S_TRUE, S_FALSE)\\n\\ndef SUM(S, N):            #对序列求N天累计和，返回序列    N=0对序列所有依次求和         \\n    return pd.Series(S).rolling(N).sum().values if N>0 else pd.Series(S).cumsum()  \\n\\ndef HHV(S,N):             # HHV(C, 5)  # 最近5天收盘最高价        \\n    return pd.Series(S).rolling(N).max().values     \\n\\ndef LLV(S,N):             # LLV(C, 5)  #",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s     \\n\\ndef LLV(S,N):             # LLV(C, 5)  # 最近5天收盘最低价     \\n    return pd.Series(S).rolling(N).min().values    \\n\\ndef EMA(S,N):             #指数移动平均,为了精度 S>4*N  EMA至少需要120周期     alpha=2/(span+1)    \\n    return pd.Series(S).ewm(span=N, adjust=False).mean().values     \\n\\ndef SMA(S, N, M=1):        #中国式的SMA,至少需要120周期才精确 (雪球180周期)    alpha=1/(1+com)\\n    return pd.Series(S).ewm(com=N-M, adjust=True).mean().values     \\n\\ndef AVEDEV(S,N):           #平均绝对偏差  (序列与其平均值的绝对差的平均值)   \\n    return pd.Series(S).",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "偏差  (序列与其平均值的绝对差的平均值)   \\n    return pd.Series(S).rolling(N).apply(lambda x: (np.abs(x - x.mean())).mean()).values \\n\\ndef SLOPE(S,N,RS=False):    #返S序列N周期回线性回归斜率 (默认只返回斜率,不返回整个直线序列)\\n    M=pd.Series(S[-N:]);   poly = np.polyfit(M.index, M.values,deg=1);    Y=np.polyval(poly, M.index); \\n    if RS: return Y[1]-Y[0],Y\\n    return Y[1]-Y[0]\\n\\n  \\n#------------------   1级：应用层函数(通过0级核心函数实现） ----------------------------------\\ndef COUNT(S_BOOL, N):                  # COUNT(CLOSE>O, N):  最近N天满足S_BOO的天数  True的天数\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    # COUNT(CLOSE>O, N):  最近N天满足S_BOO的天数  True的天数\\n    return SUM(S_BOOL,N)    \\n\\ndef EVERY(S_BOOL, N):                  # EVERY(CLOSE>O, 5)   最近N天是否都是True\\n    R=SUM(S_BOOL, N)\\n    return  IF(R==N, True, False)\\n  \\ndef LAST(S_BOOL, A, B):                #从前A日到前B日一直满足S_BOOL条件   \\n    if A<B: A=B                        #要求A>B    例：LAST(CLOSE>OPEN,5,3)  5天前到3天前是否都收阳线     \\n    return S_BOOL[-A:-B].sum()==(A-B)  #返回单个布尔值    \\n\\ndef EXIST(S_BOOL, N=5):                # EXIST(CLOSE>3010, N=5)  n日内是否存在一天大于3000",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         # EXIST(CLOSE>3010, N=5)  n日内是否存在一天大于3000点\\n    R=SUM(S_BOOL,N)    \\n    return IF(R>0, True ,False)\\n\\ndef BARSLAST(S_BOOL):                  #上一次条件成立到当前的周期  \\n    M=np.argwhere(S_BOOL);             # BARSLAST(CLOSE/REF(CLOSE)>=1.1) 上一次涨停到今天的天数\\n    return len(S_BOOL)-int(M[-1])-1  if M.size>0 else -1\\n\\ndef FORCAST(S,N):                      #返S序列N周期回线性回归后的预测值\\n    K,Y=SLOPE(S,N,RS=True)\\n    return Y[-1]+K\\n  \\ndef CROSS(S1,S2):                      #判断穿越 CROSS(MA(C,5),MA(C,10))               \\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #判断穿越 CROSS(MA(C,5),MA(C,10))               \\n    CROSS_BOOL=IF(S1>S2, True ,False)   \\n    return COUNT(CROSS_BOOL>0,2)==1    #上穿：昨天0 今天1   下穿：昨天1 今天0\\n\\n\\n\\n#------------------   2级：技术指标函数(全部通过0级，1级函数实现） ------------------------------\\ndef MACD(CLOSE,SHORT=12,LONG=26,M=9):            # EMA的关系，S取120日，和雪球小数点2位相同\\n    DIF = EMA(CLOSE,SHORT)-EMA(CLOSE,LONG);  \\n    DEA = EMA(DIF,M);      MACD=(DIF-DEA)*2\\n    return RD(DIF),RD(DEA),RD(MACD)\\n\\ndef KDJ(CLOSE,HIGH,LOW, N=9,M1=3,M2=3):         # KDJ指标\\n    R",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "E,HIGH,LOW, N=9,M1=3,M2=3):         # KDJ指标\\n    RSV = (CLOSE - LLV(LOW, N)) / (HHV(HIGH, N) - LLV(LOW, N)) * 100\\n    K = EMA(RSV, (M1*2-1));    D = EMA(K,(M2*2-1));        J=K*3-D*2\\n    return K, D, J\\n\\ndef RSI(CLOSE, N=24):                           # RSI指标,和通达信小数点2位相同\\n    DIF = CLOSE-REF(CLOSE,1) \\n    return RD(SMA(MAX(DIF,0), N) / SMA(ABS(DIF), N) * 100)  \\n\\ndef WR(CLOSE, HIGH, LOW, N=10, N1=6):            #W&R 威廉指标\\n    WR = (HHV(HIGH, N) - CLOSE) / (HHV(HIGH, N) - LLV(LOW, N)) * 100\\n    WR1 = (",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " / (HHV(HIGH, N) - LLV(LOW, N)) * 100\\n    WR1 = (HHV(HIGH, N1) - CLOSE) / (HHV(HIGH, N1) - LLV(LOW, N1)) * 100\\n    return RD(WR), RD(WR1)\\n\\ndef BIAS(CLOSE,L1=6, L2=12, L3=24):              # BIAS乖离率\\n    BIAS1 = (CLOSE - MA(CLOSE, L1)) / MA(CLOSE, L1) * 100\\n    BIAS2 = (CLOSE - MA(CLOSE, L2)) / MA(CLOSE, L2) * 100\\n    BIAS3 = (CLOSE - MA(CLOSE, L3)) / MA(CLOSE, L3) * 100\\n    return RD(BIAS1), RD(BIAS2), RD(BIAS3)\\n\\ndef BOLL(CLOSE,N=20, P=2):                       #BOLL指标，布林带    \\n    MID = MA(CLOSE, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "             #BOLL指标，布林带    \\n    MID = MA(CLOSE, N); \\n    UPPER = MID + STD(CLOSE, N) * P\\n    LOWER = MID - STD(CLOSE, N) * P\\n    return RD(UPPER), RD(MID), RD(LOWER)    \\n\\ndef PSY(CLOSE,N=12, M=6):  \\n    PSY=COUNT(CLOSE>REF(CLOSE,1),N)/N*100\\n    PSYMA=MA(PSY,M)\\n    return RD(PSY),RD(PSYMA)\\n\\ndef CCI(CLOSE,HIGH,LOW,N=20):  \\n    TP=(HIGH+LOW+CLOSE)/3\\n    return (TP-MA(TP,N))/(0.015*AVEDEV(TP,N))\\n        \\ndef ATR(CLOSE,HIGH,LOW, N=20):                    #真实波动N日平均值\\n    TR = MAX(MAX((HIGH - LOW),",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        #真实波动N日平均值\\n    TR = MAX(MAX((HIGH - LOW), ABS(REF(CLOSE, 1) - HIGH)), ABS(REF(CLOSE, 1) - LOW))\\n    return MA(TR, N)\\n\\ndef BBI(CLOSE,M1=3,M2=6,M3=12,M4=20):             #BBI多空指标   \\n    return (MA(CLOSE,M1)+MA(CLOSE,M2)+MA(CLOSE,M3)+MA(CLOSE,M4))/4    \\n\\ndef DMI(CLOSE,HIGH,LOW,M1=14,M2=6):               #动向指标：结果和同花顺，通达信完全一致\\n    TR = SUM(MAX(MAX(HIGH - LOW, ABS(HIGH - REF(CLOSE, 1))), ABS(LOW - REF(CLOSE, 1))), M1)\\n    HD = HIGH - REF(HIGH, 1);     LD = REF(LOW, 1) - LOW\\n    DMP = SUM(IF((HD >",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    LD = REF(LOW, 1) - LOW\\n    DMP = SUM(IF((HD > 0) & (HD > LD), HD, 0), M1)\\n    DMM = SUM(IF((LD > 0) & (LD > HD), LD, 0), M1)\\n    PDI = DMP * 100 / TR;         MDI = DMM * 100 / TR\\n    ADX = MA(ABS(MDI - PDI) / (PDI + MDI) * 100, M2)\\n    ADXR = (ADX + REF(ADX, M2)) / 2\\n    return PDI, MDI, ADX, ADXR  \\n\\ndef TAQ(HIGH,LOW,N):                               #唐安奇通道(海龟)交易指标，大道至简，能穿越牛熊\\n    UP=HHV(HIGH,N);    DOWN=LLV(LOW,N);    MID=(UP+DOWN)/2\\n    return UP,MID,DOWN\\n\\ndef KTN(CLOSE,HIGH,LOW,N=20,M=10)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n UP,MID,DOWN\\n\\ndef KTN(CLOSE,HIGH,LOW,N=20,M=10):                 #肯特纳交易通道, N选20日，ATR选10日\\n    MID=EMA((HIGH+LOW+CLOSE)/3,N)\\n    ATRN=ATR(CLOSE,HIGH,LOW,M)\\n    UPPER=MID+2*ATRN;   LOWER=MID-2*ATRN\\n    return UPPER,MID,LOWER       \\n  \\ndef TRIX(CLOSE,M1=12, M2=20):                      #三重指数平滑平均线\\n    TR = EMA(EMA(EMA(CLOSE, M1), M1), M1)\\n    TRIX = (TR - REF(TR, 1)) / REF(TR, 1) * 100\\n    TRMA = MA(TRIX, M2)\\n    return TRIX, TRMA\\n\\ndef VR(CLOSE,VOL,M1=26):                            #VR容量比率\\n    L",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",M1=26):                            #VR容量比率\\n    LC = REF(CLOSE, 1)\\n    return SUM(IF(CLOSE > LC, VOL, 0), M1) / SUM(IF(CLOSE <= LC, VOL, 0), M1) * 100\\n\\ndef EMV(HIGH,LOW,VOL,N=14,M=9):                     #简易波动指标 \\n    VOLUME=MA(VOL,N)/VOL;       MID=100*(HIGH+LOW-REF(HIGH+LOW,1))/(HIGH+LOW)\\n    EMV=MA(MID*VOLUME*(HIGH-LOW)/MA(HIGH-LOW,N),N);    MAEMV=MA(EMV,M)\\n    return EMV,MAEMV\\n\\n\\ndef DPO(CLOSE,M1=20, M2=10, M3=6):                  #区间震荡线\\n    DPO = CLOSE - REF(MA(CLOSE, M1), M2);    MADPO = MA(D",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = CLOSE - REF(MA(CLOSE, M1), M2);    MADPO = MA(DPO, M3)\\n    return DPO, MADPO\\n\\ndef BRAR(OPEN,CLOSE,HIGH,LOW,M1=26):                 #BRAR-ARBR 情绪指标  \\n    AR = SUM(HIGH - OPEN, M1) / SUM(OPEN - LOW, M1) * 100\\n    BR = SUM(MAX(0, HIGH - REF(CLOSE, 1)), M1) / SUM(MAX(0, REF(CLOSE, 1) - LOW), M1) * 100\\n    return AR, BR\\n\\ndef DMA(CLOSE,N1=10,N2=50,M=10):                     #平行线差指标  \\n    DIF=MA(CLOSE,N1)-MA(CLOSE,N2);    DIFMA=MA(DIF,M)\\n    return DIF,DIFMA\\n\\ndef MTM(CLOSE,N=12,M=6):                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",DIFMA\\n\\ndef MTM(CLOSE,N=12,M=6):                             #动量指标\\n    MTM=CLOSE-REF(CLOSE,N);         MTMMA=MA(MTM,M)\\n    return MTM,MTMMA\\n\\ndef MASS(HIGH,LOW,N1=9,N2=25,M=6):                   # 梅斯线\\n    MASS=SUM(MA(HIGH-LOW,N1)/MA(MA(HIGH-LOW,N1),N1),N2)\\n    MA_MASS=MA(MASS,M)\\n    return MASS,MA_MASS\\n  \\ndef ROC(CLOSE,N=12,M=6):                             #变动率指标\\n    ROC=100*(CLOSE-REF(CLOSE,N))/REF(CLOSE,N);    MAROC=MA(ROC,M)\\n    return ROC,MAROC  \\n\\ndef EXPMA(CLOSE,N1=12,N2=50):            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ROC  \\n\\ndef EXPMA(CLOSE,N1=12,N2=50):                        #EMA指数平均数指标\\n    return EMA(CLOSE,N1),EMA(CLOSE,N2);\\n\\ndef OBV(CLOSE,VOL):                                  #能量潮指标\\n    return SUM(IF(CLOSE>REF(CLOSE,1),VOL,IF(CLOSE<REF(CLOSE,1),-VOL,0)),0)/10000\\n\\ndef MFI(CLOSE,HIGH,LOW,VOL,N=14):                    #MFI指标是成交量的RSI指标\\n    TYP = (HIGH + LOW + CLOSE)/3\\n    V1=SUM(IF(TYP>REF(TYP,1),TYP*VOL,0),N)/SUM(IF(TYP<REF(TYP,1),TYP*VOL,0),N)  \\n    return 100-(100/(1+V1))     \\n  \\ndef ASI(OPEN,CLOSE,HIGH,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "00-(100/(1+V1))     \\n  \\ndef ASI(OPEN,CLOSE,HIGH,LOW,M1=26,M2=10):            #振动升降指标\\n    LC=REF(CLOSE,1);      AA=ABS(HIGH-LC);     BB=ABS(LOW-LC);\\n    CC=ABS(HIGH-REF(LOW,1));   DD=ABS(LC-REF(OPEN,1));\\n    R=IF( (AA>BB) & (AA>CC),AA+BB/2+DD/4,IF( (BB>CC) & (BB>AA),BB+AA/2+DD/4,CC+DD/4));\\n    X=(CLOSE-LC+(CLOSE-OPEN)/2+LC-REF(OPEN,1));\\n    SI=16*X/R*MAX(AA,BB);   ASI=SUM(SI,M1);   ASIT=MA(ASI,M2);\\n    return ASI,ASIT  \\n\\ndef VWAP(CLOSE,VOL,HIGH,LOW,N=14):                    #交易量加权平均价格\\n    TYP = (H",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "N=14):                    #交易量加权平均价格\\n    TYP = (HIGH + LOW + CLOSE)/3\\n    VWAP = SUM(VOL*TYP, N) / SUM(VOL, N)\\n    return VWAP\\n\\n\\next.MACD = MACD \\next.KDJ = KDJ\\next.RSI = RSI\\next.WR = WR\\next.BIAS = BIAS\\next.BOLL = BOLL\\next.PSY = PSY\\next.CCI = CCI    \\next.ATR = ATR\\next.BBI = BBI\\next.DMI = DMI\\next.TAQ = TAQ\\next.KTN = KTN\\next.TRIX = TRIX\\next.VR = VR\\next.EMV = EMV\\next.DPO = DPO\\next.BRAR = BRAR\\next.DMA = DMA\\next.MTM = MTM\\next.MASS = MASS\\next.ROC = ROC\\next.EXPMA = EXPMA\\next.OBV = OBV\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "next.ROC = ROC\\next.EXPMA = EXPMA\\next.OBV = OBV\\next.MFI = MFI\\next.ASI = ASI\\next.VWAP = VWAP\",\n    \"策略名称: 指标库python版\\n\\n# 1级：应用层函数(通过0级核心函数实现）\"\n \n\n    \"strategy_101\",\n    \"python\\ndef onTick():\\n\\t\\n\\texchange_count = len(exchanges)\\n\\tfor i in range(exchange_count):\\n\\t\\taccount = exchanges[i].GetAccount()\\n\\n\\t\\tmarketName = exchanges[i].GetName()\\n\\t\\tdepth = exchanges[i].GetDepth()\\n\\t\\tLog(\\\"Market \\\",marketName,exchanges[i].GetCurrency(),\\\"Account Balance [\\\",account[\\\"Balance\\\"],\\\"] Stocks[\\\",acco",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "alance [\\\",account[\\\"Balance\\\"],\\\"] Stocks[\\\",account[\\\"Stocks\\\"],\\\"]\\\")\\n\\t\\tif account and depth and account[\\\"Balance\\\"] > accountLimitMoney :\\n\\t\\t\\tbidPrice = depth[\\\"Asks\\\"][0][\\\"Price\\\"] \\n\\t\\t\\tif bidPrice <  maxBidPrice :\\n\\t\\t\\t\\tamount = orderAmount\\n\\t\\t\\t\\tif amount <= account[\\\"Balance\\\"]:\\n\\t\\t\\t\\t\\texchanges[i].Buy(amount)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tLog(\\\"Account Balance is less than bid Amount\\\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tLog(\\\"Bid Price >= maxBidPrice, not process\\\")\\n\\t\\telse:\\n\\t\\t\\tLog(\\\"Acc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "dPrice, not process\\\")\\n\\t\\telse:\\n\\t\\t\\tLog(\\\"Account Balance <= accountLimitMoney\\\")\\ndef main() :\\n\\twhile 1:\\n\\t\\t\\n\\t\\tonTick()\\n\\t\\ttime.sleep(orderTimeInterval)\",\n    \"策略名称: 数字货币定投\\n\\norderAmount #定投金额 BTCCNY和BCCCNY 单位 CNY, BCCBTC 单位 BTC 等等\\n\\naccountLimitMoney #账户限额,保留一部分钱，账户达到最低限额就停止定投\\n\\n\\norderTimeInterval #定投间隔,单位秒, 每分钟=60 每小时= 3600  每天=86400 每周=604800\\n\\nmaxBidPrice  #最大交易价格，超过价格就跳过，等待下次交易机会出现\\n\\n> Strategy Arguments\\n\\n\\n\\n|Argument|Default|Description|\\n|----|----|----|\\n|orderAmount|true|ord",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cription|\\n|----|----|----|\\n|orderAmount|true|order amount|\\n|maxBidPrice|false|max bid price|\\n|accountLimitMoney|false|account limit money|\\n|orderTimeInterval|60|Order Time Interval|\\n\\n\\n> Source (python)\\n\\n``` python\\ndef onTick():\\n\\t\\n\\texchange_count = len(exchanges)\\n\\tfor i in range(exchange_count):\\n\\t\\taccount = exchanges[i].GetAccount()\\n\\n\\t\\tmarketName = exchanges[i].GetName()\\n\\t\\tdepth = exchanges[i].GetDepth()\\n\\t\\tLog(\\\"Market \\\",marketName,exchanges[i].GetCurrency(),\\\"Account Balance [",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ame,exchanges[i].GetCurrency(),\\\"Account Balance [\\\",account[\\\"Balance\\\"],\\\"] Stocks[\\\",account[\\\"Stocks\\\"],\\\"]\\\")\\n\\t\\tif account and depth and account[\\\"Balance\\\"] > accountLimitMoney :\\n\\t\\t\\tbidPrice = depth[\\\"Asks\\\"][0][\\\"Price\\\"] \\n\\t\\t\\tif bidPrice <  maxBidPrice :\\n\\t\\t\\t\\tamount = orderAmount\\n\\t\\t\\t\\tif amount <= account[\\\"Balance\\\"]:\\n\\t\\t\\t\\t\\texchanges[i].Buy(amount)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tLog(\\\"Account Balance is less than bid Amount\\\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tLog(\\\"Bid Price >= maxBidPrice, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t\\telse:\\n\\t\\t\\t\\tLog(\\\"Bid Price >= maxBidPrice, not process\\\")\\n\\t\\telse:\\n\\t\\t\\tLog(\\\"Account Balance <= accountLimitMoney\\\")\\ndef main() :\\n\\twhile 1:\\n\\t\\t\\n\\t\\tonTick()\\n\\t\\ttime.sleep(orderTimeInterval)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/54256\\n\\n> Last Modified\\n\\n2017-09-08 14:43:38\"\n \n\n    \"strategy_102\",\n    \"python\\n#!python2\\n# -*- coding:utf-8 -*-\\n'''\\n主要是使用发明者量化API进行网格买卖，当前只支持单品网格买卖\\n'''\\nfrom time import sleep\\nimport datetime,copy\\n\\nsale_price_list = [] #卖出的价格列表\\nbuy_price_l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "copy\\n\\nsale_price_list = [] #卖出的价格列表\\nbuy_price_list = []  #买入的价格列表\\n\\nclass fmz_market():\\n    def get_data_depth(self):\\n        data_depth = exchange.GetDepth()\\n        return data_depth\\n\\n\\n\\n    #检查当前是否可以进行买卖操作\\n    def make_trade_check(self,symbol):\\n        trade_infor = {'price':0,'trade_type':''}\\n        #进行买卖列表判断，先更新交易记录列表\\n        trade_price_list = self.get_trade_price_list(symbol)\\n        sale_price_list = trade_price_list[0]\\n        buy_price_list = trade_price_list[1]\\n        #获取深度数据\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rice_list = trade_price_list[1]\\n        #获取深度数据\\n        data_depth = self.get_data_depth()\\n        #买单列表：\\n        data_depth_bids = data_depth.Bids[0]\\n        #卖单列表：\\n        data_depth_asks = data_depth.Asks[0]\\n        #如果买入记录不为空\\n        sale_buy_diff_now = two_distance*len(sale_price_list) if len(sale_price_list) >0 else sale_buy_diff\\n        sale_buy_diff_sale = two_distance if len(sale_price_list) > 0 else sale_buy_diff\\n        # sale_price_last = float(sale_price_list[len(sale_price_list)-1]) ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = float(sale_price_list[len(sale_price_list)-1]) if len(sale_price_list) >0 else base_price\\n        # buy_price_last = float(buy_price_list[len(buy_price_list)-1]) if len(buy_price_list) >0 else base_price\\n        sale_price_last = float(sale_price_list[0]) if len(sale_price_list) > 0 and float(sale_price_list[0]) > base_price else base_price\\n        buy_price_last = float(buy_price_list[0]) if len(buy_price_list) > 0 and float(buy_price_list[0]) < base_price else base_price\\n        #判断当前价格是否满足 卖出的价格请求",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "price else base_price\\n        #判断当前价格是否满足 卖出的价格请求\\n        if float(data_depth_bids.Price) - sale_price_last > sale_buy_diff_sale and float(data_depth_bids.Amount) > trade_amount * 1.5:\\n            Log(\\\"当前卖价：\\\",str(data_depth_bids.Price),\\\"订单中最高卖价：\\\",str(sale_price_last),\\\"生成卖单\\\")\\n            trade_infor['price'] = float(data_depth_bids.Price)\\n            trade_infor['trade_type'] = 'sale'\\n        #判断当前价格是否满足 买入的价格请求\\n        if  buy_price_last - float(data_depth_asks.Price) > sale_buy_diff_now and fl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(data_depth_asks.Price) > sale_buy_diff_now and float(data_depth_bids.Amount) > trade_amount * 1.5:\\n            #Log(\\\"当前买价：\\\", str(data_depth_asks.Price), \\\"订单中最高买价：\\\", str(sale_price_last),\\\"生成买单\\\")\\n            trade_infor['price'] = float(data_depth_bids.Price)\\n            trade_infor['trade_type'] = 'buy'\\n        #判断当前价格是否破格，破格则置空买卖信息\\n        if float(data_depth_bids.Price) - sale_price_max > 0 or buy_price_min - float(data_depth_asks.Price) > 0:\\n            trade_infor['price'] = 0\\n            t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           trade_infor['price'] = 0\\n            trade_infor['trade_type'] = ''\\n        timestr = (datetime.datetime.now()).strftime('%Y-%m-%d %H:%M:%S')\\n        Log(trade_infor,\\\"...time：\\\",timestr)\\n        if trade_infor['price'] != 0:\\n            #Log(trade_infor,\\\"...time：\\\",timestr)\\n            pass\\n        return trade_infor\\n\\n    #根据委托信息生成买卖价格列表\\n    def get_trade_price_list(self,symbol):\\n        sale_list = []\\n        buy_list = []\\n        #获取所有的交易记录，根据不同的类型 分配到 买卖列表中\\n        orders = exc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#获取所有的交易记录，根据不同的类型 分配到 买卖列表中\\n        orders = exchange.GetOrders()\\n        for i in range(len(orders)):\\n            if orders[i].Type == 1:\\n                sale_price = float(orders[i].Price)\\n                sale_price_bak = copy.deepcopy(sale_price)\\n                sale_list.append(sale_price_bak)\\n            if orders[i].Type == 0:\\n                buy_price = float(orders[i].Price)\\n                buy_price_bak = copy.deepcopy(buy_price)\\n                buy_list.append(buy_price_bak)\\n        #判",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        buy_list.append(buy_price_bak)\\n        #判断为0的数组进处理\\n        if len(sale_list) == 0:\\n            for i in range(len(buy_list)):\\n                sale_list.append(float('%.6f' % (buy_list[i] + sale_buy_diff)))\\n        if len(buy_list) == 0:\\n            for i in range(len(sale_list)):\\n                buy_list.append(float('%.6f' % (sale_list[i] - sale_buy_diff)))\\n        trade_price_list = [sale_list,buy_list]\\n        return trade_price_list\\n\\n    #网格交易入口：\\n    def grid_trade_start(self,symbol)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   #网格交易入口：\\n    def grid_trade_start(self,symbol):\\n        #进行状态获取，上涨/下跌\\n        # trend_status = self.kline_trend_check(symbol)\\n        \\n        #获取可否进行交易\\n        trade_infor = self.make_trade_check(symbol)\\n        #进行判断是否交易，判断是否可以卖出\\n        # if trend_status == 'is_up' and trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\\n            buy_price = float('%.6f' % (trade_infor['price'] - sale_buy_diff))\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "6f' % (trade_infor['price'] - sale_buy_diff))\\n            #调用下单功能,先调用卖，再调用买\\n            order_id = exchange.Sell(trade_infor['price'], trade_amount)\\n            #Log('order_id:',order_id)\\n            #检查下单是否成功，不成功，则直接返回\\n            if order_id is None:\\n                Log(\\\"下单失败，等待600s继续.........\\\")\\n                sleep(600)\\n                return 0\\n            #检查主交易是否成功：判断卖单单是否交易成功,交易成功则进行买单下单\\n            for i in range(100):\\n                sale_orders = exchange.GetOrder(order_id)\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "le_orders = exchange.GetOrder(order_id)\\n                #Log('sale_orders:',sale_orders)\\n                if sale_orders.Status == 1:\\n                    #如果卖单已成交，则进行买单提交\\n                    exchange.Buy(buy_price, trade_amount)\\n                    return 0\\n                sleep(10)\\n            #如果循环1000次还未成交，则取消订单\\n            exchange.CancelOrder(order_id)\\n        # 进行判断是否交易，判断是否可以买入\\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'buy':\\n            sale_price = float('%.6f' ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == 'buy':\\n            sale_price = float('%.6f' % (trade_infor['price'] + sale_buy_diff))\\n            # 调用下单功能，先调用买入，再调用卖出\\n            order_id = exchange.Buy(trade_infor['price'], trade_amount)\\n            # 检查下单是否成功，不成功，则直接返回\\n            if order_id is None:\\n                #Log(\\\"下单失败，等待600s继续.........\\\")\\n                sleep(600)\\n                return 0\\n            # 检查主交易是否成功：判断买单是否交易成功,交易成功则进行卖单下单\\n            for i in range(100):\\n                buy_orders = exchange.GetOrder(order_id)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        buy_orders = exchange.GetOrder(order_id)\\n                if buy_orders.Status == 1:\\n                    # 如果买单已成交，则进行卖单提交\\n                    exchange.Sell(sale_price, trade_amount)\\n                    return 0\\n                sleep(10)\\n            # 如果循环1000次还未成交，则取消订单\\n            exchange.CancelOrder(order_id)\\n\\n    #进行循环调用\\n    def grid_trade_cycle(self,symbol):\\n        cycle_num = 0\\n        while(True):\\n            timestr = (datetime.datetime.now()).strftime('%H%M%S')\\n            se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "datetime.now()).strftime('%H%M%S')\\n            self.grid_trade_start(symbol)\\n            sleep(10)\\n            cycle_num = cycle_num + 1\\n            if cycle_num % 100 == 0:\\n                account_infor = exchange.GetAccount()\\n                Log(\\\"当前用户的账号信息：%s,....当前已循环检查次数：%s\\\"%(account_infor,str(cycle_num)))\\n\\ndef main():\\n    Log(exchange.GetAccount())\\n    Log(\\\"测试\\\")\\n    fmz_market_instances = fmz_market()\\n    fmz_market_instances.grid_trade_cycle(100)\\n    #order_id = exchange.Sell(10000,1)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cycle(100)\\n    #order_id = exchange.Sell(10000,1)\",\n    \"策略名称: 暴雪网格-724小时交易机器人每日更新实盘效果\\n\\n'''\\n主要是使用发明者量化API进行网格买卖，当前只支持单品网格买卖\\n'''\\nfrom time import sleep\\nimport datetime,copy\\n\\nsale_price_list = [] #卖出的价格列表\\nbuy_price_list = []  #买入的价格列表\\n\\nclass fmz_market():\\n    def get_data_depth(self):\\n        data_depth = exchange.GetDepth()\\n        return data_depth\\n\\n\\n\\n    #检查当前是否可以进行买卖操作\\n    def make_trade_check(self,symbol):\\n        trade_infor = {'price':0,'trade_type':''}\\n        #进行买卖列表判断，先更新交易记录列表",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e':0,'trade_type':''}\\n        #进行买卖列表判断，先更新交易记录列表\\n        trade_price_list = self.get_trade_price_list(symbol)\\n        sale_price_list = trade_price_list[0]\\n        buy_price_list = trade_price_list[1]\\n        #获取深度数据\\n        data_depth = self.get_data_depth()\\n        #买单列表：\\n        data_depth_bids = data_depth.Bids[0]\\n        #卖单列表：\\n        data_depth_asks = data_depth.Asks[0]\\n        #如果买入记录不为空\\n        sale_buy_diff_now = two_distance*len(sale_price_list) if len(sale_price_list) >0 else sale_b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "price_list) if len(sale_price_list) >0 else sale_buy_diff\\n        sale_buy_diff_sale = two_distance if len(sale_price_list) > 0 else sale_buy_diff\\n        # sale_price_last = float(sale_price_list[len(sale_price_list)-1]) if len(sale_price_list) >0 else base_price\\n        # buy_price_last = float(buy_price_list[len(buy_price_list)-1]) if len(buy_price_list) >0 else base_price\\n        sale_price_last = float(sale_price_list[0]) if len(sale_price_list) > 0 and float(sale_price_list[0]) > base_price else b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " and float(sale_price_list[0]) > base_price else base_price\\n        buy_price_last = float(buy_price_list[0]) if len(buy_price_list) > 0 and float(buy_price_list[0]) < base_price else base_price\\n        #判断当前价格是否满足 卖出的价格请求\\n        if float(data_depth_bids.Price) - sale_price_last > sale_buy_diff_sale and float(data_depth_bids.Amount) > trade_amount * 1.5:\\n            Log(\\\"当前卖价：\\\",str(data_depth_bids.Price),\\\"订单中最高卖价：\\\",str(sale_price_last),\\\"生成卖单\\\")\\n            trade_infor['price'] = float(data_depth_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          trade_infor['price'] = float(data_depth_bids.Price)\\n            trade_infor['trade_type'] = 'sale'\\n        #判断当前价格是否满足 买入的价格请求\\n        if  buy_price_last - float(data_depth_asks.Price) > sale_buy_diff_now and float(data_depth_bids.Amount) > trade_amount * 1.5:\\n            #Log(\\\"当前买价：\\\", str(data_depth_asks.Price), \\\"订单中最高买价：\\\", str(sale_price_last),\\\"生成买单\\\")\\n            trade_infor['price'] = float(data_depth_bids.Price)\\n            trade_infor['trade_type'] = 'buy'\\n        #判断当前价格是否破格，破格则",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "for['trade_type'] = 'buy'\\n        #判断当前价格是否破格，破格则置空买卖信息\\n        if float(data_depth_bids.Price) - sale_price_max > 0 or buy_price_min - float(data_depth_asks.Price) > 0:\\n            trade_infor['price'] = 0\\n            trade_infor['trade_type'] = ''\\n        timestr = (datetime.datetime.now()).strftime('%Y-%m-%d %H:%M:%S')\\n        Log(trade_infor,\\\"...time：\\\",timestr)\\n        if trade_infor['price'] != 0:\\n            #Log(trade_infor,\\\"...time：\\\",timestr)\\n            pass\\n        return trade_infor",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "str)\\n            pass\\n        return trade_infor\\n\\n    #根据委托信息生成买卖价格列表\\n    def get_trade_price_list(self,symbol):\\n        sale_list = []\\n        buy_list = []\\n        #获取所有的交易记录，根据不同的类型 分配到 买卖列表中\\n        orders = exchange.GetOrders()\\n        for i in range(len(orders)):\\n            if orders[i].Type == 1:\\n                sale_price = float(orders[i].Price)\\n                sale_price_bak = copy.deepcopy(sale_price)\\n                sale_list.append(sale_price_bak)\\n            if orders[i].Type =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d(sale_price_bak)\\n            if orders[i].Type == 0:\\n                buy_price = float(orders[i].Price)\\n                buy_price_bak = copy.deepcopy(buy_price)\\n                buy_list.append(buy_price_bak)\\n        #判断为0的数组进处理\\n        if len(sale_list) == 0:\\n            for i in range(len(buy_list)):\\n                sale_list.append(float('%.6f' % (buy_list[i] + sale_buy_diff)))\\n        if len(buy_list) == 0:\\n            for i in range(len(sale_list)):\\n                buy_list.append(float('%.6",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ist)):\\n                buy_list.append(float('%.6f' % (sale_list[i] - sale_buy_diff)))\\n        trade_price_list = [sale_list,buy_list]\\n        return trade_price_list\\n\\n    #网格交易入口：\\n    def grid_trade_start(self,symbol):\\n        #进行状态获取，上涨/下跌\\n        # trend_status = self.kline_trend_check(symbol)\\n        \\n        #获取可否进行交易\\n        trade_infor = self.make_trade_check(symbol)\\n        #进行判断是否交易，判断是否可以卖出\\n        # if trend_status == 'is_up' and trade_infor['price'] > 0 and trade_infor['trade_type']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'sale':\\n            buy_price = float('%.6f' % (trade_infor['price'] - sale_buy_diff))\\n            #调用下单功能,先调用卖，再调用买\\n            order_id = exchange.Sell(trade_infor['price'], trade_amount)\\n            #Log('order_id:',order_id)\\n            #检查下单是否成功，不成功，则直接返回\\n            if order_id is None:\\n                Log(\\\"下单失败，等待600s继续.........\\\")\\n                sleep(600)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "600s继续.........\\\")\\n                sleep(600)\\n                return 0\\n            #检查主交易是否成功：判断卖单单是否交易成功,交易成功则进行买单下单\\n            for i in range(100):\\n                sale_orders = exchange.GetOrder(order_id)\\n                #Log('sale_orders:',sale_orders)\\n                if sale_orders.Status == 1:\\n                    #如果卖单已成交，则进行买单提交\\n                    exchange.Buy(buy_price, trade_amount)\\n                    return 0\\n                sleep(10)\\n            #如果循环1000次还未成交，则取消订单\\n            ex",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            #如果循环1000次还未成交，则取消订单\\n            exchange.CancelOrder(order_id)\\n        # 进行判断是否交易，判断是否可以买入\\n        if trade_infor['price'] > 0 and trade_infor['trade_type'] == 'buy':\\n            sale_price = float('%.6f' % (trade_infor['price'] + sale_buy_diff))\\n            # 调用下单功能，先调用买入，再调用卖出\\n            order_id = exchange.Buy(trade_infor['price'], trade_amount)\\n            # 检查下单是否成功，不成功，则直接返回\\n            if order_id is None:\\n                #Log(\\\"下单失败，等待600s继续.........\\\")\\n                slee",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(\\\"下单失败，等待600s继续.........\\\")\\n                sleep(600)\\n                return 0\\n            # 检查主交易是否成功：判断买单是否交易成功,交易成功则进行卖单下单\\n            for i in range(100):\\n                buy_orders = exchange.GetOrder(order_id)\\n                if buy_orders.Status == 1:\\n                    # 如果买单已成交，则进行卖单提交\\n                    exchange.Sell(sale_price, trade_amount)\\n                    return 0\\n                sleep(10)\\n            # 如果循环1000次还未成交，则取消订单\\n            exchange.CancelOrder(order_id)\\n\\n    #进",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          exchange.CancelOrder(order_id)\\n\\n    #进行循环调用\\n    def grid_trade_cycle(self,symbol):\\n        cycle_num = 0\\n        while(True):\\n            timestr = (datetime.datetime.now()).strftime('%H%M%S')\\n            self.grid_trade_start(symbol)\\n            sleep(10)\\n            cycle_num = cycle_num + 1\\n            if cycle_num % 100 == 0:\\n                account_infor = exchange.GetAccount()\\n                Log(\\\"当前用户的账号信息：%s,....当前已循环检查次数：%s\\\"%(account_infor,str(cycle_num)))\\n\\ndef main():\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(account_infor,str(cycle_num)))\\n\\ndef main():\\n    Log(exchange.GetAccount())\\n    Log(\\\"测试\\\")\\n    fmz_market_instances = fmz_market()\\n    fmz_market_instances.grid_trade_cycle(100)\\n    #order_id = exchange.Sell(10000,1)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/175807\\n\\n> Last Modified\\n\\n2020-03-12 13:53:43\"\n \n\n    \"strategy_103\",\n    \"python\\ndef main():\\n\\texchange.SetContractType(ContractSwap)\\n\\tTickerSwap = exchange.GetTicker()\\n\\tTickerSwap['BuyAmount'] = TickerSwap['Info']['result']['be",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ap['BuyAmount'] = TickerSwap['Info']['result']['best_bid_amount']\\n\\tTickerSwap['SellAmount'] = TickerSwap['Info']['result']['best_ask_amount']\\n\\texchange.SetContractType(ContractFuture)\\n\\tTickerFuture = exchange.GetTicker()\\n\\tTickerFuture['BuyAmount'] = TickerFuture['Info']['result']['best_bid_amount']\\n\\tTickerFuture['SellAmount'] = TickerFuture['Info']['result']['best_ask_amount']\\n\\n\\tDiff = _N(TickerFuture['Buy'] - TickerSwap['Sell'],2)\\n\\n\\tMsg = ''\\n\\tMsg += str(ContractSwap) +' '+ str(TickerSwap[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\tMsg += str(ContractSwap) +' '+ str(TickerSwap['Sell']) +' '+ str(TickerSwap['SellAmount'])+ '\\\\n'\\n\\tMsg += str(ContractFuture) +' '+ str(TickerFuture['Buy']) +' '+ str(TickerFuture['BuyAmount']) + '\\\\n'\\n\\tMsg += '差价: ' + str(Diff) + '\\\\n'\\n\\n\\tif Diff <= DiffMin:\\n\\t\\treturn '差价为 ' + str(_N(Diff,2)) + ' 小于设定价差 '+str(DiffMin)+'，不下单' + '\\\\n\\\\n附加信息\\\\n' +Msg\\n\\n\\tif TickerFuture['BuyAmount'] < Amount or TickerFuture['SellAmount'] < Amount:\\n\\t\\treturn '某方向挂单量小于设定下单量 '+str(Amount)+'，不下单' + '\\\\n\\\\n附加信息\\\\n' ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "挂单量小于设定下单量 '+str(Amount)+'，不下单' + '\\\\n\\\\n附加信息\\\\n' +Msg\\n\\n\\tif not RealTrade:\\n\\t\\treturn '非真实交易' + '\\\\n' + Msg\\n\\n\\texchange.SetContractType(ContractSwap)\\n\\texchange.SetDirection(\\\"buy\\\")\\n\\tBuyOrderId = exchange.Buy(TickerSwap['Sell'] + 0.2, Amount)\\n\\n\\texchange.SetContractType(ContractFuture)\\n\\texchange.SetDirection(\\\"sell\\\")\\n\\tSellOrderId = exchange.Sell(TickerFuture['Buy'] - 0.2, Amount)\\n\\n\\tBuyOrder = exchange.GetOrder(BuyOrderId)\\n\\tSellOrder = exchange.GetOrder(SellOrderId)\\n\\n\\tTradeMsg = '交易完",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchange.GetOrder(SellOrderId)\\n\\n\\tTradeMsg = '交易完成\\\\n'\\n\\tTradeMsg += '买单 ' + str(BuyOrder['ContractType']) + ' ' + str(BuyOrder['Price']) + ' ' + str(BuyOrder['DealAmount']) + '/' + str(BuyOrder['Amount']) + '\\\\n'\\n\\tTradeMsg += '卖单 ' + str(SellOrder['ContractType']) + ' ' + str(SellOrder['Price']) + ' ' + str(SellOrder['DealAmount']) + '/' + str(SellOrder['Amount']) + '\\\\n'\\n\\tTradeMsg += '\\\\n\\\\n附加信息\\\\n' +Msg\\n\\treturn TradeMsg\",\n    \"策略名称: 期现成对下单_Public\\n\\n未找到描述\"\n \n\n    \"strategy_104\",\n    \"python\\n#!/u",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n未找到描述\"\n \n\n    \"strategy_104\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n# encoding: utf-8\\n#\\n#  Persistent Storage for FMZ\\n#\\n# Copyright 2020 FawkesPan\\n# Contact : i@fawkex.me / Telegram@FawkesPan\\n#\\n#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \\n#                    Version 2, December 2004 \\n#\\n# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net> \\n#\\n# Everyone is permitted to copy and distribute verbatim or modified \\n# copies of this license document, and changing ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n# copies of this license document, and changing it is allowed as long \\n# as the name is changed. \\n#\\n#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE \\n#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION \\n#\\n#  0. You just DO WHAT THE FUCK YOU WANT TO.\\n#\\n\\nclass PersistentStorage:\\n    \\n    def __init__(self):\\n        keys = _G('__keys__')\\n        if isinstance(keys, list):\\n            self.__keys__ = keys\\n        else:\\n            self.__keys__ = []\\n            self.__",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           self.__keys__ = []\\n            self.__setitem__('__keys__', self.__keys__)\\n        return\\n    \\n    def _add_key(self, key):\\n        if key == '__keys__':\\n            return\\n        self.__keys__.append(key)\\n        self.__setitem__('__keys__', self.__keys__)\\n        return\\n        \\n    def _del_key(self, key):\\n        if key == '__keys__':\\n            return\\n        if key in self.__keys__:\\n            del self.__keys__[self.__keys__.index(key)]\\n        self.__setitem__('__keys__'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_.index(key)]\\n        self.__setitem__('__keys__', self.__keys__)\\n        return\\n    \\n    def __setitem__(self, key, value):\\n        _G(key, value)\\n        self._add_key(key)\\n        return\\n    \\n    def __delitem__(self, key):\\n        _G(key, None)\\n        self._del_key(key)\\n        return\\n    \\n    def __getitem__(self, key):\\n        return _G(key)\\n\\n    def keys(self):\\n        return self.__keys__\\n        \\n\\next.PersistentStorage = PersistentStorage\",\n    \"策略名称: 本地存储\\n\\nFMZ本地存储调用简化工具\\n关于",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tentStorage\",\n    \"策略名称: 本地存储\\n\\nFMZ本地存储调用简化工具\\n关于本地存储，请访问[FMZ API文档](https://www.fmz.com/api)\"\n \n\n    \"strategy_105\",\n    \"python\\nimport urllib2\\ndef main():\\n    Log(\\\"开始检查@\\\")\\n    while True:\\n        try:\\n            urllib2.urlopen(\\\"https://quant.la/API/Argus/predict\\\", timeout=15)\\n            Log(\\\"服务正常\\\")\\n        except:\\n            Log(_D(),\\\" 服务异常@\\\")\\n        Sleep(10*60*1000)\",\n    \"策略名称: 检查https-quantla-Argus-是否正常\\n\\n未找到描述\"\n \n\n    \"strategy_106\",\n    \"python\\nimport random\\nimport time\\nd",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "y_106\",\n    \"python\\nimport random\\nimport time\\ndef main():\\n    cfgA = {\\n        \\\"title\\\" : {\\\"text\\\" : \\\"盘口图表\\\"},\\n        \\\"xAxis\\\" : {\\n            \\\"type\\\" : \\\"datetime\\\"\\n        \\n        \\\"series\\\" : [{\\n            \\\"name\\\" : \\\"买一\\\", \\n            \\\"data\\\" : [],        \\n     \\n            \\\"name\\\" : \\\"卖一\\\",\\n            \\\"data\\\" : [],\\n        }]\\n    }\\n\\n    cfgB = {\\n        \\\"title\\\" : {\\\"text\\\" : \\\"差价图\\\"},\\n        \\\"xAxis\\\" : {\\n            \\\"type\\\" : \\\"datetime\\\"\\n       \\n        \\\"seri",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\\"type\\\" : \\\"datetime\\\"\\n       \\n        \\\"series\\\" : [{\\n            \\\"name\\\" : \\\"差价\\\",\\n            \\\"type\\\" : \\\"column\\\",\\n            \\\"data\\\" : [],\\n        }]\\n    }\\n\\n    cfgC = {\\n        \\\"__isStock\\\" : False,\\n        \\\"title\\\" : {\\n            \\\"text\\\" : \\\"饼图\\\"\\n       \\n        \\\"series\\\" : [{\\n            \\\"type\\\" : \\\"pie\\\",\\n            \\\"name\\\" : \\\"one\\\",\\n            \\\"data\\\" : [\\n                [\\\"A\\\", 25],\\n                [\\\"B\\\", 25],\\n                [\\\"C\\\", 25],\\n                [\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                [\\\"C\\\", 25],\\n                [\\\"D\\\", 25],\\n            ]\\n        }]\\n    }\\n\\n    chart = Chart([cfgA, cfgB, cfgC])\\n    chart.reset()\\n    chart.add(3, {\\n        \\\"name\\\" : \\\"ZZ\\\", \\n        \\\"y\\\" : random.random() * 100\\n    })\\n\\n\\n    chart.update([cfgA, cfgB, cfgC])\\n    chart.add(0, [_N(time.time() * 1000, 0), 50])\\n    chart.add(1, [_N(time.time() * 1000, 0), 80])\\n    chart.add(2, [_N(time.time() * 1000, 0), 90])\\n    chart.add(3, {\\n        \\\"name\\\" : \\\"ZZ\\\",\\n        \\\"y\\\" : r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ", {\\n        \\\"name\\\" : \\\"ZZ\\\",\\n        \\\"y\\\" : random.random() * 100\\n    -1)\",\n    \"策略名称: 测试多图表展示Python版\\n\\n未找到描述\"\n \n\n    \"strategy_107\",\n    \"python\\n# Contact : ck@xueqiubot.com / WeChat@stay37\\n\\nimport time\\nimport numpy as np\\n\\n\\ndef test():\\n    #延迟数据接收器\\n    delay_list = []\\n    for i in range(len(exchanges)):\\n        delay_list.append([])\\n    while True:\\n        #延迟数据获取\\n        for i in range(len(exchanges)):\\n            send_t = time.time()\\n            ticker = exchanges[i].GetTicker()\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            ticker = exchanges[i].GetTicker()\\n            delay_list[i].append(round((time.time() - send_t) * 1000 , 2))\\n        #数据输出 \\n        delay_table = {\\\"type\\\":'table',\\\"title\\\":'延迟数据',\\\"cols\\\": ['账号序号','最近一次延迟','平均延迟','已测试次数'],\\\"rows\\\":[]}\\n        for i in range(len(delay_list)):\\n            delay_table['rows'].append([i + 1, str(delay_list[i][-1])+' ms', str(round(np.mean(delay_list[i]) , 2)) + ' ms', len(delay_list[i])])\\n        LogStatus(\\\"输出的延迟为：发送一次get_ticker请求到获取到数据的真实时间\\\" + \\\"\\\\n\\\" +",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"输出的延迟为：发送一次get_ticker请求到获取到数据的真实时间\\\" + \\\"\\\\n\\\" + \\\"`\\\" + json.dumps(delay_table) + \\\"`\\\")\\n        time.sleep(0.05)\\n\\n                \\ndef main():\\n    for i in range(len(exchanges)):\\n        exchanges[i].SetContractType('swap')\\n    test()\",\n    \"策略名称: 测试托管者与交易所服务器的真实网络延迟-支持同时测试多个交易所\\n\\nimport time\\nimport numpy as np\\n\\n\\ndef test():\\n    #延迟数据接收器\\n    delay_list = []\\n    for i in range(len(exchanges)):\\n        delay_list.append([])\\n    while True:\\n        #延迟数据获取\\n        for i in range(len(exch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        #延迟数据获取\\n        for i in range(len(exchanges)):\\n            send_t = time.time()\\n            ticker = exchanges[i].GetTicker()\\n            delay_list[i].append(round((time.time() - send_t) * 1000 , 2))\\n        #数据输出 \\n        delay_table = {\\\"type\\\":'table',\\\"title\\\":'延迟数据',\\\"cols\\\": ['账号序号','最近一次延迟','平均延迟','已测试次数'],\\\"rows\\\":[]}\\n        for i in range(len(delay_list)):\\n            delay_table['rows'].append([i + 1, str(delay_list[i][-1])+' ms', str(round(np.mean(delay_list[i]) , 2)) + ' ms'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s', str(round(np.mean(delay_list[i]) , 2)) + ' ms', len(delay_list[i])])\\n        LogStatus(\\\"输出的延迟为：发送一次get_ticker请求到获取到数据的真实时间\\\" + \\\"\\\\n\\\" + \\\"`\\\" + json.dumps(delay_table) + \\\"`\\\")\\n        time.sleep(0.05)\\n\\n                \\ndef main():\\n    for i in range(len(exchanges)):\\n        exchanges[i].SetContractType('swap')\\n    test()\\n                \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/236426\\n\\n> Last Modified\\n\\n2021-01-10 19:22:52\"\n \n\n    \"strategy_108\",\n    \"python\\nimport json\\nimport",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \"strategy_108\",\n    \"python\\nimport json\\nimport time\\n\\nclass Turtle:\\n    def __init__(self, account=None, donchian_channel_open_position=20, donchian_channel_stop_profit=10, atr_day_length=20, max_risk_ratio=0.5):\\n        self.donchian_channel_open_position = donchian_channel_open_position  # 唐奇安通道的天数周期(开仓)\\n        self.donchian_channel_stop_profit = donchian_channel_stop_profit  # 唐奇安通道的天数周期(止盈)\\n        self.atr_day_length = atr_day_length  # ATR计算所用天数\\n        self.max_risk_ratio = max_risk_ratio ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "用天数\\n        self.max_risk_ratio = max_risk_ratio  # 最高风险度\\n        self.state = {\\n            \\\"position\\\": 0,  # 本策略净持仓数(正数表示多头，负数表示空头，0表示空仓)\\n            \\\"last_price\\\": float(\\\"nan\\\"),  # 上次调仓价\\n        }\\n        positions = _C(exchange.GetPosition)\\n        self.equity=0\\n        for position in positions:\\n            if position[\\\"Type\\\"]==PD_LONG:\\n                self.state[\\\"position\\\"]=position[\\\"Amount\\\"]\\n                self.state[\\\"last_price\\\"] = position[\\\"Price\\\"]\\n                self.e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\\"] = position[\\\"Price\\\"]\\n                self.equity+=position[\\\"Margin\\\"]\\n            elif position[\\\"Type\\\"]==PD_SHORT:\\n                self.state[\\\"position\\\"]=-position[\\\"Amount\\\"]\\n                self.state[\\\"last_price\\\"] = position[\\\"Price\\\"]\\n                self.equity+=position[\\\"Margin\\\"]\\n        self.account = _C(exchange.GetAccount)\\n        self.equity += self.account[\\\"Stocks\\\"]+self.account[\\\"FrozenStocks\\\"]\\n        #Log(self.equity)\\n\\n        self.n = 0  # 平均真实波幅(N值)\\n        self.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n        self.n = 0  # 平均真实波幅(N值)\\n        self.unit = 0  # 买卖单位\\n        self.donchian_channel_high = 0  # 唐奇安通道上轨\\n        self.donchian_channel_low = 0  # 唐奇安通道下轨\\n        # 由于ATR是路径依赖函数，因此使用更长的数据序列进行计算以便使其值稳定下来\\n        self.klines = exchange.GetRecords()\\n\\n    def recalc_paramter(self):\\n        # 平均真实波幅(N值)\\n        self.equity=0\\n        positions = _C(exchange.GetPosition)\\n        for position in positions:\\n            if position[\\\"Type\\\"]==PD_LONG:\\n                self.equity+=position[\\\"Mar",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "LONG:\\n                self.equity+=position[\\\"Margin\\\"]\\n            elif position[\\\"Type\\\"]==PD_SHORT:\\n                self.equity+=position[\\\"Margin\\\"]\\n        self.account = _C(exchange.GetAccount)\\n        self.equity += self.account[\\\"Stocks\\\"]+self.account[\\\"FrozenStocks\\\"]\\n        #Log(self.equity)\\n        records = _C(exchange.GetRecords)\\n        self.n =TA.ATR(records, self.atr_day_length)[-1]\\n        # 买卖单位\\n        self.current_price = records[-1][\\\"Close\\\"]\\n        self.unit = int((self.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rds[-1][\\\"Close\\\"]\\n        self.unit = int((self.equity * 0.01*self.current_price*self.current_price) / (100 * self.n))\\n        # 唐奇安通道上轨：前N个交易日的最高价\\n        #Log(records)\\n        self.donchian_channel_high =TA.Highest(records, self.donchian_channel_open_position , 'High') #唐奇安通道上轨：前N个交易日的最高价\\n        self.donchian_channel_high =TA.Highest(records, 55 , 'High')\\n        # 唐奇安通道下轨：前N个交易日的最低价\\n        self.donchian_channel_low = TA.Lowest(records, self.donchian_channel_open_position , 'Low')\\n        self.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "hian_channel_open_position , 'Low')\\n        self.donchian_channel_low = TA.Lowest(records, 55 , 'Low')\\n        #Log(\\\"唐其安通道上下轨: %f, %f\\\" % (self.donchian_channel_high, self.donchian_channel_low))\\n        \\n        self.stop_high = TA.Highest(records, self.donchian_channel_stop_profit , 'High') \\n        self.stop_high = TA.Highest(records, 20 , 'High') \\n        self.stop_low = TA.Highest(records, self.donchian_channel_stop_profit , 'Low') \\n        self.stop_low = TA.Highest(records, 20, 'Low') \\n\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "stop_low = TA.Highest(records, 20, 'Low') \\n\\n        \\n        boll = TA.BOLL(records, 50, 2)\\n        self.up_line = boll[0][-1]\\n        self.mid_line = boll[1][-1]\\n        self.down_line = boll[2][-1]\\n        close1 = records[-2]['Close']  # 最新收盘价\\n        close30 = records[-30]['Close']  # 前30根K线的收盘价\\n        hh30 = TA.Highest(records, 30, 'High')  # 最近30根K线的最高价\\n        ll30 = TA.Lowest(records, 30, 'Low')  # 最近30根K线的最低价\\n        self.cmi = abs((close1 - close30) / (hh30 - ll30)) * 100  # 计算市场波动指数\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e1 - close30) / (hh30 - ll30)) * 100  # 计算市场波动指数\\n\\n        return True\\n    def set_position(self, pos):\\n        self.state[\\\"position\\\"] = pos\\n        self.state[\\\"last_price\\\"] = self.current_price\\n        positions = _C(exchange.GetPosition)\\n        sell_amount =0\\n        long_amount = 0\\n        for position in positions:\\n            if position[\\\"Type\\\"]==PD_LONG:\\n                long_amount=position[\\\"Amount\\\"]\\n            elif position[\\\"Type\\\"]==PD_SHORT:\\n                sell_amount=positi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"]==PD_SHORT:\\n                sell_amount=position[\\\"Amount\\\"]\\n\\n        if pos>0:\\n            if sell_amount>0:\\n                exchange.SetDirection(\\\"closesell\\\")\\n                exchange.Buy(self.current_price*1.005,sell_amount)\\n            if pos>long_amount:\\n                exchange.SetDirection(\\\"buy\\\")\\n                exchange.Buy(self.current_price*1.005,pos-long_amount)\\n            elif pos<long_amount:\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                exchange.Sell(s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ion(\\\"closebuy\\\")\\n                exchange.Sell(self.current_price*0.995,long_amount-pos)\\n        elif pos<0:\\n            pos=-pos \\n            if long_amount>0:\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                exchange.Sell(self.current_price*0.995,long_amount)\\n            if pos>sell_amount:\\n                exchange.SetDirection(\\\"sell\\\")\\n                exchange.Sell(self.current_price*0.995,pos-sell_amount)\\n            elif pos<sell_amount:\\n                exchange.SetDirec",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "os<sell_amount:\\n                exchange.SetDirection(\\\"closesell\\\")\\n                exchange.Buy(self.current_price*1.005,sell_amount-pos)\\n        else:\\n            if long_amount>0:\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                exchange.Sell(self.current_price*0.995,long_amount)      \\n            if sell_amount>0:\\n                exchange.SetDirection(\\\"closesell\\\")\\n                exchange.Buy(self.current_price*1.005,sell_amount)                \\n        #self.target_pos.s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mount)                \\n        #self.target_pos.set_target_volume(self.state[\\\"position\\\"])\\n    def try_open(self):\\n        \\\"\\\"\\\"开仓策略\\\"\\\"\\\"\\n        while self.state[\\\"position\\\"] == 0:\\n            self.recalc_paramter()\\n            #Log(\\\"最新价: %f\\\" % self.current_price)\\n            if self.current_price > self.donchian_channel_high:  # 当前价>唐奇安通道上轨，买入1个Unit；(持多仓)\\n            #if self.cmi>20 and self.current_price>self.up_line:\\n                #Log(\\\"当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手\\\" % self.unit)\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手\\\" % self.unit)\\n                self.set_position(self.state[\\\"position\\\"] + self.unit)\\n            elif self.current_price < self.donchian_channel_low:  # 当前价<唐奇安通道下轨，卖出1个Unit；(持空仓)\\n            #elif self.cmi>20 and self.current_price<self.down_line:\\n                #Log(\\\"当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手\\\" % self.unit)\\n                self.set_position(self.state[\\\"position\\\"] - self.unit)\\n    def try_close(self):\\n        \\\"\\\"\\\"交易策略\\\"\\\"\\\"\\n        while self.state[\\\"p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    \\\"\\\"\\\"交易策略\\\"\\\"\\\"\\n        while self.state[\\\"position\\\"] != 0:\\n            if True:\\n                self.recalc_paramter()\\n                Log(\\\"最新价: \\\", self.current_price)\\n                #if self.cmi<20:\\n                #    self.set_position(0)\\n                if self.state[\\\"position\\\"] > 0:  # 持多单\\n                    # 加仓策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了0.5N，就再加一个Unit的多仓,并且风险度在设定范围内(以防爆仓)\\n                    if self.current_price >= self.state[\\\"last_price\\\"] + 0.5 * self.n and self.stat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "state[\\\"last_price\\\"] + 0.5 * self.n and self.state[\\\"position\\\"] + self.unit<=4*self.unit:\\n                        Log(\\\"加仓:加1个Unit的多仓\\\")\\n                        self.set_position(self.state[\\\"position\\\"] + self.unit)\\n                    # 止损策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了2N，就卖出全部头寸止损\\n                    elif self.current_price <= self.state[\\\"last_price\\\"] - 2 * self.n:\\n                        Log(\\\"止损:卖出全部头寸\\\")\\n                        self.set_position(0)\\n                    # 止盈策略: 如果是多仓且行情最新",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "osition(0)\\n                    # 止盈策略: 如果是多仓且行情最新价跌破了10日唐奇安通道的下轨，就清空所有头寸结束策略,离场\\n                    if self.current_price <= self.stop_low:\\n                    #if self.current_price<self.mid_line:\\n                        Log(\\\"止盈:清空所有头寸结束策略,离场\\\")\\n                        self.set_position(0)\\n                elif self.state[\\\"position\\\"] < 0:  # 持空单\\n                    # 加仓策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了0.5N，就再加一个Unit的空仓,并且风险度在设定范围内(以防爆仓)\\n                    if self.current_price <= self.state[\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            if self.current_price <= self.state[\\\"last_price\\\"] - 0.5 * self.n and (-self.state[\\\"position\\\"]) + self.unit<=4*self.unit:\\n                        Log(\\\"加仓:加1个Unit的空仓\\\")\\n                        self.set_position(self.state[\\\"position\\\"] - self.unit)\\n                    # 止损策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损\\n                    elif self.current_price >= self.state[\\\"last_price\\\"] + 2 * self.n:\\n                        Log(\\\"止损:卖出全部头寸\\\")\\n                        self.set_position(0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "头寸\\\")\\n                        self.set_position(0)\\n                    # 止盈策略: 如果是空仓且行情最新价升破了10日唐奇安通道的上轨，就清空所有头寸结束策略,离场\\n                    if self.current_price >= self.stop_high:\\n                    #if self.current_price>self.mid_line:\\n                        Log(\\\"止盈:清空所有头寸结束策略,离场\\\")\\n                        self.set_position(0)\\n    def strategy(self):\\n        \\\"\\\"\\\"海龟策略\\\"\\\"\\\"\\n        Log(\\\"等待K线及账户数据...\\\")\\n        while not self.recalc_paramter():\\n            raise Exception(\\\"获取数据失败，请确认行情连接正常",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "):\\n            raise Exception(\\\"获取数据失败，请确认行情连接正常并已经登录交易账户\\\")\\n        while True:\\n            self.try_open()\\n            self.try_close()\\n\\n\\ndef main():\\n    exchange.SetContractType(\\\"quarter\\\")\\n    turtle = Turtle(donchian_channel_open_position=Donchian_open,donchian_channel_stop_profit=Donchian_stop,atr_day_length=Atr)\\n    Log(\\\"策略开始运行\\\")\\n\\n    Log(\\\"当前持仓数: %d, 上次调仓价: %f\\\" % (turtle.state[\\\"position\\\"], turtle.state[\\\"last_price\\\"]))\\n    turtle.strategy()\",\n    \"策略名称: 海龟\\n\\nself.donchian_chann",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".strategy()\",\n    \"策略名称: 海龟\\n\\nself.donchian_channel_stop_profit = donchian_channel_stop_profit  # 唐奇安通道的天数周期(止盈)\\n        self.atr_day_length = atr_day_length  # ATR计算所用天数\\n        self.max_risk_ratio = max_risk_ratio  # 最高风险度\\n        self.state = {\\n            \\\"position\\\": 0,  # 本策略净持仓数(正数表示多头，负数表示空头，0表示空仓)\\n            \\\"last_price\\\": float(\\\"nan\\\"),  # 上次调仓价\\n        }\\n        positions = _C(exchange.GetPosition)\\n        self.equity=0\\n        for position in positions:\\n            if position[\\\"T",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "osition in positions:\\n            if position[\\\"Type\\\"]==PD_LONG:\\n                self.state[\\\"position\\\"]=position[\\\"Amount\\\"]\\n                self.state[\\\"last_price\\\"] = position[\\\"Price\\\"]\\n                self.equity+=position[\\\"Margin\\\"]\\n            elif position[\\\"Type\\\"]==PD_SHORT:\\n                self.state[\\\"position\\\"]=-position[\\\"Amount\\\"]\\n                self.state[\\\"last_price\\\"] = position[\\\"Price\\\"]\\n                self.equity+=position[\\\"Margin\\\"]\\n        self.account = _C(exchange.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n[\\\"Margin\\\"]\\n        self.account = _C(exchange.GetAccount)\\n        self.equity += self.account[\\\"Stocks\\\"]+self.account[\\\"FrozenStocks\\\"]\\n        #Log(self.equity)\\n\\n        self.n = 0  # 平均真实波幅(N值)\\n        self.unit = 0  # 买卖单位\\n        self.donchian_channel_high = 0  # 唐奇安通道上轨\\n        self.donchian_channel_low = 0  # 唐奇安通道下轨\\n        # 由于ATR是路径依赖函数，因此使用更长的数据序列进行计算以便使其值稳定下来\\n        self.klines = exchange.GetRecords()\\n\\n    def recalc_paramter(self):\\n        # 平均真实波幅(N值)\\n        self.equity=0\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "):\\n        # 平均真实波幅(N值)\\n        self.equity=0\\n        positions = _C(exchange.GetPosition)\\n        for position in positions:\\n            if position[\\\"Type\\\"]==PD_LONG:\\n                self.equity+=position[\\\"Margin\\\"]\\n            elif position[\\\"Type\\\"]==PD_SHORT:\\n                self.equity+=position[\\\"Margin\\\"]\\n        self.account = _C(exchange.GetAccount)\\n        self.equity += self.account[\\\"Stocks\\\"]+self.account[\\\"FrozenStocks\\\"]\\n        #Log(self.equity)\\n        records = _C(exchange.G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "#Log(self.equity)\\n        records = _C(exchange.GetRecords)\\n        self.n =TA.ATR(records, self.atr_day_length)[-1]\\n        # 买卖单位\\n        self.current_price = records[-1][\\\"Close\\\"]\\n        self.unit = int((self.equity * 0.01*self.current_price*self.current_price) / (100 * self.n))\\n        # 唐奇安通道上轨：前N个交易日的最高价\\n        #Log(records)\\n        self.donchian_channel_high =TA.Highest(records, self.donchian_channel_open_position , 'High') #唐奇安通道上轨：前N个交易日的最高价\\n        self.donchian_channel_high =TA.Highes",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "最高价\\n        self.donchian_channel_high =TA.Highest(records, 55 , 'High')\\n        # 唐奇安通道下轨：前N个交易日的最低价\\n        self.donchian_channel_low = TA.Lowest(records, self.donchian_channel_open_position , 'Low')\\n        self.donchian_channel_low = TA.Lowest(records, 55 , 'Low')\\n        #Log(\\\"唐其安通道上下轨: %f, %f\\\" % (self.donchian_channel_high, self.donchian_channel_low))\\n        \\n        self.stop_high = TA.Highest(records, self.donchian_channel_stop_profit , 'High') \\n        self.stop_high = TA.Highest(records",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "gh') \\n        self.stop_high = TA.Highest(records, 20 , 'High') \\n        self.stop_low = TA.Highest(records, self.donchian_channel_stop_profit , 'Low') \\n        self.stop_low = TA.Highest(records, 20, 'Low') \\n\\n        \\n        boll = TA.BOLL(records, 50, 2)\\n        self.up_line = boll[0][-1]\\n        self.mid_line = boll[1][-1]\\n        self.down_line = boll[2][-1]\\n        close1 = records[-2]['Close']  # 最新收盘价\\n        close30 = records[-30]['Close']  # 前30根K线的收盘价\\n        hh30 = TA.Highest(records",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]  # 前30根K线的收盘价\\n        hh30 = TA.Highest(records, 30, 'High')  # 最近30根K线的最高价\\n        ll30 = TA.Lowest(records, 30, 'Low')  # 最近30根K线的最低价\\n        self.cmi = abs((close1 - close30) / (hh30 - ll30)) * 100  # 计算市场波动指数\\n\\n        return True\\n    def set_position(self, pos):\\n        self.state[\\\"position\\\"] = pos\\n        self.state[\\\"last_price\\\"] = self.current_price\\n        positions = _C(exchange.GetPosition)\\n        sell_amount =0\\n        long_amount = 0\\n        for position in positions:\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = 0\\n        for position in positions:\\n            if position[\\\"Type\\\"]==PD_LONG:\\n                long_amount=position[\\\"Amount\\\"]\\n            elif position[\\\"Type\\\"]==PD_SHORT:\\n                sell_amount=position[\\\"Amount\\\"]\\n\\n        if pos>0:\\n            if sell_amount>0:\\n                exchange.SetDirection(\\\"closesell\\\")\\n                exchange.Buy(self.current_price*1.005,sell_amount)\\n            if pos>long_amount:\\n                exchange.SetDirection(\\\"buy\\\")\\n                exchan",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.SetDirection(\\\"buy\\\")\\n                exchange.Buy(self.current_price*1.005,pos-long_amount)\\n            elif pos<long_amount:\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                exchange.Sell(self.current_price*0.995,long_amount-pos)\\n        elif pos<0:\\n            pos=-pos \\n            if long_amount>0:\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                exchange.Sell(self.current_price*0.995,long_amount)\\n            if pos>sell_amount:\\n                excha",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        if pos>sell_amount:\\n                exchange.SetDirection(\\\"sell\\\")\\n                exchange.Sell(self.current_price*0.995,pos-sell_amount)\\n            elif pos<sell_amount:\\n                exchange.SetDirection(\\\"closesell\\\")\\n                exchange.Buy(self.current_price*1.005,sell_amount-pos)\\n        else:\\n            if long_amount>0:\\n                exchange.SetDirection(\\\"closebuy\\\")\\n                exchange.Sell(self.current_price*0.995,long_amount)      \\n            if sell_amount",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "995,long_amount)      \\n            if sell_amount>0:\\n                exchange.SetDirection(\\\"closesell\\\")\\n                exchange.Buy(self.current_price*1.005,sell_amount)                \\n        #self.target_pos.set_target_volume(self.state[\\\"position\\\"])\\n    def try_open(self):\\n        \\\"\\\"\\\"开仓策略\\\"\\\"\\\"\\n        while self.state[\\\"position\\\"] == 0:\\n            self.recalc_paramter()\\n            #Log(\\\"最新价: %f\\\" % self.current_price)\\n            if self.current_price > self.donchian_channel_high: ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " self.current_price > self.donchian_channel_high:  # 当前价>唐奇安通道上轨，买入1个Unit；(持多仓)\\n            #if self.cmi>20 and self.current_price>self.up_line:\\n                #Log(\\\"当前价>唐奇安通道上轨，买入1个Unit(持多仓): %d 手\\\" % self.unit)\\n                self.set_position(self.state[\\\"position\\\"] + self.unit)\\n            elif self.current_price < self.donchian_channel_low:  # 当前价<唐奇安通道下轨，卖出1个Unit；(持空仓)\\n            #elif self.cmi>20 and self.current_price<self.down_line:\\n                #Log(\\\"当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           #Log(\\\"当前价<唐奇安通道下轨，卖出1个Unit(持空仓): %d 手\\\" % self.unit)\\n                self.set_position(self.state[\\\"position\\\"] - self.unit)\\n    def try_close(self):\\n        \\\"\\\"\\\"交易策略\\\"\\\"\\\"\\n        while self.state[\\\"position\\\"] != 0:\\n            if True:\\n                self.recalc_paramter()\\n                Log(\\\"最新价: \\\", self.current_price)\\n                #if self.cmi<20:\\n                #    self.set_position(0)\\n                if self.state[\\\"position\\\"] > 0:  # 持多单\\n                    # 加仓策略:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sition\\\"] > 0:  # 持多单\\n                    # 加仓策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了0.5N，就再加一个Unit的多仓,并且风险度在设定范围内(以防爆仓)\\n                    if self.current_price >= self.state[\\\"last_price\\\"] + 0.5 * self.n and self.state[\\\"position\\\"] + self.unit<=4*self.unit:\\n                        Log(\\\"加仓:加1个Unit的多仓\\\")\\n                        self.set_position(self.state[\\\"position\\\"] + self.unit)\\n                    # 止损策略: 如果是多仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了2N，就卖出全部头寸止损\\n                    elif self.current_price <= s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                    elif self.current_price <= self.state[\\\"last_price\\\"] - 2 * self.n:\\n                        Log(\\\"止损:卖出全部头寸\\\")\\n                        self.set_position(0)\\n                    # 止盈策略: 如果是多仓且行情最新价跌破了10日唐奇安通道的下轨，就清空所有头寸结束策略,离场\\n                    if self.current_price <= self.stop_low:\\n                    #if self.current_price<self.mid_line:\\n                        Log(\\\"止盈:清空所有头寸结束策略,离场\\\")\\n                        self.set_position(0)\\n                elif self.state[\\\"position\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n(0)\\n                elif self.state[\\\"position\\\"] < 0:  # 持空单\\n                    # 加仓策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又下跌了0.5N，就再加一个Unit的空仓,并且风险度在设定范围内(以防爆仓)\\n                    if self.current_price <= self.state[\\\"last_price\\\"] - 0.5 * self.n and (-self.state[\\\"position\\\"]) + self.unit<=4*self.unit:\\n                        Log(\\\"加仓:加1个Unit的空仓\\\")\\n                        self.set_position(self.state[\\\"position\\\"] - self.unit)\\n                    # 止损策略: 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ": 如果是空仓且行情最新价在上一次建仓（或者加仓）的基础上又上涨了2N，就平仓止损\\n                    elif self.current_price >= self.state[\\\"last_price\\\"] + 2 * self.n:\\n                        Log(\\\"止损:卖出全部头寸\\\")\\n                        self.set_position(0)\\n                    # 止盈策略: 如果是空仓且行情最新价升破了10日唐奇安通道的上轨，就清空所有头寸结束策略,离场\\n                    if self.current_price >= self.stop_high:\\n                    #if self.current_price>self.mid_line:\\n                        Log(\\\"止盈:清空所有头寸结束策略,离场\\\")\\n                        self.set_position(0)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                        self.set_position(0)\\n    def strategy(self):\\n        \\\"\\\"\\\"海龟策略\\\"\\\"\\\"\\n        Log(\\\"等待K线及账户数据...\\\")\\n        while not self.recalc_paramter():\\n            raise Exception(\\\"获取数据失败，请确认行情连接正常并已经登录交易账户\\\")\\n        while True:\\n            self.try_open()\\n            self.try_close()\\n\\n\\ndef main():\\n    exchange.SetContractType(\\\"quarter\\\")\\n    turtle = Turtle(donchian_channel_open_position=Donchian_open,donchian_channel_stop_profit=Donchian_stop,atr_day_length=Atr)\\n    Log(\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ofit=Donchian_stop,atr_day_length=Atr)\\n    Log(\\\"策略开始运行\\\")\\n\\n    Log(\\\"当前持仓数: %d, 上次调仓价: %f\\\" % (turtle.state[\\\"position\\\"], turtle.state[\\\"last_price\\\"]))\\n    turtle.strategy()\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/192353\\n\\n> Last Modified\\n\\n2020-03-23 14:44:24\"\n \n\n    \"strategy_109\",\n    \"python\\n'''backtest\\nstart: 2019-01-01 00:00:00\\nend: 2020-03-02 00:00:00\\nperiod: 1d\\nexchanges: [{\\\"eid\\\":\\\"OKEX\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":0}]\\nargs: [[\\\"fresh_rete\\\",24],[\\\"DC_range\\\",20",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\":0}]\\nargs: [[\\\"fresh_rete\\\",24],[\\\"DC_range\\\",20],[\\\"atrlength\\\",14]]\\n'''\\n\\n\\nimport numpy as np\\nimport pandas as pd\\nimport datetime\\n\\n\\ndata = {'ordertime':[],'id':[],'price':[]}\\nhisorder = pd.DataFrame(data)\\n    \\ndef turtle():\\n    #声明全局变量\\n    global hisorder\\n    \\n    acct = exchange.GetAccount()\\n\\n    records=exchange.GetRecords(fresh_rete*60*60)\\n\\n    ticker = exchange.GetTicker()\\n    \\n\\n    portfolio_value = acct.Balance+acct.FrozenBalance+(acct.Stocks+acct.FrozenStocks)*records[-1]['C",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nce+(acct.Stocks+acct.FrozenStocks)*records[-1]['Close']\\n    atr = TA.ATR(records, atrlength)[-1]\\n    #计算得到unit大小\\n    value = portfolio_value*trade_percent\\n    unit =  min(round(value/atr,4),round(acct.Balance/(ticker['Last']+100),4))\\n    #unit =  round(value/atr,2)\\n\\n    df = pd.DataFrame(records)\\n    current_price = records[-1]['Close']\\n    last_price = 0\\n    if len(hisorder)!=0:\\n        last_price = hisorder.iloc[-1]['price']\\n    max_price = df[-DC_range:-2]['High'].max()\\n    min_price = df[-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[-DC_range:-2]['High'].max()\\n    min_price = df[-int(DC_range/2):-2]['Low'].min() \\n    \\n    opensign = len(hisorder)==0 and current_price > max_price\\n    \\n\\n    addsign = len(hisorder)!=0 and current_price > last_price + 0.5*atr\\n\\n\\n    stopsign = len(hisorder)!=0 and current_price < min_price\\n    \\n    \\n    closesign = len(hisorder)!=0 and current_price < (last_price - 2*atr)\\n\\n    \\n#    if _D(records[-1]['Time']/1000) == '2020-01-25 00:00:00':\\n#        Log(\\\"records[-1]\\\",records[-1])\\n\\n\\n\\n\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        Log(\\\"records[-1]\\\",records[-1])\\n\\n\\n\\n\\n\\n    if opensign | addsign:\\n        if acct.Balance >= (ticker['Last']+10)*unit and unit >0:\\n            id = exchange.Buy(ticker['Last']+10,unit)\\n            orderinfo = exchange.GetOrder(id)\\n            data = {'ordertime':_D(records[-1]['Time']/1000),'id':id,'price':records[-1]['Close']}\\n            hisorder = hisorder.append(data,ignore_index=True)\\n            Log('买入后，最新账户信息：', exchange.GetAccount())\\n            Log(\\\"opensign\\\",opensign,\\\"addsi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "())\\n            Log(\\\"opensign\\\",opensign,\\\"addsign\\\",addsign)\\n    #    else:\\n    #        Log('余额已不足，请充值......', exchange.GetAccount())\\n    if stopsign | closesign:\\n        exchange.Sell(-1, acct.Stocks+acct.FrozenStocks)\\n        data = {'ordertime':[],'id':[],'price':[]}\\n        hisorder = pd.DataFrame(data)\\n        Log('卖出后，最新账户信息：', exchange.GetAccount())\\n        Log(\\\"stopsign\\\",stopsign,\\\"closesign\\\",closesign)\\n\\n    \\n\\n    \\ndef main():\\n    while True:\\n        turtle()\\n        Sleep(fre",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  while True:\\n        turtle()\\n        Sleep(fresh_rete*60*60*1000)\",\n    \"策略名称: 海龟策略btc现货版\\n\\n#        Log(\\\"records[-1]\\\",records[-1])\\n\\n\\n\\n\\n\\n    if opensign | addsign:\\n        if acct.Balance >= (ticker['Last']+10)*unit and unit >0:\\n            id = exchange.Buy(ticker['Last']+10,unit)\\n            orderinfo = exchange.GetOrder(id)\\n            data = {'ordertime':_D(records[-1]['Time']/1000),'id':id,'price':records[-1]['Close']}\\n            hisorder = hisorder.append(data,ignore_index=True)\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rder = hisorder.append(data,ignore_index=True)\\n            Log('买入后，最新账户信息：', exchange.GetAccount())\\n            Log(\\\"opensign\\\",opensign,\\\"addsign\\\",addsign)\\n    #    else:\\n    #        Log('余额已不足，请充值......', exchange.GetAccount())\\n    if stopsign | closesign:\\n        exchange.Sell(-1, acct.Stocks+acct.FrozenStocks)\\n        data = {'ordertime':[],'id':[],'price':[]}\\n        hisorder = pd.DataFrame(data)\\n        Log('卖出后，最新账户信息：', exchange.GetAccount())\\n        Log(\\\"stopsign\\\",stopsign,\\\"closesi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt())\\n        Log(\\\"stopsign\\\",stopsign,\\\"closesign\\\",closesign)\\n\\n    \\n\\n    \\ndef main():\\n    while True:\\n        turtle()\\n        Sleep(fresh_rete*60*60*1000)        \\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/186598\\n\\n> Last Modified\\n\\n2020-03-06 12:04:41\"\n \n\n    \"strategy_110\",\n    \"python\\n# -*- coding: UTF-8 -*-\\nimport requests\\nimport time\\nimport random\\nimport hashlib\\nimport sys\\nimport threading\\nfrom api import *\\n\\nsymbol = sys.argv[1]\\ngap= float(sys.argv[2]) #密度/价差\\nbaseamount",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rgv[1]\\ngap= float(sys.argv[2]) #密度/价差\\nbaseamount = float(sys.argv[3])\\nbasebuy = float(sys.argv[4])\\namount_add\\t= float(sys.argv[5]) \\t#挂单增量\\t数字型(number)\\namount_add2 = float(sys.argv[6]) \\t#挂单增量\\t数字型(number)\\nlongperoidlimit = int(sys.argv[7])\\nbigbase = float(sys.argv[8])\\t\\t\\t\\t#大单基准量\\norderlimit = int(sys.argv[9])   #总单量\\napi_key = sys.argv[10]\\nsecret_key = sys.argv[11]\\n\\nshortperoidlimit = 3\\t#高频单量\\n\\npre_short_id = []\\t#高平id标记\\npre_long_id = []\\t#低频id标记\\npre_big_id = 0\\n\\nrequests.packages.urllib",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "低频id标记\\npre_big_id = 0\\n\\nrequests.packages.urllib3.disable_warnings()\\n\\ndef GetTicker():\\n\\ndef GetPV():\\n\\ndef GetDepth():\\n\\ndef GetSign(sign_str):\\n\\n\\ndef GetOrders():\\n\\ndef create_order(side,price,amount):\\n\\ndef CancelOrder(order_id):\\n\\ndef Buy(price,amount):\\n\\ndef Sell(price,amount):\\n\\ndef GetRecords(symbol,period):\\n\\ndef GetPrecision():\\n\\ndef getrr():\\n\\ndef ordersend_shortperoid():\\n\\ndef ordersend_longperoid():\\n\\ndef send_big_order():\\n\\ndef cancel():\\n\\n\\nif __name__ == '__main__':\\n\\tpr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ef cancel():\\n\\n\\nif __name__ == '__main__':\\n\\tprecision = GetPrecision()\\n\\tprint(precision)\\n\\ti = 0\\n\\tfor x in precision:\\n\\t\\tif precision[i]['symbol'] == symbol:\\n\\t\\t\\tpricedot = precision[i]['price_precision']\\n\\t\\t\\tamountdot = precision[i]['amount_precision']\\n\\t\\ti += 1\\n\\tpricegap =  max(gap,pow(10,-pricedot))\\n\\tthreading_list = [ordersend_shortperoid,ordersend_longperoid,send_big_order,cancel]\\n\\tthreadingList = []\\n\\tthreadingDict = {}\\n\\tfor x in threading_list:\\n\\t\\tth = threading.Thread(t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " x in threading_list:\\n\\t\\tth = threading.Thread(target=x)\\n\\t\\tthreadingList.append(th)\\n\\t\\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\\n\\t\\tth.start()\\n\\n\\twhile True:\\n\\t\\ttry:\\n\\t\\t\\ttime.sleep(200)\\n\\t\\t\\tfor i in threadingList:\\n\\t\\t\\t\\tif i.is_alive() is False:\\n\\t\\t\\t\\t\\tthreadingList.remove(i)\\n\\t\\t\\t\\t\\tresult = threadingDict.pop(i.name)\\n\\t\\t\\t\\t\\tth = threading.Thread(target=result)\\n\\t\\t\\t\\t\\tthreadingList.append(th)\\n\\t\\t\\t\\t\\tthreadingDict[th.__dict__['_name']] = th.__dict__",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\\n\\t\\t\\t\\t\\tth.start()\\n\\t\\texcept Exception as e:\\n\\t\\t\\tprint('check error',e)\",\n    \"策略名称: 深度做市-盘口控制-操盘机器人-做市工具\\n\\nimport requests\\nimport time\\nimport random\\nimport hashlib\\nimport sys\\nimport threading\\nfrom api import *\\n\\nsymbol = sys.argv[1]\\ngap= float(sys.argv[2]) #密度/价差\\nbaseamount = float(sys.argv[3])\\nbasebuy = float(sys.argv[4])\\namount_add\\t= float(sys.argv[5]) \\t#挂单增量\\t数字型(number)\\namount_add2 = float(sys.argv[6]) \\t#挂单增量\\t数字型(num",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "namount_add2 = float(sys.argv[6]) \\t#挂单增量\\t数字型(number)\\nlongperoidlimit = int(sys.argv[7])\\nbigbase = float(sys.argv[8])\\t\\t\\t\\t#大单基准量\\norderlimit = int(sys.argv[9])   #总单量\\napi_key = sys.argv[10]\\nsecret_key = sys.argv[11]\\n\\nshortperoidlimit = 3\\t#高频单量\\n\\npre_short_id = []\\t#高平id标记\\npre_long_id = []\\t#低频id标记\\npre_big_id = 0\\n\\nrequests.packages.urllib3.disable_warnings()\\n\\ndef GetTicker():\\n\\ndef GetPV():\\n\\ndef GetDepth():\\n\\ndef GetSign(sign_str):\\n\\n\\ndef GetOrders():\\n\\ndef create_order(side,price,am",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "def GetOrders():\\n\\ndef create_order(side,price,amount):\\n\\ndef CancelOrder(order_id):\\n\\ndef Buy(price,amount):\\n\\ndef Sell(price,amount):\\n\\ndef GetRecords(symbol,period):\\n\\ndef GetPrecision():\\n\\ndef getrr():\\n\\ndef ordersend_shortperoid():\\n\\ndef ordersend_longperoid():\\n\\ndef send_big_order():\\n\\ndef cancel():\\n\\n\\nif __name__ == '__main__':\\n\\tprecision = GetPrecision()\\n\\tprint(precision)\\n\\ti = 0\\n\\tfor x in precision:\\n\\t\\tif precision[i]['symbol'] == symbol:\\n\\t\\t\\tpricedot = precision[i]['price_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == symbol:\\n\\t\\t\\tpricedot = precision[i]['price_precision']\\n\\t\\t\\tamountdot = precision[i]['amount_precision']\\n\\t\\ti += 1\\n\\tpricegap =  max(gap,pow(10,-pricedot))\\n\\tthreading_list = [ordersend_shortperoid,ordersend_longperoid,send_big_order,cancel]\\n\\tthreadingList = []\\n\\tthreadingDict = {}\\n\\tfor x in threading_list:\\n\\t\\tth = threading.Thread(target=x)\\n\\t\\tthreadingList.append(th)\\n\\t\\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\\n\\t\\tth.start()\\n\\n\\twhile True:\\n\\t\\ttry:\\n\\t\\t\\tti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t\\tth.start()\\n\\n\\twhile True:\\n\\t\\ttry:\\n\\t\\t\\ttime.sleep(200)\\n\\t\\t\\tfor i in threadingList:\\n\\t\\t\\t\\tif i.is_alive() is False:\\n\\t\\t\\t\\t\\tthreadingList.remove(i)\\n\\t\\t\\t\\t\\tresult = threadingDict.pop(i.name)\\n\\t\\t\\t\\t\\tth = threading.Thread(target=result)\\n\\t\\t\\t\\t\\tthreadingList.append(th)\\n\\t\\t\\t\\t\\tthreadingDict[th.__dict__['_name']] = th.__dict__['_target']\\n\\t\\t\\t\\t\\tth.start()\\n\\t\\texcept Exception as e:\\n\\t\\t\\tprint('check error',e)\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/146238\\n\\n> Last",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "l\\n\\nhttps://www.fmz.com/strategy/146238\\n\\n> Last Modified\\n\\n2019-12-10 13:39:07\"\n \n\n    \"strategy_111\",\n    \"python\\n\\n\\nimport time\\nimport requests\\nimport math\\n\\naccount = 0          #保存用户资产\\nupdateProfitTime = 0   #更新收益率间隔时间\\ntradeInfo = {}         #保存交易对信息\\naccountAssets = {}\\nticker = {}\\nruntimeData = {}\\nFunding = 0   #账户资金  为0的时候自动获取\\nVersion = '0.0.1'\\nsbs = list(symbols.split(','))\\n\\n\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nif IsVirtua",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif exchange.GetName() != 'Binance':\\n    Log('只支持币安现货交易所！')\\n    exit()\\n\\ndef init():\\n    exchangeInfo = requests.get('https://api.binance.com/api/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法链接币安网络，需要海外托管者！！！')\\n        exit()\\n    for x in range(len(exchangeInfo['symbols'])):\\n        for symbol in sbs:\\n            if exchangeInfo['symbols'][x]['symbol'] == symbol+'USDT':\\n                ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "][x]['symbol'] == symbol+'USDT':\\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][x]['filters'][2]['minQty']) ,\\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][2]['stepSize']))))}\\n    # Log('tradeInfo:',tradeInfo)\\n\\ndef UpdateAccount():\\n    global accountAssets,Funding,account\\n    acc = exchange.GetAccount()\\n    if _G('Funding') is N",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= exchange.GetAccount()\\n    if _G('Funding') is None:\\n        Funding = account['Balance']\\n        Log('Funding:',Funding)\\n        _G('Funding',Funding)\\n    else:\\n        Funding = _G('Funding')\\n\\n    if account is None:\\n        Log('更新账户超时！！！')\\n        return\\n\\n    for x in range(len(acc['Info']['balances'])):\\n        for symbol in sbs:\\n            # Log(account['Info']['balances'])\\n            if acc['Info']['balances'][x]['asset'] == symbol:\\n                accountAssets[symbol] = acc['Info",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                accountAssets[symbol] = acc['Info']['balances'][x]\\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\\n                # Log('USDT:',acc['Info']['balances'][x])\\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\\n\\n    # Log('accountAssets:',accountAssets)\\n\\n\\ndef UpdateTick():\\n    globa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "',accountAssets)\\n\\n\\ndef UpdateTick():\\n    global ticker,account\\n    try:\\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\\n    except:\\n        Log('更新行情超时')\\n        return\\n    for x in range(len(res)):\\n        for symbol in sbs:\\n            if res[x]['symbol'] == symbol + 'USDT':\\n                # Log('res[x]:',res[x])\\n                ticker[symbol] = res[x]\\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "cker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\\n    # Log('ticker:',ticker)\\n    # account = 0\\n    for symbol in sbs:\\n        account += _N(ticker[symbol]['value'],4)\\n\\ndef Trade(symbol,direction,price,amount):\\n    if amount < tradeInfo[symbol]['minQty']:\\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n    else:\\n        para = ''",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ty'] * price,4) + 1)\\n    else:\\n        para = ''\\n        url = '/api/v3/order'\\n        para += 'symbol='+ symbol +'USDT'\\n        para += '&side='+ direction\\n        para += '&type=LIMIT&timeInForce=IOC'\\n        para += '&quantity='+ str(amount)\\n        para += '&price='+ str(price)\\n        para += '&timestamp='+str(time.time() * 1000);\\n        go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n        ret = go.wait()\\n        if ret  is not None:\\n            logType = LOG_TYPE_SELL\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ne:\\n            logType = LOG_TYPE_SELL\\n            if direction == 'BUY':\\n                logType =LOG_TYPE_BUY\\n            exchange.Log(logType,price,amount,symbol)\\n\\ndef UpdateStatus():\\n    global updateProfitTime\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '币",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      'title': '交易对信息',\\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\\n        'rows': []\\n    }\\n    totalProfit = account - Funding\\n    profitColors = DangerColor\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday   #平均日收益\\n    dayRate = totalProfit / Funding * 100\\n    accountTable['rows'].append([\\n    runday,\\n    Funding,\\n    account,\\n    str(_N(totalProf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    Funding,\\n    account,\\n    str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n    str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n    str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n    str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n    i=1\\n    for symbol in sbs:\\n        table['rows'].append([\\n        i,\\n        symbol,\\n        str(_N(tick",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        i,\\n        symbol,\\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\\n        str(_N(ticker[symbol]['value'],4))\\n        ])\\n        i += 1\\n\\n    retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n'\\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(tabl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "umps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = account - Funding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n\\ndef Process():\\n\\n    # Log('实时资金：',account)\\n    for symbol in sbs:\\n\\n        pct = float(ticker[symbol]['value']) / float(account)\\n        # Log(symbol,'amount:',amount,1 / len(sbs))\\n        if pct > (1 / len(sbs) + 0.015):\\n            # Log('",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pct > (1 / len(sbs) + 0.015):\\n            # Log('SELL',pct)\\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\\n            amount = _N( ( (pct-1/len(sbs) ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\\n            Trade(symbol,'SELL',_N(float(ticker[symbol]['askPrice']), int(tradeInfo[symbol]['priceSize'])),  amount)\\n        if pct < (1 / len(sbs) - 0.015):\\n            # Log('Buy', pct)\\n            Log(symbol ,'Funding:',Funding,'value:',ticker",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\\n            amount = _N( ( (1/len(sbs)-pct ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\\n            Trade(symbol,'BUY',_N(float(ticker[symbol]['bidPrice']), tradeInfo[symbol]['priceSize']),  amount)\\n\\n\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    star",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef main():\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        U",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n        #休眠时间\\n        Sleep(Interval * 1000)\",\n    \"策略名称: 现货平衡策略-001v\\n\\ndef UpdateAccount():\\n    global accountAssets,Funding,account\\n    acc = exchange.GetAccount()\\n    if _G('Funding') is None:\\n        Funding = account['Balance']\\n        Log('Funding:',Funding)\\n        _G('Funding',Funding)\\n    else:\\n        Funding = _G('Funding')\\n\\n    if account is None:\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nding = _G('Funding')\\n\\n    if account is None:\\n        Log('更新账户超时！！！')\\n        return\\n\\n    for x in range(len(acc['Info']['balances'])):\\n        for symbol in sbs:\\n            # Log(account['Info']['balances'])\\n            if acc['Info']['balances'][x]['asset'] == symbol:\\n                accountAssets[symbol] = acc['Info']['balances'][x]\\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\\n            if acc['Info']['bal",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ymbol]['locked'])\\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\\n                # Log('USDT:',acc['Info']['balances'][x])\\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\\n\\n    # Log('accountAssets:',accountAssets)\\n\\n\\ndef UpdateTick():\\n    global ticker,account\\n    try:\\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\\n    except:\\n        Log('更新行情超时')\\n        return\\n    for x in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       Log('更新行情超时')\\n        return\\n    for x in range(len(res)):\\n        for symbol in sbs:\\n            if res[x]['symbol'] == symbol + 'USDT':\\n                # Log('res[x]:',res[x])\\n                ticker[symbol] = res[x]\\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\\n    # Log('ticker:',ticker)\\n    # account = 0\\n    for symb",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'ticker:',ticker)\\n    # account = 0\\n    for symbol in sbs:\\n        account += _N(ticker[symbol]['value'],4)\\n\\ndef Trade(symbol,direction,price,amount):\\n    if amount < tradeInfo[symbol]['minQty']:\\n        Log(symbol,'合约价值偏离或冰山委托设置的过小，达不到最小成交额，最小需要：', _N(tradeInfo[symbol]['minQty'] * price,4) + 1)\\n    else:\\n        para = ''\\n        url = '/api/v3/order'\\n        para += 'symbol='+ symbol +'USDT'\\n        para += '&side='+ direction\\n        para += '&type=LIMIT&timeInForce=IOC'\\n        para += '&q",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'&type=LIMIT&timeInForce=IOC'\\n        para += '&quantity='+ str(amount)\\n        para += '&price='+ str(price)\\n        para += '&timestamp='+str(time.time() * 1000);\\n        go = exchange.Go(\\\"IO\\\", \\\"api\\\", \\\"POST\\\", url, para)\\n        ret = go.wait()\\n        if ret  is not None:\\n            logType = LOG_TYPE_SELL\\n            if direction == 'BUY':\\n                logType =LOG_TYPE_BUY\\n            exchange.Log(logType,price,amount,symbol)\\n\\ndef UpdateStatus():\\n    global updateProfitTime\\n    a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pdateStatus():\\n    global updateProfitTime\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\\n        'rows': []\\n    }\\n    totalProfit = account - Funding\\n    profitColors = DangerColor\\n    runday = runtimeData['dayDiff']\\n    if",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Color\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday   #平均日收益\\n    dayRate = totalProfit / Funding * 100\\n    accountTable['rows'].append([\\n    runday,\\n    Funding,\\n    account,\\n    str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n    str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n    str",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_N(dayProfit * 365, 2)) + (profitColors),\\n    str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n    str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n    i=1\\n    for symbol in sbs:\\n        table['rows'].append([\\n        i,\\n        symbol,\\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\\n        str(_N(ticker[symbol]['price'],tradeInfo[sym",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\\n        str(_N(ticker[symbol]['value'],4))\\n        ])\\n        i += 1\\n\\n    retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + 'Version:' + Version  + '\\\\n'\\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = account - Funding\\n        LogProfit(_N(balance, 3))\\n        updateProf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n\\ndef Process():\\n\\n    # Log('实时资金：',account)\\n    for symbol in sbs:\\n\\n        pct = float(ticker[symbol]['value']) / float(account)\\n        # Log(symbol,'amount:',amount,1 / len(sbs))\\n        if pct > (1 / len(sbs) + 0.015):\\n            # Log('SELL',pct)\\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\\n            amount = _N( ( (pct-1/len(sbs) ) * account / float(ticker[symbol]['price'])),",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bs) ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\\n            Trade(symbol,'SELL',_N(float(ticker[symbol]['askPrice']), int(tradeInfo[symbol]['priceSize'])),  amount)\\n        if pct < (1 / len(sbs) - 0.015):\\n            # Log('Buy', pct)\\n            Log(symbol ,'Funding:',Funding,'value:',ticker[symbol]['value'])\\n            amount = _N( ( (1/len(sbs)-pct ) * account / float(ticker[symbol]['price'])),tradeInfo[symbol]['amountSize'])\\n            Trade(symbol,'BUY',_N(fl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mountSize'])\\n            Trade(symbol,'BUY',_N(float(ticker[symbol]['bidPrice']), tradeInfo[symbol]['priceSize']),  amount)\\n\\n\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 10",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "me.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef main():\\n    Set",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "es) + '分钟'\\n    return ret\\n\\ndef main():\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n        #休眠时间\\n        Sleep(Interval * 1000)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/stra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "00)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/322357\\n\\n> Last Modified\\n\\n2021-10-10 20:50:05\"\n \n\n    \"strategy_112\",\n    \"python\\n\\nimport json\\nimport time\\nimport requests\\nimport math\\n\\naccount = 0  \\nupdateProfitTime = 0 \\ntradeInfo = {} \\naccountAssets = {}\\nticker = {}\\nruntimeData = {}\\nFunding = 0\\n\\nsbs = list(symbols.split(','))\\npcts = list(percent.split(','))\\nfor i in range(len(pcts)):\\n    pcts[i] = float(pcts[i])\\n\\np_dic = {\\n            'ETH':[2,4], 'BTC':[2,5], 'XRP':[4,0], 'TR",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        'ETH':[2,4], 'BTC':[2,5], 'XRP':[4,0], 'TRX':[5,1], 'LTC':[1,3], 'BNB':[1,3]\\n         }    #价格、数量精度，按需求添加\\n\\n\\nSuccessColor = '#5cb85c' #成功颜色\\nDangerColor = '#ff0000' #危险颜色\\nWrningColor = '#f0ad4e' #警告颜色\\n\\nif IsVirtual():\\n    Log('不能进行回测')\\n    exit()\\n\\nif exchange.GetName() != 'Binance':\\n    Log('只支持币安现货交易所！')\\n    exit()\\n\\ndef init():\\n    exchangeInfo = requests.get('https://api.binance.com/api/v1/exchangeInfo').json()\\n    if exchangeInfo is None:\\n        Log('无法链接币安网络，需要海外托管者！！！')\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s None:\\n        Log('无法链接币安网络，需要海外托管者！！！')\\n        exit()\\n    for x in range(len(exchangeInfo['symbols'])):\\n        for symbol in sbs:\\n            if exchangeInfo['symbols'][x]['symbol'] == symbol+'USDT':\\n                tradeInfo[symbol] = {'minQty': float(exchangeInfo['symbols'][x]['filters'][2]['minQty']) ,\\n                'priceSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][0]['tickSize'])))),'amountSize': int((math.log10(1.1/float(exchangeInfo['symbols'][x]['filters'][2][",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".1/float(exchangeInfo['symbols'][x]['filters'][2]['stepSize']))))}\\n    # Log('tradeInfo:',tradeInfo)\\n\\ndef UpdateAccount():\\n    global accountAssets,Funding,account\\n    acc = exchange.GetAccount()\\n\\n    if acc is None:\\n        Log('更新账户超时！！！')\\n        return\\n\\n    if _G('Funding') is None:\\n        Funding = acc['Balance']\\n        Log('Funding:',Funding)\\n        _G('Funding',Funding)\\n    else:\\n        Funding = _G('Funding')\\n    if init_fund >0:\\n        Funding = init_fund\\n    \\n\\n    for x i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        Funding = init_fund\\n    \\n\\n    for x in range(len(acc['Info']['balances'])):\\n        for symbol in sbs:\\n            # Log(account['Info']['balances'])\\n            if acc['Info']['balances'][x]['asset'] == symbol:\\n                accountAssets[symbol] = acc['Info']['balances'][x]\\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\\n                # Log('",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'][x]['asset'] == 'USDT':\\n                # Log('USDT:',acc['Info']['balances'][x])\\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\\n\\n    # Log('accountAssets:',accountAssets)\\n\\ndef UpdateTick():\\n    global ticker,account\\n    try:\\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\\n    except:\\n        Log('更新行情超时')\\n        return\\n    for x in range(len(res)):\\n        for symbol in sbs:\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "len(res)):\\n        for symbol in sbs:\\n            if res[x]['symbol'] == symbol + 'USDT':\\n                # Log('res[x]:',res[x])\\n                ticker[symbol] = res[x]\\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\\n    # Log('ticker:',ticker)\\n    # account = 0\\n    for symbol in sbs:\\n        account += _N(ticker[symbol]['value']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bs:\\n        account += _N(ticker[symbol]['value'],4)\\n\\ndef UpdateStatus():\\n    global updateProfitTime\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\\n        'rows': []\\n    }\\n    totalProfit = account - Funding\\n    profitCol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    totalProfit = account - Funding\\n    profitColors = DangerColor\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday   #平均日收益\\n    dayRate = totalProfit / Funding * 100\\n    accountTable['rows'].append([\\n    runday,\\n    Funding,\\n    account,\\n    str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n    str(_N(dayRate * 365, 2)) + \\\"% ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ofitColors),\\n    str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n    str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n    str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n    i=1\\n    for symbol in sbs:\\n        table['rows'].append([\\n        i,\\n        symbol,\\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountS",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\\n        str(_N(ticker[symbol]['value'],4))\\n        ])\\n        i += 1\\n\\n    retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + '本策略改编自XMaxZone大佬的现货平衡策略-0.0.1v，原策略地址：https://www.fmz.com/strategy/322357' + '\\\\n'\\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(time.time()*1000) - updateProfitTime ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = account - Funding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n\\ndef Process():\\n    # Log('实时资金：',account)\\n    for i in range(len(sbs)):\\n        pct = float(ticker[sbs[i]]['value']) / float(account)\\n        # Log(symbol,'amount:',amount,1 / len(sbs))\\n        if pct > (pcts[i] + delta):\\n            # Log('SELL',pct)\\n            amount = _N( ( (pct-pcts[i] ) * account / fl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      amount = _N( ( (pct-pcts[i] ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\\n                # Trade(sbs[i],'SELL',_N(float(ticker[sbs[i]]['askPrice']), int(tradeInfo[sbs[i]]['priceSize'])),  amount)\\n                exchange.SetCurrency(sbs[i]+'_USDT')\\n                exchange.SetP",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ncy(sbs[i]+'_USDT')\\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\\n                exchange.Sell(float(ticker[sbs[i]]['bidPrice'])*(1-slip), amount)\\n        if pct < (pcts[i] - delta):\\n            # Log('Buy', pct)\\n            amount = _N( ( (pcts[i]-pct ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\\n                Log(sbs[i] ,'Funding",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lue']) > 10:\\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\\n                # Trade(sbs[i],'BUY',_N(float(ticker[sbs[i]]['bidPrice']), tradeInfo[sbs[i]]['priceSize']),  amount)\\n                exchange.SetCurrency(sbs[i]+'_USDT')\\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\\n                exchange.Buy(float(ticker[sbs[i]]['bidPrice'])*(1+slip), amount)\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    l",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef main():\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n        #休眠时间\\n        Sleep(Interval * 1000)\",\n    \"策略名称: 现货指数平衡策略-v11曾实盘跑过一段时间现在疑似有bug因为不用了懒得改\\n\\ndef UpdateAccount():\\n    global accountAssets,Funding,account\\n    acc = exchange.GetAccount()\\n\\n    if acc is None:\\n        Log('更新账户超时！！！')\\n        retur",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " is None:\\n        Log('更新账户超时！！！')\\n        return\\n\\n    if _G('Funding') is None:\\n        Funding = acc['Balance']\\n        Log('Funding:',Funding)\\n        _G('Funding',Funding)\\n    else:\\n        Funding = _G('Funding')\\n    if init_fund >0:\\n        Funding = init_fund\\n    \\n\\n    for x in range(len(acc['Info']['balances'])):\\n        for symbol in sbs:\\n            # Log(account['Info']['balances'])\\n            if acc['Info']['balances'][x]['asset'] == symbol:\\n                accountAssets[symbo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'] == symbol:\\n                accountAssets[symbol] = acc['Info']['balances'][x]\\n                accountAssets[symbol]['amount'] = float(accountAssets[symbol]['free']) + float(accountAssets[symbol]['locked'])\\n            if acc['Info']['balances'][x]['asset'] == 'USDT':\\n                # Log('USDT:',acc['Info']['balances'][x])\\n                account = float(acc['Info']['balances'][x]['free']) + float(acc['Info']['balances'][x]['locked'])\\n\\n    # Log('accountAssets:',accountAssets)\\n\\ndef UpdateTick()",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "accountAssets:',accountAssets)\\n\\ndef UpdateTick():\\n    global ticker,account\\n    try:\\n        res = requests.get('https://api.binance.com/api/v3/ticker/bookTicker').json()\\n    except:\\n        Log('更新行情超时')\\n        return\\n    for x in range(len(res)):\\n        for symbol in sbs:\\n            if res[x]['symbol'] == symbol + 'USDT':\\n                # Log('res[x]:',res[x])\\n                ticker[symbol] = res[x]\\n                ticker[symbol]['price'] = (float(ticker[symbol]['askPrice']) + float(tick",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = (float(ticker[symbol]['askPrice']) + float(ticker[symbol]['bidPrice'])) / 2\\n                ticker[symbol]['value'] = accountAssets[symbol]['amount'] * ticker[symbol]['price']\\n    # Log('ticker:',ticker)\\n    # account = 0\\n    for symbol in sbs:\\n        account += _N(ticker[symbol]['value'],4)\\n\\ndef UpdateStatus():\\n    global updateProfitTime\\n    accountTable = {\\n        'type': \\\"table\\\",\\n        'title': \\\"盈利统计\\\",\\n        'cols': [\\\"运行天数\\\", \\\"初始资金\\\", \\\"现有资金\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "初始资金\\\", \\\"现有资金\\\", \\\"总收益\\\", \\\"预计年化\\\", \\\"预计月化\\\", \\\"平均日化\\\"],\\n        'rows': []\\n    }\\n\\n    table = {\\n        'type': 'table',\\n        'title': '交易对信息',\\n        'cols': ['编号', '币种信息', '占比%', '开仓数量',  '当前价格', '持仓价值'],\\n        'rows': []\\n    }\\n    totalProfit = account - Funding\\n    profitColors = DangerColor\\n    runday = runtimeData['dayDiff']\\n    if runday == 0:\\n        runday = 1\\n    if totalProfit > 0:\\n        profitColors = SuccessColor\\n    dayProfit = totalProfit / runday   #平均日收益\\n    dayR",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ayProfit = totalProfit / runday   #平均日收益\\n    dayRate = totalProfit / Funding * 100\\n    accountTable['rows'].append([\\n    runday,\\n    Funding,\\n    account,\\n    str(_N(totalProfit / Funding * 100, 2)) + \\\"% = $\\\" + str(_N(totalProfit, 2)) + (profitColors),\\n    str(_N(dayRate * 365, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 365, 2)) + (profitColors),\\n    str(_N(dayRate * 30, 2)) + \\\"% = $\\\" + str(_N(dayProfit * 30, 2)) + (profitColors),\\n    str(_N(dayRate, 2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitC",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "2)) + \\\"% = $\\\" + str(_N(dayProfit, 2)) + (profitColors)\\n    ])\\n\\n    i=1\\n    for symbol in sbs:\\n        table['rows'].append([\\n        i,\\n        symbol,\\n        str(_N(ticker[symbol]['value'] / account * 100, 4 )),\\n        str(_N(accountAssets[symbol]['amount'],tradeInfo[symbol]['amountSize'])),\\n        str(_N(ticker[symbol]['price'],tradeInfo[symbol]['priceSize'])),\\n        str(_N(ticker[symbol]['value'],4))\\n        ])\\n        i += 1\\n\\n    retData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tData = runtimeData['str'] + '\\\\n' + \\\"最后更新: \\\" + _D() + '\\\\n' + '本策略改编自XMaxZone大佬的现货平衡策略-0.0.1v，原策略地址：https://www.fmz.com/strategy/322357' + '\\\\n'\\n    LogStatus(retData+ '`' + json.dumps(accountTable) + '`\\\\n'+ '`' + json.dumps(table) + '`\\\\n')\\n\\n    if int(time.time()*1000) - updateProfitTime > LogInterval * 1000:\\n        balance = account - Funding\\n        LogProfit(_N(balance, 3))\\n        updateProfitTime = int(time.time()*1000)\\n\\ndef Process():\\n    # Log('实时资金：',account)\\n    for i in range(len(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   # Log('实时资金：',account)\\n    for i in range(len(sbs)):\\n        pct = float(ticker[sbs[i]]['value']) / float(account)\\n        # Log(symbol,'amount:',amount,1 / len(sbs))\\n        if pct > (pcts[i] + delta):\\n            # Log('SELL',pct)\\n            amount = _N( ( (pct-pcts[i] ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\\n                Log(sbs[i] ,'Funding:',Fu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ") > 10:\\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\\n                # Trade(sbs[i],'SELL',_N(float(ticker[sbs[i]]['askPrice']), int(tradeInfo[sbs[i]]['priceSize'])),  amount)\\n                exchange.SetCurrency(sbs[i]+'_USDT')\\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\\n                exchange.Sell(float(ticker[sbs[i]]['bidPrice'])*(1-slip), amount)\\n        if pct < (pcts[i] - delta):\\n            # Log('Buy', pct)\\n            amoun",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            # Log('Buy', pct)\\n            amount = _N( ( (pcts[i]-pct ) * account / float(ticker[sbs[i]]['price'])),tradeInfo[sbs[i]]['amountSize'])\\n            if amount >= tradeInfo[sbs[i]]['minQty'] and float(amount)*float(ticker[sbs[i]]['value']) > 10:\\n                Log(sbs[i] ,'Funding:',Funding,'value:',ticker[sbs[i]]['value'])\\n                # Trade(sbs[i],'BUY',_N(float(ticker[sbs[i]]['bidPrice']), tradeInfo[sbs[i]]['priceSize']),  amount)\\n                exchange.SetCurrency(sbs[i]+'_USDT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                exchange.SetCurrency(sbs[i]+'_USDT')\\n                exchange.SetPrecision(p_dic[sbs[i]][0], p_dic[sbs[i]][1])\\n                exchange.Buy(float(ticker[sbs[i]]['bidPrice'])*(1+slip), amount)\\n\\ndef StartTime():\\n    StartTime = _G('StartTime')\\n    if StartTime is None:\\n        StartTime = _D()\\n        _G('StartTime',StartTime)\\n    return StartTime\\n\\ndef RunTime():\\n    ret = {}\\n    startTime = StartTime()\\n    nowTime = _D()\\n    dateDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eDiff = (time.mktime(time.strptime(nowTime,'%Y-%m-%d %H:%M:%S')) - time.mktime(time.strptime(startTime,'%Y-%m-%d %H:%M:%S')) ) * 1000  #计算时间差\\n    dayDiff = math.floor(dateDiff / (24 * 3600 * 1000))\\n    lever1 = dateDiff % (24 * 3600 * 1000 )\\n    hours = math.floor(lever1 / (3600 * 1000))\\n    lever2 = lever1 % (3600 * 1000)\\n    minutes = math.floor(lever2 / (60 * 1000))\\n\\n    ret['dayDiff'] = dayDiff\\n    ret['hours'] = hours\\n    ret['minutes'] = minutes\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "es\\n    ret['str'] = '运行时间：' + str(dayDiff) + '天' + str(hours) + '小时' + str(minutes) + '分钟'\\n    return ret\\n\\ndef main():\\n    SetErrorFilter(\\\"502:|503:|tcp|character|unexpected|network|timeout|WSARecv|Connect|GetAddr|no such|reset|http|received|EOF|reused|Unknown\\\")\\n    global runtimeData\\n\\n    while True:\\n        runtimeData = RunTime()\\n        #更新账户和持仓\\n        UpdateAccount()\\n        #更新行情\\n        UpdateTick()\\n        #策略主逻辑\\n        Process()\\n        #更新图表\\n        UpdateStatus()\\n        #休眠",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        #更新图表\\n        UpdateStatus()\\n        #休眠时间\\n        Sleep(Interval * 1000)\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/329093\\n\\n> Last Modified\\n\\n2021-12-04 20:53:35\"\n \n\n    \"strategy_113\",\n    \"python\\nimport random\\n\\ndef main():\\n    account = exchange.GetAccount()\\n    balance = account[\\\"Balance\\\"]\\n    while True:\\n        LogProfit(balance - account[\\\"Balance\\\"])\\n        balance = balance * (1 + (0.5 - random.random()) / 1000 + 1 / 100000)\\n        Sleep(1000 * 60)\",\n    \"策略名称: 画线",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 100000)\\n        Sleep(1000 * 60)\",\n    \"策略名称: 画线机器人一年翻倍回撤1完美曲线\\n\\n未找到描述\"\n \n\n    \"strategy_114\",\n    \"python\\n# -*- coding: UTF-8 -*-\\nimport time\\nfrom api import *\\nfrom Huobiapi import *\\nimport sqlite3\\n\\ndef wechatmsg(text,desp):\\n\\tserver = 'https://sc.ftqq.com/xxxxxx.send'\\n\\tpayload = {'text':text,'desp':desp}\\n\\trequests.post(server,params = payload)\\n\\ndef dingmsg(title,msg):\\n\\turl = 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxx'\\n\\tdata = {\\n\\t\\t\\t \\\"msgtype\\\": \\\"markdown\\\",\\n\\t\\t\\t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ata = {\\n\\t\\t\\t \\\"msgtype\\\": \\\"markdown\\\",\\n\\t\\t\\t \\\"markdown\\\": {\\n\\t\\t\\t\\t \\\"title\\\":title+msg,\\n\\t\\t\\t\\t \\\"text\\\": \\\"#### \\\" + title + \\\"\\\\n\\\"\\n\\t\\t\\t\\t\\t\\t \\\"> \\\" + msg\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t}}\\t\\t \\n\\theader = {'Content-Type':'application/json'}\\n\\tr = requests.post(url = url ,headers=header,data = json.dumps(data)).json()\\n\\treturn r\\n\\ndef check():\\n\\ttry:\\n\\t\\tpre_balance = {}\\n\\t\\tconn = sqlite3.connect(\\\"/root/bot/hedge.db\\\")\\n\\t\\tcursor = conn.cursor()\\n\\t\\tsql = 'select * from balance order by id ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r()\\n\\t\\tsql = 'select * from balance order by id desc limit 20;'\\n\\t\\tresult = list(cursor.execute(sql))\\n\\t\\tfor a in result:\\n\\t\\t\\tif a[1] in list(pre_balance.keys()):\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpre_balance[a[1]] = a[2]   #读取之前balance\\n\\t\\tcoinname = list(pre_balance.keys())\\n\\t\\tprint(pre_balance,coinname)\\n\\n\\t\\tbalance = GetBalance()\\n\\t\\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\\n\\t\\tfor x in balance:  \\n\\t\\t\\tsql = \\\"insert into balance (coin,balance,time) values",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= \\\"insert into balance (coin,balance,time) values(?,?,?);\\\"\\n\\t\\t\\tb = x['balance']+x['frozenBalance']\\n\\t\\t\\tif b != 0:\\n\\t\\t\\t\\tv = (x['coin']['unit'],b,t)\\n\\t\\t\\t\\tprint(v)\\n\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\tfor n in coinname:\\n\\t\\t\\t\\tif n == x['coin']['unit']:\\n\\t\\t\\t\\t\\td = round(b - pre_balance[n],5)   #数量差\\n\\t\\t\\t\\t\\tif d > 0:\\n                        Sell(n,d)\\n\\t\\t\\t\\t\\t\\tmsg = '对冲卖出'+n+'数量：'+str(d)\\n\\t\\t\\t\\t\\t\\tprint(msg)\\n\\t\\t\\t\\t\\t\\twechatmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tdingmsg('对冲',msg)\\n\\t\\t\\t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g('对冲',msg)\\n\\t\\t\\t\\t\\t\\tdingmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tsql = \\\"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\\\"\\n\\t\\t\\t\\t\\t\\tv = (n,d,0,t)\\n\\t\\t\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\t\\t\\telif d < 0:\\n                        Buy(n,d)\\n\\t\\t\\t\\t\\t\\tmsg = '对冲买入：'+n+'数量：'+str(d)\\n\\t\\t\\t\\t\\t\\tprint(msg)\\n\\t\\t\\t\\t\\t\\twechatmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tdingmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tsql = \\\"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\\\"\\n\\t\\t\\t\\t\\t\\tv = (n,d,0,t)\\n\\t\\t\\t\\t\\t\\t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "?,?,?);\\\"\\n\\t\\t\\t\\t\\t\\tv = (n,d,0,t)\\n\\t\\t\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprint('no hedge')\\n\\n\\t\\tconn.commit()\\n\\t\\tconn.close()\\n\\texcept Exception as e:\\n\\t\\traise e\\n\\t\\ndef insert_balance():\\n\\ttry:\\n\\t\\tconn = sqlite3.connect(\\\"hedge.db\\\")\\n\\t\\tcursor = conn.cursor()\\n\\t\\tbalance = GetBalance()\\n\\t\\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\\n\\t\\tfor x in balance:\\n\\t\\t\\tsql = \\\"insert into balance (coin,balance,time) values(?,?,?);\\\"\\n\\t\\t\\tb = x[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(coin,balance,time) values(?,?,?);\\\"\\n\\t\\t\\tb = x['balance']+x['frozenBalance']\\n\\t\\t\\tif b != 0:\\n\\t\\t\\t\\tv = (x['coin']['unit'],b,t)\\n\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\tconn.commit()\\n\\t\\tconn.close()\\n\\t\\tprint('finish')\\n\\texcept Exception as e:\\n\\t\\tprint('err',e)\\n\\nif __name__ == '__main__':\\n\\twhile 1:\\n\\t\\ttry:\\n\\t\\t\\tcheck()\\n\\t\\texcept Exception as e:\\n\\t\\t\\tprint(e)\\n\\t\\ttime.sleep(30)\",\n    \"策略名称: 简单的做市对冲功能\\n\\nimport time\\nfrom api import *\\nfrom Huobiapi import *\\nimport sqlite3\\n\\ndef wechatm",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "m Huobiapi import *\\nimport sqlite3\\n\\ndef wechatmsg(text,desp):\\n\\tserver = 'https://sc.ftqq.com/xxxxxx.send'\\n\\tpayload = {'text':text,'desp':desp}\\n\\trequests.post(server,params = payload)\\n\\ndef dingmsg(title,msg):\\n\\turl = 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxx'\\n\\tdata = {\\n\\t\\t\\t \\\"msgtype\\\": \\\"markdown\\\",\\n\\t\\t\\t \\\"markdown\\\": {\\n\\t\\t\\t\\t \\\"title\\\":title+msg,\\n\\t\\t\\t\\t \\\"text\\\": \\\"#### \\\" + title + \\\"\\\\n\\\"\\n\\t\\t\\t\\t\\t\\t \\\"> \\\" + msg\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t}}\\t\\t \\n\\theader = {'Conten",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "g\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t}}\\t\\t \\n\\theader = {'Content-Type':'application/json'}\\n\\tr = requests.post(url = url ,headers=header,data = json.dumps(data)).json()\\n\\treturn r\\n\\ndef check():\\n\\ttry:\\n\\t\\tpre_balance = {}\\n\\t\\tconn = sqlite3.connect(\\\"/root/bot/hedge.db\\\")\\n\\t\\tcursor = conn.cursor()\\n\\t\\tsql = 'select * from balance order by id desc limit 20;'\\n\\t\\tresult = list(cursor.execute(sql))\\n\\t\\tfor a in result:\\n\\t\\t\\tif a[1] in list(pre_balance.keys()):\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpre_balance[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpre_balance[a[1]] = a[2]   #读取之前balance\\n\\t\\tcoinname = list(pre_balance.keys())\\n\\t\\tprint(pre_balance,coinname)\\n\\n\\t\\tbalance = GetBalance()\\n\\t\\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\\n\\t\\tfor x in balance:  \\n\\t\\t\\tsql = \\\"insert into balance (coin,balance,time) values(?,?,?);\\\"\\n\\t\\t\\tb = x['balance']+x['frozenBalance']\\n\\t\\t\\tif b != 0:\\n\\t\\t\\t\\tv = (x['coin']['unit'],b,t)\\n\\t\\t\\t\\tprint(v)\\n\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\tfor n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nt(v)\\n\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\tfor n in coinname:\\n\\t\\t\\t\\tif n == x['coin']['unit']:\\n\\t\\t\\t\\t\\td = round(b - pre_balance[n],5)   #数量差\\n\\t\\t\\t\\t\\tif d > 0:\\n                        Sell(n,d)\\n\\t\\t\\t\\t\\t\\tmsg = '对冲卖出'+n+'数量：'+str(d)\\n\\t\\t\\t\\t\\t\\tprint(msg)\\n\\t\\t\\t\\t\\t\\twechatmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tdingmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tsql = \\\"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\\\"\\n\\t\\t\\t\\t\\t\\tv = (n,d,0,t)\\n\\t\\t\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\t\\t\\telif d < 0:\\n  ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\tcursor.execute(sql,v)\\n\\t\\t\\t\\t\\telif d < 0:\\n                        Buy(n,d)\\n\\t\\t\\t\\t\\t\\tmsg = '对冲买入：'+n+'数量：'+str(d)\\n\\t\\t\\t\\t\\t\\tprint(msg)\\n\\t\\t\\t\\t\\t\\twechatmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tdingmsg('对冲',msg)\\n\\t\\t\\t\\t\\t\\tsql = \\\"insert into hedge (coin,hedge_amount,status,time) values(?,?,?,?);\\\"\\n\\t\\t\\t\\t\\t\\tv = (n,d,0,t)\\n\\t\\t\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprint('no hedge')\\n\\n\\t\\tconn.commit()\\n\\t\\tconn.close()\\n\\texcept Exception as e:\\n\\t\\traise e\\n\\t\\ndef insert_balance",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ception as e:\\n\\t\\traise e\\n\\t\\ndef insert_balance():\\n\\ttry:\\n\\t\\tconn = sqlite3.connect(\\\"hedge.db\\\")\\n\\t\\tcursor = conn.cursor()\\n\\t\\tbalance = GetBalance()\\n\\t\\tt = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\\n\\t\\tfor x in balance:\\n\\t\\t\\tsql = \\\"insert into balance (coin,balance,time) values(?,?,?);\\\"\\n\\t\\t\\tb = x['balance']+x['frozenBalance']\\n\\t\\t\\tif b != 0:\\n\\t\\t\\t\\tv = (x['coin']['unit'],b,t)\\n\\t\\t\\t\\tcursor.execute(sql,v)\\n\\t\\tconn.commit()\\n\\t\\tconn.close()\\n\\t\\tprint('finish",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "conn.commit()\\n\\t\\tconn.close()\\n\\t\\tprint('finish')\\n\\texcept Exception as e:\\n\\t\\tprint('err',e)\\n\\nif __name__ == '__main__':\\n\\twhile 1:\\n\\t\\ttry:\\n\\t\\t\\tcheck()\\n\\t\\texcept Exception as e:\\n\\t\\t\\tprint(e)\\n\\t\\ttime.sleep(30)\\n\\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/178194\\n\\n> Last Modified\\n\\n2019-12-12 14:39:05\"\n \n\n    \"strategy_115\",\n    \"python\\n'''backtest\\nstart: 2022-03-28 00:00:00\\nend: 2022-03-28 23:59:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":0,\\\"fee\\\":[0,0]},{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"ETH_USDT\\\"}]\\nmode: 1\\nargs: [[\\\"BurstThresholdPct\\\",0.00127],[\\\"MinStock\\\",0.001]]\\n'''\\n\\nimport time\\nclass LeeksReaper():  \\n    def __init__(self,exchange):                                      #创建构造函数LeeksReaper                                          #构造一个空的对象\\n        self.numTick = 0\\n        self.lastTradeId = 0\\n        self.vol = 0\\n        self.askPrice = 0\\n        self",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f.vol = 0\\n        self.askPrice = 0\\n        self.bidPrice = 0\\n        self.orderBook = {}\\n        self.prices = []\\n        self.tradeOrderId = 0\\n        self.p = 0.5\\n        self.account = None\\n        self.preCalc = 0\\n        self.preNet = 0\\n\\n        self.sgnum = 0\\n        # self.cny = 0\\n        # self.btc = 0\\n\\n        self.exchange = exchange\\n        #以上都是self对象的属性\\n\\n    #创建一个方法\\n    def updateTrades(self):\\n\\n        trades = _C(self.exchange.GetTrades)                     #创建一个变量trades用",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\\n                trades = _C(self.exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\\n\\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\\n\\n        tradesvol = 0\\n        for trade in trades:\\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\\n                temp = trade.Time if trade.Id == 0 else trade.Id\\n                self.lastTradeId = max(temp, self.lastTradeId)\\n                tr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = max(temp, self.lastTradeId)\\n                tradesvol = tradesvol + trade.Amount\\n\\n\\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\\n\\n\\n    #self对象的一个方法\\n    def updateOrderBook(self):\\n\\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\\n        orderBook = _C(self.exchange.GetDepth)\\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\\n            #返回undefined\\n            return\\n        \\n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\\n        #同上\\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\\n        #删除price数组的第一个值，并返",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "].Price * 0.618 - 0.01\\n        #删除price数组的第一个值，并返回第一个值\\n        del(self.prices[0])\\n        #prices数组向后添加值，值为函数_N的返回值\\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\\n\\n    #self对象的一个方法\\n    def balanceAccount(self):\\n        # 创建一个变量account用来接收GetAccount函数返回的值\\n        account = _C(self.exchange.GetAccount)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  account = _C(self.exchange.GetAccount)\\n        #判断account是否为空，是就返回undefined\\n        if account is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n        #获取当前时间的时间戳数据\\n        now = time.time()\\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\\n            #赋值\\n            self.preCalc = now\\n            #创建一个变量net用来接收_N函数的返回值\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n            #创建一个变量net用来接收_N函数的返回值\\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\\n            #判断net是否不等于self.preNet，如果是就执行下方语句\\n            if (net != self.preNet):\\n                #赋值\\n                self.preNet = net\\n                #调用函数LogProfit并传入net\\n                LogProfit(net-10000)\\n\\n        #赋值\\n        self.btc = account.Stocks\\n        self.cny = account.Balance\\n        self.p = self.btc * self.pr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "count.Balance\\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\\n        balanced = False\\n        #判断self.p的值是否小于0.48\\n        # Log(self.p)\\n        if (self.p < 0.48):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.cny =self.cny-300\\n            self.cny -= 300\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Bids) > 0):\\n                #调用buy函数并传入相应的参数\\n                self.e",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          #调用buy函数并传入相应的参数\\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.001)\\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.001)\\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.001)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #如果self.p大于0.52就执行下方语句\\n        elif (self.p > 0.52):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.btc=self.btc-0.03\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " self.p)\\n            #self.btc=self.btc-0.03\\n            self.btc -= 0.03\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Asks) > 0):\\n                #调用Sell函数并传入相应的参数\\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.001)\\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.001)\\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.001)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n        #调用函数Sleep并传入参数BalanceTimeout\\n        Sleep(BalanceTimeout)\\n        #创建标量order来接收GetOrders函数返回的值\\n        orders = _C(self.exchange.GetOrders)\\n        #判断orders是否为真\\n        if (orders):\\n            #遍历orders\\n            Log(orders)\\n            for i in range(len(orders)):\\n                #判断orders的id是否不等于self.tradeOrderId\\n                if (orders[i].Id != self.tradeOrderId):\\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           #如果是就调用CancelOrder函数并传入参数orders[i].Id\\n                    Log(orders[i].Id)\\n                    self.exchange.CancelOrder(orders[i].Id)\\n\\n\\n\\n\\n\\n    #self的一个方法\\n    def poll(self):\\n\\n        #self.numTick自加1\\n        self.numTick +=1\\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\\n        self.updateTrades()\\n        self.updateOrderBook()\\n        self.balanceAccount()\\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\\n        burstPrice = self.prices[-1] * B",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sholdPct\\n        burstPrice = self.prices[-1] * BurstThresholdPct\\n        #创建变量并赋值\\n        bull = False\\n        bear = False\\n        tradeAmount = 0\\n        #判断self.account是否为真\\n        if (self.account):\\n            #是真的话就调用LogStatus函数并传入相应的参数\\n            Log(self.exchange.GetCurrency(),self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\\\",收割机当前启动次数:\\\",self.sgnum)\\n\\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fa",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\\n        if (self.numTick > 2 and ((self.prices[-1] - max(self.prices[-6:-1]) > burstPrice) or (self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2]))):\\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\\n            bull = True\\n            tradeAmount = self.cny / self.bidPrice * 0.99\\n\\n        #同上面if\\n        elif (self.numTick > 2 and ((self.prices[-1] - min(self.prices[-6:-1]) <",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " and ((self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice) or (self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2]))):\\n            bear = True\\n            #赋值\\n            tradeAmount = self.btc\\n\\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\\n        if (self.vol < BurstThresholdVol):\\n            tradeAmount *= self.vol / BurstThresholdVol\\n\\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\\n        if (self.numTick < 5):\\n            #tradeAmount=tra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " (self.numTick < 5):\\n            #tradeAmount=tradeAmount*0.8\\n            tradeAmount *= 0.8\\n\\n        #判断self.numTick是否小于10\\n        if (self.numTick < 10):\\n            tradeAmount *= 0.8\\n\\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\\n            return\\n\\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\\n        tradePrice = self.bidPrice if bull else self.askPrice\\n        #tradeAmount是否",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "if bull else self.askPrice\\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\\n        while (tradeAmount >= MinStock):\\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\\n            orderId = self.exchange.Buy(self.bidPrice, tradeAmount) if bull else self.exchange.Sell(self.askPrice, tradeAmount)\\n            self.sgnum+=1\\n            Log(\\\"收割机第\\\",self.sgnum,\\\"次启动\\\")\\n            #调用Sleep函数传入参数400，0.4秒后执行\\n            Sleep(400)\\n            #判断orderId是否为true\\n            if (orderId):\\n               ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "否为true\\n            if (orderId):\\n                #赋值\\n                self.tradeOrderId = orderId\\n                #赋值\\n                order = None\\n                while (True):\\n                    #rder的值等于GetOrder函数的返回值\\n                    order = self.exchange.GetOrder(orderId)\\n                    #判断order是否为true\\n                    if (order):\\n                        #判断两边的值是否相等\\n                        if (order.Status == ORDER_STATE_PENDING):\\n                            #调用CancelOrder函数\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                            #调用CancelOrder函数\\n                            self.exchange.CancelOrder(orderId)\\n                            #0.2秒后执行\\n                            Sleep(200)\\n                        else:\\n                            #跳出循环\\n                            break\\n\\n\\n                #赋值\\n                self.tradeOrderId = 0\\n                tradeAmount -= order.DealAmount\\n                tradeAmount *= 0.9\\n                #判断两边是否相等\\n                if (order.Status == ORDER_STAT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "相等\\n                if (order.Status == ORDER_STATE_CANCELED):\\n                    #调用self的updateOrderBook方法\\n                    self.updateOrderBook()\\n                    #判断是否为true,如果时就进行循环\\n                    while (bull and self.bidPrice - tradePrice > 0.1):\\n                        #赋值\\n                        tradeAmount *= 0.99\\n                        tradePrice += 0.1\\n\\n                    #判断是否为true,如果时就进行循环\\n                    while (bear and self.askPrice - tradePrice < -0.1):\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "d self.askPrice - tradePrice < -0.1):\\n                        tradeAmount *= 0.99\\n                        tradePrice -= 0.1\\n        #赋值\\n        self.numTick = 0\\n\\n\\n\\n\\n#函数main\\ndef main():\\n    #reaper 是构造函数的实例\\n    reaperlist=[]\\n    for coinexchange in exchanges:\\n        reaper = LeeksReaper(coinexchange)\\n        reaperlist.append(reaper)\\n        reaper=None\\n    while (True):\\n        #通过实例调用poll方法\\n        for coinreaper in reaperlist:\\n            coinreaper.poll()\\n        Sleep(TickInterval)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    coinreaper.poll()\\n        Sleep(TickInterval)\",\n    \"策略名称: 移植-OKCoin-韭菜收割机-多品种版-注释python版\\n\\n# self.btc = 0\\n\\n        self.exchange = exchange\\n        #以上都是self对象的属性\\n\\n    #创建一个方法\\n    def updateTrades(self):\\n\\n        trades = _C(self.exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\\n              ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "              #如果trades等于0时执行下方的语句\\n                trades = _C(self.exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\\n\\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\\n\\n        tradesvol = 0\\n        for trade in trades:\\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\\n                #等号右边是一个三目运",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "> self.lastTradeId)):\\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\\n                temp = trade.Time if trade.Id == 0 else trade.Id\\n                self.lastTradeId = max(temp, self.lastTradeId)\\n                tradesvol = tradesvol + trade.Amount\\n\\n\\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\\n\\n\\n    #self对象的一个方法\\n    def updateOrderBook(self):\\n\\n        # 创建一个变量ord",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " def updateOrderBook(self):\\n\\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\\n        orderBook = _C(self.exchange.GetDepth)\\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\\n            #返回undefined\\n            return\\n        \\n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "derBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\\n        #同上\\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\\n        #删除price数组的第一个值，并返回第一个值\\n        del(self.prices[0])\\n        #prices数组向后添加值，值为函数_N的返回值\\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\\n            (orderBook.Bids[1].Price + orderBook.A",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\\n\\n    #self对象的一个方法\\n    def balanceAccount(self):\\n        # 创建一个变量account用来接收GetAccount函数返回的值\\n        account = _C(self.exchange.GetAccount)\\n        #判断account是否为空，是就返回undefined\\n        if account is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n        #获取当前时间的时间戳数据\\n        now = time.time()\\n        #判断self.orderBook.Bids的长度是否大于",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "time.time()\\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\\n            #赋值\\n            self.preCalc = now\\n            #创建一个变量net用来接收_N函数的返回值\\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\\n            #判断net是否不等于self.preNet，如果是就执行下方语句\\n            if (net != self.preNet):\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "执行下方语句\\n            if (net != self.preNet):\\n                #赋值\\n                self.preNet = net\\n                #调用函数LogProfit并传入net\\n                LogProfit(net-10000)\\n\\n        #赋值\\n        self.btc = account.Stocks\\n        self.cny = account.Balance\\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\\n        balanced = False\\n        #判断self.p的值是否小于0.48\\n        # Log(self.p)\\n        if (self.p < 0.48):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.cny =self.cny-300\\n            self.cny -= 300\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Bids) > 0):\\n                #调用buy函数并传入相应的参数\\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.001)\\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.001)\\n                self.exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.001)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ge.Buy(self.orderBook.Bids[0].Price + 0.02, 0.001)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #如果self.p大于0.52就执行下方语句\\n        elif (self.p > 0.52):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.btc=self.btc-0.03\\n            self.btc -= 0.03\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Asks) > 0):\\n                #调用Sell函数并传入相应的参数\\n                self.exchange.Sell(self.orderBoo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.001)\\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.001)\\n                self.exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.001)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n        #调用函数Sleep并传入参数BalanceTimeout\\n        Sleep(BalanceTimeout)\\n        #创建标量order来接收GetOrders函数返回的值\\n        orders = _C(self.exchange.GetOrders)\\n        #判断orders是否为真\\n        if (orders):\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #判断orders是否为真\\n        if (orders):\\n            #遍历orders\\n            Log(orders)\\n            for i in range(len(orders)):\\n                #判断orders的id是否不等于self.tradeOrderId\\n                if (orders[i].Id != self.tradeOrderId):\\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\\n                    Log(orders[i].Id)\\n                    self.exchange.CancelOrder(orders[i].Id)\\n\\n\\n\\n\\n\\n    #self的一个方法\\n    def poll(self):\\n\\n        #self.numTick自加1\\n        self.numTick +=1\\n        #执行上",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "numTick自加1\\n        self.numTick +=1\\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\\n        self.updateTrades()\\n        self.updateOrderBook()\\n        self.balanceAccount()\\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\\n        burstPrice = self.prices[-1] * BurstThresholdPct\\n        #创建变量并赋值\\n        bull = False\\n        bear = False\\n        tradeAmount = 0\\n        #判断self.account是否为真\\n        if (self.account):\\n            #是真的话就调用LogStatus函数并传入相应的参数\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           #是真的话就调用LogStatus函数并传入相应的参数\\n            Log(self.exchange.GetCurrency(),self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\\\",收割机当前启动次数:\\\",self.sgnum)\\n\\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\\n        if (self.numTick > 2 and ((self.prices[-1] - max(self.prices[-6:-1]) > burstPrice) or (self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2]))):\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e and self.prices[-1] > self.prices[-2]))):\\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\\n            bull = True\\n            tradeAmount = self.cny / self.bidPrice * 0.99\\n\\n        #同上面if\\n        elif (self.numTick > 2 and ((self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice) or (self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2]))):\\n            bear = True\\n            #赋值\\n            tradeAmount = self.btc\\n\\n        #判断self.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        tradeAmount = self.btc\\n\\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\\n        if (self.vol < BurstThresholdVol):\\n            tradeAmount *= self.vol / BurstThresholdVol\\n\\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\\n        if (self.numTick < 5):\\n            #tradeAmount=tradeAmount*0.8\\n            tradeAmount *= 0.8\\n\\n        #判断self.numTick是否小于10\\n        if (self.numTick < 10):\\n            tradeAmount *= 0.8\\n\\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\\n            return\\n\\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\\n        tradePrice = self.bidPrice if bull else self.askPrice\\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\\n        while (tradeAmount >= MinStock):\\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\\n            orderId = self.exchange.Buy(self.bidPrice, tradeAmount) if bull else self.exc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(self.bidPrice, tradeAmount) if bull else self.exchange.Sell(self.askPrice, tradeAmount)\\n            self.sgnum+=1\\n            Log(\\\"收割机第\\\",self.sgnum,\\\"次启动\\\")\\n            #调用Sleep函数传入参数400，0.4秒后执行\\n            Sleep(400)\\n            #判断orderId是否为true\\n            if (orderId):\\n                #赋值\\n                self.tradeOrderId = orderId\\n                #赋值\\n                order = None\\n                while (True):\\n                    #rder的值等于GetOrder函数的返回值\\n                    order = self.ex",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "etOrder函数的返回值\\n                    order = self.exchange.GetOrder(orderId)\\n                    #判断order是否为true\\n                    if (order):\\n                        #判断两边的值是否相等\\n                        if (order.Status == ORDER_STATE_PENDING):\\n                            #调用CancelOrder函数\\n                            self.exchange.CancelOrder(orderId)\\n                            #0.2秒后执行\\n                            Sleep(200)\\n                        else:\\n                            #跳出循环\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "else:\\n                            #跳出循环\\n                            break\\n\\n\\n                #赋值\\n                self.tradeOrderId = 0\\n                tradeAmount -= order.DealAmount\\n                tradeAmount *= 0.9\\n                #判断两边是否相等\\n                if (order.Status == ORDER_STATE_CANCELED):\\n                    #调用self的updateOrderBook方法\\n                    self.updateOrderBook()\\n                    #判断是否为true,如果时就进行循环\\n                    while (bull and self.bidPrice - tradePrice > 0.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   while (bull and self.bidPrice - tradePrice > 0.1):\\n                        #赋值\\n                        tradeAmount *= 0.99\\n                        tradePrice += 0.1\\n\\n                    #判断是否为true,如果时就进行循环\\n                    while (bear and self.askPrice - tradePrice < -0.1):\\n                        tradeAmount *= 0.99\\n                        tradePrice -= 0.1\\n        #赋值\\n        self.numTick = 0\"\n \n\n    \"strategy_116\",\n    \"python\\n'''backtest\\nstart: 2019-09-05 00:00:00\\nend: 2019-09-05 22:0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\nstart: 2019-09-05 00:00:00\\nend: 2019-09-05 22:00:00\\nperiod: 1h\\nbasePeriod: 1h\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"stocks\\\":0,\\\"fee\\\":[0,0]}]\\nmode: 1\\n'''\\n\\nimport time\\nclass LeeksReaper():  \\n    def __init__(self):                                      #创建构造函数LeeksReaper                                          #构造一个空的对象\\n        self.numTick = 0\\n        self.lastTradeId = 0\\n        self.vol = 0\\n        self.askPrice = 0\\n        self.bidPrice = 0\\n        self.orderBook",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        self.bidPrice = 0\\n        self.orderBook = {}\\n        self.prices = []\\n        self.tradeOrderId = 0\\n        self.p = 0.5\\n        self.account = None\\n        self.preCalc = 0\\n        self.preNet = 0\\n\\n        self.sgnum = 0\\n        # self.cny = 0\\n        # self.btc = 0\\n        #以上都是self对象的属性\\n\\n    #创建一个方法\\n    def updateTrades(self):\\n\\n        trades = _C(exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\\n        if (len(self.prices)== 0):     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "GetTrades\\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\\n                trades = _C(exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\\n\\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\\n\\n        tradesvol = 0\\n        for trade in trades:\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      tradesvol = 0\\n        for trade in trades:\\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\\n                temp = trade.Time if trade.Id == 0 else trade.Id\\n                self.lastTradeId = max(temp, self.lastTradeId)\\n                tradesvol = tradesvol + trade.Amount\\n\\n\\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t\\n\\n\\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\\n\\n\\n    #self对象的一个方法\\n    def updateOrderBook(self):\\n\\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\\n        orderBook = _C(exchange.GetDepth)\\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\\n            #返回undefined\\n            return\\n        \\n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\\n        #同上\\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\\n        #删除price数组的第一个值，并返回第一个值\\n        del(self.prices[0])\\n        #prices数组向后添加值，值为函数_N的返回值\\n        self.pric",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      #prices数组向后添加值，值为函数_N的返回值\\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\\n\\n    #self对象的一个方法\\n    def balanceAccount(self):\\n        # 创建一个变量account用来接收GetAccount函数返回的值\\n        account = _C(exchange.GetAccount)\\n        #判断account是否为空，是就返回undefined\\n        if account is None:\\n            return\\n\\n        #赋值\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "count is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n        #获取当前时间的时间戳数据\\n        now = time.time()\\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\\n            #赋值\\n            self.preCalc = now\\n            #创建一个变量net用来接收_N函数的返回值\\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.St",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\\n            #判断net是否不等于self.preNet，如果是就执行下方语句\\n            if (net != self.preNet):\\n                #赋值\\n                self.preNet = net\\n                #调用函数LogProfit并传入net\\n                LogProfit(net-10000)\\n\\n        #赋值\\n        self.btc = account.Stocks\\n        self.cny = account.Balance\\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\\n        balanced = False\\n        #判断self",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lf.cny)\\n        balanced = False\\n        #判断self.p的值是否小于0.48\\n        # Log(self.p)\\n        if (self.p < 0.48):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.cny =self.cny-300\\n            self.cny -= 300\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Bids) > 0):\\n                #调用buy函数并传入相应的参数\\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.01)\\n                exchange.Buy(self.orderBoo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 0.01)\\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.01)\\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.01)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #如果self.p大于0.52就执行下方语句\\n        elif (self.p > 0.52):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.btc=self.btc-0.03\\n            self.btc -= 0.03\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orde",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Asks) > 0):\\n                #调用Sell函数并传入相应的参数\\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.01)\\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.01)\\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.01)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n        #调用函数Sleep并传入参数BalanceTimeout\\n        Sleep(BalanceTimeout)\\n        #创建标量order来接收GetOrders函数返回的值\\n        orders =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #创建标量order来接收GetOrders函数返回的值\\n        orders = _C(exchange.GetOrders)\\n        #判断orders是否为真\\n        if (orders):\\n            #遍历orders\\n            Log(orders)\\n            for i in range(len(orders)):\\n                #判断orders的id是否不等于self.tradeOrderId\\n                if (orders[i].Id != self.tradeOrderId):\\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\\n                    Log(orders[i].Id)\\n                    exchange.CancelOrder(orders[i].Id)\\n\\n\\n\\n\\n\\n    #self的一个方法\\n    def poll(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rs[i].Id)\\n\\n\\n\\n\\n\\n    #self的一个方法\\n    def poll(self):\\n\\n        #self.numTick自加1\\n        self.numTick +=1\\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\\n        self.updateTrades()\\n        self.updateOrderBook()\\n        self.balanceAccount()\\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\\n        burstPrice = self.prices[-1] * BurstThresholdPct\\n        #创建变量并赋值\\n        bull = False\\n        bear = False\\n        tradeAmount = 0\\n        #判断self.account是否为真\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "radeAmount = 0\\n        #判断self.account是否为真\\n        if (self.account):\\n            #是真的话就调用LogStatus函数并传入相应的参数\\n            LogStatus(self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\\\",收割机当前启动次数:\\\",self.sgnum)\\n\\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\\n        if (self.numTick > 2 and (self.prices[-1] - max(self.prices[-6:-1]) > burstPrice or self.prices[-1] - max(self.prices[-6:-2]) > burstPrice",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2])):\\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\\n            bull = True\\n            tradeAmount = self.cny / self.bidPrice * 0.99\\n\\n        #同上面if\\n        elif (self.numTick > 2 and (self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice or self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2])):\\n            bear = True\\n            #赋值\\n          ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          bear = True\\n            #赋值\\n            tradeAmount = self.btc\\n\\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\\n        if (self.vol < BurstThresholdVol):\\n            tradeAmount *= self.vol / BurstThresholdVol\\n\\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\\n        if (self.numTick < 5):\\n            #tradeAmount=tradeAmount*0.8\\n            tradeAmount *= 0.8\\n\\n        #判断self.numTick是否小于10\\n        if (self.numTick < 10):\\n            tradeAmount *= 0.8\\n\\n        #前半段是判断!bull和!b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     tradeAmount *= 0.8\\n\\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\\n            return\\n\\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\\n        tradePrice = self.bidPrice if bull else self.askPrice\\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\\n        while (tradeAmount >= MinStock):\\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\\n            orderId = exchange.Buy(self.bidPr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "返回值\\n            orderId = exchange.Buy(self.bidPrice, tradeAmount) if bull else exchange.Sell(self.askPrice, tradeAmount)\\n            self.sgnum+=1\\n            Log(\\\"收割机第\\\",self.sgnum,\\\"次启动\\\")\\n            #调用Sleep函数传入参数400，0.4秒后执行\\n            Sleep(400)\\n            #判断orderId是否为true\\n            if (orderId):\\n                #赋值\\n                self.tradeOrderId = orderId\\n                #赋值\\n                order = None\\n                while (True):\\n                    #rder的值等于GetOrder函数的返回值\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "):\\n                    #rder的值等于GetOrder函数的返回值\\n                    order = exchange.GetOrder(orderId)\\n                    #判断order是否为true\\n                    if (order):\\n                        #判断两边的值是否相等\\n                        if (order.Status == ORDER_STATE_PENDING):\\n                            #调用CancelOrder函数\\n                            exchange.CancelOrder(orderId)\\n                            #0.2秒后执行\\n                            Sleep(200)\\n                        else:\\n                   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                        else:\\n                            #跳出循环\\n                            break\\n\\n\\n                #赋值\\n                self.tradeOrderId = 0\\n                tradeAmount -= order.DealAmount\\n                tradeAmount *= 0.9\\n                #判断两边是否相等\\n                if (order.Status == ORDER_STATE_CANCELED):\\n                    #调用self的updateOrderBook方法\\n                    self.updateOrderBook()\\n                    #判断是否为true,如果时就进行循环\\n                    while (bull and self.bi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "就进行循环\\n                    while (bull and self.bidPrice - tradePrice > 0.1):\\n                        #赋值\\n                        tradeAmount *= 0.99\\n                        tradePrice += 0.1\\n\\n                    #判断是否为true,如果时就进行循环\\n                    while (bear and self.askPrice - tradePrice < -0.1):\\n                        tradeAmount *= 0.99\\n                        tradePrice -= 0.1\\n        #赋值\\n        self.numTick = 0\\n\\n\\n\\n\\n#函数main\\ndef main():\\n    #reaper 是构造函数的实例\\n    reaper = LeeksRea",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "in():\\n    #reaper 是构造函数的实例\\n    reaper = LeeksReaper()\\n    while (True):\\n        #通过实例调用poll方法\\n        reaper.poll()\\n        Sleep(TickInterval)\",\n    \"策略名称: 移植-OKCoin-韭菜收割机-注释python版\\n\\n# self.btc = 0\\n        #以上都是self对象的属性\\n\\n    #创建一个方法\\n    def updateTrades(self):\\n\\n        trades = _C(exchange.GetTrades)                     #创建一个变量trades用来接收_C函数返回的值，传入的参数为：exchange.GetTrades\\n        if (len(self.prices)== 0):                       #如果self.prices的长度等于0\\n            while (len(trades) == 0):     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "的长度等于0\\n            while (len(trades) == 0):                      #如果trades等于0时执行下方的语句\\n                trades = _C(exchange.GetTrades) #通过数组拼接的方法把_C函数返回的值与trades进行拼接，传入的参数为：exchange.GetTrades\\n\\n            for i in range(15):                      #循环，结束条件为i=15，每次循环i都自加1\\n                self.prices.append(trades[-1].Price)#每次循环都把trades数组的最后一个值赋值给self对象的prices数组上，共循环15次\\n\\n        tradesvol = 0\\n        for trade in trades:\\n            if ((trade.Id > self.lastTradeId) or (trade.Id == 0 and trade.Time > ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f.lastTradeId) or (trade.Id == 0 and trade.Time > self.lastTradeId)):\\n                #等号右边是一个三目运算，如果trade.Id=0就返回trade.Time，否则就返回trade.Id, self.lastTradeId。并进行比较返回最大的值，最后把返回的最大值赋给self.lastTradeId\\n                temp = trade.Time if trade.Id == 0 else trade.Id\\n                self.lastTradeId = max(temp, self.lastTradeId)\\n                tradesvol = tradesvol + trade.Amount\\n\\n\\n        #self.vol的值等于他自己乘以0.7加上这段时间的交易量*0.3\\n        self.vol = 0.7 * self.vol + 0.3 * tradesvol\\n\\n\\n    #self对象的一个方法\\n    d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "vol + 0.3 * tradesvol\\n\\n\\n    #self对象的一个方法\\n    def updateOrderBook(self):\\n\\n        # 创建一个变量orderBook用来接收_C函数返回的值，传入的参数为：exchange.GetDepth\\n        orderBook = _C(exchange.GetDepth)\\n        self.orderBook = orderBook                              #self.orderBook 的值等于orderBook\\n        if (len(orderBook.Bids)< 3 or len(orderBook.Asks) < 3):#前半段是判断orderBook.Bids的长度是否小于3，后半段是判断orderBook.Asks的长度是否小于3，如果两边都小于3就执行下方的语句\\n            #返回undefined\\n            return\\n        \\n        #self.bidPrice的值等于orderBook",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "urn\\n        \\n        #self.bidPrice的值等于orderBook.Bids数组的第一个值乘以0.618加上orderBook.Asks数组的第一个值乘以0.382加上0.01\\n        self.bidPrice = orderBook.Bids[0].Price * 0.618 + orderBook.Asks[0].Price * 0.382 + 0.01\\n        #同上\\n        self.askPrice = orderBook.Bids[0].Price * 0.382 + orderBook.Asks[0].Price * 0.618 - 0.01\\n        #删除price数组的第一个值，并返回第一个值\\n        del(self.prices[0])\\n        #prices数组向后添加值，值为函数_N的返回值\\n        self.prices.append(_N((orderBook.Bids[0].Price + orderBook.Asks[0].Price) * 0.35 +\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Price + orderBook.Asks[0].Price) * 0.35 +\\n            (orderBook.Bids[1].Price + orderBook.Asks[1].Price) * 0.1 +\\n            (orderBook.Bids[2].Price + orderBook.Asks[2].Price) * 0.05))\\n\\n    #self对象的一个方法\\n    def balanceAccount(self):\\n        # 创建一个变量account用来接收GetAccount函数返回的值\\n        account = _C(exchange.GetAccount)\\n        #判断account是否为空，是就返回undefined\\n        if account is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n        #获取当前时间的时间戳数据\\n        now = time.time()\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        #获取当前时间的时间戳数据\\n        now = time.time()\\n        #判断self.orderBook.Bids的长度是否大于0和now - self.preCalc的值是否大于(CalcNetInterval * 1000)，如果都大于就执行下方语句\\n        if (len(self.orderBook.Bids) > 0 and now - self.preCalc > (CalcNetInterval)):\\n            #赋值\\n            self.preCalc = now\\n            #创建一个变量net用来接收_N函数的返回值\\n            net = _N(account.Balance + account.FrozenBalance + self.orderBook.Bids[0].Price * (account.Stocks + account.FrozenStocks))\\n            #判断net是否不等于self.preNet，如果是就执行下方语句\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           #判断net是否不等于self.preNet，如果是就执行下方语句\\n            if (net != self.preNet):\\n                #赋值\\n                self.preNet = net\\n                #调用函数LogProfit并传入net\\n                LogProfit(net-10000)\\n\\n        #赋值\\n        self.btc = account.Stocks\\n        self.cny = account.Balance\\n        self.p = self.btc * self.prices[-1] / (self.btc * self.prices[-1] + self.cny)\\n        balanced = False\\n        #判断self.p的值是否小于0.48\\n        # Log(self.p)\\n        if (self.p < 0.48):\\n            #调用L",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".p)\\n        if (self.p < 0.48):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.cny =self.cny-300\\n            self.cny -= 300\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Bids) > 0):\\n                #调用buy函数并传入相应的参数\\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.00, 0.01)\\n                exchange.Buy(self.orderBook.Bids[0].Price + 0.01, 0.01)\\n                exchange.Buy(self.orderBook.Bids[0]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "               exchange.Buy(self.orderBook.Bids[0].Price + 0.02, 0.01)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #如果self.p大于0.52就执行下方语句\\n        elif (self.p > 0.52):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n            #self.btc=self.btc-0.03\\n            self.btc -= 0.03\\n            #判断self.orderBook.Bids的长度是否大于0，如果是就执行下方语句\\n            if (len(self.orderBook.Asks) > 0):\\n                #调用Sell函数并传入相应的参数\\n                exchange.Sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   #调用Sell函数并传入相应的参数\\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.00, 0.01)\\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.01, 0.01)\\n                exchange.Sell(self.orderBook.Asks[0].Price - 0.02, 0.01)\\n\\n                Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n        #调用函数Sleep并传入参数BalanceTimeout\\n        Sleep(BalanceTimeout)\\n        #创建标量order来接收GetOrders函数返回的值\\n        orders = _C(exchange.GetOrders)\\n        #判断orders是否为真\\n        if (orders):\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " #判断orders是否为真\\n        if (orders):\\n            #遍历orders\\n            Log(orders)\\n            for i in range(len(orders)):\\n                #判断orders的id是否不等于self.tradeOrderId\\n                if (orders[i].Id != self.tradeOrderId):\\n                    #如果是就调用CancelOrder函数并传入参数orders[i].Id\\n                    Log(orders[i].Id)\\n                    exchange.CancelOrder(orders[i].Id)\\n\\n\\n\\n\\n\\n    #self的一个方法\\n    def poll(self):\\n\\n        #self.numTick自加1\\n        self.numTick +=1\\n        #执行上方创建的三个方法",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "加1\\n        self.numTick +=1\\n        #执行上方创建的三个方法updateTrades，updateOrderBook，updateOrderBook\\n        self.updateTrades()\\n        self.updateOrderBook()\\n        self.balanceAccount()\\n        #burstPrice的值等于self.prices数组的最后一个值乘以BurstThresholdPct\\n        burstPrice = self.prices[-1] * BurstThresholdPct\\n        #创建变量并赋值\\n        bull = False\\n        bear = False\\n        tradeAmount = 0\\n        #判断self.account是否为真\\n        if (self.account):\\n            #是真的话就调用LogStatus函数并传入相应的参数\\n            LogSta",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   #是真的话就调用LogStatus函数并传入相应的参数\\n            LogStatus(self.account, 'Tick:', self.numTick, ', lastPrice:', self.prices[-1], ', burstPrice: ', burstPrice,\\\",收割机当前启动次数:\\\",self.sgnum)\\n\\n        #前半段是判断self.numTick的值是否大于2，如果是大于2就往执行||后面的语句，如果不是则判断&&运算符后面的语句，如果为fales直接返回fales,执行else的语句\\n        if (self.numTick > 2 and (self.prices[-1] - max(self.prices[-6:-1]) > burstPrice or self.prices[-1] - max(self.prices[-6:-2]) > burstPrice and self.prices[-1] > self.prices[-2])):\\n            #变量bull赋值为true,tradeAmount赋",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "es[-2])):\\n            #变量bull赋值为true,tradeAmount赋值为self.cnyv/self.bidPrice乘以0.99\\n            bull = True\\n            tradeAmount = self.cny / self.bidPrice * 0.99\\n\\n        #同上面if\\n        elif (self.numTick > 2 and (self.prices[-1] - min(self.prices[-6:-1]) < -burstPrice or self.prices[-1] - min(self.prices[-6:-2]) < -burstPrice and self.prices[-1] < self.prices[-2])):\\n            bear = True\\n            #赋值\\n            tradeAmount = self.btc\\n\\n        #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    #判断self.vol是否小于BurstThresholdVol，如果是就执行if语句内的代码\\n        if (self.vol < BurstThresholdVol):\\n            tradeAmount *= self.vol / BurstThresholdVol\\n\\n        #判断self.numTick是否小于5，如果是就执行if语句内的代码\\n        if (self.numTick < 5):\\n            #tradeAmount=tradeAmount*0.8\\n            tradeAmount *= 0.8\\n\\n        #判断self.numTick是否小于10\\n        if (self.numTick < 10):\\n            tradeAmount *= 0.8\\n\\n        #前半段是判断!bull和!bear哪一个为真，后半段是判断tradeAmount是否小于MinStock，当两边都为真时就执行if语句内的代码\\n        if (((not bull)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nStock，当两边都为真时就执行if语句内的代码\\n        if (((not bull) and (not bear)) or tradeAmount < MinStock):\\n            return\\n\\n        #如果bull为真时就返回self.bidPrice的值，否则返回self.askPrice的值\\n        tradePrice = self.bidPrice if bull else self.askPrice\\n        #tradeAmount是否大于或者等于MinStock，如果时就进行循环while的语句\\n        while (tradeAmount >= MinStock):\\n            #当bull为真时返回Buy函数的返回值，否则返回Sell函数的返回值\\n            orderId = exchange.Buy(self.bidPrice, tradeAmount) if bull else exchange.Sell(self.askPrice, tradeAmount)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xchange.Sell(self.askPrice, tradeAmount)\\n            self.sgnum+=1\\n            Log(\\\"收割机第\\\",self.sgnum,\\\"次启动\\\")\\n            #调用Sleep函数传入参数400，0.4秒后执行\\n            Sleep(400)\\n            #判断orderId是否为true\\n            if (orderId):\\n                #赋值\\n                self.tradeOrderId = orderId\\n                #赋值\\n                order = None\\n                while (True):\\n                    #rder的值等于GetOrder函数的返回值\\n                    order = exchange.GetOrder(orderId)\\n                    #判断orde",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nge.GetOrder(orderId)\\n                    #判断order是否为true\\n                    if (order):\\n                        #判断两边的值是否相等\\n                        if (order.Status == ORDER_STATE_PENDING):\\n                            #调用CancelOrder函数\\n                            exchange.CancelOrder(orderId)\\n                            #0.2秒后执行\\n                            Sleep(200)\\n                        else:\\n                            #跳出循环\\n                            break\\n\\n\\n                #赋值\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            break\\n\\n\\n                #赋值\\n                self.tradeOrderId = 0\\n                tradeAmount -= order.DealAmount\\n                tradeAmount *= 0.9\\n                #判断两边是否相等\\n                if (order.Status == ORDER_STATE_CANCELED):\\n                    #调用self的updateOrderBook方法\\n                    self.updateOrderBook()\\n                    #判断是否为true,如果时就进行循环\\n                    while (bull and self.bidPrice - tradePrice > 0.1):\\n                        #赋值\\n                        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                     #赋值\\n                        tradeAmount *= 0.99\\n                        tradePrice += 0.1\\n\\n                    #判断是否为true,如果时就进行循环\\n                    while (bear and self.askPrice - tradePrice < -0.1):\\n                        tradeAmount *= 0.99\\n                        tradePrice -= 0.1\\n        #赋值\\n        self.numTick = 0\"\n \n\n    \"strategy_117\",\n    \"python\\n'''backtest\\nstart: 2021-01-01 00:00:00\\nend: 2021-11-17 00:00:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"F",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "riod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"Futures_Binance\\\",\\\"currency\\\":\\\"BTC_USDT\\\",\\\"balance\\\":2500}]\\nargs: [[\\\"H\\\",30],[\\\"n1\\\",0.001],[\\\"grid\\\",300],[\\\"xia\\\",50000]]\\n'''\\n\\ndef CancelPendingOrders():\\n    orders = _C(exchanges[0].GetOrders)\\n    if len(orders)>0:\\n        for j in range(len(orders)):\\n            exchanges[0].CancelOrder(orders[j].Id, orders[j])\\n            j=j+1\\n\\ndef main():\\n    exchange.SetContractType('swap')\\n    exchange.SetMarginLevel(M)\\n    currency=exchange.GetCurr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e.SetMarginLevel(M)\\n    currency=exchange.GetCurrency()\\n    if _G('buyp') and _G('sellp'):\\n        buyp=_G('buyp')\\n        sellp=_G('sellp')\\n        Log('读取网格价格')\\n    else:\\n        ticker=exchange.GetTicker()\\n        buyp=ticker[\\\"Last\\\"]-grid\\n        sellp=ticker[\\\"Last\\\"]+grid\\n        _G('buyp',buyp)\\n        _G('sellp',sellp)\\n        Log('网格数据初始化')\\n    while True:\\n            account=exchange.GetAccount()\\n            ticker=exchange.GetTicker()\\n            position=exchange.GetPosition()\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r()\\n            position=exchange.GetPosition()\\n            orders=exchange.GetOrders()\\n            if len(position)==0:\\n                if ticker[\\\"Last\\\"]>shang:\\n                    exchange.SetDirection('sell')\\n                    exchange.Sell(-1,n1*H)\\n                    Log(currency,'到达开空区域,买入空头底仓')\\n                    \\n                else:\\n                    exchange.SetDirection('buy')\\n                    exchange.Buy(-1,n1*H)\\n                    Log(currency,'到达开多区域,买入多头底仓')\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "           Log(currency,'到达开多区域,买入多头底仓')\\n            if len(position)==1:\\n                if position[0][\\\"Type\\\"]==1:\\n                    if ticker[\\\"Last\\\"]<xia:\\n                        Log(currency,'空单全部止盈反手')\\n                        exchange.SetDirection('closesell')\\n                        exchange.Buy(-1,position[0].Amount)\\n                    else:\\n                        orders=exchange.GetOrders()\\n                        if len(orders)==0:\\n                            exchange.SetDirection",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n                            exchange.SetDirection('sell')\\n                            exchange.Sell(sellp,n1)\\n                            exchange.SetDirection('closesell')\\n                            exchange.Buy(buyp,n1)\\n                        if len(orders)==1:\\n                            if orders[0][\\\"Type\\\"]==1: #止盈成交\\n                                Log(currency,'网格减仓,当前份数:',position[0].Amount)\\n                                CancelPendingOrders()\\n                                buyp=buyp-gr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rs()\\n                                buyp=buyp-grid\\n                                sellp=sellp-grid\\n                                LogProfit(account[\\\"Balance\\\"])\\n                            if orders[0][\\\"Type\\\"]==0:\\n                                Log(currency,'网格加仓,当前份数:',position[0].Amount)\\n                                CancelPendingOrders()\\n                                buyp=buyp+grid\\n                                sellp=sellp+grid\\n                                LogProfit(account[\\\"Bal",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                           LogProfit(account[\\\"Balance\\\"])\\n            \\n                if position[0][\\\"Type\\\"]==0:\\n                    if ticker[\\\"Last\\\"]>float(shang):\\n                        Log(currency,'多单全部止盈反手')\\n                        exchange.SetDirection('closebuy')\\n                        exchange.Sell(-1,position[0].Amount)\\n                    else:\\n                        orders=exchange.GetOrders()\\n                        if len(orders)==0:\\n                            exchange.SetDi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s)==0:\\n                            exchange.SetDirection('buy')\\n                            exchange.Buy(buyp,n1)\\n                            exchange.SetDirection('closebuy')\\n                            exchange.Sell(sellp,n1)\\n                        if len(orders)==1:\\n                            if orders[0][\\\"Type\\\"]==0: #止盈成交\\n                                Log(currency,'网格减仓,当前份数:',position[0].Amount)\\n                                CancelPendingOrders()\\n                                buyp=bu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "gOrders()\\n                                buyp=buyp+grid\\n                                sellp=sellp+grid\\n                                LogProfit(account[\\\"Balance\\\"])\\n                            if orders[0][\\\"Type\\\"]==1:\\n                                Log(currency,'网格加仓,当前份数:',position[0].Amount)\\n                                CancelPendingOrders()\\n                                buyp=buyp-grid\\n                                sellp=sellp-grid\\n                                LogProfit(account[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                                LogProfit(account[\\\"Balance\\\"])\",\n    \"策略名称: 简易等差合约网格\\n\\n未找到描述\"\n \n\n    \"strategy_118\",\n    \"python\\n\\ndef RSI():\\n    ticker = exchange.GetTicker()\\n    account = exchange.GetAccount()\\n    r = exchange.GetRecords(PERIOD_H1 * 4)\\n    rsi = TA.RSI(r, 14)\\n    is_buy = False\\n    is_sell = False\\n    if rsi[-1] > 70 and account[\\\"Stocks\\\"] > 0:\\n        id = exchange.Sell(ticker[\\\"Buy\\\"], account[\\\"Stocks\\\"] * 0.01)\\n        is_buy = True\\n    elif rsi[-1] < 30 and account[\\\"Ba",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "buy = True\\n    elif rsi[-1] < 30 and account[\\\"Balance\\\"] > 0:\\n        id = exchange.Buy(ticker[\\\"Sell\\\"], account[\\\"Balance\\\"] / ticker[\\\"Sell\\\"] * 0.01)\\n        is_sell = True\\n\\n\\n    if is_buy or is_sell:\\n        Sleep(1000 * 60 * 4)\\n        \\n#    if rsi[-1] < 40 and account[\\\"Balance\\\"] > 0:\\n#        id = exchange.Buy(ticker[\\\"Buy\\\"], account[\\\"Balance\\\"] / ticker[\\\"Sell\\\"] * 0.0005)\\n#    if rsi[-1] > 60 and account[\\\"Stocks\\\"] > 0:\\n#        id = exchange.Sell(ticker[\\\"Sell\\\"], account[\\\"Stock",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = exchange.Sell(ticker[\\\"Sell\\\"], account[\\\"Stocks\\\"] * 0.0005)\\n#    if rsi[-1] < 40 and account[\\\"Balance\\\"] > 0:\\n#        id = exchange.Buy(ticker[\\\"Buy\\\"], account[\\\"Balance\\\"] / ticker[\\\"Sell\\\"] * 0.05)\\n    return\\n \\ndef main():\\n    Log(\\\"策略开始 !\\\")\\n    i = 0\\n    while True:        #循环\\n        RSI()       #执行策略主函数\\n        i = i + 1\\n        if i % 50 == 0:\\n            account = exchange.GetAccount()\\n            Log(account[\\\"Balance\\\"], account[\\\"Stocks\\\"])\\n        \\n'''\\ndef main():\\n    Lo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t[\\\"Stocks\\\"])\\n        \\n'''\\ndef main():\\n    Log(\\\"策略开始 !\\\")\\n    ticker = exchange.GetTicker()\\n    account = exchange.GetAccount()\\n    id = exchange.Buy(ticker[\\\"Buy\\\"], 0.01)\\n    Log(account[\\\"Balance\\\"])\\n    Log(id)\\n    Sleep(60 * 1000)\\n'''\",\n    \"策略名称: 练习01RSI\\n\\n#        id = exchange.Buy(ticker[\\\"Buy\\\"], account[\\\"Balance\\\"] / ticker[\\\"Sell\\\"] * 0.0005)\"\n \n\n    \"strategy_119\",\n    \"python\\n'''backtest\\nstart: 2020-02-27 00:00:00\\nend: 2020-02-27 00:00:00\\nperiod: 1d\\nexchanges: [{\\\"eid\\\":\\\"Fu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "27 00:00:00\\nperiod: 1d\\nexchanges: [{\\\"eid\\\":\\\"Futures_OKCoin\\\",\\\"currency\\\":\\\"ETH_USD\\\",\\\"stocks\\\":1.6}]\\n'''\\n#常规上下网格\\nimport json\\nglobal_param={\\n              'sell_id':0,\\n              'buy_id':0,\\n              'buy_amount':0,#当前多单数量\\n              'sell_amount':0,#当前空单数量\\n              'buy_profit':0,#多单利润\\n              'sell_profit':0#空单利润\\n             }\\n\\ndef open_order(price):\\n    net_buy_count = global_param['buy_amount'] / net_amount\\n    net_sell_count = global_param['sell_amount'] / net",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "net_sell_count = global_param['sell_amount'] / net_amount\\n    if(net_buy_count>= net_limit or net_sell_count>=net_limit):\\n        Log(\\\"超过网格数量限制，不开仓！\\\")\\n        return\\n    if(net_type == 1 or net_type == 2):#如果设置为开空或者多空双开\\n        exchange.SetDirection(\\\"sell\\\")#设置下单类型为做空\\n        order_id = exchange.Sell(_N(price*(1+net_interval),2),net_amount)#以当前价格上限开空，合约数量为10张下单\\n        global_param['sell_id'] = order_id\\n    if(net_type == 0 or net_type == 2):#如果设置为开多或者多空双开\\n        exchange.SetDirection(\\\"buy\\\")#",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "为开多或者多空双开\\n        exchange.SetDirection(\\\"buy\\\")#设置下单类型为做多\\n        order_id = exchange.Buy(_N(price*(1-net_interval),2),net_amount)#以当前价格下限开多，合约数量为10张下单                        \\n        global_param['buy_id'] = order_id\\n        \\ndef cancel_order():\\n    for order in _C(exchange.GetOrders):\\n        _C(exchange.CancelOrder,int(order['Id']))\\n    global_param['sell_id']=0\\n    global_param['buy_id']=0\\n        \\ndef judge_order_finish():\\n    if(global_param['buy_id']!=0):\\n        order = exchange.GetOrd",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "am['buy_id']!=0):\\n        order = exchange.GetOrder(global_param['buy_id'])\\n        if(order[\\\"Status\\\"]==ORDER_STATE_CLOSED):\\n            return True\\n        else:\\n            return False\\n    if(global_param['sell_id']!=0):\\n        order = exchange.GetOrder(global_param['sell_id'])\\n        if(order[\\\"Status\\\"]==ORDER_STATE_CLOSED):\\n            return True  \\n        else:\\n            return False\\n    return True\\n        \\ndef get_position():\\n    global_param['sell_amount'] = 0\\n    global_par",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   global_param['sell_amount'] = 0\\n    global_param['sell_profit'] = 0\\n    global_param['buy_amount'] = 0\\n    global_param['buy_profit'] = 0\\n    positions= exchange.GetPosition()\\n    for position in positions:\\n        if(position['Type']==PD_SHORT): #空仓      \\n            global_param['sell_amount'] = position['Amount']#获取空单持仓\\n            global_param['sell_profit'] = position['Profit']#获取空单盈利\\n        elif(position['Type']==PD_LONG):\\n            global_param['buy_amount'] = position['Amount']#获取多单持",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bal_param['buy_amount'] = position['Amount']#获取多单持仓\\n            global_param['buy_profit'] = position['Profit']#获取多单盈利\\n\\n    \\ndef check_stop(price):#止盈止损判断\\n    total_profit = global_param['sell_profit'] + global_param['buy_profit']\\n    if( total_profit>= stop_profit or total_profit<=-stop_loss):#如果获利达到止盈值或者亏损达到止损值 平仓\\n        Log(\\\"止盈止损平仓，当前持仓总盈利\\\",total_profit)\\n        if(global_param['sell_amount']>0):  \\n            Log(\\\"sell_amount\\\",global_param['sell_amount'])\\n            exchange.SetDirection",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'sell_amount'])\\n            exchange.SetDirection(\\\"closesell\\\");#设置下单类型为平空\\n            exchange.Buy(_N(price*1.005,2),global_param['sell_amount'])\\n        if(global_param['buy_amount']>0):\\n            Log(\\\"buy_amount\\\",global_param['buy_amount'])\\n            exchange.SetDirection(\\\"closebuy\\\");#设置下单类型为平多\\n            exchange.Sell(_N(price*0.995,2),global_param['buy_amount'])\\n                \\ndef main():\\n    exchange.SetContractType(contract_type)#设置合约\\n    exchange.SetMarginLevel(margin_level)#杠杆",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "设置合约\\n    exchange.SetMarginLevel(margin_level)#杠杆比例\\n    while True:\\n        ticker = exchange.GetTicker()\\n        price = ticker['Last']\\n        get_position()\\n        check_stop(price)\\n        if(judge_order_finish()):\\n            Log(\\\"当前价格为:\\\",price)\\n            cancel_order()#撤单\\n            open_order(price)#下单\\n        Sleep(1000)\",\n    \"策略名称: 网格合约\\n\\n未找到描述\"\n \n\n    \"strategy_120\",\n    \"# 创建了一个价格1000-800，数量为10的等差网格\\nGridPriceManager(upper_price=1000, lower_price=800, grid_num=10)\\n\\n# 创建了一个价格1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=1000, lower_price=800, grid_num=10)\\n\\n# 创建了一个价格1000-800，间隔为1%的等比网格\\nGridPriceManager(upper_price=1000, lower_price=800, interval=1)\\n\\n# 传入已有网格信息\\ndata = {\\n\\t\\\"grid_list\\\":  99:None,100:None,101:None,102:None,103:None,104:None},\\n\\t\\\"interval\\\":     None,\\n\\t\\\"upper_price\\\":  104,\\n\\t\\\"lower_price\\\":  99,\\n\\t\\\"grid_num\\\":     6,\\n\\t\\\"side\\\":         \\\"long\\\",\\n\\t\\\"grid_diff\\\":    1,\\n\\t\\\"type\\\":         \\\"等差\\\",\\n}\\nGridPriceManager(Data=data)\\n\\n# ==========================================\\n\\ngm = GridPr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "===================================\\n\\ngm = GridPriceManager(1000, 800, 10)\\n\\n# 底仓事件，在调用base_position方法时会触发此事件\\n@gm.event('base_position')\\ndef base_position(price):\\n    # 传入最近的网格价格，以此价格作为买入价格参考\\n    print(price)\\n    return 123456\\t# 返回底仓订单，manger将订单记录\\n\\n# ==========================================\\n\\npython\\ngm = GridPriceManager(1000, 800, 10)\\n\\n# 底仓事件，在调用base_position方法时会触发此事件\\n@gm.event('base_position')\\ndef base_position(price):\\n    # 传入最近的网格价格，以此价格作为买入价格参考\\n    print(price)\\n    return 123456\\t#",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "价格作为买入价格参考\\n    print(price)\\n    return 123456\\t# 返回底仓订单，manger将订单记录\\n\\n# ==========================================\\n\\npython\\nclass GridPriceManager:\\n    def __init__(self, Data=None, upper_price=None, lower_price=None, interval=None, grid_num=None, side: Literal['long','short']='long') -> dict:\\n        self.interval = interval\\n        self.upper_price = upper_price\\n        self.lower_price = lower_price\\n        self.grid_num = grid_num\\n        self.side = side\\n        self.grid_diff = None\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".side = side\\n        self.grid_diff = None\\n        self.type = None    # 网格类型\\n        if self.grid_num is not None:\\n            self.grid_diff = (self.upper_price - self.lower_price) / (self.grid_num - 1)\\n        if Data is None: \\n            if self.interval is None:\\n                self.grid_list = self._generate_grid_list_difference()\\n                self.type = \\\"等差\\\"\\n            else:\\n                self.grid_list = self._generate_grids_list_ratio()\\n                self.type = \\\"等比\\\"\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ratio()\\n                self.type = \\\"等比\\\"\\n        else:\\n            self.grid_list = Data[\\\"grid_list\\\"]\\n            self.interval = Data[\\\"interval\\\"]\\n            self.upper_price = Data[\\\"upper_price\\\"]\\n            self.lower_price = Data[\\\"lower_price\\\"]\\n            self.grid_num = Data[\\\"grid_num\\\"]\\n            self.side = Data[\\\"side\\\"]\\n            self.grid_diff = Data[\\\"grid_diff\\\"]\\n            self.type = Data[\\\"type\\\"]\\n        self.data = f\\\"网格类型: {self.type}, 网格数量: {len(self.grid_list)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= f\\\"网格类型: {self.type}, 网格数量: {len(self.grid_list)}, 上下区间: [{self.upper_price}-{self.lower_price}, 方向: {self.side}]\\\"\\n        self.callback = {}\\n\\n    def event(self, event_name):\\n        \\\"\\\"\\\"事件\\\"\\\"\\\"\\n        def decorator(func):\\n            self.callback[event_name] = func\\n            return func\\n        return decorator\\n\\n    def _generate_grid_list_difference(self) -> dict:\\n        \\\"\\\"\\\"等差网格生成\\\"\\\"\\\"\\n        grid_list = {}\\n        price = self.lower_price\\n        for _ in range(self.grid_nu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f.lower_price\\n        for _ in range(self.grid_num):\\n            grid_list[price] = None\\n            price += self.grid_diff\\n        grid_list[self.upper_price] = None\\n        return grid_list\\n\\n    def _generate_grids_list_ratio(self) -> dict:\\n        \\\"\\\"\\\"等比网格生成\\\"\\\"\\\"\\n        ratio = 1 + self.interval / 100\\n        grid = [self.lower_price * (ratio ** i) for i in range(-100, 101)]\\n        return {round(g, 8): None for g in grid if self.lower_price <= g <= self.upper_price}\\n\\n\\n    def get_near",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ce <= g <= self.upper_price}\\n\\n\\n    def get_nearest_buy_price(self, current_price) -> float:\\n        \\\"\\\"\\\"获取最近网格买入价格\\\"\\\"\\\"\\n        nearest_price = None\\n        for price in sorted(self.grid_list.keys()):\\n            if price > current_price:\\n                break\\n            nearest_price = price\\n        return nearest_price\\n\\n    def get_nearest_sell_price(self, current_price) -> float:\\n        \\\"\\\"\\\"获取最近网格卖出价格\\\"\\\"\\\"\\n        nearest_price = None\\n        for price in sorted(self.grid_list.keys",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\n        for price in sorted(self.grid_list.keys(), reverse=True):\\n            if price < current_price:\\n                break\\n            nearest_price = price\\n        return nearest_price\\n    \\n    def base_position(self, ticker) -> Union[str, int]:\\n        \\\"\\\"\\\"底仓\\\"\\\"\\\"\\n        if self.side == \\\"short\\\":\\n            t = self.get_nearest_sell_price(ticker)\\n        else:\\n            t = self.get_nearest_buy_price(ticker)\\n        order_id = self.callback[\\\"base_position\\\"](t)\\n        self.gri",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f.callback[\\\"base_position\\\"](t)\\n        self.grid_list[t] = order_id\\n        self.callback[\\\"change\\\"](self.grid_list)\\n        return order_id\\n    \\n    def add_order(self, order_id) -> Union[Dict, bool]:\\n        \\\"\\\"\\\"增加网格上下挂单\\\"\\\"\\\"\\n        up_price = None\\n        down_price = None\\n        ticker = None\\n        keys = list(self.grid_list.keys())\\n        for i in range(len(keys)-1):\\n            if self.grid_list[keys[i]] == order_id:\\n                ticker = keys[i]\\n                try:\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     ticker = keys[i]\\n                try:\\n                    if self.side is None or self.side == \\\"long\\\":\\n                        up_price = keys[i+1]\\n                        down_price = keys[i-1]\\n                    else:\\n                        up_price = keys[i-1]\\n                        down_price = keys[i+1]\\n                except IndexError:\\n                    return False\\n                break\\n\\n        PriceDict = {\\\"up\\\": up_price, \\\"down\\\": down_price}\\n        d = self.callback[\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\\"down\\\": down_price}\\n        d = self.callback[\\\"add_order\\\"](PriceDict)\\n        d = {\\\"up\\\": d[\\\"up\\\"], \\\"down\\\": d[\\\"down\\\"]}\\n        self.grid_list[up_price] = d[\\\"up\\\"]\\n        self.grid_list[down_price] = d[\\\"down\\\"]\\n        self.grid_list[ticker] = None\\n        self.callback[\\\"change\\\"](self.grid_list)\\n        return d\\n    \\n    def cancel_order(self, order_id):\\n        \\\"\\\"\\\"撤销订单\\\"\\\"\\\"\\n        result = self.callback[\\\"cancel_order\\\"](order_id)\\n        if result == True:\\n            for i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "id)\\n        if result == True:\\n            for items in self.grid_list.items():\\n                if items[1] == order_id:\\n                    self.grid_list[items[0]] = None\\n                    self.callback[\\\"change\\\"](self.grid_list)\\n                    break\\n\\ndef main():\\n    gm = GridPriceManager(1000, 500, 10)\\n\\n    @gm.event('add_order')\\n    def add_order(price):\\n        print(price)\\n        return {\\n            'up': 36543,\\n            'down': 87957,\\n        }\\n\\n    @gm.event('cancel_o",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "own': 87957,\\n        }\\n\\n    @gm.event('cancel_order')\\n    def cancel_order(order_id):\\n        return True\\n\\n    @gm.event('base_position')\\n    def base_position(price):\\n        print(price)\\n        return 123456\\n\\n    a = gm.base_position(600)\\n    print(a)\\n    a = gm.add_order(123456)\\n    print(gm.grid_list)\\n    gm.cancel_order(87957)\\n    print(gm.grid_list)\",\n    \"策略名称: 网格管理工具\\n\\n| 参数        | 是否必需 | 描述                                        |\\n| ----------- | -------- | --------------------",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "|\\n| ----------- | -------- | ------------------------------------------- |\\n| upper_price | NO       | 网格上边界价格                              |\\n| lower_price | NO       | 网格下边界价格                              |\\n| grid_num    | NO       | 网格数量(等差)                              |\\n| interval    | NO       | 网格间隔(等比)                              |\\n| side        | NO       | 支持传入`long`，`short`，不填写则默认`long` |\\n| Data        | NO       | 已有网格信息，类型为字典                    |\\n\\n```python\"\n \n\n    \"strategy_121\",\n    \"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      |\\n\\n```python\"\n \n\n    \"strategy_121\",\n    \"python\\ndef init():\\n    global symbols, min_value\\n    # 获取交易规则\\n    exchange.SetBase('https://dapi.binance.com')\\n    rule = exchange.IO(\\\"api\\\", \\\"GET\\\", \\\"/dapi/v1/exchangeInfo\\\", \\\"\\\", \\\"\\\")[\\\"symbols\\\"]\\n    Log(rule)\\n    # 获取交易对名称\\n    for i in range(len(exchanges)):\\n        exchanges[i].SetMarginLevel(M)\\n        exchanges[i].SetContractType(\\\"swap\\\")  # 设置永续合约\\n        _symbol = exchanges[i].GetCurrency().split(\\\"_\\\")[0]   # +'USDT'币本位交易对名称\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rency().split(\\\"_\\\")[0]   # +'USDT'币本位交易对名称\\n        # 设置交易精度\\n        j = 0\\n        flag1 = False\\n        flag2 = False\\n        #Log(rule)\\n        while (j < len(rule)) and flag1 == False and flag2 == False:\\n            if str(rule[j][\\\"symbol\\\"]).rfind(_symbol)>=0:\\n                for x in rule[j][\\\"filters\\\"]:\\n                    if x[\\\"filterType\\\"] == \\\"PRICE_FILTER\\\" and flag1 == False:\\n                        #Log(\\\"价格\\\",x[\\\"tickSize\\\"])\\n                        #Log(len(str(float(x[\\\"tickSiz",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                    #Log(len(str(float(x[\\\"tickSize\\\"])).split('.')[-1]))\\n                        price_precision = len(str(float(x[\\\"tickSize\\\"])).split('.')[-1])\\n                        flag1 = True\\n                    elif x[\\\"filterType\\\"] == \\\"LOT_SIZE\\\" and flag2 == False:\\n                        amount_precision = len(x[\\\"minQty\\\"].split('.')[-1])\\n                        flag2 = True\\n            j = j + 1\\n        exchanges[i].SetPrecision(price_precision, amount_precision)\\n    Log(\\\"初始化结束\\\")\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_precision, amount_precision)\\n    Log(\\\"初始化结束\\\")\",\n    \"策略名称: 自动获取币安永续合约交易精度最小开仓u已弃坑\\n\\nexchange.SetBase('https://dapi.binance.com')\\n    rule = exchange.IO(\\\"api\\\", \\\"GET\\\", \\\"/dapi/v1/exchangeInfo\\\", \\\"\\\", \\\"\\\")[\\\"symbols\\\"]\\n    Log(rule)\\n    # 获取交易对名称\\n    for i in range(len(exchanges)):\\n        exchanges[i].SetMarginLevel(M)\\n        exchanges[i].SetContractType(\\\"swap\\\")  # 设置永续合约\\n        _symbol = exchanges[i].GetCurrency().split(\\\"_\\\")[0]   # +'USDT'币本位交易对名称\\n        # 设置交易精度\\n        j = 0\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "SDT'币本位交易对名称\\n        # 设置交易精度\\n        j = 0\\n        flag1 = False\\n        flag2 = False\\n        #Log(rule)\\n        while (j < len(rule)) and flag1 == False and flag2 == False:\\n            if str(rule[j][\\\"symbol\\\"]).rfind(_symbol)>=0:\\n                for x in rule[j][\\\"filters\\\"]:\\n                    if x[\\\"filterType\\\"] == \\\"PRICE_FILTER\\\" and flag1 == False:\\n                        #Log(\\\"价格\\\",x[\\\"tickSize\\\"])\\n                        #Log(len(str(float(x[\\\"tickSize\\\"])).split('.')[-1]))\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r(float(x[\\\"tickSize\\\"])).split('.')[-1]))\\n                        price_precision = len(str(float(x[\\\"tickSize\\\"])).split('.')[-1])\\n                        flag1 = True\\n                    elif x[\\\"filterType\\\"] == \\\"LOT_SIZE\\\" and flag2 == False:\\n                        amount_precision = len(x[\\\"minQty\\\"].split('.')[-1])\\n                        flag2 = True\\n            j = j + 1\\n        exchanges[i].SetPrecision(price_precision, amount_precision)\\n    Log(\\\"初始化结束\\\")\\n```\\n\\n> Detail\\n\\nhttps://www",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    Log(\\\"初始化结束\\\")\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/322632\\n\\n> Last Modified\\n\\n2021-11-12 15:44:44\"\n \n\n    \"strategy_122\",\n    \"python\\n#coding: utf-8\\nimport urllib2 as url\\nimport json\\nimport time\\n\\ndef hxRecords(instrument,timeFrame=1,size=1,includeLastBar=True,to_df=True):\\n    ##从和讯获取期货实时数据\\n    pInst=instrument.lower()\\n    if pInst[-4]!='1':\\n        pInst=pInst[:-3]+'1'+pInst[-3:]\\n    xchg=None\\n    for i in instList:\\n        if pInst[:-4] in i['inst']:\\n            xchg=i['xch",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " pInst[:-4] in i['inst']:\\n            xchg=i['xchg']\\n    if xchg is None:\\n        print (\\\"获取K线时发生错误: 找不到合约\\\")\\n        return None\\n    tfs=[1,5,15,30,60,'D','W']\\n    tf=None\\n    for i in range(len(tfs)):\\n        if timeFrame==tfs[i]:\\n            tf=i\\n    if tf is None:\\n        print(\\\"获取K线时发生错误: K线周期不正确\\\")\\n        return None\\n    now=time.localtime()\\n    timestr=str(now.tm_year+1)+str(12)+str(31)+'000000'\\n    resp='http://webftcn.hermes.hexun.com/shf/kline?code=' + xchg + pInst + '&start=' + ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "com/shf/kline?code=' + xchg + pInst + '&start=' + timestr + '&number=-' + str(size) + '&type=' + str(tf)\\n    try:\\n        resp=url.urlopen(resp)\\n        resp=resp.read()[1:-2]\\n        resp=json.loads(resp)['Data']\\n    except:\\n        print '获取K线时发生错误: 不完整的JSON数据'\\n        return None\\n    re=[]\\n    pw=float(resp[4])\\n    for i in resp[0]:\\n        res=dict(Time=time.mktime(time.strptime(str(i[0]),'%Y%m%d%H%M%S'))*1000,Open=i[2]/pw,High=i[4]/pw\\n                ,Low=i[5]/pw,Close=i[3]/pw,Volume=i[6])\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          ,Low=i[5]/pw,Close=i[3]/pw,Volume=i[6])\\n        re.append(res)\\n    if to_df:\\n        re=pd.DataFrame(re)\\n        col=[]\\n        for i in re.columns:\\n            if i is 'Time':\\n                i='Date'\\n            col.append(i.lower())\\n        re.columns=col\\n        re['date']=re['date'].map(ts_dt64)\\n    return re\\n        \\n\\ninstList = [{\\n    \\\"xchg\\\": \\\"SHFE\\\",\\n    \\\"inst\\\": [\\\"fu\\\", \\\"ru\\\", \\\"wr\\\"]\\n}, {\\n    \\\"xchg\\\": \\\"SHFE2\\\",\\n    \\\"inst\\\": [\\\"ag\\\", \\\"au\\\"]\\n}, {\\n    \\\"xchg\\\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    \\\"inst\\\": [\\\"ag\\\", \\\"au\\\"]\\n}, {\\n    \\\"xchg\\\": \\\"SHFE3\\\",\\n    \\\"inst\\\": [\\\"al\\\", \\\"bu\\\", \\\"cu\\\", \\\"hc\\\", \\\"ni\\\", \\\"pb\\\", \\\"rb\\\", \\\"sn\\\", \\\"zn\\\"]\\n}, {\\n    \\\"xchg\\\": \\\"CZCE\\\",\\n    \\\"inst\\\": [\\\"cf\\\", \\\"fg\\\", \\\"lr\\\", \\\"ma\\\", \\\"oi\\\", \\\"pm\\\", \\\"ri\\\", \\\"rm\\\", \\\"rs\\\", \\\"sf\\\", \\\"sm\\\", \\\"sr\\\", \\\"ta\\\", \\\"wh\\\", \\\"zc\\\"]\\n}, {\\n    \\\"xchg\\\": \\\"DCE\\\",\\n    \\\"inst\\\": [\\\"a\\\", \\\"b\\\", \\\"bb\\\", \\\"c\\\", \\\"cs\\\", \\\"fb\\\", \\\"i\\\", \\\"j\\\", \\\"jd\\\", \\\"jm\\\", \\\"l\\\", \\\"m\\\", \\\"p\\\", \\\"pp\\\", \\\"v\\\", \\\"y\\\"]\\n}]\\n\\ndef main():\\n    Log(ex",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "pp\\\", \\\"v\\\", \\\"y\\\"]\\n}]\\n\\ndef main():\\n    Log(exchange.GetAccount())\",\n    \"策略名称: 获取和讯期货数据Python版本\\n\\n未找到描述\"\n \n\n    \"strategy_123\",\n    \"python\\ndef  getAvgPrice(position):\\n    if hasattr(position[0],'Info') and hasattr(position[0].Info,'cost_open'):# Huobi\\n        return position[0].Info.cost_open\\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'avg_cost'):#OKex\\n        return position[0].Info.avg_cost\\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'entryPrice'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'Info') and  hasattr(position[0].Info,'entryPrice'):#binance\\n        return position[0].Info.entryPrice\\n    else:\\n        return position[0][\\\"Price\\\"] \\n\\ndef main():\\n    Log(exchange.GetAccount())\\n    position = exchanges[0].GetPosition()\\n    if len(position)>0:\\n        avgPrice = getAvgPrice(position)\\n        Log(avgPrice)\",\n    \"策略名称: 获取持仓均价你用对了吗\\n\\nreturn position[0].Info.cost_open\\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'avg_cost'):#OKex\\n        return position[0].",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nfo,'avg_cost'):#OKex\\n        return position[0].Info.avg_cost\\n    elif hasattr(position[0],'Info') and  hasattr(position[0].Info,'entryPrice'):#binance\\n        return position[0].Info.entryPrice\\n    else:\\n        return position[0][\\\"Price\\\"] \\n\\ndef main():\\n    Log(exchange.GetAccount())\\n    position = exchanges[0].GetPosition()\\n    if len(position)>0:\\n        avgPrice = getAvgPrice(position)\\n        Log(avgPrice)\\n    \\n    \\n\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/261288\\n\\n> Last Mo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\nhttps://www.fmz.com/strategy/261288\\n\\n> Last Modified\\n\\n2021-03-11 14:45:53\"\n \n\n    \"strategy_124\",\n    \"python\\n\\n#!,encrypt\\n'''backtest\\nstart: 2022-01-01 00:00:00\\nend: 2022-01-31 23:59:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"OKX\\\",\\\"currency\\\":\\\"ETH_USDT\\\",\\\"balance\\\":1000,\\\"stocks\\\":0,\\\"fee\\\":[0.08,0.1]}]\\n'''\\n\\nfrom datetime import datetime, timedelta, timezone\\nimport json\\n\\nIs_Debug = False\\nmanager = None\\ndebug = None\\nlog = None\\n\\ndef main():\\n    Log('开始要饭了')\\n    EnableLo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "one\\n\\ndef main():\\n    Log('开始要饭了')\\n    EnableLog(Is_Debug)\\n    OnInit()\\n    while True:\\n        Sleep(1000)\\n        manager.LoadData()\\n        OnCommand()\\n        manager.OnTick()\\n        manager.SaveData()\\n    Log('要饭结束了')\\n\\n#如果曾经没有数据，则初始化所有数据。\\ndef OnInit():\\n    #设置重试时间间隔\\n    _CDelay(600000)\\n    #过滤网络错误日志\\n    global Is_Debug\\n    if Is_Debug == False:\\n        SetErrorFilter(\\\"400:|503:|429:|504:\\\")\\n    \\n    global manager\\n    manager = Manager()\\n\\n    return\\n\\n#处理来自UI的交互响应\\ndef OnCom",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Manager()\\n\\n    return\\n\\n#处理来自UI的交互响应\\ndef OnCommand():\\n    pass\\n\\n\\nclass Manager:\\n    Account = None\\n    Tick = None\\n    State = \\\"\\\"\\n    Node_List = []\\n\\n    BuyPrice = 0\\n    SellPrice = 0\\n    Balance = 0\\n    Stocks = 0\\n    TickTime = 0\\n    FrozenBalance = 0\\n    FrozenStocks = 0\\n\\n    #防守模式中的盈利次数\\n    DefenceProfitCount = 0\\n\\n    ClearOrder = 0\\n\\n    def Ins():\\n        global manager\\n        if manager == None:\\n            manager = Manager()\\n        return manager\\n\\n    def GetInf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "anager()\\n        return manager\\n\\n    def GetInfo(self):\\n        self.Tick = _C(exchange.GetTicker)\\n        if self.Tick == None:\\n            return False\\n        \\n        self.Account = _C(exchange.GetAccount)\\n        if self.Account == None:\\n            return False\\n        \\n        self.SellPrice = self.Tick[\\\"Sell\\\"]\\n        self.BuyPrice = self.Tick[\\\"Buy\\\"]\\n        self.Balance = self.Account[\\\"Balance\\\"]\\n        self.Stocks = self.Account['Stocks']\\n        self.TickTime = self.Tick['Ti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t['Stocks']\\n        self.TickTime = self.Tick['Time']\\n        self.FrozenBalance = self.Account['FrozenBalance']\\n        self.FrozenStocks = self.Account['FrozenStocks']\\n        return True\\n\\n    def OnTick(self):\\n        if self.GetInfo() == False:\\n            return\\n\\n        if self.State == \\\"\\\":\\n            #第一次运行\\n            MyLog.Ins().StartTime = self.TickTime\\n            MyLog.Ins().StartMoney = self.TotalMoney()\\n            self.ToAttack()\\n        else:\\n            MyLog.Ins().PrintL",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k()\\n        else:\\n            MyLog.Ins().PrintLog()\\n\\n        if self.State == \\\"平仓\\\":\\n            self.ClearTick()\\n            return\\n\\n        if self.State == '防守':\\n            if self.DefenceProfitCount >= UI_AttackThreshold:\\n                MyLog.Write(\\\"防守计分足够，进入进攻模式。\\\")\\n                self.ToAttack()\\n                return\\n\\n        if len(self.Node_List) == 0:\\n            #仓位空，原地买\\n            node = Node.Buy(self.SellPrice, self.GetBuyNumber())\\n            if node != None:\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Number())\\n            if node != None:\\n                self.Node_List.append(node)\\n                last_node = Node.Buy(Node.MinLeftPrice(), self.GetBuyNumber())\\n                if last_node != None:\\n                    self.Node_List.insert(0, last_node)\\n            return\\n\\n        if Node.CenterNode() != None:\\n            #我在节点中间\\n            if self.NodeCheck(Node.CenterNode()):\\n                #检查自己\\n                return\\n            \\n            index = Manager.Ins().Node_List.index(Node.C",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      index = Manager.Ins().Node_List.index(Node.CenterNode())\\n            if index > 0:\\n                #说明左边有节点\\n                left = self.Node_List[index-1]\\n                #问问节点\\n                if self.NodeCheck(left):\\n                    return\\n                #问问买单\\n                if Node.CenterNode()['buy_order'] == 0:\\n                    self.NodeBuy(Node.CenterNode())\\n                    MyLog.AddBuyBuyTimes()\\n                    return\\n            else:\\n                #说明左边没节点\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n            else:\\n                #说明左边没节点\\n                if len(self.Node_List) < UI_NodeCount:\\n                    #那就建一个节点\\n                    left_node = Node.Buy(Node.CenterNode()['buy_price'] * 0.995, self.GetBuyNumber())\\n                    if left_node != None:\\n                        self.Node_List.insert(0, left_node)\\n                    MyLog.AddBuyBuyTimes()\\n                    return\\n\\n            #再看看右边有没有\\n            if index < len(self.Node_List) - 1:\\n                right = sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "(self.Node_List) - 1:\\n                right = self.Node_List[index + 1]\\n                if self.NodeCheck(right):\\n                    return\\n                #右边的，不用下买单，不然会亏\\n\\n        if self.SellPrice < Node.MinPrice():\\n            #重新检查自己是不是在所有节点左边\\n            if len(self.Node_List) >= UI_NodeCount:\\n                #看看高位有没有垃圾仓\\n                if Node.HasSell(Node.MaxNode()) == False:\\n                    #再看看买单是不是成功了，以防万一\\n                    if Node.CheckBuy(Node.MaxNode()) == False:\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de.CheckBuy(Node.MaxNode()) == False:\\n                        #这是个垃圾单，可以删除\\n                        Node.NodeClear(Node.MaxNode())\\n                        self.Node_List.remove(Node.MaxSellPrice)\\n                        return\\n                #平仓\\n                MyLog.Write(\\\"节点在最左边，并且仓位满了，平仓\\\" + \\\"当前价格：\\\" + str(self.SellPrice))\\n                self.ToClear()\\n                return\\n            else:\\n                #贴边买一个\\n                MyLog.Write(\\\"节点在最左边，仓位没好，买一单\\\" + \\\"当前价格：\\\" + str(self.SellP",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e(\\\"节点在最左边，仓位没好，买一单\\\" + \\\"当前价格：\\\" + str(self.SellPrice))\\n                new_node = Node.Buy(Node.MinLeftPrice(),self.GetBuyNumber())\\n                if new_node != None:\\n                    self.Node_List.insert(0,new_node)\\n                MyLog.AddBuyBuyTimes()\\n                return\\n\\n        if self.SellPrice > Node.MaxSellPrice():\\n            #我在所有节点的右边\\n            #看看满了没，没满就下单，满了就减仓\\n            if len(self.Node_List) >= UI_NodeCount:\\n                #满了，减仓\\n                if Node.HasSell(No",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        #满了，减仓\\n                if Node.HasSell(Node.MinNode()) == False:\\n                    if Node.HasBuy(Node.MinNode()) == False or Node.CheckBuy(Node.MinNode()) == False:\\n                        MyLog.Write(\\\"突然暴涨，单还满了，减个仓\\\" + \\\"。当前价格：\\\" + str(self.SellPrice))\\n                        Node.NodeClear(Node.MinNode())\\n                        self.Node_List.remove(Node.MinNode())\\n                        return\\n                self.NodeCheck(Node.MinNode())\\n            else:\\n                #下单，贴\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de())\\n            else:\\n                #下单，贴\\n                MyLog.Write(\\\"突然暴涨，单没满，从下往上补仓位\\\" + \\\"当前价格：\\\" + str(self.SellPrice))\\n                new_node = Node.Buy(Node.MaxSellPrice(), self.GetBuyNumber())\\n                if new_node != None:\\n                    self.Node_List.append(new_node)\\n\\n\\n    def NodeBuy(self,_node):\\n        node = Node.Buy(_node['buy_price'], self.GetBuyNumber())\\n        if node == None:\\n            return None\\n        _node['buy_order'] = node['buy_order']\\n        _",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " _node['buy_order'] = node['buy_order']\\n        _node['state'] = node['state']\\n        _node['number'] = 0\\n        \\n        return _node\\n\\n    def NodeCheck(self,_node):\\n        if Node.HasSell(_node):\\n            #我有卖单,检查卖单\\n            if Node.CheckSell(_node):\\n                MyLog.Write(\\\"我所处的节点卖好了。\\\" + \\\"当前价格：\\\" + str(self.SellPrice))\\n                MyLog.Ins().WriteProfit(Node.GetProfit(_node))\\n                Node.Reset_Node(_node)\\n                MyLog.Ins().BuyBuy_Count = 0#重新计数\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         MyLog.Ins().BuyBuy_Count = 0#重新计数\\n                return True\\n        else:\\n            if Node.HasBuy(_node):\\n                if Node.CheckBuy(_node):\\n                    Node.Sell(_node)\\n                    return True\\n        return False\\n\\n    def DelEmptyNode(self,_node):\\n        self.Node_List.remove(_node)\\n        Node.NodeClear(_node)\\n        return\\n\\n    #处理卖掉的节点。\\n    def DelSellNode(self,_node):\\n        self.Node_List.remove(_node)\\n        MyLog.Ins().WriteProfit(Node.GetPr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_node)\\n        MyLog.Ins().WriteProfit(Node.GetProfit(_node))\\n        return\\n\\n\\n    #平仓\\n    def ClearTick(self):\\n        #收集清单，逐一取消\\n        MyLog.Write(\\\"平仓运行中\\\")\\n        orders = exchange.GetOrders()\\n        if len(orders) > 0:\\n            MyLog.Write(\\\"未处理订单大于0，取消订单\\\")\\n            for _o in orders:\\n                Node.CancelOrder(_o['Id'])\\n            return\\n        self.Node_List.clear()\\n        #统计仓位，统一售卖\\n        if self.Stocks + self.FrozenStocks > 50 / self.BuyPrice:\\n            MyLo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ozenStocks > 50 / self.BuyPrice:\\n            MyLog.Write(\\\"有持仓，卖掉\\\")\\n            if self.ClearOrder == 0:\\n                #售卖\\n                MyLog.Write(\\\"有持仓，数量：\\\" + str(_N(self.Stocks,4)) + \\\"。 卖价：\\\" + str(_N(self.BuyPrice * 0.999,4)))\\n                order_id = exchange.Sell(self.BuyPrice * 0.999, self.Stocks)\\n                if order_id == None:\\n                    MyLog.Write(\\\"奇怪的错误产生了，160行左右。\\\")\\n                    return\\n                self.ClearOrder = order_id\\n                Sleep(100",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f.ClearOrder = order_id\\n                Sleep(100000)\\n                return\\n            else:\\n                order = _C(exchange.GetOrder,self.ClearOrder)\\n                if order['Status'] != 1:\\n                    MyLog.Write(\\\"订单没有卖掉，重新换价格\\\")\\n                    Node.CancelOrder(self.ClearOrder)\\n                    self.ClearOrder = 0\\n                    return\\n                elif order['Status'] == 1:\\n                    MyLog.Write(\\\"订单卖掉了，退出平仓模式\\\")\\n                    self.ClearOrder = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "，退出平仓模式\\\")\\n                    self.ClearOrder = 0\\n\\n                #无限循环，直到卖完币\\n        \\n        #当清单为0，仓位为0，则进入防守模式。\\n        self.ToDefence()\\n\\n    #转移到防守阶段\\n    def ToDefence(self):\\n        MyLog.Write('进入防守')\\n        if self.State == \\\"平仓\\\":\\n            MyLog.Ins().Defence_Count += 1\\n        MyLog.Ins().StateWrite(\\\"防守\\\",self.State)\\n        self.State = \\\"防守\\\"\\n        self.DefenceProfitCount = 0\\n    \\n    #转移到进攻阶段\\n    def ToAttack(self):\\n        MyLog.Write('进入进攻模式')\\n        MyLog.Ins().",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       MyLog.Write('进入进攻模式')\\n        MyLog.Ins().StateWrite(\\\"进攻\\\",self.State)\\n        MyLog.Ins().Attack_Count += 1\\n        self.State = \\\"进攻\\\"\\n        self.Node_List.clear()\\n\\n    #转移到平仓阶段\\n    def ToClear(self):\\n        MyLog.Write('开始平仓')\\n        if self.State == \\\"防守\\\":#如果来自于防守模式，不用平仓，直接重新进入防守模式。\\n            self.Node_List.clear()\\n            self.ToDefence()\\n            return\\n        MyLog.Ins().StateWrite(\\\"平仓\\\",self.State)\\n        self.State = \\\"平仓\\\"\\n        self.ClearOrder = 0\\n\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "tate = \\\"平仓\\\"\\n        self.ClearOrder = 0\\n\\n    def LoadData(self):\\n        MyLog.Ins().LoadData()\\n        if MyLog.Ins().StartTime == None:\\n            #第一次运行，不加载后续数据了\\n            return\\n        self.Node_List = json.loads(_G('Node_List'))\\n        self.State = _G(\\\"State\\\")\\n        self.DefenceProfitCount = _G('DefenceProfitCount')\\n        self.ClearOrder = _G('ClearOrder')\\n\\n    def SaveData(self):\\n        MyLog.Ins().SaveData()\\n        _G(\\\"Node_List\\\",json.dumps(self.Node_List))\\n        _G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ode_List\\\",json.dumps(self.Node_List))\\n        _G(\\\"State\\\",self.State)\\n        _G(\\\"DefenceProfitCount\\\",self.DefenceProfitCount)\\n        _G(\\\"ClearOrder\\\",self.ClearOrder)\\n    \\n    def TotalMoney(self):\\n        return self.Balance + self.FrozenBalance + (self.Stocks + self.FrozenStocks) * self.BuyPrice\\n\\n    def GetBuyNumber(self):\\n        number = self.TotalMoney() * UI_AttackRatio / UI_NodeCount / self.SellPrice\\n        #去掉太多的精度\\n        return _N(number,4)\\n\\nclass Node:\\n\\n    #创建一个数据并返回\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_N(number,4)\\n\\nclass Node:\\n\\n    #创建一个数据并返回\\n    def CreateNodeData(_state):\\n        data = {}\\n        data['state'] = _state\\n        data['buy_price'] = 0\\n        data['sell_price'] = 0\\n        data['buy_order'] = 0\\n        data['sell_order']=0\\n        data['number'] = 0\\n        return data\\n\\n    #Node还要用，重置下\\n    def Reset_Node(_node):\\n        _node['number'] = 0\\n        _node['buy_order'] = 0\\n        _node['sell_order'] = 0\\n\\n\\n    def Buy(_price,_number):\\n        MyLog.Write('买单，价格：' + s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_price,_number):\\n        MyLog.Write('买单，价格：' + str(_price) + '. 数量：' + str(_number) + \\\"。 价值：\\\" + str(_N(_number * _price,2)))\\n        if Manager.Ins().State == \\\"进攻\\\":\\n            buy_id = exchange.Buy(_price, _number)\\n            if buy_id == None:\\n                return None\\n        else:\\n            buy_id = 1\\n        node = Node.CreateNodeData(Manager.Ins().State)\\n        node['state'] = Manager.Ins().State\\n        node['buy_price'] = _price\\n        node['sell_price'] = _price * 1.005\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        node['sell_price'] = _price * 1.005\\n        node['buy_order'] = buy_id\\n        node['number'] = 0\\n\\n        return node\\n\\n    def HasBuy(_node):\\n        return _node['buy_order'] != 0\\n\\n    def HasSell(_node):\\n        return _node['sell_order'] != 0\\n    \\n    #查看这个节点是不是右边的节点\\n    def IsRight(_node):\\n        right_price = Manager.Ins().SellPrice * 1.005\\n        if right_price > _node['buy_price'] and right_price < _node['sell_price']:\\n            return True\\n        return False\\n\\n    d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        return True\\n        return False\\n\\n    def IsLeft(_node):\\n        right_price = Manager.Ins().SellPrice * 0.995\\n        if right_price > _node['buy_price'] and right_price < _node['sell_price']:\\n            return True\\n        return False\\n\\n    def CenterNode():\\n        for node in Manager.Ins().Node_List:\\n            if Manager.Ins().SellPrice > node['buy_price'] and Manager.Ins().SellPrice < node['sell_price']:\\n                return node\\n        return None\\n\\n    def MaxNode():\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e\\n        return None\\n\\n    def MaxNode():\\n        return Manager.Ins().Node_List[-1]\\n\\n    def MaxBuyPrice():\\n        return Node.MaxNode()['buy_price']\\n\\n    def MaxSellPrice():\\n        return Node.MaxNode()['sell_price']\\n\\n    def MaxHasSell():\\n        return Node.MaxNode()['sell_order'] != 0\\n\\n    def MinNode():\\n        return Manager.Ins().Node_List[0]\\n\\n    def MinPrice():\\n        return Manager.Ins().Node_List[0]['buy_price']\\n\\n    def MinLeftPrice():\\n        return _N(Node.MinPrice() ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "inLeftPrice():\\n        return _N(Node.MinPrice() * 0.995,4)\\n\\n    #检查买单是否OK\\n    def CheckBuy(_node):\\n        if _node['state'] == \\\"防守\\\":\\n            _node['number'] = 1\\n            return True\\n        order = _C(exchange.GetOrder,_node['buy_order'])\\n        if order['Status'] == 1:\\n            _node['number'] = order['DealAmount']\\n            return True\\n        return  False\\n\\n    def MinSellPrice():\\n        return Manager.Ins().Node_List[0]['sell_price']\\n\\n    def MinHasSell():\\n        ret",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sell_price']\\n\\n    def MinHasSell():\\n        return Manager.Ins().Node_List[0]['sell_order'] != 0\\n    \\n    def Sell(_node):\\n        MyLog.Write('卖单，价格：' + str(_node['sell_price']))\\n        if _node['state'] == \\\"防守\\\":\\n            _node['sell_order'] = 1\\n            return True\\n        # 仓位判断，容差\\n        # if Manager.Ins().Stocks < _node['number']:\\n        #     _node['number'] = Manager.Ins().Stocks\\n        \\n        order_id = exchange.Sell(_node['sell_price'], _node['number'])\\n        if order",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "['sell_price'], _node['number'])\\n        if order_id == None:\\n            return False\\n        _node['sell_order'] = order_id\\n        return True\\n\\n    def CheckSell(_node):\\n        if _node['state'] == \\\"防守\\\":\\n            if Manager.Ins().BuyPrice > _node['sell_price']:\\n                return True\\n            return False\\n        \\n        order = _C(exchange.GetOrder,_node['sell_order'])\\n        #再次精准仓位\\n        if order['Status'] == 1:\\n            return True\\n        return False\\n\\n    def ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     return True\\n        return False\\n\\n    def GetProfit(_node):\\n        value = (_node['sell_price'] - _node['buy_price']) * _node['number']\\n        return _N(value,2)\\n    \\n    def NodeClear(_node):\\n        if _node['state'] == \\\"防守\\\":\\n            return\\n\\n        if _node['sell_order'] != 0:\\n            Node.CancelOrder(_node['sell_order'])\\n        if _node['buy_order'] != 0:\\n            Node.CancelOrder(_node['buy_order'])\\n\\n    #确保订单取消成功\\n    def CancelOrder(_id):\\n        MyLog.Write('取消订",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   def CancelOrder(_id):\\n        MyLog.Write('取消订单:' + str(_id))\\n        while True:\\n            order = _C(exchange.GetOrder,_id)\\n            if order['Status'] == 1:\\n                return True\\n            if order['Status'] != 2:\\n                result = exchange.CancelOrder(_id)\\n                if result == True:\\n                    return True\\n                Sleep(1000)\\n            elif order['Status'] == 2:\\n                return True\\n\\n\\nclass MyLog:\\n    #第一次运行的时间\\n    StartTime = 0\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nclass MyLog:\\n    #第一次运行的时间\\n    StartTime = 0\\n    StartMoney = 0\\n    Profit_List = []\\n    State_List = []\\n    Log_Tables = []\\n\\n    Attack_Count = 0\\n    Defence_Count = 0\\n    Exchange_Count = 0\\n\\n    #当期网格收益\\n    StateProfit = 0\\n\\n    #连续购买计数\\n    BuyBuy_Count = 0\\n    BuyBuyClear_Count = 0\\n\\n    def Ins():\\n        global log\\n        if log == None:\\n            log = MyLog()\\n        \\n        return log\\n    \\n    def LoadData(self):\\n        self.Log_Tables = []\\n        self.StartTime = _G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " self.Log_Tables = []\\n        self.StartTime = _G(\\\"StartTime\\\")\\n        if self.StartTime == None:\\n            return\\n        \\n        self.StartMoney = _G(\\\"StartMoney\\\")\\n        self.Profit_List = json.loads(_G(\\\"Profit_List\\\"))\\n        self.State_List = json.loads(_G(\\\"State_List\\\"))\\n        self.Attack_Count = _G(\\\"Attack_Count\\\")\\n        self.Defence_Count = _G(\\\"Defence_Count\\\")\\n        self.Exchange_Count = _G(\\\"Exchange_Count\\\")\\n        self.StateProfit = _G(\\\"StateProfit\\\")\\n        sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "elf.StateProfit = _G(\\\"StateProfit\\\")\\n        self.BuyBuy_Count = _G(\\\"BuyBuy_Count\\\")\\n        self.BuyBuyClear_Count = _G(\\\"BuyBuyClear_Count\\\")\\n\\n    def SaveData(self):\\n        _G(\\\"StartTime\\\",self.StartTime)\\n        _G(\\\"StartMoney\\\",self.StartMoney)\\n        _G(\\\"Profit_List\\\",json.dumps(self.Profit_List))\\n        _G(\\\"State_List\\\",json.dumps(self.State_List))\\n        _G(\\\"Attack_Count\\\",self.Attack_Count)\\n        _G(\\\"Defence_Count\\\",self.Defence_Count)\\n        _G(\\\"Exchange_Count\\\",self.Exc",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nce_Count)\\n        _G(\\\"Exchange_Count\\\",self.Exchange_Count)\\n        _G(\\\"StateProfit\\\",self.StateProfit)\\n        _G(\\\"BuyBuy_Count\\\", self.BuyBuy_Count)\\n        _G(\\\"BuyBuyClear_Count\\\", self.BuyBuyClear_Count)\\n\\n    def WriteProfit(self,_value):\\n        if Manager.Ins().State == \\\"防守\\\":\\n            #Log(\\\"防守计分一次\\\")\\n            Manager.Ins().DefenceProfitCount += 1\\n            return\\n\\n        #Log(\\\"感谢好心人，给了我\\\" + str(_value) + \\\"USDT。\\\")\\n        self.StateProfit += _value\\n        self.Exchang",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  self.StateProfit += _value\\n        self.Exchange_Count += 1\\n        data = []\\n        #日期，利润，当前浮亏,当前币价\\n        data.append(self.GetTimeStr(Manager.Ins().TickTime))\\n        data.append(_value)\\n        data.append(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\\n        data.append(_N(Manager.Ins().BuyPrice,2))\\n        if len(self.Profit_List) > 10:\\n            self.Profit_List.pop()\\n        self.Profit_List.insert(0,data)\\n        #利润日志\\n        LogProfit(_N(Manager.Ins().TotalMoney() - self.S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  LogProfit(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\\n\\n    def AddBuyBuyTimes():\\n        MyLog.Ins().BuyBuy_Count += 1\\n        if MyLog.Ins().BuyBuy_Count >= UI_DefenceThreshold and Manager.Ins().State == \\\"进攻\\\":\\n            MyLog.Write(\\\"达到了连续购买阈值，进入防守模式\\\")\\n            if Manager.Ins().State == \\\"进攻\\\":\\n                MyLog.Ins().BuyBuyClear_Count += 1\\n            Manager.Ins().ToClear()\\n\\n\\n    def GetTimeStr(self,_time):\\n        utc_dt = datetime.utcfromtimestamp(_time/1000)\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " = datetime.utcfromtimestamp(_time/1000)\\n        cn_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))\\n        d = cn_dt.strftime('%Y-%m-%d %H:%M:%S')\\n        return d\\n    \\n    def GetRunDays(self):\\n        now_date = datetime.utcfromtimestamp(Manager.Ins().TickTime/1000)\\n        start_date = datetime.utcfromtimestamp(self.StartTime/1000)\\n        span = now_date - start_date\\n        run_time = span.days\\n        if run_time < 1:\\n            run_time = 1\\n        return run_time\\n\\n    def GetToT",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ime = 1\\n        return run_time\\n\\n    def GetToTalProfit(self):\\n        return Manager.Ins().TotalMoney() - self.StartMoney\\n\\n    def GetAnnualized(self):\\n        a = self.GetToTalProfit() / self.GetRunDays() * 365 / self.StartMoney * 100\\n        return _N(a,2)\\n\\n    def PrintLog(self):\\n        #基础信息表\\n        rows = []\\n        rows.append([\\\"当期启动时间：\\\",self.GetTimeStr(self.StartTime)])\\n        rows.append([\\\"当期初始资金：\\\", self.StartMoney])\\n        rows.append([\\\"当前总仓：\\\", _N(Manager.Ins().TotalMoney(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ws.append([\\\"当前总仓：\\\", _N(Manager.Ins().TotalMoney(),4)])\\n        rows.append([\\\"当前利润：\\\",_N(self.GetToTalProfit(),4)])\\n        rows.append([\\\"当前年化：\\\",str(self.GetAnnualized()) + \\\"%\\\"])\\n        rows.append([\\\"当前持币:\\\",_N(Manager.Ins().Stocks,4)])\\n        rows.append([\\\"当前锁币：\\\", _N(Manager.Ins().FrozenStocks,4)])\\n        rows.append([\\\"钱包剩余：\\\", _N(Manager.Ins().Balance,4)])\\n        rows.append([\\\"钱包冻结：\\\", _N(Manager.Ins().FrozenBalance,4)])\\n        rows.append(['当前状态：',Manager.Ins().State])\\n        row",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "append(['当前状态：',Manager.Ins().State])\\n        rows.append([\\\"防御次数：\\\", self.Defence_Count])\\n        rows.append([\\\"强平次数：\\\", self.BuyBuyClear_Count])\\n        self.Add_Log_Table(\\\"基础信息\\\",[\\\"项目\\\",\\\"内容\\\"], rows)\\n        #Log(json.dumps(rows))\\n        #构建并添加仓位表\\n        n_list = []\\n        for _node in Manager.Ins().Node_List:\\n            n = []\\n            n.append(_node['buy_price'])\\n            n.append(_node['buy_order'])\\n            n.append(_node['sell_price'])\\n            n.append(_node['sell_or",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sell_price'])\\n            n.append(_node['sell_order'])\\n            n.append(_node['number'])\\n            n_list.append(n)\\n        global Is_Debug\\n        if Is_Debug:\\n            self.Add_Log_Table(\\\"仓位信息\\\",['买价','买单',\\\"卖价\\\",\\\"卖单\\\",\\\"仓位数量\\\"],n_list)\\n        #添加利润表\\n        self.Add_Log_Table(\\\"收益记录\\\",[\\\"时间\\\",\\\"利润\\\",\\\"当前浮亏\\\",\\\"当前币价\\\"], self.Profit_List)\\n        #添加状态表\\n        self.Add_Log_Table(\\\"状态表\\\",[\\\"时间\\\",\\\"进入状态\\\",\\\"上一个状态\\\",\\\"当前币价\\\",\\\"当前盈利\\\",\\\"上期网格收益\\\",\\\"上期成交数\\\"],self.State_List)\\n        #调参日",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "上期网格收益\\\",\\\"上期成交数\\\"],self.State_List)\\n        #调参日志\\n        \\n        LogStatus('`' + json.dumps(self.Log_Tables) + '`')\\n    \\n    def StateWrite(self,_name,_lastname):\\n        #时间，状态，上一个状态，此时市场价，此时盈利\\n        data = [self.GetTimeStr(Manager.Ins().TickTime), _name, _lastname, _N(Manager.Ins().SellPrice,2), _N(self.GetToTalProfit(),2),_N(self.StateProfit,2),self.Exchange_Count]\\n        self.State_List.insert(0, data)\\n\\n        if len(self.State_List) >= 100:\\n            self.State_List.pop()\\n        \\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "100:\\n            self.State_List.pop()\\n        \\n        self.StateProfit = 0\\n        self.Exchange_Count = 0\\n        self.BuyBuy_Count = 0\\n\\n    def Add_Log_Table(self, _title, _cols, _rows):\\n        table = {\\n            \\\"type\\\" : \\\"table\\\", \\n            \\\"title\\\" : _title, \\n            \\\"cols\\\" : _cols, \\n            \\\"rows\\\" : _rows\\n        }\\n        self.Log_Tables.append(table)\\n\\n    def Write(_str):\\n        global Is_Debug\\n        if Is_Debug:\\n            Log(str(_str))\",\n    \"策略名称: 要",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_Debug:\\n            Log(str(_str))\",\n    \"策略名称: 要饭机器人30\\n\\n# if Manager.Ins().Stocks < _node['number']:\\n        #     _node['number'] = Manager.Ins().Stocks\\n        \\n        order_id = exchange.Sell(_node['sell_price'], _node['number'])\\n        if order_id == None:\\n            return False\\n        _node['sell_order'] = order_id\\n        return True\\n\\n    def CheckSell(_node):\\n        if _node['state'] == \\\"防守\\\":\\n            if Manager.Ins().BuyPrice > _node['sell_price']:\\n                return T",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e > _node['sell_price']:\\n                return True\\n            return False\\n        \\n        order = _C(exchange.GetOrder,_node['sell_order'])\\n        #再次精准仓位\\n        if order['Status'] == 1:\\n            return True\\n        return False\\n\\n    def GetProfit(_node):\\n        value = (_node['sell_price'] - _node['buy_price']) * _node['number']\\n        return _N(value,2)\\n    \\n    def NodeClear(_node):\\n        if _node['state'] == \\\"防守\\\":\\n            return\\n\\n        if _node['sell_order'] != 0:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    return\\n\\n        if _node['sell_order'] != 0:\\n            Node.CancelOrder(_node['sell_order'])\\n        if _node['buy_order'] != 0:\\n            Node.CancelOrder(_node['buy_order'])\\n\\n    #确保订单取消成功\\n    def CancelOrder(_id):\\n        MyLog.Write('取消订单:' + str(_id))\\n        while True:\\n            order = _C(exchange.GetOrder,_id)\\n            if order['Status'] == 1:\\n                return True\\n            if order['Status'] != 2:\\n                result = exchange.CancelOrder(_id)\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  result = exchange.CancelOrder(_id)\\n                if result == True:\\n                    return True\\n                Sleep(1000)\\n            elif order['Status'] == 2:\\n                return True\\n\\n\\nclass MyLog:\\n    #第一次运行的时间\\n    StartTime = 0\\n    StartMoney = 0\\n    Profit_List = []\\n    State_List = []\\n    Log_Tables = []\\n\\n    Attack_Count = 0\\n    Defence_Count = 0\\n    Exchange_Count = 0\\n\\n    #当期网格收益\\n    StateProfit = 0\\n\\n    #连续购买计数\\n    BuyBuy_Count = 0\\n    BuyBuyClear_Count = 0\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n    BuyBuy_Count = 0\\n    BuyBuyClear_Count = 0\\n\\n    def Ins():\\n        global log\\n        if log == None:\\n            log = MyLog()\\n        \\n        return log\\n    \\n    def LoadData(self):\\n        self.Log_Tables = []\\n        self.StartTime = _G(\\\"StartTime\\\")\\n        if self.StartTime == None:\\n            return\\n        \\n        self.StartMoney = _G(\\\"StartMoney\\\")\\n        self.Profit_List = json.loads(_G(\\\"Profit_List\\\"))\\n        self.State_List = json.loads(_G(\\\"State_List\\\"))\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ate_List = json.loads(_G(\\\"State_List\\\"))\\n        self.Attack_Count = _G(\\\"Attack_Count\\\")\\n        self.Defence_Count = _G(\\\"Defence_Count\\\")\\n        self.Exchange_Count = _G(\\\"Exchange_Count\\\")\\n        self.StateProfit = _G(\\\"StateProfit\\\")\\n        self.BuyBuy_Count = _G(\\\"BuyBuy_Count\\\")\\n        self.BuyBuyClear_Count = _G(\\\"BuyBuyClear_Count\\\")\\n\\n    def SaveData(self):\\n        _G(\\\"StartTime\\\",self.StartTime)\\n        _G(\\\"StartMoney\\\",self.StartMoney)\\n        _G(\\\"Profit_List\\\",json.dumps(self",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Money)\\n        _G(\\\"Profit_List\\\",json.dumps(self.Profit_List))\\n        _G(\\\"State_List\\\",json.dumps(self.State_List))\\n        _G(\\\"Attack_Count\\\",self.Attack_Count)\\n        _G(\\\"Defence_Count\\\",self.Defence_Count)\\n        _G(\\\"Exchange_Count\\\",self.Exchange_Count)\\n        _G(\\\"StateProfit\\\",self.StateProfit)\\n        _G(\\\"BuyBuy_Count\\\", self.BuyBuy_Count)\\n        _G(\\\"BuyBuyClear_Count\\\", self.BuyBuyClear_Count)\\n\\n    def WriteProfit(self,_value):\\n        if Manager.Ins().State == \\\"防守\\\":\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n        if Manager.Ins().State == \\\"防守\\\":\\n            #Log(\\\"防守计分一次\\\")\\n            Manager.Ins().DefenceProfitCount += 1\\n            return\\n\\n        #Log(\\\"感谢好心人，给了我\\\" + str(_value) + \\\"USDT。\\\")\\n        self.StateProfit += _value\\n        self.Exchange_Count += 1\\n        data = []\\n        #日期，利润，当前浮亏,当前币价\\n        data.append(self.GetTimeStr(Manager.Ins().TickTime))\\n        data.append(_value)\\n        data.append(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\\n        data.append(_N(Manager.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lf.StartMoney,2))\\n        data.append(_N(Manager.Ins().BuyPrice,2))\\n        if len(self.Profit_List) > 10:\\n            self.Profit_List.pop()\\n        self.Profit_List.insert(0,data)\\n        #利润日志\\n        LogProfit(_N(Manager.Ins().TotalMoney() - self.StartMoney,2))\\n\\n    def AddBuyBuyTimes():\\n        MyLog.Ins().BuyBuy_Count += 1\\n        if MyLog.Ins().BuyBuy_Count >= UI_DefenceThreshold and Manager.Ins().State == \\\"进攻\\\":\\n            MyLog.Write(\\\"达到了连续购买阈值，进入防守模式\\\")\\n            if Manager.Ins().",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "达到了连续购买阈值，进入防守模式\\\")\\n            if Manager.Ins().State == \\\"进攻\\\":\\n                MyLog.Ins().BuyBuyClear_Count += 1\\n            Manager.Ins().ToClear()\\n\\n\\n    def GetTimeStr(self,_time):\\n        utc_dt = datetime.utcfromtimestamp(_time/1000)\\n        cn_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))\\n        d = cn_dt.strftime('%Y-%m-%d %H:%M:%S')\\n        return d\\n    \\n    def GetRunDays(self):\\n        now_date = datetime.utcfromtimestamp(Manager.Ins().TickTime/1000)\\n        start_date = d",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nager.Ins().TickTime/1000)\\n        start_date = datetime.utcfromtimestamp(self.StartTime/1000)\\n        span = now_date - start_date\\n        run_time = span.days\\n        if run_time < 1:\\n            run_time = 1\\n        return run_time\\n\\n    def GetToTalProfit(self):\\n        return Manager.Ins().TotalMoney() - self.StartMoney\\n\\n    def GetAnnualized(self):\\n        a = self.GetToTalProfit() / self.GetRunDays() * 365 / self.StartMoney * 100\\n        return _N(a,2)\\n\\n    def PrintLog(self):\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "eturn _N(a,2)\\n\\n    def PrintLog(self):\\n        #基础信息表\\n        rows = []\\n        rows.append([\\\"当期启动时间：\\\",self.GetTimeStr(self.StartTime)])\\n        rows.append([\\\"当期初始资金：\\\", self.StartMoney])\\n        rows.append([\\\"当前总仓：\\\", _N(Manager.Ins().TotalMoney(),4)])\\n        rows.append([\\\"当前利润：\\\",_N(self.GetToTalProfit(),4)])\\n        rows.append([\\\"当前年化：\\\",str(self.GetAnnualized()) + \\\"%\\\"])\\n        rows.append([\\\"当前持币:\\\",_N(Manager.Ins().Stocks,4)])\\n        rows.append([\\\"当前锁币：\\\", _N(Manager.Ins().Frozen",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   rows.append([\\\"当前锁币：\\\", _N(Manager.Ins().FrozenStocks,4)])\\n        rows.append([\\\"钱包剩余：\\\", _N(Manager.Ins().Balance,4)])\\n        rows.append([\\\"钱包冻结：\\\", _N(Manager.Ins().FrozenBalance,4)])\\n        rows.append(['当前状态：',Manager.Ins().State])\\n        rows.append([\\\"防御次数：\\\", self.Defence_Count])\\n        rows.append([\\\"强平次数：\\\", self.BuyBuyClear_Count])\\n        self.Add_Log_Table(\\\"基础信息\\\",[\\\"项目\\\",\\\"内容\\\"], rows)\\n        #Log(json.dumps(rows))\\n        #构建并添加仓位表\\n        n_list = []\\n        for _node in ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "并添加仓位表\\n        n_list = []\\n        for _node in Manager.Ins().Node_List:\\n            n = []\\n            n.append(_node['buy_price'])\\n            n.append(_node['buy_order'])\\n            n.append(_node['sell_price'])\\n            n.append(_node['sell_order'])\\n            n.append(_node['number'])\\n            n_list.append(n)\\n        global Is_Debug\\n        if Is_Debug:\\n            self.Add_Log_Table(\\\"仓位信息\\\",['买价','买单',\\\"卖价\\\",\\\"卖单\\\",\\\"仓位数量\\\"],n_list)\\n        #添加利润表\\n        self.Add_Log_Table(\\\"收",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t)\\n        #添加利润表\\n        self.Add_Log_Table(\\\"收益记录\\\",[\\\"时间\\\",\\\"利润\\\",\\\"当前浮亏\\\",\\\"当前币价\\\"], self.Profit_List)\\n        #添加状态表\\n        self.Add_Log_Table(\\\"状态表\\\",[\\\"时间\\\",\\\"进入状态\\\",\\\"上一个状态\\\",\\\"当前币价\\\",\\\"当前盈利\\\",\\\"上期网格收益\\\",\\\"上期成交数\\\"],self.State_List)\\n        #调参日志\\n        \\n        LogStatus('`' + json.dumps(self.Log_Tables) + '`')\\n    \\n    def StateWrite(self,_name,_lastname):\\n        #时间，状态，上一个状态，此时市场价，此时盈利\\n        data = [self.GetTimeStr(Manager.Ins().TickTime), _name, _lastname, _N(Manager.Ins().SellPri",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "kTime), _name, _lastname, _N(Manager.Ins().SellPrice,2), _N(self.GetToTalProfit(),2),_N(self.StateProfit,2),self.Exchange_Count]\\n        self.State_List.insert(0, data)\\n\\n        if len(self.State_List) >= 100:\\n            self.State_List.pop()\\n        \\n        self.StateProfit = 0\\n        self.Exchange_Count = 0\\n        self.BuyBuy_Count = 0\\n\\n    def Add_Log_Table(self, _title, _cols, _rows):\\n        table = {\\n            \\\"type\\\" : \\\"table\\\", \\n            \\\"title\\\" : _title, \\n            \\\"co",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "            \\\"title\\\" : _title, \\n            \\\"cols\\\" : _cols, \\n            \\\"rows\\\" : _rows\\n        }\\n        self.Log_Tables.append(table)\\n\\n    def Write(_str):\\n        global Is_Debug\\n        if Is_Debug:\\n            Log(str(_str))\\n```\\n\\n> Detail\\n\\nhttps://www.fmz.com/strategy/377408\\n\\n> Last Modified\\n\\n2022-10-06 14:58:03\"\n \n\n    \"strategy_125\",\n    \"python\\nimport numpy as np\\nimport json\\n\\n#全局变量\\nprice_precision = {}\\namount_precision = {}\\nhands = {}\\ncan_buy_price = {}\\ncan_sell_price",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "{}\\nhands = {}\\ncan_buy_price = {}\\ncan_sell_price = {}\\nclass mid_class():\\n    def __init__(self, this_exchange):\\n        '''\\n        初始化数据填充交易所的信息，首次获取价格，首次获取account信息\\n        设定好密钥……\\n        \\n        Args:\\n            this_exchange: FMZ的交易所结构\\n        \\n        '''\\n        self.init_timestamp = time.time()\\n        self.exchange = this_exchange\\n        self.name = self.exchange.GetName()\\n        self.jyd = self.exchange.GetCurrency()        \\n    \\n    def get_precision(self,pair):\\n        '''",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \\n    def get_precision(self,pair):\\n        '''\\n        获取交易对的价格精度和数量精度\\n        '''\\n        precision = [4,6,1]\\n        if pair not in price_precision.keys():\\n            Log('没有配置价格精度： ' + pair)\\n            return precision\\n        if pair not in amount_precision.keys():\\n            Log('没有配置数量精度: ' + pair)\\n            return precision\\n        if pair not in hands.keys():\\n            Log('没有配置一手数量: ' + pair)\\n            return precision\\n        return [price_precision[pair], amount_precisio",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    return [price_precision[pair], amount_precision[pair], hands[pair]]\\n        \\n    def switch_currency(self,pair):\\n        '''\\n        替换交易对\\n        '''\\n        self.exchange.IO(\\\"currency\\\",pair)\\n\\n    def get_account(self):\\n        '''\\n        获取账户信息\\n        \\n        Returns:\\n            获取信息成功返回True，获取信息失败返回False\\n        '''\\n        self.Balance = '---'\\n        self.Amount = '---'\\n        self.FrozenBalance = '---'\\n        self.FrozenStocks = '---'\\n        \\n        try:\\n            ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ocks = '---'\\n        \\n        try:\\n            self.account = self.exchange.GetAccount()\\n\\n            self.Balance =  self.account['Balance']\\n            self.Amount = self.account['Stocks']\\n            self.FrozenBalance =  self.account['FrozenBalance']\\n            self.FrozenStocks = self.account['FrozenStocks']\\n            return True\\n        except:\\n            return False\\n    \\n    def get_ticker(self):\\n        '''\\n        获取市价信息\\n        \\n        Returns:\\n            获取信息成功返回True，获取信息",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n        Returns:\\n            获取信息成功返回True，获取信息失败返回False\\n        '''\\n        self.high = '---'\\n        self.low = '---'\\n        self.Sell =  '---'\\n        self.Buy =  '---'\\n        self.last =  '---'\\n        self.Volume = '---'\\n        \\n        try:\\n            self.ticker = self.exchange.GetTicker()\\n        \\n            self.high = self.ticker['High']\\n            self.low = self.ticker['Low']\\n            self.Sell =  self.ticker['Sell']\\n            self.Buy =  self.ticker['Buy']\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "          self.Buy =  self.ticker['Buy']\\n            self.last =  self.ticker['Last']\\n            self.Volume = self.ticker['Volume']\\n            return True\\n        except:\\n            return False\\n        \\n        \\n    def get_depth(self):\\n        '''\\n        获取深度信息\\n        \\n        Returns:\\n            获取信息成功返回True，获取信息失败返回False\\n        '''\\n        self.Ask = '---'\\n        self.Bids = '---'\\n        \\n        try:\\n            self.Depth = self.exchange.GetDepth()\\n            self.Ask = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " self.exchange.GetDepth()\\n            self.Ask = self.Depth['Asks']\\n            self.Bids = self.Depth ['Bids']\\n            return True\\n        except:\\n            return False\\n        \\n        \\n    \\n    def get_ohlc_data(self, period = PERIOD_M1):\\n        '''\\n        获取K线信息\\n        \\n        Args:\\n            period: K线周期，PERIOD_M1 指1分钟, PERIOD_M5 指5分钟, PERIOD_M15 指15分钟,\\n            PERIOD_M30 指30分钟, PERIOD_H1 指1小时, PERIOD_D1 指一天。\\n        '''\\n        self.ohlc_data = exchange.GetRecords(per",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n        self.ohlc_data = exchange.GetRecords(period)\\n        \\n        \\n    \\n    def create_order(self, order_type, price, amount):\\n        '''\\n        post一个挂单信息\\n        \\n        Args:\\n            order_type：挂单类型，'buy'指挂买单，'sell'指挂卖单\\n            price：挂单价格\\n            amount:挂单数量\\n            \\n        Returns:\\n            挂单Id号，可用以取消挂单\\n        '''\\n        if order_type == 'buy':\\n            try:\\n                order_id = self.exchange.Buy( price, amount)\\n            except:\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "( price, amount)\\n            except:\\n                return False\\n            \\n        elif order_type == 'sell':\\n            try:\\n                order_id = self.exchange.Sell( price, amount)\\n            except:\\n                return False\\n        \\n        return order_id\\n    \\n    def get_orders(self):\\n        self.undo_ordes = self.exchange.GetOrders()\\n        return self.undo_ordes\\n    \\n    def cancel_order(self, order_id):\\n        '''\\n        取消一个挂单信息\\n        \\n        Args:\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        取消一个挂单信息\\n        \\n        Args:\\n            order_id：希望取消的挂单ID号\\n            \\n        Returns:\\n            取消挂单成功返回True，取消挂单失败返回False\\n        '''\\n        return self.exchange.CancelOrder(order_id)\\n        \\n    def refreash_data(self):\\n        '''\\n        刷新信息\\n        \\n        Returns:\\n            刷新信息成功返回 'refreash_data_finish!' 否则返回相应刷新失败的信息提示\\n        '''\\n\\n        if not self.get_account():\\n            return 'false_get_account'\\n        \\n        if not self.get_ticker():\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       \\n        if not self.get_ticker():\\n            return 'false_get_ticker'\\n        if not self.get_depth():\\n            return 'false_get_depth'\\n        try:\\n            self.get_ohlc_data()\\n        except:\\n            return 'false_get_K_line_info'\\n        \\n        return 'refreash_data_finish!'\\n\\n \\nclass qushi_class():\\n    def __init__(self, mid_class, amount_N, price_N):\\n        '''\\n        设定好初始需要考虑的参数\\n        Args:\\n            mid_class: 所使用的交易所中间层\\n            amount_N：数量小数点限制\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "class: 所使用的交易所中间层\\n            amount_N：数量小数点限制\\n            price_N：价格小数点限制\\n            \\n        Attributes：\\n            amount_N：数量小数点限制\\n            price_N：价格小数点限制\\n            init_time：初始时间\\n            last_time：上一次执行操作的时间\\n            trade_list:交易请求的id\\n        '''\\n        self.jys = mid_class\\n        \\n        self.init_time = time.time()\\n        self.last_time = time.time()\\n        \\n        self.amount_N = amount_N\\n        self.price_N = price_N\\n        \\n        self.trade_list = []\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "price_N\\n        \\n        self.trade_list = []\\n    \\n    def cancel_orders(self):\\n        '''\\n        遍历当前挂单，如果时间超时则取消\\n        '''\\n        undo_orders = self.jys.get_orders()\\n        for i in range(len(undo_orders)):\\n           self.jys.cancel_order(undo_orders[i].Id)\\n\\n            \\n    def refreash_data(self):\\n        '''\\n        用来从交易所获取最新的价格和数量信息\\n        \\n        Attributes：\\n            B：商品币数量\\n            money：计价币数量\\n            can_buy_B：当前理论可购买商品币数量\\n            Buy_price:当前市场上最近的一单挂单",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "B：当前理论可购买商品币数量\\n            Buy_price:当前市场上最近的一单挂单买价\\n        '''\\n        \\n        message = self.jys.refreash_data()\\n        if message == 'refreash_data_finish!':\\n            self.B = self.jys.Amount\\n            self.money = self.jys.Balance\\n            self.Buy_price = self.jys.Buy\\n            self.Sell_price = self.jys.Sell\\n            self.can_buy_B = self.money/ self.Sell_price * 0.9\\n            #要求仓位只能是30%\\n            if self.B > ((self.B + self.can_buy_B)*0.3):\\n                self.can_bu",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "self.can_buy_B)*0.3):\\n                self.can_buy_B = 0\\n            else:\\n                self.can_buy_B = _N(self.can_buy_B, self.amount_N )\\n            return True\\n        else:\\n            return False\\n            \\n    def make_trade_by_dict(self, trade_dicts):\\n        '''\\n        用来批量完成交易订单\\n        \\n        Attributes：\\n            trade_list:已提交的交易请求的id\\n        '''\\n        for this_trade in trade_dicts:\\n            this_price = _N(this_trade['price'], self.price_N )\\n            this_am",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rade['price'], self.price_N )\\n            this_amount = _N(this_trade['amount'], self.amount_N )\\n            \\n            this_trade_id = self.jys.create_order( this_trade['side'], this_price , this_amount ) \\n            self.trade_list.append( this_trade_id )\\n    \\n    def condition_chicang(self, hands_num):\\n        '''\\n        根据持仓情况来做交易判定的条件\\n        Args:\\n            hands_num：表示交易一共几手（我们假设当前每次交易不高于一手）\\n            \\n        Attributes：\\n            min_trade_B: 一手最多交易的商品币数量\\n            min_tra",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    min_trade_B: 一手最多交易的商品币数量\\n            min_trade_money: 一手最多交易的计价币数量\\n        \\n        '''\\n        self.min_trade_B = (self.can_buy_B + self.B) / hands_num\\n        self.min_buy_B = min(self.min_trade_B, self.can_buy_B)\\n        self.min_sell_B = min(self.min_trade_B, self.B)\\n        self.min_trade_money = self.min_trade_B* self.jys.Buy\\n\\n\\n    \\n    def condition_qushi(self):\\n        '''\\n        根据市场价格情况来做交易判定的条件\\n        '''\\n        rt = False\\n        currency = self.jys.jyd\\n        #Log('cur",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        currency = self.jys.jyd\\n        #Log('cur price' + self.jys.Sell)\\n        #Log('cur range' + can_buy_price[currency][0])\\n        if self.jys.Sell > can_buy_price[currency][0] and self.jys.Sell < can_buy_price[currency][1]:\\n            rt = 'Buy'\\n        if self.jys.Buy > can_sell_price[currency][0] and self.jys.Buy < can_sell_price[currency][1]:\\n            rt = 'Sell'\\n       \\n        return rt\\n    \\n    \\n    def make_trade_dicts(self, hands_num ):\\n        '''\\n        制作交易用字典表单\\n        ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s_num ):\\n        '''\\n        制作交易用字典表单\\n        Args:\\n            hands_num：一共交易多少手\\n            change_pct：价格变化多少交易一手\\n            \\n        Returns：\\n            this_trade_dicts: 根据当前价格变化，制作出需交易的字典的列表\\n        \\n        '''\\n        self.condition_chicang(hands_num)\\n        rt = self.condition_qushi()\\n        this_trade_dicts = []\\n        if rt:\\n            if rt == 'Buy':\\n                if self.min_buy_B > 10**-self.amount_N:\\n                    this_trade_dicts.append({\\n                     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  this_trade_dicts.append({\\n                        'side':'buy',\\n                        'price':self.jys.Buy,\\n                        'amount':self.min_buy_B\\n                    })\\n            else:\\n                if self.min_sell_B > 10**-self.amount_N:\\n                    this_trade_dicts.append({\\n                        'side':'sell',\\n                        'price':self.jys.Sell,\\n                        'amount':self.min_sell_B\\n                    })\\n            return this_trade_dicts\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        })\\n            return this_trade_dicts\\n        else:\\n            return False\\n\\n\\n\\ndef main():\\n\\n    #获取配置的值\\n    global price_precision\\n    price_precision = json.loads(PRICE_PRECISION)\\n    global amount_precision \\n    amount_precision = json.loads(AMOUNT_PRECISION)\\n    global hands \\n    hands = json.loads(HANDS)\\n    global can_buy_price\\n    can_buy_price = json.loads(CAN_BUY_PRICE)\\n    global can_sell_price\\n    can_sell_price = json.loads(CAN_SELL_PRICE)\\n    round = 1\\n    while Tr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "loads(CAN_SELL_PRICE)\\n    round = 1\\n    while True:\\n        Sleep(1000)\\n        for i in range(len(exchanges)):\\n            #定义交易中间件\\n            test_mid = mid_class(exchanges[i])\\n            currency = test_mid.jyd\\n            #获取交易对的价格，数量精度\\n            currency_precision = test_mid.get_precision(currency)\\n            #生成策略类\\n            test_qushi = qushi_class(test_mid , currency_precision[0], currency_precision[1])\\n            #获取最新数据\\n            result  = test_qushi.refreash_data()\\n       ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "     result  = test_qushi.refreash_data()\\n            if result == True:\\n                now_trade_dicts = test_qushi.make_trade_dicts(currency_precision[2])\\n                if now_trade_dicts:\\n                    test_qushi.make_trade_by_dict(now_trade_dicts)\\n                    now_trade_dicts = False\\n            #检查挂单情况\\n            if round % 20 == 0:\\n                Log('开始撤单')\\n                Log(test_mid.account)\\n                test_qushi.cancel_orders()\\n        \\n        round = round + 1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ncel_orders()\\n        \\n        round = round + 1\",\n    \"策略名称: 轮询价格买入卖出\\n\\n未找到描述\"\n \n\n    \"strategy_126\",\n    \"python\\nlist=[]\\n\\ndef doTicker():\\n    #Log(exchange.GetAccount())\\n    #Log(list)\\n    ticker = exchange.GetTicker()\\n    last = ticker.Last\\n    if len(list) < LENGTH:\\n        list.append(last)\\n    else:\\n        pMax = max(list)\\n        pMin = min(list)\\n        if last > pMax:\\n            Log(\\\"buy \\\" + str(exchange.GetAccount()))\\n            account = exchange.GetAccount()\\n            i",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    account = exchange.GetAccount()\\n            if account.Balance > last:\\n                #id = exchange.Buy(last, 1)\\n                id = exchange.Buy(-1, 1)\\n                Log(\\\"buy id --> \\\" + str(id))\\n        elif last < pMin:\\n            Log(\\\"sell \\\" + str(exchange.GetAccount()))\\n            account = exchange.GetAccount()\\n            if account.Stocks > 0:\\n                #id = exchange.Sell(last, 1)\\n                id = exchange.Sell(-1, 1)\\n                Log(\\\"sell id --> \\\" + str(id)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1)\\n                Log(\\\"sell id --> \\\" + str(id))\\n        list.pop(0)\\n        list.append(last)\\n\\ndef main():\\n    while(true):\\n        doTicker() #执行策略\\n        Sleep(PERIOD * 1000) #休息一段时间\",\n    \"策略名称: 追涨杀跌\\n\\n未找到描述\"\n \n\n    \"strategy_127\",\n    \"python\\n#!Python3\\n\\n\\\"\\\"\\\"\\n《策略代写》 与 （此程序帮助），致信QQ：35787501\\n\\n钉钉长消息推送，用于群自定义机器人\\n由于@可推送的信息过短，在字符串长度过长时，可以使用此程序\\n\\\"\\\"\\\"\\n\\nimport time\\nimport json\\nimport hmac\\nimport hashlib\\nimport base64\\nimport urllib.parse\\nimport urllib.request\\n\\n\\ndef send_request(u",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rse\\nimport urllib.request\\n\\n\\ndef send_request(url, data):\\n    headers = {\\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\\n                      'Chrome/92.0.4515.159 Safari/537.36',\\n        'Accept': 'text/html,application/xhtml+xml,application/xml;'\\n                  'q=0.9,image/avif,image/webp,image/apng,*/*;'\\n                  'q=0.8,application/signed-exchange;v=b3;q=0.9',\\n        \\\"Content-Type\\\": \\\"applicati",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=b3;q=0.9',\\n        \\\"Content-Type\\\": \\\"application/json\\\",\\n        \\\"Charset\\\": \\\"UTF-8\\\",\\n    }\\n    request = urllib.request.Request(url=url, data=json.dumps(data).encode(\\\"utf-8\\\"), headers=headers)\\n    opener = urllib.request.urlopen(request)\\n    return opener.read().decode()\\n\\n\\ndef get_time_sign(secret):\\n    timestamp = str(round(time.time() * 1000))\\n    secret_enc = secret.encode('utf-8')\\n    string_to_sign = '{}\\\\n{}'.format(timestamp, secret)\\n    string_to_sign_enc = string_to_sign.encod",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "et)\\n    string_to_sign_enc = string_to_sign.encode('utf-8')\\n    h_mac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\\n    sign = urllib.parse.quote_plus(base64.b64encode(h_mac_code))\\n    return timestamp, sign\\n\\n\\ndef send(text):\\n    timestamp, sign = get_time_sign(ding_secret)\\n    my_url = \\\"{}&timestamp={}&sign={}\\\".format(ding_url, timestamp, sign)\\n    data = {\\\"msgtype\\\": \\\"text\\\", \\\"text\\\": {\\\"content\\\": text}}\\n    return send_request(my_url, data)\\n\\n\\ndef L",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n    return send_request(my_url, data)\\n\\n\\ndef LogDing(*args):\\n    Log(send(\\\" \\\".join(args)))\\n\\n\\ndef main():\\n    LogDing(\\\" test \\\" * 1000)\\n\\n\\next.LogDing = LogDing\",\n    \"策略名称: 钉钉群机器人推送超长信息必备\\n\\n未找到描述\"\n \n\n    \"strategy_128\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\n\\nimport json\\nimport time\\n\\nimport requests\\nfrom kumex.client import Trade\\n\\n\\ndef check_response_data(response_data):\\n    if response_data.status_code == 200:\\n        try:\\n            d = response_data.jso",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n        try:\\n            d = response_data.json()\\n        except ValueError:\\n            raise Exception(response_data.content)\\n        else:\\n            if d and d.get('s'):\\n                if d.get('s') == 'ok':\\n                    return d\\n                else:\\n                    raise Exception(\\\"{}-{}\\\".format(response_data.status_code, response_data.text))\\n    else:\\n        raise Exception(\\\"{}-{}\\\".format(response_data.status_code, response_data.text))\\n\\n\\ndef get_kline(s, r, f, t, ti",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "onse_data.text))\\n\\n\\ndef get_kline(s, r, f, t, timeout=5, is_sandbox=False):\\n    headers = {}\\n    url = 'https://kitchen.kumex.com/kumex-kline/history'\\n    if is_sandbox:\\n        url = 'https://kitchen-sdb.kumex.com/kumex-kline/history'\\n    uri_path = url\\n    data_json = ''\\n    p = []\\n    if s:\\n        p.append(\\\"{}={}\\\".format('symbol', s))\\n    if r:\\n        p.append(\\\"{}={}\\\".format('resolution', r))\\n    if f:\\n        p.append(\\\"{}={}\\\".format('from', f))\\n    if t:\\n        p.append(\\\"{}={}",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t('from', f))\\n    if t:\\n        p.append(\\\"{}={}\\\".format('to', t))\\n    data_json += '&'.join(p)\\n    uri_path += '?' + data_json\\n\\n    response_data = requests.request('GET', uri_path, headers=headers, timeout=timeout)\\n    return check_response_data(response_data)\\n\\n\\nclass Shock(object):\\n\\n    def __init__(self):\\n        # read configuration from json file\\n        with open('config.json', 'r') as file:\\n            config = json.load(file)\\n\\n        self.api_key = config['api_key']\\n        self",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    self.api_key = config['api_key']\\n        self.api_secret = config['api_secret']\\n        self.api_passphrase = config['api_passphrase']\\n        self.sandbox = config['is_sandbox']\\n        self.symbol = config['symbol']\\n        self.resolution = int(config['resolution'])\\n        self.valve = float(config['valve'])\\n        self.leverage = float(config['leverage'])\\n        self.size = int(config['size'])\\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".api_secret, self.api_passphrase, is_sandbox=self.sandbox)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    shock = Shock()\\n\\n    while 1:\\n        time_to = int(time.time())\\n        time_from = time_to - shock.resolution * 60 * 35\\n        data = get_kline(shock.symbol, shock.resolution, time_from, time_to, is_sandbox=shock.sandbox)\\n        print('now time =', time_to)\\n        print('symbol closed time =', data['t'][-1])\\n        if time_to != data['t'][-1]:\\n            continue\\n        now_price = int(data['c",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "         continue\\n        now_price = int(data['c'][-1])\\n        print('closed price =', now_price)\\n        # high_track\\n        high = data['h'][-31:-1]\\n        high.sort(reverse=True)\\n        high_track = float(high[0])\\n        print('high_track =', high_track)\\n\\n        # low_track\\n        low = data['l'][-31:-1]\\n        low.sort()\\n        low_track = float(low[0])\\n        print('low_track =', low_track)\\n\\n        # interval_range\\n        interval_range = (high_track - low_track) / (high_tr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "terval_range = (high_track - low_track) / (high_track + low_track)\\n        print('interval_range =', interval_range)\\n\\n        order_flag = 0\\n        # current position qty of the symbol\\n        position_details = shock.trade.get_position_details(shock.symbol)\\n        position_qty = int(position_details['currentQty'])\\n        print('current position qty of the symbol =', position_qty)\\n        if position_qty > 0:\\n            order_flag = 1\\n        elif position_qty < 0:\\n            order_flag = -1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lif position_qty < 0:\\n            order_flag = -1\\n\\n        if order_flag == 1 and now_price < low_track:\\n            order = shock.trade.create_limit_order(shock.symbol, 'sell', position_details['realLeverage'],\\n                                                   position_qty, now_price)\\n            print('order_flag == 1,order id =', order['orderId'])\\n            order_flag = 0\\n        elif order_flag == -1 and now_price > high_track:\\n            order = shock.trade.create_limit_order(shock.symbol,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "der = shock.trade.create_limit_order(shock.symbol, 'buy', position_details['realLeverage'],\\n                                                   position_qty, now_price)\\n            print('order_flag == -1,order id =', order['orderId'])\\n            order_flag = 0\\n\\n        if interval_range < shock.valve and order_flag == 0:\\n            if now_price > high_track:\\n                order = shock.trade.create_limit_order(shock.symbol, 'buy', shock.leverage, shock.size, now_price)\\n                print('now",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "shock.size, now_price)\\n                print('now price > high track,buy order id =', order['orderId'])\\n                order_flag = 1\\n            if now_price < high_track:\\n                order = shock.trade.create_limit_order(shock.symbol, 'sell', shock.leverage, shock.size, now_price)\\n                print('now price < high track,sell order id =', order['orderId'])\\n                order_flag = -1\",\n    \"策略名称: 震荡突破策略\\n\\n上轨：过去30根K线的最高价\\n\\n下轨：过去30根K线的最低价\\n\\n区间幅度：（上轨 - 下轨）/ （上轨 + 下轨）\\n\\n如果区间幅度小于阈值a，价格",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "最低价\\n\\n区间幅度：（上轨 - 下轨）/ （上轨 + 下轨）\\n\\n如果区间幅度小于阈值a，价格向上突破上轨，买入开仓，价格跌破下轨平仓\\n\\n如果区间幅度小于阈值a，价格向下突破上轨，卖出开仓，价格突破上轨平仓\\n ![IMG](https://www.fmz.com/upload/asset/15f35e56ef95b1f550644.png)\"\n \n\n    \"strategy_129\",\n    \"python\\n'''backtest\\nstart: 2021-04-01 00:00:00\\nend: 2021-04-30 23:59:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"Binance\\\",\\\"currency\\\":\\\"ETH_USDT\\\",\\\"stocks\\\":0}]\\n'''\\n\\nimport time\\nclass juncang_strategy():  \\n    def __init__(self,exchange):\\n        self.p = 0.5\\n        self.account =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ge):\\n        self.p = 0.5\\n        self.account = None\\n        self.cny = 0\\n        self.btc = 0\\n        self.exchange =exchange\\n    \\n    #K线合成函数\\n    def k_compose(self,Recordlist,num):\\n        newRecordlist = []\\n        for i in range(len(Recordlist)):\\n            if (i+1)%num == 1:\\n                tempk = {}\\n                tempk[\\\"Time\\\"]=Recordlist[i][\\\"Time\\\"]\\n                tempk[\\\"Open\\\"]=Recordlist[i][\\\"Open\\\"]\\n                tempk[\\\"High\\\"]=Recordlist[i][\\\"High\\\"]\\n                t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "High\\\"]=Recordlist[i][\\\"High\\\"]\\n                tempk[\\\"Low\\\"]=Recordlist[i][\\\"Low\\\"]\\n                tempk[\\\"Close\\\"]=Recordlist[i][\\\"Close\\\"]\\n                tempk[\\\"Volume\\\"]=Recordlist[i][\\\"Volume\\\"]\\n                newRecordlist.append(tempk)\\n            elif (i+1)%num == 0:\\n                if Recordlist[i][\\\"High\\\"]>tempk[\\\"High\\\"]:\\n                    tempk[\\\"High\\\"] = Recordlist[i][\\\"High\\\"]\\n                if Recordlist[i][\\\"Low\\\"]<tempk[\\\"Low\\\"]:\\n                    tempk[\\\"Low\\\"] = Recor",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ow\\\"]:\\n                    tempk[\\\"Low\\\"] = Recordlist[i][\\\"Low\\\"]\\n                tempk[\\\"Time\\\"]=Recordlist[i][\\\"Time\\\"]\\n                tempk[\\\"Close\\\"]=Recordlist[i][\\\"Close\\\"]\\n                tempk[\\\"Volume\\\"]=tempk[\\\"Volume\\\"]+Recordlist[i][\\\"Volume\\\"]\\n                del(newRecordlist[-1])\\n                newRecordlist.append(tempk)\\n            else:\\n                if Recordlist[i][\\\"High\\\"]>tempk[\\\"High\\\"]:\\n                    tempk[\\\"High\\\"] = Recordlist[i][\\\"High\\\"]\\n                if R",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"] = Recordlist[i][\\\"High\\\"]\\n                if Recordlist[i][\\\"Low\\\"]<tempk[\\\"Low\\\"]:\\n                    tempk[\\\"Low\\\"] = Recordlist[i][\\\"Low\\\"]\\n                del(newRecordlist[-1])\\n                newRecordlist.append(tempk)\\n        return newRecordlist\\n\\n    #唐安奇通道计算，分析出当前什么行情\\n    def donchian(self):\\n        exchange.SetMaxBarLen(2000)\\n        temp_k = _C(self.exchange.GetRecords,PERIOD_D1)\\n        week_kline = self.k_compose(temp_k,7)\\n        rt=False\\n        # Log(len(week_kline),week_kl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   rt=False\\n        # Log(len(week_kline),week_kline[-1][\\\"High\\\"],TA.Highest(week_kline, 20, 'High'))\\n        if len(week_kline)>20:\\n            if week_kline[-1][\\\"High\\\"]>TA.Highest(week_kline, 20, 'High'):\\n                rt = '全仓'\\n            elif week_kline[-1][\\\"High\\\"]<TA.Highest(week_kline, 20, 'High') and week_kline[-1][\\\"Low\\\"]>TA.MA(week_kline, 10)[-1]:\\n                rt = '均仓'\\n            elif week_kline[-1][\\\"Low\\\"]<TA.MA(week_kline, 10)[-1]:\\n                rt = '空仓'\\n        else:\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")[-1]:\\n                rt = '空仓'\\n        else:\\n            rt = '均仓'\\n        return rt\\n    def cancelAllOrders(self):\\n        orders = self.exchange.GetOrders()\\n        for order in orders:\\n            self.exchange.CancelOrder(order['Id'], order)\\n        return True\\n    #全仓买入函数\\n    def allin(self):\\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\\n        account = _C(self.exchange.GetAccount)\\n        self.cny = account.Balance\\n        buynum=_N(self.cny*0.99/kr[-1].Close,3)\\n        if b",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "num=_N(self.cny*0.99/kr[-1].Close,3)\\n        if buynum>0:\\n            Log(\\\"全仓allin\\\")\\n            self.exchange.Buy(kr[-1].Close,buynum)\\n        \\n    #全仓卖出函数\\n    def allout(self):\\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\\n        account = _C(self.exchange.GetAccount)\\n        self.btc = _N(account.Stocks,3)\\n        if self.btc>0:\\n            Log(\\\"空仓allout\\\")\\n            self.exchange.Sell(kr[-1].Close,self.btc)\\n    #均仓函数\\n    def balanceAccount(self):\\n        kr =  _C(self.exchang",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "lanceAccount(self):\\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\\n        account = _C(self.exchange.GetAccount)\\n        if account is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n\\n        #赋值\\n        self.btc = account.Stocks\\n        self.cny = account.Balance\\n        \\n        accountmoney=self.btc * kr[-1].Close + self.cny\\n        self.p = self.btc * kr[-1].Close / accountmoney\\n        tradenum=_N(accountmoney/kr[-1].Close/100,3)\\n        if tradenum<0.001:\\n ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "kr[-1].Close/100,3)\\n        if tradenum<0.001:\\n            tradenum=0.001\\n        #判断self.p的值是否小于0.48\\n        # Log(self.p)\\n        if (0.45<self.p < 0.49):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #判断self.p的值是否大于0.52\\n        elif (0.55 > self.p > 0.51):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n     ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            #调用Sell函数并传入相应的参数\\n            self.exchange.Sell(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p >= 0.55):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡,快速平仓\\\", self.p)\\n\\n            self.exchange.Sell(kr[-1].Close, _N(tradenum*10,3))\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p <= 0.45):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡，快速建仓\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, _N(tradenum*10,3))\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n    #交易循环\\n    def loop(self):\\n        self.cancelAllOrders()\\n        rt=self.donchian()\\n        if rt=='全仓':\\n            self.allin()\\n        elif rt=='均仓':\\n            self.balanceAccount()\\n        else:\\n            self.allout()\\n        Sleep(1000*60)\\n\\n\\n\\n\\n#函数main\\ndef main():\\n    #reaper 是构造函",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "0)\\n\\n\\n\\n\\n#函数main\\ndef main():\\n    #reaper 是构造函数的实例\\n    reaper = juncang_strategy(exchange)\\n    while (True):\\n        reaper.loop()\",\n    \"策略名称: 韭菜保护程序唐安奇通道均仓策略\\n\\nif len(week_kline)>20:\\n            if week_kline[-1][\\\"High\\\"]>TA.Highest(week_kline, 20, 'High'):\\n                rt = '全仓'\\n            elif week_kline[-1][\\\"High\\\"]<TA.Highest(week_kline, 20, 'High') and week_kline[-1][\\\"Low\\\"]>TA.MA(week_kline, 10)[-1]:\\n                rt = '均仓'\\n            elif week_kline[-1][\\\"Low\\\"]<TA.MA(week_kl",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "        elif week_kline[-1][\\\"Low\\\"]<TA.MA(week_kline, 10)[-1]:\\n                rt = '空仓'\\n        else:\\n            rt = '均仓'\\n        return rt\\n    def cancelAllOrders(self):\\n        orders = self.exchange.GetOrders()\\n        for order in orders:\\n            self.exchange.CancelOrder(order['Id'], order)\\n        return True\\n    #全仓买入函数\\n    def allin(self):\\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\\n        account = _C(self.exchange.GetAccount)\\n        self.cny = account.Balance\\n    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "Account)\\n        self.cny = account.Balance\\n        buynum=_N(self.cny*0.99/kr[-1].Close,3)\\n        if buynum>0:\\n            Log(\\\"全仓allin\\\")\\n            self.exchange.Buy(kr[-1].Close,buynum)\\n        \\n    #全仓卖出函数\\n    def allout(self):\\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\\n        account = _C(self.exchange.GetAccount)\\n        self.btc = _N(account.Stocks,3)\\n        if self.btc>0:\\n            Log(\\\"空仓allout\\\")\\n            self.exchange.Sell(kr[-1].Close,self.btc)\\n    #均仓函数\\n   ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "change.Sell(kr[-1].Close,self.btc)\\n    #均仓函数\\n    def balanceAccount(self):\\n        kr =  _C(self.exchange.GetRecords,PERIOD_H1)\\n        account = _C(self.exchange.GetAccount)\\n        if account is None:\\n            return\\n\\n        #赋值\\n        self.account = account\\n\\n        #赋值\\n        self.btc = account.Stocks\\n        self.cny = account.Balance\\n        \\n        accountmoney=self.btc * kr[-1].Close + self.cny\\n        self.p = self.btc * kr[-1].Close / accountmoney\\n        tradenum=_N(accoun",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "].Close / accountmoney\\n        tradenum=_N(accountmoney/kr[-1].Close/100,3)\\n        if tradenum<0.001:\\n            tradenum=0.001\\n        #判断self.p的值是否小于0.48\\n        # Log(self.p)\\n        if (0.45<self.p < 0.49):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n\\n            #判断self.p的值是否大于0.52\\n        elif (0.55 > self.p > 0.51):\\n            #调用Log函数并传入参数\\\"开",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "55 > self.p > 0.51):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡\\\", self.p)\\n\\n            #调用Sell函数并传入相应的参数\\n            self.exchange.Sell(kr[-1].Close, tradenum)\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p >= 0.55):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡,快速平仓\\\", self.p)\\n\\n            self.exchange.Sell(kr[-1].Close, _N(tradenum*10,3))\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n        elif (self.p <= 0.45)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",\\\"现金数:\\\",self.cny)\\n        elif (self.p <= 0.45):\\n            #调用Log函数并传入参数\\\"开始平衡\\\", self.p\\n            Log(\\\"开始平衡，快速建仓\\\", self.p)\\n\\n            self.exchange.Buy(kr[-1].Close, _N(tradenum*10,3))\\n\\n            Log(\\\"持币数:\\\",self.btc,\\\"现金数:\\\",self.cny)\\n    #交易循环\\n    def loop(self):\\n        self.cancelAllOrders()\\n        rt=self.donchian()\\n        if rt=='全仓':\\n            self.allin()\\n        elif rt=='均仓':\\n            self.balanceAccount()\\n        else:\\n            self.allout()\\n        Sleep",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "   else:\\n            self.allout()\\n        Sleep(1000*60)\"\n \n\n    \"strategy_130\",\n    \"python\\n'''backtest\\nstart: 2021-05-01 00:00:00\\nend: 2021-05-14 00:00:00\\nperiod: 1m\\nbasePeriod: 1m\\nexchanges: [{\\\"eid\\\":\\\"Futures_Binance\\\",\\\"currency\\\":\\\"EOS_USDT\\\",\\\"balance\\\":1000}]\\nargs: [[\\\"zuokong\\\",true],[\\\"n\\\",3],[\\\"E\\\",0.02]]\\n'''\\ndef main():\\n    while True:\\n        exchange.SetContractType(\\\"swap\\\")\\n        exchange.SetMarginLevel(MarginLevel)\\n        ticker = _C(exchange.GetTicker)\\n        account ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " ticker = _C(exchange.GetTicker)\\n        account = _C(exchange.GetAccount)\\n        position = _C(exchange.GetPosition)\\n        if zuoduo:\\n            if len(position) == 0:   \\n                    exchange.SetDirection(\\\"buy\\\")\\n                    exchange.Buy(-1, k, \\\"开多\\\")\\n            if len(position) > 0:\\n                if position[0].Type==0:\\n                    \\n                    if position[0].Price+Q<ticker[\\\"Last\\\"]:\\n                        exchange.SetDirection(\\\"closebuy\\\")\\n         ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "    exchange.SetDirection(\\\"closebuy\\\")\\n                        exchange.Sell(-1, position[0].Amount) \\n                        account = exchange.GetAccount()\\n                        LogProfit(account[\\\"Balance\\\"]) \\n                    fx=(E/n)*position[0].Amount  \\n                    if position[0].Profit<position[0].Margin * -fx :\\n                        #轮询加仓\\n                            exchange.SetDirection(\\\"buy\\\")\\n                            exchange.Buy(-1, k)\\n                            Log",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "change.Buy(-1, k)\\n                            LogProfit(account[\\\"Balance\\\"])     \\n        if zuokong:\\n            if len(position) == 0:   \\n                    exchange.SetDirection(\\\"sell\\\")\\n                    exchange.Sell(-1, k, \\\"开空\\\")\\n            if len(position) > 0:\\n                if position[0].Type == 1 :\\n                    fp=Q*position[0].Amount\\n                    if position[0].Profit > 0.01*fp*ticker[\\\"Last\\\"] :\\n                        exchange.SetDirection(\\\"closesell\\\")\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "      exchange.SetDirection(\\\"closesell\\\")\\n                        exchange.Buy(-1, position[0].Amount) \\n                        account = exchange.GetAccount()\\n                        LogProfit(account[\\\"Balance\\\"]) \\n                    fx=(E/n)*position[0].Amount  \\n                    if position[0].Profit<position[0].Margin * -fx :\\n                        #轮询加仓\\n                            exchange.SetDirection(\\\"sell\\\")\\n                            exchange.Sell(-1, n)\\n                           ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " exchange.Sell(-1, n)\\n                            LogProfit(account[\\\"Balance\\\"])\\n        \\n        Sleep(3000)\",\n    \"策略名称: 马丁变种原始版\\n\\n未找到描述\"\n \n\n    \"strategy_131\",\n    \"python\\n#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\nimport json\\nimport time\\n\\nfrom kumex.client import Trade, Market\\n\\n\\nclass Hf(object):\\n\\n    def __init__(self):\\n        # read configuration from json file\\n        with open('config.json', 'r') as file:\\n            config = json.load(file)\\n\\n        self.api_key = config",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "= json.load(file)\\n\\n        self.api_key = config['api_key']\\n        self.api_secret = config['api_secret']\\n        self.api_passphrase = config['api_passphrase']\\n        self.sandbox = config['is_sandbox']\\n        self.symbol_a = config['symbol_a']\\n        self.symbol_b = config['symbol_b']\\n        self.spread_mean = float(config['spread_mean'])\\n        self.leverage = float(config['leverage'])\\n        self.size = int(config['size'])\\n        self.num_param = float(config['num_param'])\\n        se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "num_param = float(config['num_param'])\\n        self.trade = Trade(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\\n        self.market = Market(self.api_key, self.api_secret, self.api_passphrase, is_sandbox=self.sandbox)\\n\\n    def get_symbol_price(self, symbol):\\n        ticker = self.market.get_ticker(symbol)\\n        return float(ticker['price'])\\n\\n\\nif __name__ == '__main__':\\n    hf = Hf()\\n    while 1:\\n        # ticker of symbols\\n        price_af = hf.get_symbol_price(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f symbols\\n        price_af = hf.get_symbol_price(hf.symbol_a)\\n        price_bf = hf.get_symbol_price(hf.symbol_b)\\n        # position of symbols\\n        position_a = hf.trade.get_position_details(hf.symbol_a)\\n        position_a_qty = int(position_a['currentQty'])\\n        position_b = hf.trade.get_position_details(hf.symbol_b)\\n        position_b_qty = int(position_b['currentQty'])\\n        # interval of price\\n        new_spread = price_af - price_bf\\n        print('new_spread =', new_spread)\\n\\n      ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "       print('new_spread =', new_spread)\\n\\n        if position_a_qty == position_b_qty == 0 and new_spread < (hf.spread_mean - hf.num_param):\\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'buy', hf.leverage, hf.size, price_af + 1)\\n            print('buy %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'sell', hf.leverage, hf.size, price_bf - 1)\\n            print('sell %s,order id =%s' % (hf.symbol_b, sell_order[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "'sell %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\\n        elif position_a_qty == position_b_qty == 0 and new_spread > (hf.spread_mean + hf.num_param):\\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'sell', hf.leverage, hf.size, price_af - 1)\\n            print('sell %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'buy', hf.leverage, hf.size, price_bf + 1)\\n            print('buy %s,order id =%s' % (hf",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 1)\\n            print('buy %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\\n        elif position_a_qty > 0 and position_b_qty < 0 and new_spread > hf.spread_mean:\\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'sell', position_a['realLeverage'],\\n                                                    position_a_qty, price_af + 1)\\n            print('sell %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'buy'",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r = hf.trade.create_limit_order(hf.symbol_b, 'buy', position_a['realLeverage'],\\n                                                     position_a_qty, price_bf - 1)\\n            print('buy %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\\n        elif position_a_qty < 0 and position_b_qty > 0 and new_spread < hf.spread_mean:\\n            buy_order = hf.trade.create_limit_order(hf.symbol_a, 'buy', position_a['realLeverage'],\\n                                                    position_a_qty, price_af",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "                          position_a_qty, price_af - 1)\\n            print('buy %s,order id =%s' % (hf.symbol_a, buy_order['orderId']))\\n            sell_order = hf.trade.create_limit_order(hf.symbol_b, 'sell', position_a['realLeverage'],\\n                                                     position_a_qty, price_bf + 1)\\n            print('sell %s,order id =%s' % (hf.symbol_b, sell_order['orderId']))\\n\\n        time.sleep(60)\",\n    \"策略名称: 高频跨期套利策略\\n\\n交易标的：比特币（BTC）\\n\\n价差数据：BTC 永续 - BTC 季度（省略协整性检验）\\n\\n交易周期：1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "特币（BTC）\\n\\n价差数据：BTC 永续 - BTC 季度（省略协整性检验）\\n\\n交易周期：1 分钟\\n\\n头寸匹配：1:1\\n\\n交易类型：同品种跨期\\n\\n做多价差开仓条件：如果当前账户没有持仓，并且价差 < （长期价差水平 - 阈值），就做多价差。即：买开 BTC 永续，卖开 BTC 季度。\\n\\n做空价差开仓条件：如果当前账户没有持仓，并且价差 > （长期价差水平 + 阈值），就做空价差。即：卖开 BTC 永续，买开 BTC 季度。\\n\\n做多价差平仓条件：如果当前账户持有 BTC 永续多单，并且持有 BTC 季度空单，并且价差 > 长期价差水平，就平多价差。即：卖平 BTC 永续，买平 BTC 季度。\\n\\n做空价差平仓条件：如果当前账户持有 BTC 永续空单，并且持有 BTC 季度多单，并且价差 < 长期价差水平，就平空价差。即：买平 BTC 永续，卖平 BTC 季度。\\n\\n**举个例子**，假设 BTC 永续 和 BTC 当季的价差长期维持在 35 左右。如果某一天价差达到 50 ，我们预计价差会在未来某段时间回归到 35 及以下。那么就可以卖出 BTC 永续，同时买入 BTC 当季，来",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "计价差会在未来某段时间回归到 35 及以下。那么就可以卖出 BTC 永续，同时买入 BTC 当季，来做空这个价差。反之亦然，注意 BTC 永续 和 BTC 当季 的价差总会回归到0附近（到期交割），所以价差为正的时候，优先做空价差，价差为负的时候，优先做多价差。\"\n \n\n    \"strategy_132\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import\\n3. from gm.api import *\\n4. import talib\\n\\n\\n7. '''\\n8. 本策略以SHFE.rb2101为交易标的，根据其一分钟(即60s频度）bar数据建立双均线模型，\\n9. 短周期为20，长周期为60，当短期均线由上向下穿越长期均线时做空，\\n10. 当短期均线由下向上穿越长期均线时做多,每次开仓前先平掉所持仓位，再开仓。\\n11. 注：为了适用于仿真和实盘，在策略中增加了一个“先判断是否平仓成功再开仓”的判断逻辑，以避免出现未平仓成功，可用资金不足的情况。\\n12. 回测数据为:SHFE.rb",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "再开仓”的判断逻辑，以避免出现未平仓成功，可用资金不足的情况。\\n12. 回测数据为:SHFE.rb2101的60s频度bar数据\\n13. 回测时间为:2020-04-01 09:00:00到2020-05-31 15:00:00\\n14. '''\\n\\n\\n17. def init(context):\\n18. context.short = 20                                             # 短周期均线\\n19. context.long = 60                                              # 长周期均线\\n20. context.symbol = 'SHFE.rb2101'                                 # 订阅交易标的\\n21. context.period = context.long + 1                              # 订阅数据滑窗长度\\n22. context.open_long = False                    ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n22. context.open_long = False                                      # 开多单标记\\n23. context.open_short = False                                     # 开空单标记\\n24. subscribe(context.symbol, '60s', count=context.period)         # 订阅行情\\n\\n\\n27. def on_bar(context, bars):\\n28. # 获取通过subscribe订阅的数据\\n29. prices = context.data(context.symbol, '60s', context.period, fields='close')\\n\\n31. # 利用talib库计算长短周期均线\\n32. short_avg = talib.SMA(prices.values.reshape(context.period), context.short)\\n33. long_avg = talib.SMA(prices.v",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " context.short)\\n33. long_avg = talib.SMA(prices.values.reshape(context.period), context.long)\\n\\n35. # 查询持仓\\n36. position_long = context.account().position(symbol=context.symbol, side=1)\\n37. position_short = context.account().position(symbol=context.symbol, side=2)\\n\\n39. # 短均线下穿长均线，做空(即当前时间点短均线处于长均线下方，前一时间点短均线处于长均线上方)\\n40. if long_avg[-2] < short_avg[-2] and long_avg[-1] >= short_avg[-1]:\\n\\n42. # 无多仓情况下，直接开空\\n43. if not position_long:\\n44. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sel",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ymbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Open,\\n45. order_type=OrderType_Market)\\n46. print(context.symbol, '以市价单调空仓到仓位')\\n\\n48. # 有多仓情况下，先平多，再开空(开空命令放在on_order_status里面)\\n49. else:\\n50. context.open_short = True\\n\\n52. # 以市价平多仓\\n53. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Close,\\n54. order_type=OrderType_Market)\\n55. print(context.symbol, '以市价单平多仓')\\n\\n57. # 短均线上穿长均线，做多（即当前时间点短均线处于长均线上方，前一时间点短均线处于长均线下方）\\n58",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 短均线上穿长均线，做多（即当前时间点短均线处于长均线上方，前一时间点短均线处于长均线下方）\\n58. if short_avg[-2] < long_avg[-2] and short_avg[-1] >= long_avg[-1]:\\n\\n60. # 无空仓情况下，直接开多\\n61. if not position_short:\\n62. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy, position_effect=PositionEffect_Open,\\n63. order_type=OrderType_Market)\\n64. print(context.symbol, '以市价单调多仓到仓位')\\n\\n66. # 有空仓的情况下，先平空，再开多(开多命令放在on_order_status里面)\\n67. else:\\n68. context.open_long = True\\n\\n70. # 以市价平空仓\\n71. order_volume(symbol=context.symbol, volume=1, sid",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\\n72. position_effect=PositionEffect_Close, order_type=OrderType_Market)\\n73. print(context.symbol, '以市价单平空仓')\\n\\n\\n76. def on_order_status(context, order):\\n\\n78. # 查看下单后的委托状态\\n79. status = order['status']\\n\\n81. # 成交命令的方向\\n82. side = order['side']\\n\\n84. # 交易类型\\n85. effect = order['position_effect']\\n\\n87. # 当平仓委托全成后，再开仓\\n88. if status == 3:\\n\\n90. # 以市价开空仓，需等到平仓成功无仓位后再开仓\\n91. # 如果无多仓且side=2（说明平多仓成功），开空仓\\n92. if effect == 2 and side == 2 an",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "（说明平多仓成功），开空仓\\n92. if effect == 2 and side == 2 and context.open_short:\\n93. context.open_short = False\\n94. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell, position_effect=PositionEffect_Open,\\n95. order_type=OrderType_Market)\\n96. print(context.symbol, '以市价单调空仓到仓位')\\n\\n98. # 以市价开多仓,需等到平仓成功无仓位后再开仓\\n99. # 如果无空仓且side=1（说明平空仓成功），开多仓\\n100. if effect == 2 and side == 1 and context.open_long:\\n101. context.open_long = False\\n102. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ymbol=context.symbol, volume=1, side=OrderSide_Buy, position_effect=PositionEffect_Open,\\n103. order_type=OrderType_Market)\\n104. print(context.symbol, '以市价单调多仓到仓位')\\n\\n\\n107. if __name__ == '__main__':\\n108. '''\\n109. 策略ID,由系统生成\\n110. filename文件名,请与本文件名保持一致\\n111. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n112. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n113. backtest_start_time回测开始时间\\n114. backtest_end_time回测结束时间\\n115. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n116. backtest_initial_cash回测初始资金\\n117. ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "JUST_POST\\n116. backtest_initial_cash回测初始资金\\n117. backtest_commission_ratio回测佣金比例\\n118. backtest_slippage_ratio回测滑点比例\\n119. '''\\n120. run(='',\\n121. filename='main.py',\\n122. mode=MODE_BACKTEST,\\n123. token='token_id',\\n124. backtest_start_time='2020-04-01 09:00:00',\\n125. backtest_end_time='2020-05-31 15:00:00',\\n126. backtest_adjust=ADJUST_NONE,\\n127. backtest_initial_cash=10000000,\\n128. backtest_commission_ratio=0.0001,\\n129. backtest_slippage_ratio=0.0001)\",\n    \"# 双均线策略(期货)\\n\\n分享\\n\\n阅读 567308\\n 更新 202",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "01)\",\n    \"# 双均线策略(期货)\\n\\n分享\\n\\n阅读 567308\\n 更新 2022-05-09 16:56:48\\n\\n* [双均线策略](#512c387f42bd8bbb)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [均线的“前世今生”](#8739be5a3b750087)\\n    - [均线理论为什么有效？](#10b66049c43202c8)\\n    - [均线理论的缺陷](#bb02b6da783b762a)\\n    - [均线理论的改进](#bfb608c318c7a05d)\\n  + [2. 策略逻辑](#fdd18c620885abac)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 双均线策略\\n\\n## 1. 原理\\n\\n### 均线的“前世今生”\\n\\n均线，一个进行形态分析时总也绕不过去的指标。\\n\\n均线最早由美国投资专家Joseph E.Granville(格兰威尔)于20世纪中期提出，现在仍然广泛为人们使",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "美国投资专家Joseph E.Granville(格兰威尔)于20世纪中期提出，现在仍然广泛为人们使用，成为判断买卖信号的一大重要指标。从统计角度来说，均线就是历史价格的平均值，可以代表过去N日股价的平均走势。\\n\\n1962年7月，Joseph E.Granville在他的书中提出了著名的Granville八大买卖法则。只利用股价和均线即可进行择时，方法简单有效，一经提出，迅速受到市场追捧。尤其是其中的金叉和死叉信号，更是沿用至今。\\n\\nGranville 八大法则其中有四条是用于判断买进时机，另外四条是用于判断卖出时机。买进和卖出法则一一对应，分布在高点的左右两侧（除买4和卖4以外）。法则内容如下所示：\\n\\n买1：均线整体上行，股价由下至上上穿均线，此为黄金交叉，形成第一个买点。  \\n买2：股价出现下跌迹象，但尚未跌破均线，此时均线变成支撑线，形成第二个买点。  \\n买3：股价仍处于均线上方，但呈现急剧下跌趋势。当跌破均线时，出现第三个买点。  \\n买4：（右侧）股价和均线都处于下降通道，且股价处于均线下方，严重远离均线，出现第四个买点。\\n\\n卖1：均线由上升状态变为缓慢下降的状态，股价也开始下降",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "线下方，严重远离均线，出现第四个买点。\\n\\n卖1：均线由上升状态变为缓慢下降的状态，股价也开始下降。当股价跌破均线时，此为死亡交叉，形成第一个卖点。  \\n卖2：股价仍处于均线之下，但股价开始呈现上涨趋势，当股价无限接近均线但尚未突破时，此时均线变成阻力线，形成第二个卖点。  \\n卖3：股价终于突破均线，处于均线上方。但持续时间不长，股价开始下跌，直至再一次跌破均线，此为第三个卖点。  \\n卖4：（左侧）股价和均线都在上涨，股价上涨的速度远快于均线上涨的速度。当股价严重偏离均线时，出现第四个卖点。  \\n(部分资料来源于百度百科)\\n\\n![](/uploads/202010/attach_16402fcc49ff5d9b.jpg)  \\n（图片来源于网络）\\n\\n### 均线理论为什么有效？\\n\\nShiller（1981）在研究中发现，资产的长期价格呈现均值回复的特征，即从长期来看，资产的价格会回归均值。这也是均线理论被广泛应用的前提。\\n\\n### 均线理论的缺陷\\n\\n均线归根到底是一种平均值，平均值在应用过程中存在最大的问题就是其**滞后性**。当出现买入卖出信号时，最佳时机早已过去。举例来说，如",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "在应用过程中存在最大的问题就是其**滞后性**。当出现买入卖出信号时，最佳时机早已过去。举例来说，如果A股票最新价格出现了较大的涨幅，股价和均线都上涨，但均线的速度慢于股价上涨速度。此时，从形态上来看，金叉出现，为买入信号。次日，股价回调，股价下降的速度快于均线下降的速度，形成死叉，为卖点。这样一买一卖不仅没有盈利，反而出现亏损。\\n\\n### 均线理论的改进\\n\\n针对均线的缺点，市场上提出了各种各样的改进方法。\\n\\n1.对均线的计算方法进行改正。\\n\\n加权移动平均线是在移动平均线的基础上按照时间进行加权。越靠近当前日期的价格对未来价格的影响越大，赋予更大的权重；越远离当前日期价格，赋予越小的权重。\\n\\n2.调整均线周期\\n\\n利用不同周期均线得到的结果也不同。许多有经验的投资者发现，在不同的市场中，有些均线的效果显著优于其他周期均线。有些长线投资者还会将股价替换成短周期均线进行趋势判断。\\n\\n## 2. 策略逻辑\\n\\n第一步：获取数据，计算长短期均线  \\n第二步：设置交易信号\\n\\n当短期均线由上向下穿越长期均线时做空  \\n当短期均线由下向上穿越长期均线时做多\\n\\n回测数据: SHFE.r",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "上向下穿越长期均线时做空  \\n当短期均线由下向上穿越长期均线时做多\\n\\n回测数据: SHFE.rb2101的60s频度bar数据  \\n回测时间: 2020-04-01 到 2020-05-31  \\n回测初始资金：3万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_133\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import\\n3. from gm.api import *\\n\\n\\n6. \\\"\\\"\\\"\\n7. Dual Thrust是一个趋势跟踪系统\\n8. 计算前N天的最高价－收盘价和收盘价－最低价。然后取这2N个价差的最大值，乘以k值。把结果称为触发值。\\n9. 在今天的开盘，记录开盘价，然后在价格超过上轨（开盘＋触发值）时马上买入，或者价格低于下轨（开盘－触发值）时马上卖空。\\n10. 没有明确止损。这个系统是反转系统，也就是说，如果在价格超过（开盘＋触发值）时手头有空单，则平空开多。\\n11. 同理，如果在价格低于（开盘－触发值）时手上有多单，则平多",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "发值）时手头有空单，则平空开多。\\n11. 同理，如果在价格低于（开盘－触发值）时手上有多单，则平多开空。\\n12. 选用了SHFE的rb2010 在2020-02-07 15:00:00 到 2020-04-15 15:00:00' 进行回测。\\n13. 注意：\\n14. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\\n15. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交\\n16. \\\"\\\"\\\"\\n\\n\\n19. # 策略中必须有init方法\\n20. def init(context):\\n\\n22. # 设置要进行回测的合约（可以在掘金终端的仿真交易中查询标的代码）\\n23. context.symbol = 'SHFE.rb2010'  # 订阅&交易标的, 此处订阅的是上期所的螺纹钢 2010\\n\\n25. # 设置参数\\n26. context.N = 5\\n27. context.k1 = 0.2\\n28. context.k2 = 0.2\\n\\n30. # 获取当前时间\\n31. time = cont",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " context.k2 = 0.2\\n\\n30. # 获取当前时间\\n31. time = context.now.strftime('%H:%M:%S')\\n\\n33. # 如果策略执行时间点是交易时间段，则直接执行algo定义buy_line和sell_line，以防直接进入on_bar()导致context.buy_line和context.sell_line未定义\\n34. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\\n35. algo(context)\\n\\n37. # 如果是交易时间段，等到开盘时间确保进入algo()\\n38. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\\n39. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\\n\\n41. # 只需要最新价，所以只需要订阅一个, 如果用tick，次数太多，",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "1:00:00')\\n\\n41. # 只需要最新价，所以只需要订阅一个, 如果用tick，次数太多，用一分钟线代替\\n42. subscribe(symbols=context.symbol, frequency='60s', count = 1)\\n\\n\\n45. def algo(context):\\n46. # 取历史数据\\n47. data = history_n(symbol=context.symbol, frequency='1d', end_time=context.now,\\n48. fields='symbol,open,high,low,close', count=context.N + 1, df=True)\\n49. # 取开盘价\\n50. # 回测模式下，开盘价可以直接用history_n取到\\n51. if context.mode == 2:\\n52. # 获取当天的开盘价\\n53. current_open = data['open'].loc[context.N]\\n54. # 去掉当天的实时数据\\n55. data.drop(context.N, inplace = Tr",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "# 去掉当天的实时数据\\n55. data.drop(context.N, inplace = True)\\n56. # 如果是实时模式，开盘价需要用current取到\\n57. else:\\n58. # 获取当天的开盘价\\n59. current_open = current(context.symbol)[0]['open']\\n\\n61. # 计算Dual Thrust 的上下轨\\n62. HH = data['high'].max()\\n63. HC = data['close'].max()\\n64. LC = data['close'].min()\\n65. LL = data['low'].min()\\n66. range = max(HH - LC, HC - LL)\\n67. context.buy_line = current_open + range * context.k1  # 上轨\\n68. context.sell_line = current_open - range * context.k2  # 下轨\\n\\n\\n71. def on_bar(context, bars):\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "text.k2  # 下轨\\n\\n\\n71. def on_bar(context, bars):\\n72. # 取出订阅的这一分钟的bar\\n73. bar = bars[0]\\n74. # 取出买卖线\\n75. buy_line =  context.buy_line\\n76. sell_line = context.sell_line\\n\\n78. # 获取现有持仓\\n79. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\\n80. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\\n\\n82. # 交易逻辑部分\\n83. # 如果超过range的上界\\n84. if bar.close > buy_line:\\n85. if position_long:  # 已经持有多仓，直接返回\\n86. return\\n87. elif positi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_long:  # 已经持有多仓，直接返回\\n86. return\\n87. elif position_short:  # 已经持有空仓，平仓再做多。\\n88. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\\n89. order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n90. print('市价单平空仓', context.symbol)\\n91. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\\n92. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n93. print('市价单开多仓', context.symbol)\\n94. else:  # 没有持仓时，市价开多。\\n95. order_volume(symbol=context.symbol, volume=1,",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n95. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\\n96. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n97. print('市价单开多仓', context.symbol)\\n98. # 如果低于range的下界\\n99. elif bar.close < sell_line:\\n100. if position_long:  # 已经持有多仓， 平多再开空。\\n101. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\\n102. order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n103. print('市价单平多仓', context.symbol)\\n104. order_volume(symbol=context.symbol, volume=1, si",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ". order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\\n105. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n106. print('市价单开空仓', context.symbol)\\n107. elif position_short:  # 已经持有空仓，直接返回。\\n108. return\\n109. else:  # 没有持仓，直接开空\\n110. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\\n111. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n112. print('市价单开空仓', context.symbol)\\n\\n\\n115. if __name__ == '__main__':\\n116. '''\\n117. 策略ID,由系统生成\\n118.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "__ == '__main__':\\n116. '''\\n117. 策略ID,由系统生成\\n118. filename文件名,请与本文件名保持一致\\n119. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n120. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n121. backtest_start_time回测开始时间\\n122. backtest_end_time回测结束时间\\n123. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n124. backtest_initial_cash回测初始资金\\n125. backtest_commission_ratio回测佣金比例\\n126. backtest_slippage_ratio回测滑点比例\\n127. '''\\n128. run(='',\\n129. filename='main.py',\\n130. mode=MODE_BACKTEST,\\n131. token='token_id',\\n132. backtest_s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "BACKTEST,\\n131. token='token_id',\\n132. backtest_start_time='2020-02-07 15:00:00',\\n133. backtest_end_time='2020-04-15 15:00:00',\\n134. backtest_initial_cash= 30000,\\n135. backtest_commission_ratio=0.0001,\\n136. backtest_slippage_ratio=0.0001)\",\n    \"# Dual Thrust(期货)\\n\\n分享\\n\\n阅读 72976\\n 更新 2022-05-09 16:56:48\\n\\n* [Dual Thrust](#b48a0f5838e23bf3)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n  + [2. 策略逻辑](#fdd18c620885abac)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# Dual Thrust\\n\\n##",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "果与稳健性分析](#3e2df45effccee1c)\\n\\n# Dual Thrust\\n\\n## 1. 原理\\n\\n由Michael Chalek在20世纪80年代开发的Dual Thrust策略是一个趋势跟踪策略。\\n\\n其核心思想是定义一个区间，区间的上界和下界分别为支撑线和阻力线。当价格超过上界时，如果持有空仓，先平再开多；如果没有仓位，直接开多。当价格跌破下界时，如果持有多仓，则先平仓，再开空仓；如果没有仓位，直接开空仓。\\n\\n上下界的设定是交易策略的核心部分。在计算上下界时共用到：最高价、最低价、收盘价、开盘价四个参数。\\n\\n公式如下：\\n\\n **Range = Max(HH-LC,HC-LL)** \\n\\n上限：Open + K1  *Range  \\n下限：Open + k2*  Range\\n\\nK1 和 K2一般根据自己经验以及回测结果进行优化。\\n\\n## 2. 策略逻辑\\n\\n第一步：设置参数N、k1、k2  \\n第二步：计算HH、LC、HC、LL  \\n第三步：计算range  \\n第四步：设定做多和做空信号\\n\\n回测标的：SHFE.rb2010  \\n回测期：2020-0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n第四步：设定做多和做空信号\\n\\n回测标的：SHFE.rb2010  \\n回测期：2020-02-07 15:00:00 到 2020-04-15 15:00:00  \\n回测初始资金：3万\\n\\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_134\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import\\n3. import pandas as pd\\n4. from gm.api import *\\n5. from datetime import datetime, timedelta\\n\\n\\n8. \\\"\\\"\\\"\\n9. R-Breaker是一种短线日内交易策略\\n10. 根据前一个交易日的收盘价、最高价和最低价数据通过一定方式计算出六个价位，从大到小依次为：\\n11. 突破买入价、观察卖出价、反转卖出价、反转买入、观察买入价、突破卖出价。以此来形成当前交易\\n12. 日盘中交易的触发条件。\\n13. ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "、反转买入、观察买入价、突破卖出价。以此来形成当前交易\\n12. 日盘中交易的触发条件。\\n13. 追踪盘中价格走势，实时判断触发条件。具体条件如下：\\n14. 突破\\n15. 在空仓条件下，如果盘中价格超过突破买入价，则采取趋势策略，即在该点位开仓做多。\\n16. 在空仓条件下，如果盘中价格跌破突破卖出价，则采取趋势策略，即在该点位开仓做空。\\n17. 反转\\n18. 持多单，当日内最高价超过观察卖出价后，盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，采取反转策略，即在该点位反手做空。\\n19. 持空单，当日内最低价低于观察买入价后，盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，采取反转策略，即在该点位反手做多。\\n20. 设定止损条件。当亏损达到设定值后，平仓。\\n\\n22. 注意：\\n23. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\\n24. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\\n25. 3：本策略使用在15点收盘时全平的方式来处理不持有隔夜单的情况，实际使用中15点是无法平仓",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n25. 3：本策略使用在15点收盘时全平的方式来处理不持有隔夜单的情况，实际使用中15点是无法平仓的。\\n26. \\\"\\\"\\\"\\n\\n\\n29. def init(context):\\n30. # 设置交易品种\\n31. context.symbol = 'SHFE.ag'\\n32. # 设置止损点数\\n33. context.stopLossPrice = 50\\n\\n35. # 获取前一交易日的主力合约\\n36. startDate = get_previous_trading_date(exchange='SHFE', date=context.now.date())\\n37. continuous_contract = get_continuous_contracts(context.symbol, startDate, startDate)\\n38. context.mainContract = continuous_contract[0]['symbol']\\n\\n40. # 获取当前时间\\n41. time = context.now.strftime('%H:%M:%S')\\n\\n43. #",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ". time = context.now.strftime('%H:%M:%S')\\n\\n43. # 如果当前时间是非交易时间段，则直接执行algo,以防直接进入on_bar()导致context.bBreak等未定义\\n44. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\\n45. algo(context)\\n\\n47. # 如果是交易时间段，等到开盘时间确保进入algo()\\n48. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\\n49. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00:00')\\n\\n51. # 订阅行情\\n52. subscribe(continuous_contract[0]['symbol'], frequency='60s', count=1)\\n\\n\\n55. def algo(context):\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ency='60s', count=1)\\n\\n\\n55. def algo(context):\\n56. # 检查主力和约，发生变化则更换订阅\\n57. # 由于主力合约在盘后才公布，为了防止未来函数，选择上一交易日的主力合约。\\n58. startDate = get_previous_trading_date(exchange='SHFE', date=context.now.date())\\n59. contractInfo = get_continuous_contracts(context.symbol, startDate, startDate)\\n60. if context.mainContract != contractInfo[0]['symbol']:\\n61. context.mainContract = contractInfo[0]['symbol']\\n62. subscribe(context.mainContract, frequency='60s', count=1, unsubscribe_previous=True)\\n\\n64. # 获取历史数据\\n65. data",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "subscribe_previous=True)\\n\\n64. # 获取历史数据\\n65. data = history_n(symbol=context.mainContract, frequency='1d',\\n66. end_time=context.now, fields='high,low,open,symbol,close', count=2, df=True)\\n67. high = data['high'].iloc[0]  # 前一日的最高价\\n68. low = data['low'].iloc[0]  # 前一日的最低价\\n69. close = data['close'].iloc[0]  # 前一日的收盘价\\n70. pivot = (high + low + close) / 3  # 枢轴点\\n71. context.bBreak = high + 2 * (pivot - low)  # 突破买入价\\n72. context.sSetup = pivot + (high - low)  # 观察卖出价\\n73. context.sEnter = 2 * pivot - low",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ow)  # 观察卖出价\\n73. context.sEnter = 2 * pivot - low  # 反转卖出价\\n74. context.bEnter = 2 * pivot - high  # 反转买入价\\n75. context.bSetup = pivot - (high - low)  # 观察买入价\\n76. context.sBreak = low - 2 * (high - pivot)  # 突破卖出价\\n77. context.data = data\\n\\n\\n80. def on_bar(context, bars):\\n\\n82. # 获取止损价\\n83. STOP_LOSS_PRICE = context.stopLossPrice\\n\\n85. # 设置参数\\n86. bBreak = context.bBreak\\n87. sSetup = context.sSetup\\n88. sEnter = context.sEnter\\n89. bEnter = context.bEnter\\n90. bSetup = context.bSetup\\n91. sBreak = co",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "nter\\n90. bSetup = context.bSetup\\n91. sBreak = context.sBreak\\n92. data = context.data\\n\\n94. # 获取现有持仓\\n95. position_long = context.account().position(symbol=context.mainContract, side=PositionSide_Long)\\n96. position_short = context.account().position(symbol=context.mainContract, side=PositionSide_Short)\\n\\n98. # 突破策略:\\n99. if not position_long and not position_short:  # 空仓条件下\\n100. if bars[0].close > bBreak:\\n101. # 在空仓的情况下，如果盘中价格超过突破买入价，则采取趋势策略，即在该点位开仓做多\\n102. order_volume(symbol=context.mainContract, v",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n102. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Buy,\\n103. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做多\\n104. print(\\\"空仓,盘中价格超过突破买入价: 开仓做多\\\")\\n105. context.open_position_price = bars[0].close\\n106. elif bars[0].close < sBreak:\\n107. # 在空仓的情况下，如果盘中价格跌破突破卖出价，则采取趋势策略，即在该点位开仓做空\\n108. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Sell,\\n109. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做空\\n110. print(\\\"空仓,盘中价格跌破突破",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sitionEffect_Open)  # 做空\\n110. print(\\\"空仓,盘中价格跌破突破卖出价: 开仓做空\\\")\\n111. context.open_position_price = bars[0].close\\n\\n113. # 设置止损条件\\n114. else:  # 有持仓时\\n115. # 开仓价与当前行情价之差大于止损点则止损\\n116. if (position_long and context.open_position_price - bars[0].close >= STOP_LOSS_PRICE) or \\\\\\n117. (position_short and bars[0].close - context.open_position_price >= STOP_LOSS_PRICE):\\n118. print('达到止损点，全部平仓')\\n119. order_close_all()  # 平仓\\n\\n121. # 反转策略:\\n122. if position_long:  # 多仓条件下\\n123. if data.high.iloc[1] > sSetup and ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  # 多仓条件下\\n123. if data.high.iloc[1] > sSetup and bars[0].close < sEnter:\\n124. # 多头持仓,当日内最高价超过观察卖出价后，\\n125. # 盘中价格出现回落，且进一步跌破反转卖出价构成的支撑线时，\\n126. # 采取反转策略，即在该点位反手做空\\n127. order_close_all()  # 平仓\\n128. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Sell,\\n129. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做空\\n130. print(\\\"多头持仓,当日内最高价超过观察卖出价后跌破反转卖出价: 反手做空\\\")\\n131. context.open_position_price = bars[0].close\\n132. elif position_short:  # 空头持仓\\n133. if data.low.iloc[1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f position_short:  # 空头持仓\\n133. if data.low.iloc[1] < bSetup and bars[0].close > bEnter:\\n134. # 空头持仓，当日内最低价低于观察买入价后，\\n135. # 盘中价格出现反弹，且进一步超过反转买入价构成的阻力线时，\\n136. # 采取反转策略，即在该点位反手做多\\n137. order_close_all()  # 平仓\\n138. order_volume(symbol=context.mainContract, volume=10, side=OrderSide_Buy,\\n139. order_type=OrderType_Market, position_effect=PositionEffect_Open)  # 做多\\n140. print(\\\"空头持仓,当日最低价低于观察买入价后超过反转买入价: 反手做多\\\")\\n141. context.open_position_price = bars[0].close\\n\\n143. if context.now.hour == 14 and context.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ose\\n\\n143. if context.now.hour == 14 and context.now.minute == 59:\\n144. order_close_all()\\n145. print('全部平仓')\\n\\n\\n148. if __name__ == '__main__':\\n149. run(='',\\n150. filename='main.py',\\n151. mode=MODE_BACKTEST,\\n152. token='token_id',\\n153. backtest_start_time='2019-10-1 15:00:00',\\n154. backtest_end_time='2020-04-16 15:00:00',\\n155. backtest_initial_cash=1000000,\\n156. backtest_commission_ratio=0.0001,\\n157. backtest_slippage_ratio=0.0001)\",\n    \"# R-Breaker(期货)\\n\\n分享\\n\\n阅读 62146\\n 更新 2022-05-09 16:56",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "reaker(期货)\\n\\n分享\\n\\n阅读 62146\\n 更新 2022-05-09 16:56:48\\n\\n* [R Breaker](#95e32de9cbc3c066)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [1.1 原理](#6a0fbf342f63eb77)\\n    - [1.2 触发条件](#cee22b7a4e233343)\\n    - [1.3 背后逻辑解析](#3984987f6bbb6f35)\\n  + [2、策略逻辑](#b8a3058d88bf3ad2)\\n  + [3、策略代码](#caba9bac1a6a5be2)\\n  + [4、回测结果与稳健性分析](#017ce2183a41051c)\\n\\n# R Breaker\\n\\n## 1. 原理\\n\\n### 1.1 原理\\n\\nR Breaker是一种日内回转交易策略，属于短线交易。日内回转交易是指当天买入或卖出标的后于当日再卖出或买入标的。日内回转交易通过标的短期波动盈利，低买高卖，时间短、投机性强，适合短线投资者。\\n\\nR Breaker主要分为分为反转和趋势两部分。空仓时进行",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "时间短、投机性强，适合短线投资者。\\n\\nR Breaker主要分为分为反转和趋势两部分。空仓时进行趋势跟随，持仓时等待反转信号反向开仓。\\n\\n由于我国A股采用的是“T+1”交易制度，为了方便起见，以期货为例演示R Breaker策略。\\n\\n反转和趋势突破的价位点根据前一交易日的收盘价、最高价和最低价数据计算得出，分别为：突破买入价、观察卖出价、反转卖出价、反转买入价、观察买入价和突破卖出价。计算方法如下：\\n\\n| 指标计算方法 |\\n| --- |\\n| 中心价位P = （H + C + L）/3 |\\n| 突破买入价 = H + 2P -2L |\\n| 观察卖出价 = P + H - L |\\n| 反转卖出价 = 2P - L |\\n| 反转买入价 = 2P - H |\\n| 观察买入价 = P - (H - L) |\\n| 突破卖出价 = L - 2(H - P) |\\n\\n### 1.2 触发条件\\n\\n空仓时：突破策略  \\n空仓时，当盘中价格>突破买入价，则认为上涨的趋势还会继续，开仓做多；  \\n空仓时，当盘中价格<突破卖出价，则认为下跌的趋势还会继续，开仓做空。\\n\\n持仓时：反转策略 ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " \\n空仓时，当盘中价格<突破卖出价，则认为下跌的趋势还会继续，开仓做空。\\n\\n持仓时：反转策略  \\n持多单时：当日内最高价>观察卖出价后，盘中价格回落，跌破反转卖出价构成的支撑线时，采取反转策略，即做空；  \\n持空单时：当日内最低价<观察买入价后，盘中价格反弹，超过反转买入价构成的阻力线时，采取反转策略，即做多。\\n\\n如下图所示：  \\n![](/uploads/202010/attach_16417be280731bd9.png)\\n\\n### 1.3 背后逻辑解析\\n\\n首先看一下这6个价格与前一日价格之间的关系。\\n\\n* 反转卖出价和反转买入价  \\n  根据公式推导，发现这两个价格和前一日最高最低价没有确定的大小关系。\\n* 观察卖出价和观察买入价。  \\n  用观察卖出价 - 前一交易日最高价发现，(H+P-L)-H = P - L >0,说明观察卖出价>前一交易日最高价；同理可证，观察买入价<前一交易日最低价。\\n* 突破买入价和突破卖出价  \\n  突破买入价>观察卖出价>前一交易日最高价，可以说明突破买入价>>前一交易日最高价。做差后可以发现，突破买入价 - 前一交易日最高价 = ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "高价，可以说明突破买入价>>前一交易日最高价。做差后可以发现，突破买入价 - 前一交易日最高价 = 2[(C-L)+(H-L)]/3。\\n\\n用K线形态表示：\\n\\n前一交易日K线越长，下影线越长，突破买入价越高。  \\n前一交易日K线越长，上影线越长，突破卖入价越高。  \\n这样一来就可以解释R Breaker背后的逻辑了。\\n\\n当今日的价格突破前一交易日的最高点，形态上来看会是上涨趋势，具备一定的开多仓条件，但还不够。若前一交易日的下影线越长，说明多空方博弈激烈，多方力量强大。因此可以设置更高的突破买入价，一旦突破说明多方力量稳稳地占据了上风，那么就有理由相信未来会继续上涨。同理可解释突破卖出价背后的逻辑。\\n\\n持有多仓时，若标的价格持续走高，则在当天收盘之前平仓获利离场。若价格不升反降，跌破观察卖出价时，此时价格仍处于前一交易日最高价之上，继续观望。若继续下跌，直到跌破反转卖出价时，平仓止损。\\n\\n持有空仓时，若标的价格持续走低，则在当天收盘之前平仓获利离场。若价格不降反升，升至观察买入价时，此时价格仍处于前一交易日最低价之下，继续观望。若继续上涨，直到升至反转买入价时，平仓止损。\\n\\n## 2",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "格仍处于前一交易日最低价之下，继续观望。若继续上涨，直到升至反转买入价时，平仓止损。\\n\\n## 2、策略逻辑\\n\\n第一步：根据收盘价、最高价和最低价数据计算六个价位。  \\n第二步：如果是空仓条件下，如果价格超过突破买入价，则开多仓；如果价格跌破突破卖出价，则开空仓。  \\n第三步：在持仓条件下:\\n\\n **持多单时，当最高价超过观察卖出价，盘中价格进一步跌破反转卖出价，反手做多；  \\n持空单时，当最低价低于观察买入价，盘中价格进一步超过反转买入价，反手做空。**  \\n第四步：接近收盘时，全部平仓。\\n\\n回测标的：SHFE.rb2010  \\n回测期：2019-10-1 15:00:00 到 2020-04-16 15:00:00  \\n回测初始资金：100万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n## 3、策略代码\\n\\n```\"\n \n\n    \"strategy_135\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import\\n3. from gm.api",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rt print_function, absolute_import\\n3. from gm.api import *\\n\\n\\n6. \\\"\\\"\\\"\\n7. 上轨=昨日最高点；\\n8. 下轨=昨日最低点；\\n9. 止损=今日开盘价;\\n10. 如果没有持仓，且现价大于了昨天最高价做多，小于昨天最低价做空。\\n11. 如果有多头持仓，当价格跌破了开盘价止损。\\n12. 如果有空头持仓，当价格上涨超过开盘价止损。\\n13. 选取 进行了回测。\\n14. 注意：\\n15. 1：为回测方便，本策略使用了on_bar的一分钟来计算，实盘中可能需要使用on_tick。\\n16. 2：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\\n17. \\\"\\\"\\\"\\n\\n\\n20. def init(context):\\n21. # 设置标的\\n22. context.symbol = 'SHFE.rb2010'\\n23. # 订阅一分钟线\\n24. subscribe(symbols = context.symbol,frequency = '60s',count = 1)\\n25. # ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ontext.symbol,frequency = '60s',count = 1)\\n25. # 记录开仓次数，保证一天只开仓一次\\n26. context.count = 0\\n27. # 记录当前时间\\n28. time = context.now.strftime('%H:%M:%S')\\n\\n30. # 如果当前时间点是交易时间段，则直接执行algo获取历史数据，以防直接进入on_bar()导致context.history_data未定义\\n31. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\\n32. algo(context)\\n\\n34. # 如果是非交易时间段，等到上午9点或晚上21点再执行algo()\\n35. schedule(schedule_func = algo, date_rule = '1d', time_rule = '09:00:00')\\n36. schedule(schedule_func = algo, date_rule = '1d', time_rule = '21:00",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_func = algo, date_rule = '1d', time_rule = '21:00:00')\\n\\n\\n39. def algo(context):\\n40. # 获取历史的n条信息\\n41. context.history_data = history_n(symbol=context.symbol, frequency = '1d', end_time = context.now,\\n42. fields='symbol,open,high,low',count=2, df=True)\\n\\n\\n45. def on_bar(context,bars):\\n46. # 取出订阅的一分钟bar\\n47. bar = bars[0]\\n48. # 提取数据\\n49. data = context.history_data\\n50. # 现有持仓情况\\n51. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\\n52. position_short = contex",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de=PositionSide_Long)\\n52. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\\n\\n54. # 如果是回测模式\\n55. if context.mode == 2:\\n56. # 开盘价直接在data最后一个数据里取到,前一交易日的最高和最低价为history_data里面的倒数第二条中取到\\n57. open = data.loc[1, 'open']\\n58. high = data.loc[0, 'high']\\n59. low = data.loc[0, 'low']\\n\\n61. # 如果是实时模式\\n62. else:\\n63. # 开盘价通过current取到\\n64. open = current(context.symbol)[0]['open']\\n65. # 实时模式不会返回当天的数据，所以history_data里面的最后一条数据是前一交易日的数据\\n66. high = data.loc[-1, 'high']\\n67. lo",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "是前一交易日的数据\\n66. high = data.loc[-1, 'high']\\n67. low = data.loc[-1, 'low']\\n\\n\\n70. # 交易逻辑部分\\n71. if position_long:  # 多头持仓小于开盘价止损。\\n72. if bar.close < open:\\n73. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\\n74. order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n75. print('以市价单平多仓')\\n76. elif position_short: # 空头持仓大于开盘价止损。\\n77. if bar.close > open:\\n78. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\\n79. order_type=OrderType_Market, position_effect=P",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "79. order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n80. print('以市价单平空仓')\\n\\n82. else:  # 没有持仓。\\n83. if bar.close > high and not context.count:  # 当前的最新价大于了前一天的最高价\\n84. # 开多\\n85. order_volume(symbol=context.symbol, volume=1, side=OrderSide_Buy,\\n86. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n87. print('以市价单开多仓')\\n88. context.count = 1\\n89. elif bar.close < low and not context.count:  # 当前最新价小于了前一天的最低价\\n90. # 开空\\n91. order_volume(symbol=context.symbol, volume=1, sid",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " order_volume(symbol=context.symbol, volume=1, side=OrderSide_Sell,\\n92. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n93. print('以市价单开空仓')\\n94. context.count = 1\\n\\n96. # 每天收盘前一分钟平仓\\n97. if context.now.hour == 14 and context.now.minute == 59:\\n98. order_close_all()\\n99. print('全部平仓')\\n100. context.count = 0\\n\\n\\n103. if __name__ == '__main__':\\n104. '''\\n105. 策略ID,由系统生成\\n106. filename文件名,请与本文件名保持一致\\n107. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n108. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n109. back",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "TEST\\n108. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n109. backtest_start_time回测开始时间\\n110. backtest_end_time回测结束时间\\n111. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n112. backtest_initial_cash回测初始资金\\n113. backtest_commission_ratio回测佣金比例\\n114. backtest_slippage_ratio回测滑点比例\\n115. '''\\n116. run(='',\\n117. filename='main.py',\\n118. mode=MODE_BACKTEST,\\n119. token='token_id',\\n120. backtest_start_time='2020-01-01 15:00:00',\\n121. backtest_end_time='2020-09-01 16:00:00',\\n122. backtest_adjust=ADJUST_PRE",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "-09-01 16:00:00',\\n122. backtest_adjust=ADJUST_PREV,\\n123. backtest_initial_cash=100000,\\n124. backtest_commission_ratio=0.0001,\\n125. backtest_slippage_ratio=0.0001)\",\n    \"# 菲阿里四价(期货)\\n\\n分享\\n\\n阅读 61350\\n 更新 2022-05-09 16:56:48\\n\\n* [菲阿里四价](#bd04006eb998c5e4)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n  + [2. 策略逻辑](#fdd18c620885abac)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 菲阿里四价\\n\\n## 1. 原理\\n\\n菲阿里四价同R Breaker一样，也是一种日内策略交易，适合短线投资者。\\n\\n菲阿里四价指的是：昨日高点、昨日低点、昨天收盘、今天开盘四个价格。\\n\\n菲阿里四价上下",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "者。\\n\\n菲阿里四价指的是：昨日高点、昨日低点、昨天收盘、今天开盘四个价格。\\n\\n菲阿里四价上下轨的计算非常简单。昨日高点为上轨，昨日低点为下轨。当价格突破上轨时，买入开仓；当价格突破下轨时，卖出开仓。\\n\\n## 2. 策略逻辑\\n\\n第一步：获取昨日最高价、最低价、收盘价、开盘价四个数据。  \\n第二步：计算上轨和下轨。当价格上穿上轨时，买入开仓；当价格下穿下轨时，卖出开仓。  \\n第三步：当日平仓。\\n\\n回测标的：SHFE.rb2010  \\n回测期：2020-02-07 至 2020-04-15  \\n回测初始资金：200万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_136\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. from gm.api import *\\n4. from datetime import timedelta\\n\\n\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "i import *\\n4. from datetime import timedelta\\n\\n\\n7. \\\"\\\"\\\"\\n8. 小市值策略\\n9. 本策略每个月触发一次，计算当前沪深市场上市值最小的前30只股票，并且等权重方式进行买入。\\n10. 对于不在前30的有持仓的股票直接平仓。\\n11. 回测时间为：2005-01-01 08:00:00 到 2020-10-01 16:00:00\\n12. \\\"\\\"\\\"\\n\\n\\n15. def init(context):\\n16. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\\n17. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\\n18. # 使用多少的资金来进行开仓。\\n19. context.ratio = 0.8\\n20. # 定义股票池数量\\n21. context.num = 30\\n22. # 通过get_instruments获取所有的上市股票代码\\n23. context.all_stock = get_instrum",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ts获取所有的上市股票代码\\n23. context.all_stock = get_instruments(exchanges='SHSE, SZSE', sec_types=[1], skip_suspended=False,\\n24. skip_st=False, fields='symbol, listed_date, delisted_date',\\n25. df=True)\\n\\n\\n28. def algo(context):\\n29. # 获取筛选时间：date1表示当前日期之前的100天，date2表示当前时间\\n30. date1 = (context.now - timedelta(days=100)).strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n31. date2 = context.now.strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n\\n33. # 上市不足100日的新股和退市股和B股\\n34. code = context.all_stock[(context.all_stock['listed_date'] < date1) & (co",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k[(context.all_stock['listed_date'] < date1) & (context.all_stock['delisted_date'] > date2) &\\n35. (context.all_stock['symbol'].str[5] != '9') & (context.all_stock['symbol'].str[5] != '2')]\\n36. # 剔除停牌和st股\\n37. df_code = get_history_instruments(symbols=code['symbol'].to_list(), start_date=date2, end_date=date2, df=True)\\n38. df_code = df_code[(df_code['is_suspended'] == 0) & (df_code['sec_level'] == 1)]\\n\\n40. # 获取所有股票市值\\n41. fundamental = get_fundamentals_n('trading_derivative_indicator', df_code['symbol']",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "('trading_derivative_indicator', df_code['symbol'].to_list(),\\n42. context.now, fields='TOTMKTCAP', order_by='TOTMKTCAP', count=1, df=True)\\n\\n44. # 对市值进行排序（升序），并且获取前30个。 最后将这个series 转化成为一个list即为标的池\\n45. trade_symbols = fundamental.reset_index(\\n46. drop=True).loc[:context.num - 1, 'symbol'].to_list()\\n47. print('本次股票池有股票数目: ', len(trade_symbols))\\n\\n49. # 计算每个个股应该在持仓中的权重\\n50. percent = 1.0 / len(trade_symbols) * context.ratio\\n\\n52. # 获取当前所有仓位\\n53. positions = context.account().positions()\\n\\n55. # 平不在标的池的",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s = context.account().positions()\\n\\n55. # 平不在标的池的仓位\\n56. for position in positions:\\n57. symbol = position['symbol']\\n58. if symbol not in trade_symbols:\\n59. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\\n60. position_side=PositionSide_Long)\\n61. print('市价单平不在标的池的', symbol)\\n\\n63. # 将标中已有持仓的和还没有持仓的都调整到计算出来的比例。\\n64. for symbol in trade_symbols:\\n65. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\\n66. position_side=PositionSide_Long)\\n67. prin",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t,\\n66. position_side=PositionSide_Long)\\n67. print(symbol, '以市价单调整至权重', percent)\\n\\n\\n70. if __name__ == '__main__':\\n71. '''\\n72. 策略ID,由系统生成\\n73. filename文件名,请与本文件名保持一致\\n74. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n75. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n76. backtest_start_time回测开始时间\\n77. backtest_end_time回测结束时间\\n78. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n79. backtest_initial_cash回测初始资金\\n80. backtest_commission_ratio回测佣金比例\\n81. backtest_slippage_ratio回测滑点比例\\n82. '''\\n83. run(='13a64e72",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_slippage_ratio回测滑点比例\\n82. '''\\n83. run(='13a64e72-e900-11eb-b05f-309c2322ba62',\\n84. filename='main.py',\\n85. mode=MODE_BACKTEST,\\n86. token='2b62e7651c9897d0cdd4a6cd818a7ba8488af710',\\n87. backtest_start_time='2005-01-01 08:00:00',\\n88. backtest_end_time='2020-10-01 16:00:00',\\n89. backtest_adjust=ADJUST_PREV,\\n90. backtest_initial_cash=1000000,\\n91. backtest_commission_ratio=0.0001,\\n92. backtest_slippage_ratio=0.0001)\",\n    \"# 小市值(股票)\\n\\n分享\\n\\n阅读 63504\\n 更新 2022-05-09 16:56:48\\n\\n* [小市值策略（股票）](#8a41beb7",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " 更新 2022-05-09 16:56:48\\n\\n* [小市值策略（股票）](#8a41beb7b7d129a3)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [1.1 因子投资](#2bb5d63b71d8bf05)\\n    - [1.2 规模因子](#b6a57aa95deebd34)\\n  + [2. 策略逻辑](#fdd18c620885abac)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果和稳健性分析](#e8b0a560bf110088)\\n\\n# 小市值策略（股票）\\n\\n（以下部分内容参考《因子投资：方法与实践》一书）\\n\\n## 1. 原理\\n\\n### 1.1 因子投资\\n\\n提到量化策略，总是绕不开因子投资。自CAPM模型提出以来，因子投资不断发展壮大，成为市场广泛关注的领域。市面上的策略很大一部分都是基于各种各样的因子创造的，因子在股票和债券市场上的应用也取得了不小的成就。\\n\\n**到底什么是因子投资?**\\n\\n20世纪60年代，资本资产定价模型（Capital Asset Pricing ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "子投资?**\\n\\n20世纪60年代，资本资产定价模型（Capital Asset Pricing Model）提出，揭示了资产的预期收益率（预期超额收益率）与风险之间的关系，第一次给出了资本资产定价的直观表达式。\\n\\n![](/uploads/202010/attach_16421d0004a68320.png)  \\n其中Rm表示市场预期收益率，β表示市场的风险暴露。\\n\\n该公式指出资产的预期超额收益率由资产对市场风险的暴露大小决定，也就是说，资产的超额预期收益率可以完全由**市场因子**解释。\\n\\n随着市场异象不断出现，人们发现资产的收益率并非只由市场因子决定，还受到其他因子的影响。1976年，Ross提出了无套利定价理论，构建了多因子定价模型，表达式为：  \\n![](/uploads/202010/attach_16421d095591da46.png)  \\n其中λ是因子预期收益率，β是对应的因子暴露，α表示误差项。\\n\\n该公式指出资产的预期收益率是由**一系列因子**及其因子暴露加上误差项决定的。而因子投资的目的就是寻找到能够解释资产收益率的因子。\\n\\n**既然资产预期收益率是由众多因",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "决定的。而因子投资的目的就是寻找到能够解释资产收益率的因子。\\n\\n**既然资产预期收益率是由众多因子决定的，什么是因子？怎么寻找因子？**\\n\\n根据《因子投资方法与实践》一书中的定义，“一个因子描述了众多资产共同暴露的某种系统性风险，该风险是资产收益率背后的驱动力，因子收益率正式这种系统性风险的风险溢价或风险补偿，它是这些资产的共性收益。”翻译过来就是，想要作为因子，必须能够解释多个资产的收益情况，并且能够带来正收益。\\n\\n再来看式2，可以发现，资产预期收益率是由两部分组成的，除了λ以外，还有一个α项，称之为误差项，表示资产预期收益率中λ无法解释的部分。α的出现可能有以下两个原因，一种是因为模型设定错误，右侧遗漏了重要的因子；一种是由于选用样本数据可能存在一定偏差，导致在该样本数据下出现了α项。\\n\\n为了确定α的出现是哪种原因，需要利用统计检验进行判断。\\n\\n**如果α显著为零，说明α的出现只是偶然，并不能说明定价模型存在错误；  \\n如果α显著为零，说明α的出现只是偶然，并不能说明定价模型存在错误；**\\n\\n如果α显著不为零，说明资产预期收益里尚存在定价模型未能完全解释的部分。这种情况，就成为*",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "**\\n\\n如果α显著不为零，说明资产预期收益里尚存在定价模型未能完全解释的部分。这种情况，就成为**异象**。  \\n因此，因子大体上可分为两种，一种是**定价因子**，也就是λ部分；一种是**异象因子**，也就是α部分。\\n\\n### 1.2 规模因子\\n\\n1981年Banz基于纽交所长达40年的数据发现，小市值股票月均收益率比其他股票高0.4%。其背后的原因可能是投资者普遍不愿意持有小公司股票，使得这些小公司价格普遍偏低，甚至低于成本价，因此会有较高的预期收益率。由此产生了小市值策略，即投资于市值较小的股票。市值因子也被纳入进大名鼎鼎的Fama三因子模型和五因子模型之中。\\n\\nA股市场上规模因子是否有效？研究发现，2016年以前，A股市场上规模因子的显著性甚至超过了欧美等发达国家市场。但到了2017-2018年期间，大市值股票的表现明显优于小市值股票，使得规模因子在A股市场上的有效性存疑。\\n\\n## 2. 策略逻辑\\n\\n第一步：确定调仓频率，以每月第一天调仓为例  \\n第二步：确定股票池股票数量，这里假设有30支  \\n第三步：调仓日当天获取前一个月的历史数据，并按照市值由小到大排序  \\n第四",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "这里假设有30支  \\n第三步：调仓日当天获取前一个月的历史数据，并按照市值由小到大排序  \\n第四步：买入前30支股票\\n\\n回测期：2005-01-01 到 2020-10-01  \\n股票池：所有A股股票  \\n回测初始资金：100万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_137\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import\\n3. from gm.api import *\\n\\n\\n6. \\\"\\\"\\\"\\n7. 本策略采用布林线进行均值回归交易。当价格触及布林线上轨的时候进行卖出，当触及下轨的时候，进行买入。\\n8. 使用600004在 2009-09-17 13:00:00 到 2020-03-21 15:00:00 进行了回测。\\n9. 注意：\\n10. 1：实盘中，如果在收盘的那一根bar或tick触发交易信号，需要自行处理，实盘可能不会成交。\\n11. \\\"\\\"\\\"\\n\\n13. # 策略中必须有init方法\\n14. def init",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "交。\\n11. \\\"\\\"\\\"\\n\\n13. # 策略中必须有init方法\\n14. def init(context):\\n15. # 设置布林线的三个参数\\n16. context.maPeriod = 26  # 计算BOLL布林线中轨的参数\\n17. context.stdPeriod = 26  # 计算BOLL 标准差的参数\\n18. context.stdRange = 1  # 计算BOLL 上下轨和中轨距离的参数\\n\\n20. # 设置要进行回测的合约\\n21. context.symbol = 'SHSE.600004'  # 订阅&交易标的, 此处订阅的是600004\\n22. context.period = max(context.maPeriod, context.stdPeriod, context.stdRange) + 1  # 订阅数据滑窗长度\\n\\n24. # 订阅行情\\n25. subscribe(symbols= context.symbol, frequency='1d', count=context.period)\\n\\n\\n28. def on_bar(conte",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "', count=context.period)\\n\\n\\n28. def on_bar(context, bars):\\n29. # 获取数据滑窗，只要在init里面有订阅，在这里就可以取的到，返回值是pandas.DataFrame\\n30. data = context.data(symbol=context.symbol, frequency='1d', count=context.period, fields='close')\\n\\n32. # 计算boll的上下界\\n33. bollUpper = data['close'].rolling(context.maPeriod).mean() \\\\\\n34. + context.stdRange * data['close'].rolling(context.stdPeriod).std()\\n35. bollBottom = data['close'].rolling(context.maPeriod).mean() \\\\\\n36. - context.stdRange * data['close'].rolling(context.stdPeri",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t.stdRange * data['close'].rolling(context.stdPeriod).std()\\n37. # 获取现有持仓\\n38. pos = context.account().position(symbol=context.symbol, side=PositionSide_Long)\\n\\n40. # 交易逻辑与下单\\n41. # 当有持仓，且股价穿过BOLL上界的时候卖出股票。\\n42. if data.close.values[-1] > bollUpper.values[-1] and data.close.values[-2] < bollUpper.values[-2]:\\n43. if pos:  # 有持仓就市价卖出股票。\\n44. order_volume(symbol=context.symbol, volume=100, side=OrderSide_Sell,\\n45. order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n46. print('以市价单卖出一手')\\n\\n4",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=PositionEffect_Close)\\n46. print('以市价单卖出一手')\\n\\n48. # 当没有持仓，且股价穿过BOLL下界的时候买出股票。\\n49. elif data.close.values[-1] < bollBottom.values[-1] and data.close.values[-2] > bollBottom.values[-2]:\\n50. if not pos:  # 没有持仓就买入一百股。\\n51. order_volume(symbol=context.symbol, volume=100, side=OrderSide_Buy,\\n52. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n53. print('以市价单买入一手')\\n\\n\\n56. if __name__ == '__main__':\\n57. '''\\n58. 策略ID,由系统生成\\n59. filename文件名,请与本文件名保持一致\\n60. mode实时模式:MODE_LIVE回测模式:MODE_BAC",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "件名,请与本文件名保持一致\\n60. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n61. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n62. backtest_start_time回测开始时间\\n63. backtest_end_time回测结束时间\\n64. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n65. backtest_initial_cash回测初始资金\\n66. backtest_commission_ratio回测佣金比例\\n67. backtest_slippage_ratio回测滑点比例\\n68. '''\\n69. run(='',\\n70. filename='main.py',\\n71. mode=MODE_BACKTEST,\\n72. token='token_id',\\n73. backtest_start_time='2009-09-17 13:00:00',\\n74. backtest_end_time='2020-03-21 15:00:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":00:00',\\n74. backtest_end_time='2020-03-21 15:00:00',\\n75. backtest_adjust=ADJUST_PREV,\\n76. backtest_initial_cash=1000,\\n77. backtest_commission_ratio=0.0001,\\n78. backtest_slippage_ratio=0.0001)\",\n    \"# 布林线均值回归(股票)\\n\\n分享\\n\\n阅读 69471\\n 更新 2022-05-09 16:56:48\\n\\n* [布林线均值回归策略](#b1b49dfea4506938)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 布林线均值回归策略\\n\\n## 1. 原理\\n\\n提起布林线均值回归策略，就不得不提布林带这个概念。布林带是利用统计学中的均值和标准差联合",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "原理\\n\\n提起布林线均值回归策略，就不得不提布林带这个概念。布林带是利用统计学中的均值和标准差联合计算得出的，分为均线，上轨线和下轨线。布林线均值回归策略认为，标的价格在上轨线和下轨线围成的范围内浮动，即使短期内突破上下轨，但长期内仍然会回归到布林带之中。因此，一旦突破上下轨，即形成买卖信号。\\n\\n当股价向上突破上界时，为卖出信号，当股价向下突破下界时，为买入信号。\\n\\nBOLL线的计算公式：\\n\\n中轨线 = N日移动平均线  \\n上轨线 = 中轨线 + k  *标准差  \\n下轨线 = 中轨线 - k*  标准差\\n\\n## 2. 策略思路\\n\\n第一步：根据数据计算BOLL线的上下界  \\n第二步：获得持仓信号  \\n第三步：回测分析\\n\\n回测标的：SHSE.600004  \\n回测期：2009-09-17 13:00:00 到 2020-03-21 15:00:00  \\n回测初始资金：1000元\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_138\",\n    \"1. # coding=utf-8\\n2. from __future__ import prin",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. from gm.api import *\\n\\n\\n6. '''\\n7. 本策略每隔1个月定时触发计算SHSE.000300成份股的过去一天EV/EBITDA值并选取30只EV/EBITDA值最小且大于零的股票\\n8. 对不在股票池的股票平仓并等权配置股票池的标的\\n9. 并用相应的CFFEX.IF对应的真实合约等额对冲\\n10. 回测数据为:SHSE.000300和他们的成份股和CFFEX.IF对应的真实合约\\n11. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\\n12. 注意：本策略仅供参考，实际使用中要考虑到期货和股票处于两个不同的账户，需要人为的保证两个账户的资金相同。\\n13. '''\\n\\n\\n16. def init(context):\\n17. # 每月第一个交易日09:40:00的定时执行algo任务（仿真和实盘时不支持该频率）\\n18. sche",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "月第一个交易日09:40:00的定时执行algo任务（仿真和实盘时不支持该频率）\\n18. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\\n19. # 设置开仓在股票和期货的资金百分比(期货在后面自动进行杠杆相关的调整)\\n20. context.percentage_stock = 0.4\\n21. context.percentage_futures = 0.4\\n\\n\\n24. def algo(context):\\n25. # 获取当前时刻\\n26. now = context.now\\n\\n28. # 获取上一个交易日\\n29. last_day = get_previous_trading_date(exchange='SHSE', date=now)\\n\\n31. # 获取沪深300成份股的股票代码\\n32. stock300 = get_history_constituents(index='SHSE.000300', start_date=last_day,\\n33. end_date=last_day)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "300', start_date=last_day,\\n33. end_date=last_day)[0]['constituents'].keys()\\n\\n35. # 获取上一个工作日的CFFEX.IF对应的合约\\n36. index_futures = get_continuous_contracts(csymbol='CFFEX.IF', start_date=last_day, end_date=last_day)[-1]['symbol']\\n\\n38. # 获取当天有交易的股票\\n39. not_suspended_info = get_history_instruments(symbols=stock300, start_date=now, end_date=now)\\n40. not_suspended_symbols = [item['symbol'] for item in not_suspended_info if not item['is_suspended']]\\n\\n42. # 获取成份股EV/EBITDA大于0并为最小的30个\\n43. fin = get_fundamenta",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "取成份股EV/EBITDA大于0并为最小的30个\\n43. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended_symbols,\\n44. start_date=now, end_date=now, fields='EVEBITDA',\\n45. filter='EVEBITDA>0', order_by='EVEBITDA', limit=30, df=True)\\n46. fin.index = fin.symbol\\n\\n48. # 获取当前仓位\\n49. positions = context.account().positions()\\n\\n51. # 平不在标的池或不为当前股指期货主力合约对应真实合约的标的\\n52. for position in positions:\\n53. symbol = position['symbol']\\n54. sec_type = get_instrumentinfos(symbols=symbol)[0]['sec_type']\\n\\n56. # ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mentinfos(symbols=symbol)[0]['sec_type']\\n\\n56. # 若类型为期货且不在标的池则平仓\\n57. if sec_type == SEC_TYPE_FUTURE and symbol != index_futures:\\n58. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\\n59. position_side=PositionSide_Short)\\n60. print('市价单平不在标的池的', symbol)\\n61. elif symbol not in fin.index:\\n62. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\\n63. position_side=PositionSide_Long)\\n64. print('市价单平不在标的池的', symbol)\\n\\n66. # 获取股票的权重\\n67. percent = context.p",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " symbol)\\n\\n66. # 获取股票的权重\\n67. percent = context.percentage_stock / len(fin.index)\\n\\n69. # 买在标的池中的股票\\n70. for symbol in fin.index:\\n71. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\\n72. position_side=PositionSide_Long)\\n73. print(symbol, '以市价单调多仓到仓位', percent)\\n\\n75. # 获取股指期货的保证金比率\\n76. ratio = get_history_instruments(symbols=index_futures, start_date=last_day, end_date=last_day)[0]['margin_ratio']\\n\\n78. # 更新股指期货的权重\\n79. percent = context.percentage_futures * ratio\\n\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ". percent = context.percentage_futures * ratio\\n\\n81. # 买入股指期货对冲\\n82. # 注意：股指期货的percent参数是按照期货的保证金来算比例，不是按照合约价值， 比如说0.1就是用0.1的仓位的资金全部买入期货。\\n83. order_target_percent(symbol=index_futures, percent=percent, order_type=OrderType_Market,\\n84. position_side=PositionSide_Short)\\n85. print(index_futures, '以市价单调空仓到仓位', percent)\\n\\n\\n88. if __name__ == '__main__':\\n89. '''\\n90. 策略ID,由系统生成\\n91. filename文件名,请与本文件名保持一致\\n92. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n93. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n94. backtest_start_time回测",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "绑定计算机的ID,可在系统设置-密钥管理中生成\\n94. backtest_start_time回测开始时间\\n95. backtest_end_time回测结束时间\\n96. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n97. backtest_initial_cash回测初始资金\\n98. backtest_commission_ratio回测佣金比例\\n99. backtest_slippage_ratio回测滑点比例\\n100. '''\\n101. run(='',\\n102. filename='main.py',\\n103. mode=MODE_BACKTEST,\\n104. token='token_id',\\n105. backtest_start_time='2017-07-01 08:00:00',\\n106. backtest_end_time='2017-10-01 16:00:00',\\n107. backtest_adjust=ADJUST_PREV,\\n108. backtest_init",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ". backtest_adjust=ADJUST_PREV,\\n108. backtest_initial_cash=10000000,\\n109. backtest_commission_ratio=0.0001,\\n110. backtest_slippage_ratio=0.0001)\",\n    \"# alpha对冲(股票+期货)\\n\\n分享\\n\\n阅读 143126\\n 更新 2022-05-09 16:56:48\\n\\n* [Alpha对冲策略](#d4f501d529728393)\\n  + [1. 策略原理](#c4a1bed1475f07da)\\n    - [何为alpha？](#f27fbfaa13560440)\\n    - [什么是alpha对冲策略？](#04a1252f01719cb4)\\n    - [怎么对冲？](#cec42677286aab15)\\n    - [策略收益情况](#28b65952cc2121da)\\n    - [策略要点](#32fbd110ec5d9a83)\\n  + [2. 策略实现](#90594d462f3ea350)\\n  + [3. 策略代",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "83)\\n  + [2. 策略实现](#90594d462f3ea350)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# Alpha对冲策略\\n\\n## 1. 策略原理\\n\\n### 何为alpha？\\n\\n提到Alpha策略，首先要理解什么是CAPM模型。\\n\\nCAPM模型于1964年被Willian Sharpe等人提出。Sharpe等人认为，假设市场是均衡的，资产的预期超额收益率就由市场收益超额收益和风险暴露决定的。如下式所示。  \\n![](/uploads/202010/attach_1642f606dd5564c6.png)  \\n其中rm为市场组合，rf为无风险收益率。\\n\\n根据CAPM模型可知，投资组合的预期收益由两部分组成，一部分为无风险收益率rf，另一部分为风险收益率。\\n\\nCAPM模型一经推出就受到了市场的追捧。但在应用过程中发现，CAPM模型表示的是在均衡状态下市场的情况，但市场并不总是处于均衡状态，个股总会获得超出市场基准水平的收益，即在CAPM模型的右端总是存在一个",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "，但市场并不总是处于均衡状态，个股总会获得超出市场基准水平的收益，即在CAPM模型的右端总是存在一个alpha项。\\n\\n为了解决这个问题，1968年，美国经济学家迈克·詹森（Michael Jensen）提出了詹森指数来描述这个alpha，因此又称alpha指数。计算方式如式2所示。  \\n![](/uploads/202010/attach_1642f609cc4ce9bf.png)  \\n因此，投资组合的收益可以改写成  \\n![](/uploads/202010/attach_1642f60c9ff81fb5.png)  \\n可将投资组合的收益拆分为alpha收益和beta收益。其中beta的计算公式为  \\n![](/uploads/202010/attach_1642f610efd39a5a.png)  \\nβ是由市场决定的，属于系统性风险，与投资者管理能力无关，只与投资组合与市场的关系有关。当市场整体下跌时，β对应的收益也会随着下跌（假设beta为正）。alpha收益与市场无关，是投资者自身能力的体现。投资者通过自身的经验进行选股择时，得到超过市场的收益。\\n\\n### 什么是alpha对冲策略",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "体现。投资者通过自身的经验进行选股择时，得到超过市场的收益。\\n\\n### 什么是alpha对冲策略？\\n\\n所谓的alpha对冲不是将alpha收益对冲掉，恰恰相反，alpha对冲策略是将β收益对冲掉，只获取alpha收益，如下图所示。\\n\\n![](/uploads/202010/attach_1642f61acc4df4ad.png)\\n\\nalpha对冲策略将市场性风险对冲掉，只剩下alpha收益，整体收益完全取决于投资者自身的能力水平，与市场无关。目前，有许多私募基金采用alpha对冲策略。\\n\\n### 怎么对冲？\\n\\nalpha对冲策略常采用股指期货做对冲。在股票市场上做多头，在期货市场上做股指期货空头。当股票现货市场亏损时，可以通过期货市场弥补亏损；当期货市场亏损时，可以通过股票现货市场弥补亏损。\\n\\n### 策略收益情况\\n\\n目前alpha对冲策略主要用于各类基金中。国际上比较知名的桥水基金、AQR基金等都采用过这种策略。国内也有许多利用alpha对冲策略的基金，比如海富通阿尔法对冲混合、华宝量化对冲混合等，近一年平均收益率约为36.70%。\\n\\n### 策略要点\\n\\nalpha策",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "、华宝量化对冲混合等，近一年平均收益率约为36.70%。\\n\\n### 策略要点\\n\\nalpha策略能否成功，主要包括以下几个要点\\n\\n* 获取到的alpha收益是否足够高，能否超过无风险利率以及指数.\\n* 期货和现货之间的基差变化.\\n* 期货合约的选择.\\n\\nalpha对冲只是一种对冲市场风险的方法，在创建策略时需要结合其他理论一起使用，怎样获取到较高的alpha收益才是决定策略整体收益的关键。\\n\\n## 2. 策略实现\\n\\n第一步：制定一个选股策略，构建投资组合，使其同时拥有alpha和beta收益。  \\n（本策略选取过去一天EV/EBITDA值并选取30只EV/EBITDA值最小且大于零的股票）  \\n第二步：做空股指期货，将投资组合的beta抵消，只剩alpha部分。  \\n第三步：进行回测。\\n\\n股票池：沪深300指数  \\n期货标的：CFFEX.IF对应的真实合约  \\n回测时间：2017-07-01 08:00:00 至 2017-10-01 16:00:00  \\n回测初始资金：1000万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_139\"",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "：1000万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_139\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import numpy as np\\n4. from gm.api import *\\n5. from pandas import DataFrame\\n6. '''\\n7. 本策略每隔1个月定时触发,根据Fama-French三因子模型对每只股票进行回归，得到其alpha值。\\n8. 假设Fama-French三因子模型可以完全解释市场，则alpha为负表明市场低估该股，因此应该买入。\\n9. 策略思路：\\n10. 计算市场收益率、个股的账面市值比和市值,并对后两个进行了分类,\\n11. 根据分类得到的组合分别计算其市值加权收益率、SMB和HML.\\n12. 对各个股票进行回归(假设无风险收益率等于0)得到alpha值.\\n13. 选取alpha值小于0并为最小的10只股票进入标的池\\n14. 平掉",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")得到alpha值.\\n13. 选取alpha值小于0并为最小的10只股票进入标的池\\n14. 平掉不在标的池的股票并等权买入在标的池的股票\\n15. 回测数据:SHSE.000300的成份股\\n16. 回测时间:2017-07-01 08:00:00到2017-10-01 16:00:00\\n17. '''\\n18. def init(context):\\n19. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\\n20. schedule(schedule_func=algo, date_rule='1m', time_rule='09:40:00')\\n21. # 数据滑窗\\n22. context.date = 20\\n23. # 设置开仓的最大资金量\\n24. context.ratio = 0.8\\n25. # 账面市值比的大/中/小分类\\n26. context.BM_BIG = 3.0\\n27. context.BM_MID = 2.0\\n28. context.BM_SMA = 1.0\\n29. # 市值大/小分类\\n30. context.MV_BIG =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ".BM_SMA = 1.0\\n29. # 市值大/小分类\\n30. context.MV_BIG = 2.0\\n31. context.MV_SMA = 1.0\\n\\n33. # 计算市值加权的收益率的函数,MV为市值的分类对应的组别,BM为账目市值比的分类对应的组别\\n34. def market_value_weighted(stocks, MV, BM):\\n35. select = stocks[(stocks['NEGOTIABLEMV'] == MV) & (stocks.['BM'] == BM)] # 选出市值为MV，账目市值比为BM的所有股票数据\\n36. market_value = select['mv'].values     # 对应组的全部市值数据\\n37. mv_total = np.sum(market_value)        # 市值求和\\n38. mv_weighted = [mv / mv_total for mv in market_value]   # 市值加权的权重\\n39. stock_return = select['return'].values\\n\\n4",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "重\\n39. stock_return = select['return'].values\\n\\n41. # 返回市值加权的收益率的和\\n42. return_total = []\\n43. for i in range(len(mv_weighted)):\\n44. return_total.append(mv_weighted[i] * stock_return[i])\\n45. return_total = np.sum(return_total)\\n46. return return_total\\n\\n48. def algo(context):\\n49. # 获取上一个交易日的日期\\n50. last_day = get_previous_trading_date(exchange='SHSE', date=context.now)\\n51. # 获取沪深300成份股\\n52. context.stock300 = get_history_constituents(index='SHSE.000300', start_date=last_day,\\n53. end_date=last_day)[0]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "', start_date=last_day,\\n53. end_date=last_day)[0]['constituents'].keys()\\n54. # 获取当天有交易的股票\\n55. not_suspended = get_history_instruments(symbols=context.stock300, start_date=last_day, end_date=last_day)\\n56. not_suspended = [item['symbol'] for item in not_suspended if not item['is_suspended']]\\n57. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended,\\n58. start_date=last_day, end_date=last_day,fields='PB,NEGOTIABLEMV', df=True)  # 获取P/B和市值数据\\n\\n60. # 计算账面市值比,为P/B的倒数\\n61. fin['",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  # 获取P/B和市值数据\\n\\n60. # 计算账面市值比,为P/B的倒数\\n61. fin['PB'] = (fin['PB'] ** -1)\\n62. # 计算市值的50%的分位点,用于后面的分类\\n63. size_gate = fin['NEGOTIABLEMV'].quantile(0.50)\\n64. # 计算账面市值比的30%和70%分位点,用于后面的分类\\n65. bm_gate = [fin['PB'].quantile(0.30), fin['PB'].quantile(0.70)]\\n66. fin.index = fin.symbol\\n67. # 设置存放股票收益率的list\\n68. x_return = []\\n\\n70. # 对未停牌的股票进行处理\\n71. for symbol in not_suspended:\\n72. # 计算收益率，存放到x_return里面\\n73. close = history_n(symbol=symbol, frequency='1d', count=context.date + 1, end_time=last_day, fields=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "count=context.date + 1, end_time=last_day, fields='close',\\n74. skip_suspended=True, fill_missing='Last', adjust=ADJUST_PREV, df=True)['close'].values\\n75. stock_return = close[-1] / close[0] - 1\\n76. pb = fin['PB'][symbol]\\n77. market_value = fin['NEGOTIABLEMV'][symbol]\\n78. # 获取[股票代码， 股票收益率, 账面市值比的分类, 市值的分类, 流通市值]\\n79. # 其中账面市值比的分类为：大（3）、中（2）、小（1）\\n80. # 流通市值的分类：大（2）、小（1）\\n81. if pb < bm_gate[0]:\\n82. if market_value < size_gate:\\n83. label = [symbol, stock_return, context.BM_SMA, context.MV_SMA, market_v",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "k_return, context.BM_SMA, context.MV_SMA, market_value]\\n84. else:\\n85. label = [symbol, stock_return, context.BM_SMA, context.MV_BIG, market_value]\\n86. elif pb < bm_gate[1]:\\n87. if market_value < size_gate:\\n88. label = [symbol, stock_return, context.BM_MID, context.MV_SMA, market_value]\\n89. else:\\n90. label = [symbol, stock_return, context.BM_MID, context.MV_BIG, market_value]\\n91. elif market_value < size_gate:\\n92. label = [symbol, stock_return, context.BM_BIG, context.MV_SMA, market_value]\\n93. else",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xt.BM_BIG, context.MV_SMA, market_value]\\n93. else:\\n94. label = [symbol, stock_return, context.BM_BIG, context.MV_BIG, market_value]\\n95. if len(x_return) == 0:\\n96. x_return = label\\n97. else:\\n98. x_return = np.vstack([x_return, label])\\n\\n100. # 将股票代码、 股票收益率、 账面市值比的分类、 市值的分类、 流通市值存为数据表\\n101. stocks = DataFrame(data=x_return, columns=['symbol', 'return', 'BM', 'NEGOTIABLEMV', 'mv'])\\n102. stocks.index = stocks.symbol\\n103. columns = ['return', 'BM', 'NEGOTIABLEMV', 'mv']\\n104. for column in columns:\\n105",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "TIABLEMV', 'mv']\\n104. for column in columns:\\n105. stocks[column] = stocks[column].astype(np.float64)\\n\\n107. # 计算SMB.HML和市场收益率（市值加权法）\\n108. smb_s = (market_value_weighted(stocks, context.MV_SMA, context.BM_SMA) +\\n109. market_value_weighted(stocks, context.MV_SMA, context.BM_MID) +\\n110. market_value_weighted(stocks, context.MV_SMA, context.BM_BIG)) / 3\\n\\n112. # 获取大市值组合的市值加权组合收益率\\n113. smb_b = (market_value_weighted(stocks, context.MV_BIG, context.BM_SMA) +\\n114. market_value_weighted(stocks, context.MV_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " +\\n114. market_value_weighted(stocks, context.MV_BIG, context.BM_MID) +\\n115. market_value_weighted(stocks, context.MV_BIG, context.BM_BIG)) / 3\\n116. smb = smb_s - smb_b\\n\\n118. # 获取大账面市值比组合的市值加权组合收益率\\n119. hml_b = (market_value_weighted(stocks, context.MV_SMA, 3) +\\n120. market_value_weighted(stocks, context.MV_BIG, context.BM_BIG)) / 2\\n\\n122. # 获取小账面市值比组合的市值加权组合收益率\\n123. hml_s = (market_value_weighted(stocks, context.MV_SMA, context.BM_SMA) +\\n124. market_value_weighted(stocks, context.MV_BIG, context.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "et_value_weighted(stocks, context.MV_BIG, context.BM_SMA)) / 2\\n125. hml = hml_b - hml_s\\n\\n127. # 获取市场收益率\\n128. close = history_n(symbol='SHSE.000300', frequency='1d', count=context.date + 1,\\n129. end_time=last_day, fields='close', skip_suspended=True,\\n130. fill_missing='Last', adjust=ADJUST_PREV, df=True)['close'].values\\n131. market_return = close[-1] / close[0] - 1\\n132. coff_pool = []\\n\\n134. # 对每只股票进行回归获取其alpha值\\n135. for stock in stocks.index:\\n136. x_value = np.array([[market_return], [smb], [hml]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " x_value = np.array([[market_return], [smb], [hml], [1.0]])\\n137. y_value = np.array([stocks['return'][stock]])\\n138. # OLS估计系数\\n139. coff = np.linalg.lstsq(x_value.T, y_value)[0][3]\\n140. coff_pool.append(coff)\\n\\n142. # 获取alpha最小并且小于0的10只的股票进行操作(若少于10只则全部买入)\\n143. stocks['alpha'] = coff_pool\\n144. stocks = stocks[stocks.alpha < 0].sort_values(by='alpha').head(10)\\n145. symbols_pool = stocks.index.tolist()\\n146. positions = context.account().positions()\\n\\n148. # 平不在标的池的股票\\n149. for position in positions:\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "148. # 平不在标的池的股票\\n149. for position in positions:\\n150. symbol = position['symbol']\\n151. if symbol not in symbols_pool:\\n152. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\\n153. position_side=PositionSide_Long)\\n154. print('市价单平不在标的池的', symbol)\\n\\n156. # 获取股票的权重\\n157. percent = context.ratio / len(symbols_pool)\\n\\n159. # 买在标的池中的股票\\n160. for symbol in symbols_pool:\\n161. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\\n162. position_side=Positi",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "_type=OrderType_Market,\\n162. position_side=PositionSide_Long)\\n163. print(symbol, '以市价单调多仓到仓位', percent)\\n\\n165. if __name__ == '__main__':\\n166. '''\\n167. 策略ID,由系统生成\\n168. filename文件名,请与本文件名保持一致\\n169. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n170. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n171. backtest_start_time回测开始时间\\n172. backtest_end_time回测结束时间\\n173. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n174. backtest_initial_cash回测初始资金\\n175. backtest_commission_ratio回测佣金比例\\n176. backtest_slippage_ratio回",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "mission_ratio回测佣金比例\\n176. backtest_slippage_ratio回测滑点比例\\n177. '''\\n178. run(='',\\n179. filename='main.py',\\n180. mode=MODE_BACKTEST,\\n181. token='token_id',\\n182. backtest_start_time='2017-07-01 08:00:00',\\n183. backtest_end_time='2017-10-01 16:00:00',\\n184. backtest_adjust=ADJUST_PREV,\\n185. backtest_initial_cash=10000000,\\n186. backtest_commission_ratio=0.0001,\\n187. backtest_slippage_ratio=0.0001)\",\n    \"# 多因子选股(股票)\\n\\n分享\\n\\n阅读 187817\\n 更新 2022-05-09 16:56:48\\n\\n* [多因子策略](#9999705c4a097b93)\\n  + [1. 原理](",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "6:48\\n\\n* [多因子策略](#9999705c4a097b93)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [Fama-French三因子模型](#f2fdebfcb64333d9)\\n    - [策略设计思路（假设三因子模型是完全有效的）](#713a39754db63f0b)\\n  + [2. 策略步骤](#c306d1ad1c8a5699)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性检验](#8fb635bf3a219945)\\n\\n# 多因子策略\\n\\n（注：以下部分内容引用自《因子投资：方法与实践》一书）\\n\\n## 1. 原理\\n\\n多因子策略是最广泛应用的策略之一。CAPM模型的提出为股票的收益提供了解释，但随着各种市场异象的出现，使得人们发现股票存在超额收益，这种收益不能为市场因子所解释，因此，出现了多因子模型。\\n\\n多因子模型最早是由Fama-French提出，包括三因子和五因子模型。Fama认为，股票的超额收益可以由市场因子、市值因子和账面价值比因子共同解释。随着市场的发展，出现许多",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ama认为，股票的超额收益可以由市场因子、市值因子和账面价值比因子共同解释。随着市场的发展，出现许多三因子模型难以解释的现象。因此，Fama又提出了五因子模型，加入了盈利水平、投资水平因子。\\n\\n此后，陆续出现了六因子模型、八因子模型等，目前多少个因子是合适的尚无定论。\\n\\n市场上常用的多因子模型包括如下几个。\\n\\n| 模型 | 出处 | 所含因子 |\\n| --- | --- | --- |\\n| Fama-French三因子 | Fama and Farench(1993) | 市场、规模、价值 |\\n| Carhart四因子 | Carhart（1997） | 市场、规模、价值、动量 |\\n| Novy-Marx四因子 | Novy-Marx（2013） | 市场、规模、价值、盈利 |\\n| Fama-French五因子 | Fama and Farench(2015) | 市场、规模、价值、盈利、投资 |\\n| Hou-Xue-Zhang四因子 | Hou et al | 市场、规模、盈利、投资 |\\n| Stambaugh-Yuan四因子 | Stambaugh and Yuan(2017) ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "|\\n| Stambaugh-Yuan四因子 | Stambaugh and Yuan(2017) | 市场、规模、管理、表现 |\\n| Daniel-Hirshleifer-Sun三因子 | Daniel et al（2020） | 市场、长周期行为、短周期行为 |\\n\\n本策略以Fama提出的三因子模型作为基础。\\n\\n### Fama-French三因子模型\\n\\n在多因子模型出现以前，CAPM模型被奉为典型，几乎所有定价均是按照CAPM模型计算的。后来学者们发现了各种异象，这些异象无法用CAPM模型解释。较为典型的有Basu发现的盈利市值比效应和Banz发现的小市值效应。遗憾的是，虽然单一异象被发现后都对CAPM提出了挑战，但并没有形成合力，直到Fama三因子模型出现。\\n\\nFama等人在CAPM的基础上，Fama加入了HML和SMB两个因子，提出了三因子模型，也是多因子模型的基础。\\n\\n![](/uploads/202011/attach_1646221cab7ec002.png)  \\n其中E[R\\\\_i]代表股票i的预期收益率，R\\\\_f代表无风险收益率，E[R\\\\_m]为市场组合预期收益率",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "R\\\\_i]代表股票i的预期收益率，R\\\\_f代表无风险收益率，E[R\\\\_m]为市场组合预期收益率，E[R\\\\_SMB]和E[R\\\\_HML]分别为规模因子收益率和价值因子预期收益率。  \\n  \\n为构建价值因子和规模因子，Fama选择BM和市值两个指标进行双重排序，将股票分为大市值组B和小市值组S；按照账面市值比将股票分为BM高于70%分位数的H组，BM低于30%分位数的L组，BM处于二者之间的记为M组。如表所示。  \\n![](/uploads/202011/attach_1646223b74c77c26.png)  \\n得到上述分组以后，就可以构建规模和价值两个因子。  \\n![](/uploads/202011/attach_16462244e23ef82a.png)\\n\\n上述式子解释一下可以发现，规模因子是三个小市值组合的等权平均减去三个大市值组合的等权平均；价值因子是两个高BM组合的等权平均减去两个低BM组合的等权平均。\\n\\n### 策略设计思路（假设三因子模型是完全有效的）\\n\\n在用三因子模型估算股票预期收益率时，经常会发现并非每只股票都能严格吻合式1，大部分股票都会存在一个alpha",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "子模型估算股票预期收益率时，经常会发现并非每只股票都能严格吻合式1，大部分股票都会存在一个alpha截距项。当存在alpha截距项时，说明股票当前价格偏离均衡价格。基于此，可以设计套利策略。\\n\\nalpha < 0时，说明股票收益率低于均衡水平，股票价格被低估，应该买入。  \\nalpha > 0时，说明股票收益率高于均衡水平，股票价格被高估，应该卖出。\\n\\n因此，可以获取alpha最小并且小于0的10只的股票买入开仓。\\n\\n## 2. 策略步骤\\n\\n第一步：获取股票市值以及账面市值比数据。  \\n第二步：将股票按照各个因子进行排序分组，分组方法如上表所示。  \\n第三步：依据式2式3，计算SMB、HML因子。  \\n第四步：因子回归，计算alpha值。获取alpha最小并且小于0的10只的股票买入开仓。\\n\\n回测期：2017-07-01 8:00:00 至 2017-10-01 16:00:00  \\n回测初始资金：1000万  \\n回测标的：沪深300成分股\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_140\",\n    \"1. # coding=utf-8\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "`\"\n \n\n    \"strategy_140\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import numpy as np\\n4. import pandas as pd\\n5. from gm.api import *\\n\\n7. '''\\n8. 本策略标的为：SHFE.rb1901\\n9. 价格中枢设定为：前一交易日的收盘价\\n10. 从阻力位到压力位分别为：1.03 * open、1.02 * open、1.01 * open、open、0.99 * open、0.98 * open、0.97 * open\\n11. 每变动一个网格，交易量变化100个单位\\n12. 回测数据为:SHFE.rb1901的1min数据\\n13. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\\n14. '''\\n\\n\\n17. def init(context):\\n18. # 策略标的为SHFE.rb190",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n\\n17. def init(context):\\n18. # 策略标的为SHFE.rb1901\\n19. context.symbol = 'SHFE.rb1901'\\n20. # 订阅SHFE.rb1901, bar频率为1min\\n21. subscribe(symbols = context.symbol, frequency='60s')\\n22. # 设置每变动一格，增减的数量\\n23. context.volume = 1\\n24. # 储存前一个网格所处区间，用来和最新网格所处区间作比较\\n25. context.last_grid = 0\\n26. # 以前一日的收盘价为中枢价格\\n27. context.center = history_n(symbol= context.symbol,frequency='1d',end_time=context.now,count = 1,fields = 'close')[0]['close']\\n28. # 记录上一次交易时网格范围的变化情况（例如从4区到5区，记为4,5）\\n29. context.grid_change_last = [0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "例如从4区到5区，记为4,5）\\n29. context.grid_change_last = [0,0]\\n\\n\\n32. def on_bar(context, bars):\\n33. bar = bars[0]\\n34. # 获取多仓仓位\\n35. position_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\\n36. # 获取空仓仓位\\n37. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\\n\\n39. # 设置网格和当前价格所处的网格区域\\n40. context.band = np.array([0.97, 0.98, 0.99, 1, 1.01, 1.02, 1.03]) * context.center\\n41. grid = pd.cut([bar.close], context.band, labels=[1, 2, 3, 4, 5, 6",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bar.close], context.band, labels=[1, 2, 3, 4, 5, 6])[0]\\n\\n43. # 如果价格超出网格设置范围，则提示调节网格宽度和数量\\n44. if np.isnan(grid):\\n45. print('价格波动超过网格范围，可适当调节网格宽度和数量')\\n\\n47. # 如果新的价格所处网格区间和前一个价格所处的网格区间不同，说明触碰到了网格线，需要进行交易\\n48. # 如果新网格大于前一天的网格，做空或平多\\n49. if context.last_grid < grid:\\n50. # 记录新旧格子范围（按照大小排序）\\n51. grid_change_new = [context.last_grid,grid]\\n52. # 几种例外：\\n53. # 当last_grid = 0 时是初始阶段，不构成信号\\n54. # 如果此时grid = 3，说明当前价格仅在开盘价之下的3区域中，没有突破网格线\\n55. # 如果此时grid = 4，说明当前价格仅在开盘价之上的4区域中，没有突破网格线\\n56. if context.last_grid == 0",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "在开盘价之上的4区域中，没有突破网格线\\n56. if context.last_grid == 0:\\n57. context.last_grid = grid\\n58. return\\n59. if context.last_grid != 0:\\n60. # 如果前一次开仓是4-5，这一次是5-4，算是没有突破，不成交\\n61. if grid_change_new != context.grid_change_last:\\n62. # 更新前一次的数据\\n63. context.last_grid = grid\\n64. context.grid_change_last = grid_change_new\\n65. # 如果有多仓，平多\\n66. if position_long:\\n67. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Sell, order_type=OrderType_Market,\\n68. position_effect=PositionEffect_Close)\\n69. ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ",\\n68. position_effect=PositionEffect_Close)\\n69. print('以市价单平多仓{}手'.format(context.volume))\\n70. # 否则，做空\\n71. if not position_long:\\n72. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Sell, order_type=OrderType_Market,\\n73. position_effect=PositionEffect_Open)\\n74. print('以市价单开空{}手'.format(context.volume))\\n\\n76. # 如果新网格小于前一天的网格，做多或平空\\n77. if context.last_grid > grid:\\n78. # 记录新旧格子范围（按照大小排序）\\n79. grid_change_new = [grid,context.last_grid]\\n80. # 几种例外：\\n81. # 当last_grid = 0 时是初始阶段",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "st_grid]\\n80. # 几种例外：\\n81. # 当last_grid = 0 时是初始阶段，不构成信号\\n82. # 如果此时grid = 3，说明当前价格仅在开盘价之下的3区域中，没有突破网格线\\n83. # 如果此时grid = 4，说明当前价格仅在开盘价之上的4区域中，没有突破网格线\\n84. if context.last_grid == 0:\\n85. context.last_grid = grid\\n86. return\\n87. if context.last_grid != 0:\\n88. # 如果前一次开仓是4-5，这一次是5-4，算是没有突破，不成交\\n89. if grid_change_new != context.grid_change_last:\\n90. # 更新前一次的数据\\n91. context.last_grid = grid\\n92. context.grid_change_last = grid_change_new\\n93. # 如果有空仓，平空\\n94. if position_short:\\n95. order_volume(symbol=conte",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " if position_short:\\n95. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Buy,\\n96. order_type=OrderType_Market,\\n97. position_effect=PositionEffect_Close)\\n98. print('以市价单平空仓{}手'.format(context.volume))\\n\\n100. # 否则，做多\\n101. if not position_short:\\n102. order_volume(symbol=context.symbol, volume=context.volume, side=OrderSide_Buy,\\n103. order_type=OrderType_Market,\\n104. position_effect=PositionEffect_Open)\\n105. print('以市价单开多{}手'.format(context.volume))\\n\\n107. # 设计一个止损条件：当持仓量达到10",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ormat(context.volume))\\n\\n107. # 设计一个止损条件：当持仓量达到10手，全部平仓\\n108. if position_short == 10 or position_long == 10:\\n109. order_close_all()\\n110. print('触发止损，全部平仓')\\n\\n\\n113. if __name__ == '__main__':\\n114. '''\\n115. 策略ID,由系统生成\\n116. filename文件名,请与本文件名保持一致\\n117. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n118. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n119. backtest_start_time回测开始时间\\n120. backtest_end_time回测结束时间\\n121. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n122. backtest_initial_cash回测初始资金\\n123. backte",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "OST\\n122. backtest_initial_cash回测初始资金\\n123. backtest_commission_ratio回测佣金比例\\n124. backtest_slippage_ratio回测滑点比例\\n125. '''\\n126. run(='',\\n127. filename='main.py',\\n128. mode=MODE_BACKTEST,\\n129. token='token_id',\\n130. backtest_start_time='2018-07-01 08:00:00',\\n131. backtest_end_time='2018-10-01 16:00:00',\\n132. backtest_adjust=ADJUST_PREV,\\n133. backtest_initial_cash=100000,\\n134. backtest_commission_ratio=0.0001,\\n135. backtest_slippage_ratio=0.0001)\",\n    \"# 网格交易(期货)\\n\\n分享\\n\\n阅读 174440\\n 更新 2022-05-09 1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "  \"# 网格交易(期货)\\n\\n分享\\n\\n阅读 174440\\n 更新 2022-05-09 16:56:48\\n\\n* [网格交易法（期货）](#a3a8216fc187c669)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [什么是网格交易法？](#0826fd0b2e938ab7)\\n    - [怎样设计网格？](#148bf6919cad712c)\\n    - [网格交易法的盈利情况](#e9beafd820a1ba4a)\\n    - [核心](#67477ceb50f7c2e9)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n    - [策略难点：](#4a606bba6ea7c206)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果和稳健性分析](#e8b0a560bf110088)\\n\\n# 网格交易法（期货）\\n\\n## 1. 原理\\n\\n### 什么是网格交易法？\\n\\n网格交易法是一种利用行情震荡进行获利的策略。在标的价格不断震荡的过程中，对标的价格绘制网格，在市场价格触碰",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "易法是一种利用行情震荡进行获利的策略。在标的价格不断震荡的过程中，对标的价格绘制网格，在市场价格触碰到某个网格线时进行加减仓操作尽可能获利。\\n\\n网格交易法属于左侧交易的一种。与右侧交易不同，网格交易法并非跟随行情，追涨杀跌，而是逆势而为，在价格下跌时买入，价格上涨时卖出。\\n\\n### 怎样设计网格？\\n\\n投资者可以随意设置网格的宽度和数量。既可以设置为等宽度，也可以设置为不等宽度的。设置等宽度网格可能会导致买点卖点过早，收益率较低。设置不等宽度网格能够避免这个问题，但如果行情出现不利变动，可能会错失买卖机会。\\n\\n### 网格交易法的盈利情况\\n\\n***在行情震荡上涨时：***  \\n![](/uploads/202010/attach_1642640f8e2ec613.png)\\n\\n假设格子之间的差为1元钱，每变化一个格子相应的买入或卖出1手，则通过网格交易当前账户的净收益为6元，持空仓4手，持仓均价为12.5元。\\n\\n***行情震荡下跌时：***  \\n![](/uploads/202010/attach_164264143d608515.png)\\n\\n同理可知，净收益为8元，持4手多仓",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "/attach_164264143d608515.png)\\n\\n同理可知，净收益为8元，持4手多仓，平均成本为7.5元。\\n\\n可以看到，无论行情上涨还是下跌，已平仓的部分均为正收益，未平仓的部分需要等下一个信号出现再触发交易。\\n\\n即使网格交易能够获得较为稳定的收益，但也存在一定的风险。如果行情呈现大涨或大跌趋势，会导致不断开仓，增加风险敞口。这也是为什么网格交易更适用震荡行情，不合适趋势性行情。\\n\\n### 核心\\n\\n网格交易主要包括以下几个核心要点：\\n\\n**- 挑选的标的最好是价格变化较大，交易较为活跃**  \\n网格交易是基于行情震荡进行获利的策略，如果标的不活跃，价格波动不大，很难触发交易。  \\n**- 选出网格的压力位和阻力位**  \\n确定适当的压力位和阻力位，使价格大部分时间能够在压力位和阻力位之间波动。如果压力位和阻力位设置范围过大，会导致难以触发交易；如果压力位和阻力位设置范围过小，则会频繁触发交易。  \\n**- 设置网格的宽度和数量**  \\n设定多少个网格以及网格的宽度可根据投资者自身喜好自行确定。\\n\\n## 2. 策略思路\\n\\n第一步：确定价格中枢、压力位和阻力位",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "根据投资者自身喜好自行确定。\\n\\n## 2. 策略思路\\n\\n第一步：确定价格中枢、压力位和阻力位  \\n第二步：确定网格的数量和间隔  \\n第三步：当价格触碰到网格线时，若高于买入价，则每上升一格卖出m手；若低于买入价，则每下跌一格买入m手。\\n\\n回测标的：SHFE.rb1901  \\n回测时间：2018-07-01 到 2018-10-01  \\n回测初始资金：10万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n### 策略难点：\\n\\n* 怎样记录价格是否突破网格线？\\n\\n解决方法：有些人可能会想到用当前价格与网格线对应的价格进行比较，但这样操作比较麻烦，步骤繁琐。这里采用区域判断方式。根据网格线划分网格区域为1、2、3、4、5、6.利用pandas库提供的cut函数，将当前价格所处的网格区域表示出来。当网格区域发生变化，说明价格突破了一个网格线。\\n\\n* 如何避免出现4区-5区开仓一次,5区-4区又平仓一次这种“假突破”？\\n\\n解决方法：4-5开仓一次和5-4平仓一次实际上突破的是一根线，此时的形态是价格沿着这根线上下波动。只有第一次穿过这条线时才是真正的交易信号，其他",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "上突破的是一根线，此时的形态是价格沿着这根线上下波动。只有第一次穿过这条线时才是真正的交易信号，其他的并没有形成突破。因此我们需要一个变量储存每一次交易时网格区域的变化形态(按照从大到小的顺序)，比如5-4可以记为[4,5],4-5记为[4,5]。当新的记录=旧的记录时，信号失效。\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_141\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import numpy as np\\n4. from gm.api import *\\n5. from pandas import DataFrame\\n\\n\\n8. '''\\n9. 本策略以0.8为初始权重跟踪指数标的沪深300中权重大于0.35%的成份股.\\n10. 个股所占的百分比为(0.8*成份股权重)*100%.然后根据个股是否:\\n11. 1.连续上涨5天 2.连续下跌5天\\n12. 来判定个股是否为强势股/弱势股,并对其把",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":\\n11. 1.连续上涨5天 2.连续下跌5天\\n12. 来判定个股是否为强势股/弱势股,并对其把权重由0.8调至1.0或0.6\\n13. 回测时间为:2017-07-01 08:50:00到2017-10-01 17:00:00\\n14. '''\\n\\n\\n17. def init(context):\\n18. # 资产配置的初始权重,配比为0.6-0.8-1.0\\n19. context.ratio = 0.8\\n\\n21. # 获取沪深300当时的成份股和相关数据\\n22. stock300 = get_history_constituents(index='SHSE.000300', start_date='2017-06-30', end_date='2017-06-30')[0][\\n23. 'constituents']\\n24. stock300_symbol = []\\n25. stock300_weight = []\\n26. for key in stock300:\\n27. # 保留权重大于0.35%的成份股\\n28. if (stock300[key] / 100) > 0.003",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "重大于0.35%的成份股\\n28. if (stock300[key] / 100) > 0.0035:\\n29. stock300_symbol.append(key)\\n30. stock300_weight.append(stock300[key] / 100)\\n31. context.stock300 = DataFrame([stock300_weight], columns=stock300_symbol, index=['weight']).T\\n32. print('选择的成分股权重总和为: ', np.sum(stock300_weight))\\n33. subscribe(symbols=stock300_symbol, frequency='1d', count=5, wait_group=True)\\n\\n\\n36. def on_bar(context, bars):\\n37. # 若没有仓位则按照初始权重开仓\\n38. for bar in bars:\\n39. symbol = bar['symbol']\\n40. position = context.account().po",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "bar['symbol']\\n40. position = context.account().position(symbol=symbol, side=PositionSide_Long)\\n41. if not position:\\n42. buy_percent = context.stock300['weight'][symbol] * context.ratio\\n43. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\\n44. position_side=PositionSide_Long)\\n45. print(symbol, '以市价单开多仓至仓位:', buy_percent)\\n46. else:\\n\\n48. # 获取过去5天的价格数据,若连续上涨则为强势股,权重+0.2;若连续下跌则为弱势股,权重-0.2\\n49. recent_data = context.data(symbol=symbol, frequency='1d', count=5, fields='",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "a(symbol=symbol, frequency='1d', count=5, fields='close')['close'].tolist()\\n50. if all(np.diff(recent_data) > 0):\\n51. buy_percent = context.stock300['weight'][symbol] * (context.ratio + 0.2)\\n52. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\\n53. position_side=PositionSide_Long)\\n54. print('强势股', symbol, '以市价单调多仓至仓位:', buy_percent)\\n55. elif all(np.diff(recent_data) < 0):\\n56. buy_percent = context.stock300['weight'][symbol] * (context.ratio - 0.2)\\n57. order_target",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "[symbol] * (context.ratio - 0.2)\\n57. order_target_percent(symbol=symbol, percent=buy_percent, order_type=OrderType_Market,\\n58. position_side=PositionSide_Long)\\n59. print('弱势股', symbol, '以市价单调多仓至仓位:', buy_percent)\\n\\n\\n62. if __name__ == '__main__':\\n63. '''\\n64. 策略ID,由系统生成\\n65. filename文件名,请与本文件名保持一致\\n66. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n67. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n68. backtest_start_time回测开始时间\\n69. backtest_end_time回测结束时间\\n70. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n71. backtest_initial_cash回测初始资金\\n72. backtest_commission_ratio回测佣金比例\\n73. backtest_slippage_ratio回测滑点比例\\n74. '''\\n75. run(='',\\n76. filename='main.py',\\n77. mode=MODE_BACKTEST,\\n78. token='token_id',\\n79. backtest_start_time='2017-07-01 08:00:00',\\n80. backtest_end_time='2017-10-01 16:00:00',\\n81. backtest_adjust=ADJUST_PREV,\\n82. backtest_initial_cash=10000000,\\n83. backtest_commission_ratio=0.0001,\\n84. backtest_slippage_ratio=0.0001)\",\n    \"# 指数增强(股票)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "acktest_slippage_ratio=0.0001)\",\n    \"# 指数增强(股票)\\n\\n分享\\n\\n阅读 94773\\n 更新 2022-05-09 16:56:48\\n\\n* [指数增强策略](#042069c643f068af)\\n  + [1. 策略原理](#c4a1bed1475f07da)\\n  + [2. 策略步骤](#c306d1ad1c8a5699)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果和稳健性分析](#e8b0a560bf110088)\\n\\n# 指数增强策略\\n\\n## 1. 策略原理\\n\\n说到指数增强，就不得不说指数。\\n\\n在进行股票投资时，有一种分类方式是将投资分为**主动型投资**和**被动型投资**。被动型投资是指完全复制指数，跟随指数的投资方式。与被动型投资相反，主动型投资是根据投资者的知识结合经验进行主动选股，不是被动跟随指数。主动型投资者期望获得超越市场的收益，被动型投资者满足于市场平均收益率水平。\\n\\n指数增强是指在跟踪指数的基础上，采用一些判断基准，将不看好的股票权重调低或平仓，将看好的股票加",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n指数增强是指在跟踪指数的基础上，采用一些判断基准，将不看好的股票权重调低或平仓，将看好的股票加大仓位，以提高收益率的方法。\\n\\n**既然如此，我已经判断出来哪只是“好股票”，哪只是“一般”的股票，为什么不直接买入？而是要买入指数呢？**\\n\\n指数增强不同于其他主动投资方式，除了注重获取超越市场的收益，还要兼顾降低组合风险，注重收益的稳定性。如果判断失误，只买入选中股票而非指数会导致投资者承受巨大亏损。\\n\\n**怎样选择股票？**\\n\\n和alpha对冲策略类似，指数增强仅仅是一个思路，怎样选择“好股”还需投资者结合自身经验判断。\\n\\n本策略利用“动量”这一概念，认为过去5天连续上涨的股票具备继续上涨的潜力，属于强势股；过去5天连续下跌的股票未来会继续下跌，属于弱势股。\\n\\n## 2. 策略步骤\\n\\n第一步：选择跟踪指数，以权重大于0.35%的成分股为股票池。  \\n第二步：根据个股价格动量来判断是否属于优质股，即连续上涨5天则为优势股；间隔连续下跌5天则为劣质股。  \\n第三步：将优质股权重调高0.2，劣质股权重调低0.2。\\n\\n回测时间:2017-07-01 08:00:00 到 201",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "高0.2，劣质股权重调低0.2。\\n\\n回测时间:2017-07-01 08:00:00 到 2017-10-01 16:00:00  \\n回测选股股票池：沪深300成分股  \\n回测初始资金：1000万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_142\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. from gm.api import *\\n4. import numpy as np\\n\\n6. def init(context):\\n7. # 选择的两个合约\\n8. context.symbol = ['DCE.j1901', 'DCE.jm1901']\\n9. # 订阅历史数据\\n10. subscribe(symbols=context.symbol,frequency='1d',count=11,wait_group=True)\\n\\n12. def on_bar(context, bars):\\n1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t_group=True)\\n\\n12. def on_bar(context, bars):\\n13. # 数据提取\\n14. j_close = context.data(symbol=context.symbol[0],frequency='1d',fields='close',count=31).values\\n15. jm_close = context.data(symbol=context.symbol[1],frequency='1d',fields='close',count=31).values\\n16. # 提取最新价差\\n17. new_price = j_close[-1] - jm_close[-1]\\n18. # 计算历史价差,上下限，止损点\\n19. spread_history = j_close[:-2] -  jm_close[:-2]\\n20. context.spread_history_mean = np.mean(spread_history)\\n21. context.spread_history_std = np.std(spread_history)\\n22",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xt.spread_history_std = np.std(spread_history)\\n22. context.up = context.spread_history_mean + 0.75 * context.spread_history_std\\n23. context.down = context.spread_history_mean - 0.75 * context.spread_history_std\\n24. context.up_stoppoint = context.spread_history_mean + 2 * context.spread_history_std\\n25. context.down_stoppoint = context.spread_history_mean - 2 * context.spread_history_std\\n26. # 查持仓\\n27. position_jm_long = context.account().position(symbol=context.symbol[0],side=1)\\n28. position_jm_short =",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "context.symbol[0],side=1)\\n28. position_jm_short = context.account().position(symbol=context.symbol[0],side=2)\\n\\n30. # 设计买卖信号\\n31. # 设计开仓信号\\n32. if not position_jm_short and not position_jm_long:\\n33. if new_price > context.up:\\n34. print('做空价差组合')\\n35. order_volume(symbol=context.symbol[0],side=OrderSide_Sell,volume=1,order_type=OrderType_Market,position_effect=1)\\n36. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n37",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "e_Market, position_effect=PositionEffect_Open)\\n37. if new_price < context.down:\\n38. print('做多价差组合')\\n39. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n40. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n\\n42. # 设计平仓信号\\n43. # 持jm多仓时\\n44. if position_jm_long:\\n45. if new_price >= context.spread_history_mean:\\n46. # 价差回归到均值水平时，平仓\\n4",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ntext.spread_history_mean:\\n46. # 价差回归到均值水平时，平仓\\n47. print('价差回归到均衡水平，平仓')\\n48. order_volume(symbol=context.symbol[0], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n49. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n\\n51. if new_price < context.down_stoppoint:\\n52. # 价差达到止损位，平仓止损\\n53. print('价差超过止损点，平仓止损')\\n54. order_volume(symbol=context.symbol[0], side=OrderSide_Se",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "volume(symbol=context.symbol[0], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n55. order_volume(symbol=context.symbol[1], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n\\n57. # 持jm空仓时\\n58. if position_jm_short:\\n59. if new_price <= context.spread_history_mean:\\n60. # 价差回归到均值水平时，平仓\\n61. print('价差回归到均衡水平，平仓')\\n62. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Mark",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n63. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n\\n65. if new_price > context.up_stoppoint:\\n66. # 价差达到止损位，平仓止损\\n67. print('价差超过止损点，平仓止损')\\n68. order_volume(symbol=context.symbol[0], side=OrderSide_Buy, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n69. order_volume(symbol=context.symbol[1], si",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "se)\\n69. order_volume(symbol=context.symbol[1], side=OrderSide_Sell, volume=1, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n\\n\\n72. if __name__ == '__main__':\\n73. '''\\n74. 策略ID,由系统生成\\n75. filename文件名,请与本文件名保持一致\\n76. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n77. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n78. backtest_start_time回测开始时间\\n79. backtest_end_time回测结束时间\\n80. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n81. backtest_initial_cash回测初始资金\\n82. backtest_commission_ratio回测佣金比例",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "al_cash回测初始资金\\n82. backtest_commission_ratio回测佣金比例\\n83. backtest_slippage_ratio回测滑点比例\\n84. '''\\n85. run(='',\\n86. filename='main.py',\\n87. mode=MODE_BACKTEST,\\n88. token='token',\\n89. backtest_start_time='2018-02-01 08:00:00',\\n90. backtest_end_time='2018-12-31 16:00:00',\\n91. backtest_adjust=ADJUST_PREV,\\n92. backtest_initial_cash=2000000,\\n93. backtest_commission_ratio=0.0001,\\n94. backtest_slippage_ratio=0.0001)\",\n    \"# 跨品种套利(期货)\\n\\n分享\\n\\n阅读 77411\\n 更新 2022-05-09 16:56:48\\n\\n* [跨品种套利](#09193f1e386d702e)",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "022-05-09 16:56:48\\n\\n* [跨品种套利](#09193f1e386d702e)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 跨品种套利\\n\\n## 1. 原理\\n\\n**什么是套利？**\\n\\n套利是指在买入或卖出一种金融资产的同时卖出或买入另一种相关的金融资产从中利用价差获得套利的过程。\\n\\n**什么是跨品种套利？**\\n\\n当两个合约有很强的相关性时，可能存在相似的变动关系，两种合约之间的价差会维持在一定的水平上。当市场出现变化时，两种合约之间的价差会偏离均衡水平。此时，可以买入其中一份合约同时卖出其中一份合约，当价差恢复到正常水平时平仓，获取收益。\\n\\n以大商所玉米和淀粉为例，合约分别为DCE.c1801和DCE.cs1801。二者之间相关性为0.7333，价差处于相对稳定合理区间。如图所示。\\n\\n![](/uploads/20201",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "关性为0.7333，价差处于相对稳定合理区间。如图所示。\\n\\n![](/uploads/202011/attach_16447dccc6e340a8.png)\\n\\n二者价差整体处于250-350之间。当价差偏离此区间时，可以进行跨品种套利。\\n\\n**跨品种套利有以下几个特点：**\\n\\n1.套利的两种资产必须有一定的相关性。  \\n2.两种合约标的不同，到期时间相同。  \\n3.两种资产之间的价差呈现一定规律。\\n\\n**怎样确定合约之间有相关性？**\\n\\n最常用的方法是利用EG两步法对两个序列做协整检验，判断两个序列是否平稳。只有单整阶数相同，二者才有可能存在一定的关系。\\n\\n以大豆和豆粕为例，选取其在2017年1月1日至2018年1月1日的主力合约价格时间序列，利用statsmodels包进行协整检验。\\n\\n检验结果为：  \\n焦炭的t = -1.7886，1%置信区间的临界值为-3.4576,说明该序列在99%的置信水平下平稳。  \\n焦煤的t = -2.0500，1%置信区间的临界值为-3.4576,说明该序列在99%的置信水平下平稳。\\n\\n因此，二者都为**平稳序列**。\\n\\n利用O",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "4576,说明该序列在99%的置信水平下平稳。\\n\\n因此，二者都为**平稳序列**。\\n\\n利用OLS回归检残差序列是否平稳，残差的t=-2.3214，临界值为-3.4577，说明残差平稳。因此，可以认为二者之间存在一定关系。\\n\\n回归后的残差图如下：  \\n![](/uploads/202011/attach_16447dd8a2012b87.png)\\n\\n对残差进行ks检验，检验结果p=0,说明残差分布为正态分布。\\n\\n**策略设计**\\n\\n传统利用价差进行跨品种套利的方法是计算出均值和方差，设定开仓、平仓和止损阈值。当新的价格达到阈值时，进行相应的开仓和平仓操作。\\n\\n**应该怎样确定均值？**\\n\\n均值的选取主要有两种方法，第一种方法是固定均值。先历史价格计算相应的阈值（比如利用2017年2月-2017年6月的数据计算阈值，在2019年7月进行套利），再用最新价差进行比较，会发现前后均值差异很大。如图所示。  \\n![](/uploads/202011/attach_16447de3754242dd.png)  \\n因此，常用变动的均值设定阈值。即用过去N天两个标的之间差值的均值和方差。",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "242dd.png)  \\n因此，常用变动的均值设定阈值。即用过去N天两个标的之间差值的均值和方差。\\n\\n## 2. 策略思路\\n\\n第一步：选择相关性较高的两个合约，本例选择大商所的焦炭和焦煤。  \\n第二步：以过去30个的1d频率bar的均值正负0.75个标准差作为开仓阈值，以正负2个标准差作为止损阈值。  \\n第三步：最新价差上穿上界时做空价差，回归到均值附近平仓；下穿下界时做多价差，回归到均值附近平仓。设定止损点，触发止损点则全部平仓。\\n\\n回测期：2018-02-01 8:00:00 至 2018-12-31 16:00:00  \\n回测标的：DCE.j1901, DCE.jm1901  \\n回测初始资金：200万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_143\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import numpy a",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "solute_import, unicode_literals\\n3. import numpy as np\\n4. from gm.api import *\\n5. '''\\n6. 通过计算两个真实价格序列回归残差的0.9个标准差上下轨,并在价差突破上轨的时候做空价差,价差突破下轨的时候做多价差\\n7. 并在回归至标准差水平内的时候平仓\\n8. 回测数据为:DCE.m1801和DCE.m1805的1min数据\\n9. 回测时间为:2017-09-25 08:00:00到2017-10-01 15:00:00\\n10. '''\\n11. def init(context):\\n12. context.goods = ['DCE.m1801', 'DCE.m1805']\\n13. # 订阅品种数据\\n14. subscribe(symbols = context.goods,frequency = '1d',count = 31,wait_group = True)\\n\\n16. def on_bar(context, bars):\\n17. # 获取历史数据\\n18. close_1801 = context",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "xt, bars):\\n17. # 获取历史数据\\n18. close_1801 = context.data(symbol=context.goods[0], frequency='1d', count=31, fields='close')['close'].values\\n19. close_1805 = context.data(symbol=context.goods[1], frequency='1d', count=31, fields='close')['close'].values\\n20. # 计算上下轨\\n21. spread = close_1801[:-2] - close_1805[:-2]\\n22. spread_new = close_1801[-1] - close_1805[-1]\\n23. up = np.mean(spread) + 0.75 * np.std(spread)\\n24. down = np.mean(spread) - 0.75 * np.std(spread)\\n25. up_stop = np.mean(spread) + 2 * np.std(sp",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ad)\\n25. up_stop = np.mean(spread) + 2 * np.std(spread)\\n26. down_stop = np.mean(spread) - 2 * np.std(spread)\\n\\n28. # 获取仓位\\n29. position1801_long = context.account().position(symbol = context.goods[0],side =PositionSide_Long)\\n30. position1801_short = context.account().position(symbol = context.goods[0],side =PositionSide_Short)\\n\\n32. # 没有仓位时\\n33. if not position1801_short and not position1801_long:\\n34. # 上穿上轨时，买近卖远\\n35. if spread_new > up:\\n36. order_volume(symbol=context.goods[0], volume=1, order_type=",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ume(symbol=context.goods[0], volume=1, order_type=OrderType_Market, side=OrderSide_Buy, position_effect=PositionEffect_Open)\\n37. order_volume(symbol=context.goods[1], volume=1, order_type=OrderType_Market, side=OrderSide_Sell, position_effect=PositionEffect_Open)\\n38. print('上穿上轨，买近卖远')\\n39. # 下穿下轨时，卖近买远\\n40. if spread_new < down:\\n41. order_volume(symbol=context.goods[0], volume=1, order_type=OrderType_Market, side=OrderSide_Sell, position_effect=PositionEffect_Open)\\n42. order_volume(symbol=context.goods",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ffect_Open)\\n42. order_volume(symbol=context.goods[1], volume=1, order_type=OrderType_Market, side=OrderSide_Buy, position_effect=PositionEffect_Open)\\n43. print('下穿下轨，卖近买远')\\n\\n45. # 价差回归到上轨时，平仓\\n46. if position1801_long:\\n47. if spread_new <= np.mean(spread):\\n48. order_close_all()\\n49. print('价差回归，平仓')\\n50. if spread_new > up_stop:\\n51. order_close_all()\\n52. print('达到止损点，全部平仓')\\n\\n54. # 价差回归到下轨时，平仓\\n55. if position1801_short:\\n56. if spread_new >= np.mean(spread):\\n57. order_close_all()\\n58. print('价差回归",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n(spread):\\n57. order_close_all()\\n58. print('价差回归，平全部仓')\\n59. if spread_new < down_stop:\\n60. order_close_all()\\n61. print('达到止损点，全部平仓')\\n\\n63. if __name__ == '__main__':\\n64. '''\\n65. 策略ID,由系统生成\\n66. filename文件名,请与本文件名保持一致\\n67. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n68. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n69. backtest_start_time回测开始时间\\n70. backtest_end_time回测结束时间\\n71. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n72. backtest_initial_cash回测初始资金\\n73. backtest_commission_ratio回测佣金比例\\n74. back",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "始资金\\n73. backtest_commission_ratio回测佣金比例\\n74. backtest_slippage_ratio回测滑点比例\\n75. '''\\n76. run(='',\\n77. filename='main.py',\\n78. mode=MODE_BACKTEST,\\n79. token='token_id',\\n80. backtest_start_time='2017-07-01 08:00:00',\\n81. backtest_end_time='2017-12-31 16:00:00',\\n82. backtest_adjust=ADJUST_PREV,\\n83. backtest_initial_cash=2000000,\\n84. backtest_commission_ratio=0.0001,\\n85. backtest_slippage_ratio=0.0001)\",\n    \"# 跨期套利(期货)\\n\\n分享\\n\\n阅读 95767\\n 更新 2022-05-09 16:56:48\\n\\n* [跨期套利策略](#ef9527d0cf571341)\\n  + [",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "9 16:56:48\\n\\n* [跨期套利策略](#ef9527d0cf571341)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [什么是跨期套利？](#82f7714859e29834)\\n    - [套利方法](#a61d5be123b8fa09)\\n    - [协整检验](#21efc72039481792)\\n  + [2. 策略步骤](#c306d1ad1c8a5699)\\n    - [3. 策略代码](#69a3fc437f0227e3)\\n    - [4. 回测结果](#7356929dacb239c9)\\n\\n# 跨期套利策略\\n\\n## 1. 原理\\n\\n### 什么是跨期套利？\\n\\n跨期套利是指在同益市场利用标的相同、交割月份不同的商品期货合约进行长短期套利的策略。跨期套利本质上是一种风险对冲，当价格出现单方向变动时，单边投机者要承担价格反向变动的风险，而跨期套利过滤了大部分的价格波动风险，只承担价差反向变动的风险。\\n\\n跨期套利相较于跨品种套利而言更复杂一些。跨期套利分为牛市套利、熊市套利、牛熊交换套利。每种套利方式下还有正向套利和反向套利",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "利而言更复杂一些。跨期套利分为牛市套利、熊市套利、牛熊交换套利。每种套利方式下还有正向套利和反向套利。不管是哪种套利方式，其核心都是认为“价差会向均值回归”。因此，在价差偏离均值水平时，按照判断买入被低估的合约，卖出被高估的合约。\\n\\n### 套利方法\\n\\n套利方法可归结为以下几类：\\n\\n| 价差（近-远） | 未来价 | 原理 | 操作 |\\n| --- | --- | --- | --- |\\n| 偏大 | 上涨/下跌 | 近月增长 >远月增长 | 买近卖远 |\\n| 近月下跌 < 远月下跌 |\\n| 偏小 | 上涨/下跌 | 近月增长 < 远月增长 | 卖近买远 |\\n| 近月下跌 > 远月下跌 |\\n|\\n\\n### 协整检验\\n\\n要想判断两个序列之间是否存在关系，需要对序列进行协整检验。以大商所豆粕为例，对DCE.m1701和DCE.m1705进行检验。\\n\\n1701合约的t值 = -2.1176，临界值为-3.4769，t > 临界值说明序列平稳。  \\n1705合约的t值 = -2.5194，临界值为-3.4769，t > 临界值说明序列平稳。\\n\\n两个序列都为单整序列，残差序列也平",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "94，临界值为-3.4769，t > 临界值说明序列平稳。\\n\\n两个序列都为单整序列，残差序列也平稳，说明二者之间存在长期稳定的均衡关系。\\n\\n## 2. 策略步骤\\n\\n第一步：选择同一标的不同月份的合约，本策略以豆粕为例。  \\n第二步：计算价差的上下轨。  \\n第三步：设计信号。价差上穿上轨，买近卖远；价差下穿下轨，卖近买远。  \\n价差达到止损点时平仓，价差回归到均值附近时平仓。\\n\\n回测标的：DCE.m1801、DCE.m1805  \\n回测时间:2017-09-25 到 2017-10-01  \\n回测初始资金：200万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n### 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_144\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import sys\\n4. try:\\n5. import talib\\n6. except:\\n7. print(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s\\n4. try:\\n5. import talib\\n6. except:\\n7. print('请安装TA-Lib库')\\n8. # 安装talib请看文档https://www.myquant.cn/docs/gm3_faq/154?\\n9. sys.exit(-1)\\n10. from gm.api import *\\n\\n\\n13. def init(context):\\n14. # 设置标的股票\\n15. context.symbol = 'SHSE.600000'\\n16. # 用于判定第一个仓位是否成功开仓\\n17. context.first = 0\\n18. # 订阅浦发银行, bar频率为1min\\n19. subscribe(symbols=context.symbol, frequency='60s', count=35)\\n20. # 日内回转每次交易100股\\n21. context.trade_n = 100\\n22. # 获取昨今天的时间\\n23. context.day = [0, 0]\\n24. # 用于判断是否到达接近收盘，所以不再交易\\n25. context.en",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " [0, 0]\\n24. # 用于判断是否到达接近收盘，所以不再交易\\n25. context.ending = 1\\n\\n\\n28. def on_bar(context, bars):\\n29. bar = bars[0]\\n30. # 配置底仓\\n31. if context.first == 0:\\n32. # 需要保持的总仓位\\n33. context.total = 10000\\n34. # 购买10000股浦发银行股票\\n35. order_volume(symbol=context.symbol, volume=context.total, side=OrderSide_Buy,\\n36. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n37. print(context.symbol, '以市价单开多仓10000股')\\n38. context.first = 1.\\n39. day = bar.bob.strftime('%Y-%m-%d')\\n40. context.day[-1] = int(day[",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "rftime('%Y-%m-%d')\\n40. context.day[-1] = int(day[-2:])\\n41. # 每天的仓位操作\\n42. context.turnaround = [0, 0]\\n43. return\\n\\n45. # 更新最新的日期\\n46. day = bar.bob.strftime('%Y-%m-%d %H:%M:%S')\\n47. context.day[0] = bar.bob.day\\n\\n49. # 若为新的一天,获取可用于回转的昨仓\\n50. if context.day[0] != context.day[-1]:\\n51. context.ending = 0\\n52. context.turnaround = [0, 0]\\n\\n54. # 如果接近收盘，则不再交易\\n55. if context.ending == 1:\\n56. return\\n\\n58. # 若有可用的昨仓则操作\\n59. if context.total >= 0:\\n60. # 获取时间序列数据\\n61. symbol = bar['symbol']\\n62. recent_da",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "取时间序列数据\\n61. symbol = bar['symbol']\\n62. recent_data = context.data(symbol=symbol, frequency='60s', count=35, fields='close')\\n63. # 计算MACD线\\n64. macd = talib.MACD(recent_data['close'].values)[0][-1]\\n65. # 根据MACD>0则开仓,小于0则平仓\\n66. if macd > 0:\\n67. # 多空单向操作都不能超过昨仓位,否则最后无法调回原仓位\\n68. if context.turnaround[0] + context.trade_n < context.total:\\n69. # 计算累计仓位\\n70. context.turnaround[0] += context.trade_n\\n71. order_volume(symbol=context.symbol, volume=context.trade_n, side=OrderSide_Buy,\\n72. order_type=OrderTyp",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de_n, side=OrderSide_Buy,\\n72. order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n73. print(symbol, '市价单开多仓', context.trade_n, '股')\\n74. elif macd < 0:\\n75. if context.turnaround[1] + context.trade_n < context.total:\\n76. context.turnaround[1] += context.trade_n\\n77. order_volume(symbol=context.symbol, volume=context.trade_n, side=OrderSide_Sell,\\n78. order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n79. print(symbol, '市价单开空仓', context.trade_n, '股')\\n80. # 临近收盘时若仓位数不等于昨仓则回转",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "仓', context.trade_n, '股')\\n80. # 临近收盘时若仓位数不等于昨仓则回转所有仓位\\n81. if day[11:16] == '14:55' or day[11:16] == '14:57':\\n82. position = context.account().position(symbol=context.symbol, side=PositionSide_Long)\\n83. if position['volume'] != context.total:\\n84. order_target_volume(symbol=context.symbol, volume=context.total, order_type=OrderType_Market,\\n85. position_side=PositionSide_Long)\\n86. print('市价单回转仓位操作...')\\n87. context.ending = 1\\n88. # 更新过去的日期数据\\n89. context.day[-1] = context.day[0]\\n\\n\\n92. if __name__ ==",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t.day[-1] = context.day[0]\\n\\n\\n92. if __name__ == '__main__':\\n93. '''\\n94. 策略ID,由系统生成\\n95. filename文件名,请与本文件名保持一致\\n96. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n97. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n98. backtest_start_time回测开始时间\\n99. backtest_end_time回测结束时间\\n100. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n101. backtest_initial_cash回测初始资金\\n102. backtest_commission_ratio回测佣金比例\\n103. backtest_slippage_ratio回测滑点比例\\n104. '''\\n105. run(='',\\n106. filename='main.py',\\n107. mode=MODE_BACKTEST,\\n1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ". filename='main.py',\\n107. mode=MODE_BACKTEST,\\n108. token='token_id',\\n109. backtest_start_time='2017-09-01 08:00:00',\\n110. backtest_end_time='2017-10-01 16:00:00',\\n111. backtest_adjust=ADJUST_PREV,\\n112. backtest_initial_cash=2000000,\\n113. backtest_commission_ratio=0.0001,\\n114. backtest_slippage_ratio=0.0001)\",\n    \"# 日内回转交易(股票)\\n\\n分享\\n\\n阅读 89072\\n 更新 2022-05-09 16:56:48\\n\\n* [日内回转策略(股票)](#b47cfad4c6c99652)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [1.1 日内回转交易](#06f595f138bb40a0)\\n    - [1.2 股票的日内回转交易](",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "日内回转交易](#06f595f138bb40a0)\\n    - [1.2 股票的日内回转交易](#392304c3971efd73)\\n    - [1.3 MACD指标简介](#509702eac2040b89)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 日内回转策略(股票)\\n\\n## 1. 原理\\n\\n### 1.1 日内回转交易\\n\\n日内回转交易，顾名思义就是在一天内完成“买”和“卖”两个相反方向的操作（可一次也可多次），也就是“T+0”交易。\\n\\n日内回转可用于股票和期货。其中期货采用“T+0”交易制度，可以直接进行日内回转交易。由于A股采用的是“T+1”交易制度，无法直接进行日内回转交易，需要先配置一定的底仓再进行回转交易。\\n\\n### 1.2 股票的日内回转交易\\n\\n**怎样对股票进行日内回转交易？**\\n\\n首先，在正式交易的前一个交易日配置一定的底仓。以500股为例，记做total = 500。\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n\\n首先，在正式交易的前一个交易日配置一定的底仓。以500股为例，记做total = 500。\\n\\n然后开始正式的日内回转交易。\\n\\n配置底仓的作用是利用替代法实现“T+0”。由于当天买入的股票当天不能卖出，但底仓是可以卖出的，用底仓替代新买入的股票进行卖出操作。假设在第二个交易日发生了1次买入，5次卖出交易，每次交易买卖数量为100股。利用turnaround = [0,0]变量记录每次交易的数量，也是当天收盘时需要回转的记录。其中第一个数据表示当日买入数量，第二个数据表示当日卖出数量。下表为单个交易日的买卖信号。\\n\\n| 信号方向 | 数量 | 交易记录 | 剩余可回转的数量 | 总仓位 |\\n| --- | --- | --- | --- | --- |\\n| 买 | 100 | [100,0] | 500 | 600 |\\n| 卖 | 100 | [100,100] | 400 | 500 |\\n| 卖 | 100 | [100,200] | 300 | 400 |\\n| 卖 | 100 | [100,300] | 200 | 300 |\\n| 卖 | 100 | [100,400] | 10",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "100,300] | 200 | 300 |\\n| 卖 | 100 | [100,400] | 100 | 200 |\\n\\n**假设在表的最后再加一个卖出信号是否可行？**\\n\\n答案是**不可行**。\\n\\n因为如果再加一个卖出信号，需要回转的股票数量变为[100,500]，即开多100股，开空500股。这就意味着在当天收盘之前，需要卖出100股，再买入500股进行回转。这个交易日内已经出现5次卖出信号，底仓的500股已经全部卖出，仅有100股今日买入的仓位，这部分股票是不能当日卖出的。所以，不能再添加卖出信号。\\n\\n因此，在判断买入或卖出信号是否能执行时，隐含一个判断条件。即：\\n\\n**每次交易的数量 + 当日买入的数量（turnaround的第一位）< 底仓数量（以卖出信号为例）**。\\n\\n### 1.3 MACD指标简介\\n\\nMACD又称“异移动平均线”，是根据双指数移动平均线发展而来。由快的指数（常12）减去慢的指数（常26）得到DIF，再用2×（快线DIF-DIF的9日加权移动均线DEA）得到MACD柱。\\n\\nDIF的计算方法为： DIF = 当天的12日指数移动平均值 - 当天的26",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "得到MACD柱。\\n\\nDIF的计算方法为： DIF = 当天的12日指数移动平均值 - 当天的26日指数应对平均值。  \\n***注：上市首日的EMA12和EMA26利用当天的收盘价替代。***\\n\\n## 2. 策略思路\\n\\n第一步：设置变量  \\n**context.first:底仓配置信号，0表示未配置底仓；1表示配置底仓。  \\ncontext.trade\\\\_n:每次交易数量。  \\ncontext.day:用来获取前一交易日的时间和最新交易日的时间，第一位是最新交易日，第二位是前一交易日。当二者不同时，意味着新的一天，需要初始化其他变量。  \\ncontext.ending：开始回转信号，0表示未触发；1表示已触发。  \\ncontext.turnaround：当日买卖股票操作记录，也是回转记录。第一位代表买入股数，第二位代表卖出股数。**\\n\\n第二步：计算MACD指标，设计交易信号  \\n当 MACD 小于 0 时，买入对应股票100手；  \\n当 MACD 大于 0 时，卖出对应股票100手;\\n\\n第三步：接近收盘时，全部回转\\n\\n回测标的：SHSE.600000  \\n回测期：20",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "手;\\n\\n第三步：接近收盘时，全部回转\\n\\n回测标的：SHSE.600000  \\n回测期：2017-09-01 8:00:00 到2017-10-01 16:00:00  \\n回测初始资金：200万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_145\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. from gm.api import *\\n\\n\\n6. '''\\n7. 本策略通过不断对CZCE.CF801进行:\\n8. 买(卖)一价现价单开多(空)仓和卖(买)一价平多(空)仓来做市\\n9. 并以此赚取差价\\n10. 回测数据为:CZCE.CF801的tick数据\\n11. 回测时间为:2017-09-29 11:25:00到2017-09-29 11:30:00\\n12. 需要特别注意的是:本平台对于回测对限价单固定完全成交,本例子 仅供参考.\\n13. 敬请通过适当调整回测参数\\n14. 1.backte",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "价单固定完全成交,本例子 仅供参考.\\n13. 敬请通过适当调整回测参数\\n14. 1.backtest_commission_ratio回测佣金比例\\n15. 2.backtest_slippage_ratio回测滑点比例\\n16. 3.backtest_transaction_ratio回测成交比例\\n17. 以及优化策略逻辑来达到更贴近实际的回测效果\\n18. 目前只支持最近三个月的tick数据，回测时间和标的需要修改\\n19. '''\\n\\n\\n22. def init(context):\\n23. # 订阅CZCE.CF801的tick数据\\n24. context.symbol = 'CZCE.CF801'\\n25. subscribe(symbols=context.symbol, frequency='tick')\\n\\n\\n28. def on_tick(context, tick):\\n29. quotes = tick['quotes'][0]\\n30. # 获取持有的多仓\\n31. position_long = context.account().position(symbol=co",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "sition_long = context.account().position(symbol=context.symbol, side=PositionSide_Long)\\n32. # 获取持有的空仓\\n33. position_short = context.account().position(symbol=context.symbol, side=PositionSide_Short)\\n34. # 没有仓位则双向开限价单\\n35. # 若有仓位则限价单平仓\\n36. if not position_long:\\n37. # 获取买一价\\n38. price = quotes['bid_p']\\n39. print('买一价为: ', price)\\n40. order_target_volume(symbol=context.symbol, volume=1, price=price, order_type=OrderType_Limit,\\n41. position_side=PositionSide_Long)\\n42. print('CZCE.CF801开限价单多仓1手')\\n43. els",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "de_Long)\\n42. print('CZCE.CF801开限价单多仓1手')\\n43. else:\\n44. # 获取卖一价\\n45. price = quotes['ask_p']\\n46. print('卖一价为: ', price)\\n47. order_target_volume(symbol=context.symbol, volume=0, price=price, order_type=OrderType_Limit,\\n48. position_side=PositionSide_Long)\\n49. print('CZCE.CF801平限价单多仓1手')\\n50. if not position_short:\\n51. # 获取卖一价\\n52. price = quotes['ask_p']\\n53. print('卖一价为: ', price)\\n54. order_target_volume(symbol=context.symbol, volume=1, price=price, order_type=OrderType_Limit,\\n55. position_side=Pos",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "order_type=OrderType_Limit,\\n55. position_side=PositionSide_Short)\\n56. print('CZCE.CF801卖一价开限价单空仓')\\n57. else:\\n58. # 获取买一价\\n59. price = quotes['bid_p']\\n60. print('买一价为: ', price)\\n61. order_target_volume(symbol=context.symbol, volume=0, price=price, order_type=OrderType_Limit,\\n62. position_side=PositionSide_Short)\\n63. print('CZCE.CF801买一价平限价单空仓')\\n\\n\\n66. if __name__ == '__main__':\\n67. '''\\n68. 策略ID,由系统生成\\n69. filename文件名,请与本文件名保持一致\\n70. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n71. token绑定计算机的ID,可在系统设置-密",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "LIVE回测模式:MODE_BACKTEST\\n71. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n72. backtest_start_time回测开始时间\\n73. backtest_end_time回测结束时间\\n74. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n75. backtest_initial_cash回测初始资金\\n76. backtest_commission_ratio回测佣金比例\\n77. backtest_slippage_ratio回测滑点比例\\n78. backtest_transaction_ratio回测成交比例\\n79. '''\\n80. run(='',\\n81. filename='main.py',\\n82. mode=MODE_BACKTEST,\\n83. token='token_id',\\n84. backtest_start_time='2017-09-29 11:25:00',\\n85. backtest_end_time='2017-09-29 1",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "29 11:25:00',\\n85. backtest_end_time='2017-09-29 11:30:00',\\n86. backtest_adjust=ADJUST_PREV,\\n87. backtest_initial_cash=500000,\\n88. backtest_commission_ratio=0.00006,\\n89. backtest_slippage_ratio=0.0001,\\n90. backtest_transaction_ratio=0.5)\",\n    \"# 做市商交易(期货)\\n\\n分享\\n\\n阅读 63805\\n 更新 2022-05-09 16:56:48\\n\\n* [做市商策略](#453ebf89037b4e6d)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [做市商制度](#618419f38b80684e)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果](#7356929dacb239c9)\\n\\n# 做市",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "f0227e3)\\n  + [4. 回测结果](#7356929dacb239c9)\\n\\n# 做市商策略\\n\\n## 1. 原理\\n\\n### 做市商制度\\n\\n做市商制度是一种报价驱动制度。做市商根据自己的判断，不断地报出买入报价和卖出报价，以自有资金与投资者进行交易。做市商获取的收益就是买入价和卖出价的价差。\\n\\n假设做市商以6344卖出一手合约，同时以6333买入一手合约。如果都成交，做市商可净获利11个点。但如果当时合约价格持续走高或走低，做市商没有对手方能够成交，这时就不得不提高自己的买价或降低自己的卖价进行交易，做市商就会亏损。因此，做市商并不是稳赚不赔的。\\n\\n## 2. 策略思路\\n\\n第一步：订阅tick数据（只有最近3个月数据）  \\n第二步：获取tick数据中的卖一和买一价格。  \\n第三步：以买一价格开多，以卖一价格开空。以卖一价格平多，以买一价格平空。\\n\\n回测标的：CZCE.CF801  \\n回测时间： 2017-09-29 11:25:00 至 2017-09-29 11:30:00  \\n回测初始资金：50万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "30:00  \\n回测初始资金：50万  \\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_146\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import numpy as np\\n4. import pandas as pd\\n5. from gm.api import *\\n\\n\\n8. '''\\n9. 以短期为例：20日线\\n10. 第一步：获取历史数据，计算唐奇安通道和ATR\\n11. 第二步：当突破唐奇安通道时，开仓。\\n12. 第三步：计算加仓和止损信号。\\n13. '''\\n\\n\\n16. def init(context):\\n17. # 设置计算唐奇安通道的参数\\n18. context.n = 20\\n19. # 设置合约标的\\n20. context.symbol = 'DCE.i2012'\\n21. # 设置交易最大资金比率\\n22.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ontext.symbol = 'DCE.i2012'\\n21. # 设置交易最大资金比率\\n22. context.ratio = 0.8\\n23. # 订阅数据\\n24. subscribe(symbols=context.symbol, frequency='60s', count=2)\\n25. # 获取当前时间\\n26. time = context.now.strftime('%H:%M:%S')\\n27. # 如果策略执行时间点是交易时间段，则直接执行algo定义atr等参数，以防直接进入on_bar()导致atr等未定义\\n28. if '09:00:00' < time < '15:00:00' or '21:00:00' < time < '23:00:00':\\n29. algo(context)\\n30. # 如果是交易时间段，等到开盘时间确保进入algo()\\n31. schedule(schedule_func=algo, date_rule='1d', time_rule='09:00:00')\\n32. schedule(schedule_func=algo, date_rul",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "00:00')\\n32. schedule(schedule_func=algo, date_rule='1d', time_rule='21:00:00')\\n\\n\\n35. def algo(context):\\n36. # 计算通道的数据:当日最低、最高、上一交易日收盘\\n37. # 注：由于talib库计算ATR的结果与公式求得的结果不符，所以这里利用公式计算ATR\\n38. # 如果是回测模式,当天的数据直接用history取到\\n39. if context.mode == 2:\\n40. data = history_n(symbol=context.symbol, frequency='1d', count=context.n+1, end_time=context.now, fields='close,high,low,bob', df=True) # 计算ATR\\n41. tr_list = []\\n42. for i in range(0, len(data)-1):\\n43. tr = max((data['high'].iloc[i] - data['low'].iloc[i]), ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "max((data['high'].iloc[i] - data['low'].iloc[i]), data['close'].shift(-1).iloc[i] - data['high'].iloc[i],\\n44. data['close'].shift(-1).iloc[i] - data['low'].iloc[i])\\n45. tr_list.append(tr)\\n46. context.atr = int(np.floor(np.mean(tr_list)))\\n47. context.atr_half = int(np.floor(0.5 * context.atr))\\n\\n\\n50. # 计算唐奇安通道\\n51. context.don_open = np.max(data['high'].values[-context.n:])\\n52. context.don_close = np.min(data['low'].values[-context.n:])\\n\\n54. # 如果是实时模式，当天的数据需要用current取到\\n55. if context.mode == 1:\\n56",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "式，当天的数据需要用current取到\\n55. if context.mode == 1:\\n56. data = history_n(symbol=context.symbol, frequency='1d', count=context.n, end_time=context.now, fields='close,high,low',\\n57. df=True)  # 计算ATR\\n58. current_data = current(symbols=context.symbol)   # 最新一个交易日的最高、最低\\n59. tr_list = []\\n60. for i in range(1, len(data)):\\n61. tr = max((data['high'].iloc[i] - data['low'].iloc[i]),\\n62. data['close'].shift(-1).iloc[i] - data['high'].iloc[i],\\n63. data['close'].shift(-1).iloc[i] - data['low'].iloc[i])\\n64. tr_list.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "t(-1).iloc[i] - data['low'].iloc[i])\\n64. tr_list.append(tr)\\n\\n66. # 把最新一期tr加入列表中\\n67. tr_new = max((current_data[0]['high'] - current_data[0]['low']),\\n68. data['close'].iloc[-1] - current_data[0]['high'],\\n69. data['close'].iloc[-1] - current_data[0]['low'])\\n70. tr_list.append(tr_new)\\n71. context.atr = int(np.floor(np.mean(tr_list)))\\n72. context.atr_half = int(np.floor(0.5 * context.atr))\\n\\n74. # 计算唐奇安通道\\n75. context.don_open = np.max(data['high'].values[-context.n:])\\n76. context.don_close = np.min(",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ues[-context.n:])\\n76. context.don_close = np.min(data['low'].values[-context.n:])\\n\\n78. # 计算加仓点和止损点\\n79. context.long_add_point = context.don_open + context.atr_half\\n80. context.long_stop_loss = context.don_open - context.atr_half\\n81. context.short_add_point = context.don_close - context.atr_half\\n82. context.short_stop_loss = context.don_close + context.atr_half\\n\\n\\n85. def on_bar(context, bars):\\n86. # 提取数据\\n87. symbol = bars[0]['symbol']\\n88. recent_data = context.data(symbol=context.symbol, frequen",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "data = context.data(symbol=context.symbol, frequency='60s', count=2, fields='close,high,low')\\n89. close = recent_data['close'].values[-1]\\n\\n91. # 账户仓位情况\\n92. position_long = context.account().position(symbol=symbol, side=PositionSide_Long)\\n93. position_short = context.account().position(symbol=symbol, side=PositionSide_Short)\\n\\n95. # 当无持仓时\\n96. if not position_long and not position_short:\\n97. # 如果向上突破唐奇安通道，则开多\\n98. if close > context.don_open:\\n99. order_volume(symbol=symbol, side=OrderSide_Buy, volume",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "r_volume(symbol=symbol, side=OrderSide_Buy, volume=context.atr, order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n100. print('开多仓atr')\\n\\n102. # 如果向下突破唐奇安通道，则开空\\n103. if close < context.don_close:\\n104. order_volume(symbol=symbol, side=OrderSide_Sell, volume=context.atr, order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n105. print('开空仓atr')\\n\\n107. # 有持仓时\\n108. # 持多仓，继续突破（加仓）\\n109. if position_long:\\n110. # 当突破1/2atr时加仓\\n111. if close > context.long_add_point:\\n112. order_v",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ". if close > context.long_add_point:\\n112. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Buy, order_type=OrderType_Market,position_effect=PositionEffect_Open)\\n113. print('继续加仓0.5atr')\\n114. context.long_add_point += context.atr_half\\n115. context.long_stop_loss += context.atr_half\\n116. # 持多仓，止损位计算\\n117. if close < context.long_stop_loss:\\n118. volume_hold = position_long['volume']\\n119. if volume_hold >= context.atr_half:\\n120. order_volume(symbol=symbol, volume=context.atr_half, sid",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Sell, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n121. else:\\n122. order_volume(symbol=symbol, volume=volume_hold, side=OrderSide_Sell, order_type=OrderType_Market,position_effect=PositionEffect_Close)\\n123. print('平多仓0.5atr')\\n124. context.long_add_point -= context.atr_half\\n125. context.long_stop_loss -= context.atr_half\\n\\n127. # 持空仓，继续突破（加仓）\\n128. if position_short:\\n129. # 当跌破加仓点时加仓\\n130. if close < context.short_add_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "9. # 当跌破加仓点时加仓\\n130. if close < context.short_add_point:\\n131. order_volume(symbol = symbol, volume=context.atr_half, side=OrderSide_Sell, order_type=OrderType_Market, position_effect=PositionEffect_Open)\\n132. print('继续加仓0.5atr')\\n133. context.short_add_point -= context.atr_half\\n134. context.short_stop_loss -= context.atr_half\\n\\n136. # 持多仓，止损位计算\\n137. if close > context.short_stop_loss:\\n138. volume_hold = position_short['volume']\\n139. if volume_hold >= context.atr_half:\\n140. order_volume(symbol=symbol",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "context.atr_half:\\n140. order_volume(symbol=symbol, volume=context.atr_half, side=OrderSide_Buy, order_type=OrderType_Market, position_effect=PositionEffect_Close)\\n141. else:\\n142. order_volume(symbol=symbol, volume=volume_hold, side=OrderSide_Buy, order_type=OrderType_Market,position_effect=PositionEffect_Close)\\n143. print('平空仓0.5atr')\\n144. context.short_add_point += context.atr_half\\n145. context.short_stop_loss += context.atr_half\\n\\n\\n148. if __name__ == '__main__':\\n149. '''\\n150. 策略ID,由系统生成\\n151. f",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " == '__main__':\\n149. '''\\n150. 策略ID,由系统生成\\n151. filename文件名,请与本文件名保持一致\\n152. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n153. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n154. backtest_start_time回测开始时间\\n155. backtest_end_time回测结束时间\\n156. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n157. backtest_initial_cash回测初始资金\\n158. backtest_commission_ratio回测佣金比例\\n159. backtest_slippage_ratio回测滑点比例\\n160. '''\\n161. run(='',\\n162. filename='main.py',\\n163. mode=MODE_BACKTEST,\\n164. token='token',\\n165. backtest_start_",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "CKTEST,\\n164. token='token',\\n165. backtest_start_time='2020-02-15 09:15:00',\\n166. backtest_end_time='2020-09-01 15:00:00',\\n167. backtest_adjust=ADJUST_PREV,\\n168. backtest_initial_cash=1000000,\\n169. backtest_commission_ratio=0.0001,\\n170. backtest_slippage_ratio=0.0001)\",\n    \"# 海龟交易法(期货)\\n\\n分享\\n\\n阅读 192903\\n 更新 2022-05-09 16:56:48\\n\\n* [海龟交易法](#30c4142fd6f8262d)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [1.1 起源](#58896c8f4826f4ef)\\n    - [1.2 建仓资金](#f464e09082bb0180)\\n    - [1.3 入市信号](#2c623029a9da9f50)\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "9082bb0180)\\n    - [1.3 入市信号](#2c623029a9da9f50)\\n    - [1.4 加仓和止损](#5e4d162e21ab4eb8)\\n    - [1.5 止盈](#6645f9b1b74126ed)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 海龟交易法\\n\\n## 1. 原理\\n\\n### 1.1 起源\\n\\n海龟交易思想起源于上世纪八十年代的美国。理查德丹尼斯与好友比尔打赌，主题是一个成功的交易员是天生的还是后天的。理查德用十年时间证明了通过日常系统培训，交易员可以通过后天培训成为一名优秀的交易者。这套培训系统就是海龟交易系统。\\n\\n海龟交易系统是一个完整的、机械的交易思想，可以系统地完成整个交易过程。它包括了买卖什么、头寸规模、何时买卖、何时退出等一系列交易策略，是一个趋势交易策略。它最显著的特点是捕捉中长期趋势，力求在短期内获得最大的收益。\\n\\n### 1.2 建仓资金\\n\\",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "。它最显著的特点是捕捉中长期趋势，力求在短期内获得最大的收益。\\n\\n### 1.2 建仓资金\\n\\n海龟交易法将建仓资金按照一定比例划分为若干个小部分，每次建仓头寸和加仓规模都与波动量N（又称平均真实波动振幅average true range ATR）有关。ATR是日内指数最大波动的平均振幅，由当日最高、最低价和上一交易日的收盘价决定。\\n\\n***ATR***\\n\\n![](/uploads/202011/attach_1644dade59a71009.png)  \\n其中PDC是前一交易日的收盘价，ATR就是TR在N天内的均值。  \\n  \\n***价值波动量***  \\n  \\n利用N值来体现价值波动量DV：  \\n**DV = N \\\\* 合约每点价值**\\n\\n其中每点代表的价值量是指每一个指数点数所代表的价格。  \\n每一次开仓交易合约数unit的确定是将总资产的1%除以DV得到。\\n\\n![](/uploads/202011/attach_1644db0e005d0867.png)\\n\\n### 1.3 入市信号\\n\\n海龟交易法使用的是以一个理查德唐奇安的通道突破系统为基础的入市系统。唐奇",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "# 1.3 入市信号\\n\\n海龟交易法使用的是以一个理查德唐奇安的通道突破系统为基础的入市系统。唐奇安通道分为系统一和系统二，对应短期突破和中长期突破。其中，短期突破系统是以20日（最高价或最低价）突破为基础，当价格突破20日价格即为入市信号；中长期系统是当盘中价格突破过去55日价格为入市信号。\\n\\n### 1.4 加仓和止损\\n\\n海龟交易法的加仓规则是当捕捉到入市信号后建立第一个交易单位的头寸，市价继续向盈利方向突破1/2N时加仓。\\n\\n止损位为2N,同加仓一样采用平均真实振幅N值为止损单位。每加仓一次，止损位就提高1/2N。\\n\\n### 1.5 止盈\\n\\n短期：多头头寸在突破过去10日最低价处止盈离市，空头头寸在突破过去10日最高价处止盈离市。  \\n中长期：多头头寸在突破过去20日最低价处止盈离市，空头头寸在突破过去20日最高价处止盈离市。\\n\\n## 2. 策略思路\\n\\n第一步：获取历史数据，计算唐奇安通道和ATR  \\n第二步：当突破唐奇安通道时，开仓。  \\n第三步：计算加仓和止损信号。\\n\\n回测标的：DCE.i2012  \\n回测时间：2020-02-15 至 2020-09-01",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n\\n回测标的：DCE.i2012  \\n回测时间：2020-02-15 至 2020-09-01  \\n回测初始资金：100万\\n\\n**Tips：**  \\nATR值是不断变化的，这就会导致在对期货平仓时，可能出现平仓数量 > 持仓数量的现象。比如前一交易日的持仓为10，今日的ATR值为22.假设当前价格触发平仓条件，平仓1/2*ATR。1/2*ATR=11 > 10, 这样就会导致委托失败报错。所以要加入一个变量volume\\\\_hold用来记录当前持仓量，与1/2\\\\*ATR作比较。\\n\\n**注意：若修改回测期，需要修改对应的回测标的。**\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_147\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. import numpy as np\\n4. from gm.api import *\\n5. '''\\n6. 本策略每隔1个月定时触发计算SHSE.000910.S",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "i import *\\n5. '''\\n6. 本策略每隔1个月定时触发计算SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914\\n7. (300工业.300材料.300可选.300消费.300医药.300金融)这几个行业指数过去\\n8. 20个交易日的收益率并选取了收益率最高的指数的成份股获取并获取了他们的市值数据\\n9. 随后把仓位调整至市值最大的5只股票上\\n10. 回测数据为:SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914和他们的成份股\\n11. 回测时间为:2017-07-01 08:00:00到2017-10-01 16:00:00\\n12. '''\\n13. def init(context):\\n14. # 每月第一个交易日的09:40 定时执行algo任务（仿真和实盘时不支持该频率）\\n15. schedule(schedule_func=algo, date_rule='1m', time_rule='09:",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "schedule_func=algo, date_rule='1m', time_rule='09:40:00')\\n16. # 用于筛选的行业指数\\n17. context.index = ['SHSE.000910', 'SHSE.000909', 'SHSE.000911', 'SHSE.000912', 'SHSE.000913', 'SHSE.000914']\\n18. # 用于统计数据的天数\\n19. context.date = 20\\n20. # 最大下单资金比例\\n21. context.ratio = 0.8\\n\\n23. def algo(context):\\n24. # 获取当天的日期\\n25. today = context.now\\n26. # 获取上一个交易日\\n27. last_day = get_previous_trading_date(exchange='SHSE', date=today)\\n28. return_index = []\\n\\n30. # 获取并计算行业指数收益率\\n31. for i in context.index:\\n32. return_index",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "收益率\\n31. for i in context.index:\\n32. return_index_his = history_n(symbol=i, frequency='1d', count=context.date, fields='close,bob',\\n33. fill_missing='Last', adjust=ADJUST_PREV, end_time=last_day, df=True)\\n34. return_index_his = return_index_his['close'].values\\n35. return_index.append(return_index_his[-1] / return_index_his[0] - 1)\\n\\n37. # 获取指定数内收益率表现最好的行业\\n38. sector = context.index[np.argmax(return_index)]\\n39. print('最佳行业指数是: ', sector)\\n\\n41. # 获取最佳行业指数成份股\\n42. symbols = get_history_constituents(ind",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "业指数成份股\\n42. symbols = get_history_constituents(index=sector, start_date=last_day, end_date=last_day)[0]['constituents'].keys()\\n\\n44. # 获取当天有交易的股票\\n45. not_suspended_info = get_history_instruments(symbols=symbols, start_date=today, end_date=today)\\n46. not_suspended_symbols = [item['symbol'] for item in not_suspended_info if not item['is_suspended']]\\n\\n48. # 获取最佳行业指数成份股的市值，从大到小排序并选取市值最大的5只股票\\n49. fin = get_fundamentals(table='trading_derivative_indicator', symbols=not_suspended_symbols, start_date=last_day",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "symbols=not_suspended_symbols, start_date=last_day,\\n50. end_date=last_day, limit=5, fields='NEGOTIABLEMV', order_by='-NEGOTIABLEMV', df=True)\\n51. fin.index = fin['symbol']\\n\\n53. # 计算权重\\n54. percent = 1.0 / len(fin.index) * context.ratio\\n\\n56. # 获取当前所有仓位\\n57. positions = context.account().positions()\\n\\n59. # 如标的池有仓位,平不在标的池的仓位\\n60. for position in positions:\\n61. symbol = position['symbol']\\n62. if symbol not in fin.index:\\n63. order_target_percent(symbol=symbol, percent=0, order_type=OrderType_Market,\\n",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "=symbol, percent=0, order_type=OrderType_Market,\\n64. position_side=PositionSide_Long)\\n65. print('市价单平不在标的池的', symbol)\\n\\n67. # 对标的池进行操作\\n68. for symbol in fin.index:\\n69. order_target_percent(symbol=symbol, percent=percent, order_type=OrderType_Market,\\n70. position_side=PositionSide_Long)\\n71. print(symbol, '以市价单调整至仓位', percent)\\n\\n73. if __name__ == '__main__':\\n74. '''\\n75. 策略ID,由系统生成\\n76. filename文件名,请与本文件名保持一致\\n77. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n78. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n79. backtest_s",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n78. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n79. backtest_start_time回测开始时间\\n80. backtest_end_time回测结束时间\\n81. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n82. backtest_initial_cash回测初始资金\\n83. backtest_commission_ratio回测佣金比例\\n84. backtest_slippage_ratio回测滑点比例\\n85. '''\\n86. run(='',\\n87. filename='main.py',\\n88. mode=MODE_BACKTEST,\\n89. token='token_id',\\n90. backtest_start_time='2017-07-01 08:00:00',\\n91. backtest_end_time='2017-10-01 16:00:00',\\n92. backtest_adjust=ADJUST_PREV,\\n93. backtest_in",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n92. backtest_adjust=ADJUST_PREV,\\n93. backtest_initial_cash=10000000,\\n94. backtest_commission_ratio=0.0001,\\n95. backtest_slippage_ratio=0.0001)\",\n    \"# 行业轮动(股票)\\n\\n分享\\n\\n阅读 91216\\n 更新 2022-05-09 16:56:48\\n\\n* [行业轮动策略](#0154de37d02116fa)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [行业轮动现象](#a8e1628d8676e515)\\n    - [行业轮动的原因](#e1d8c185f9839e8e)\\n    - [行业轮动下资产配置](#ce741e7a54261bed)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果分析与稳健性检验](#2a39edb4bd1fa9ab)\\n\\n# 行业轮动策略\\n\\n## 1.",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "果分析与稳健性检验](#2a39edb4bd1fa9ab)\\n\\n# 行业轮动策略\\n\\n## 1. 原理\\n\\n### 行业轮动现象\\n\\n在某一段时间内，某一行业或某几个行业组内股票价格共同上涨或下降的现象。\\n\\n行业轮动策略是根据行业轮动现象做成的策略，利用行业趋势进行获利的方法，属于主动交易策略。其本质是通过一段时期的市场表现，力求抓住表现较好的行业以及投资品种，选择不同时期的强势行业进行获利。\\n\\n### 行业轮动的原因\\n\\n***原因1：行业周期***\\n\\n行业的成长周期可以分为初创期、成长期、成熟期和衰退期，一般行业会按照这个周期运行。初创期属于行业刚刚起步阶段，风险高、收益小。成长期内风险高、收益高。处于成熟期的企业风险低、收益高。处于衰退期的企业风险低、收益低。在一段时间内，不同的行业会处于不同的行业周期，在时间维度上看会呈现行业轮动现象。\\n\\n***原因2：国家政策***\\n\\n国家政策对我国资本市场有重大影响。我国每年的财政政策和货币政策都是市场关注的热点，货币政策和财政政策会释放出影响市场的信息，如利率。当政策释放出下调利率的信号，就为资金需求量大、项目周期长的行业缓解了压力",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "放出影响市场的信息，如利率。当政策释放出下调利率的信号，就为资金需求量大、项目周期长的行业缓解了压力，如房地产行业，这时对于这类行业利好，相应的股价就会上涨。\\n\\n***原因3：重大事件***\\n\\n资本市场对于消息的反应是迅速的。根据有效市场理论，在半强式有效市场下，一切已公开的信息都会反映在股价当中。以疫情为例，消息一出迅速拉动医疗行业股价水平，带动行业增长。\\n\\n### 行业轮动下资产配置\\n\\n**1. 美林时钟：大类资产配置**\\n\\n根据经济增长和通货膨胀可以将经济分为四个周期：衰退、复苏、过热、滞涨。\\n\\n美林时钟分析了四个不同时期，并总结出适合投资的资产类别。\\n\\n| 周期阶段 | 经济增长 | 通货膨胀 | 最优资产类别 | 最优股票板块 |\\n| --- | --- | --- | --- | --- |\\n| 衰退 | 下降 | 下降 | 债券 | 防御成长 |\\n| 复苏 | 上升 | 下降 | 股票 | 周期成长 |\\n| 过热 | 上升 | 上升 | 商品 | 周期价值 |\\n| 滞涨 | 下降 | 上升 | 现金 | 防御价值 |\\n\\n研究宏观经济时主要关注两个变量：G",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "n| 滞涨 | 下降 | 上升 | 现金 | 防御价值 |\\n\\n研究宏观经济时主要关注两个变量：GDP和CPI。\\n\\n其中GDP选择不变价（剔除通货膨胀的影响），关心同比值差分后的符号。如果同比值>0，差分后仍然>0，说明GDP在加速上涨；如果同比值<0,差分后仍然<0，说明GDP在加速下跌。\\n\\n**当经济增长速度加快时，与国家经济联系紧密的行业如钢铁、煤炭、电力等基建利润也会随之增长。**\\n\\n**当经济增速放缓是，非周期性的行业如医药、基础消费品、基础建设等行业呈现较强的防御性。**\\n\\n**当通货膨胀处于较低水平时，市场利率水平也处于较低水平。按照股票估值理论，此时的折现率处于低水平，价格相对而言较高。此时，金融行业的股价会呈现明显的上涨。**\\n\\n**当通货膨胀处于较高水平时，市场利率较高，此时现金为王，原材料价格走高。与此相关的原材料行业就会表现较好，如天然气、石油等。**\\n\\n**2. 策略设计**\\n\\n**行业动量策略**\\n\\n部分研究表明，行业在日、月频率上会存在动量现象，在周频率上会存在反转现象，也就是行业间轮动。因此，在日和月频率上可以利用行业动量设计策略，如果是在周频",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "周频率上会存在反转现象，也就是行业间轮动。因此，在日和月频率上可以利用行业动量设计策略，如果是在周频率上可以利用反转效应设计策略。  \\n（引自：武文超. 中国A股市场的行业轮动现象分析——基于动量和反转交易策略的检验[J]. 金融理论与实践, 2014, 000(009):111-114.）\\n\\n**行业因子策略**\\n\\n将行业变量作为一个因子放入多因子模型中，利用多因子模型预测各个行业的周期收益率，采用滚动预测方法每次得到一个样本外预测值，根据这些预测值判断该买入哪些行业，卖出哪些行业。  \\n（引自：高波, 任若恩. 基于主成分回归模型的行业轮动策略及其业绩评价[J]. 数学的实践与认识, 2016, 46(019):82-92.）\\n\\n## 2. 策略思路\\n\\n策略示例采用第一种策略构建方法，利用行业动量设计策略。为了提高策略速度，以6个行业为例进行演示。\\n\\n第一步：确定行业指数，获取行业指数收益率。  \\n第二步：根据行业动量获取最佳行业指数。  \\n第三步：在最佳行业中，选择最大市值的5支股票买入。\\n\\n回测时间：2017-07-01 08:00:00 到 2017-10-01 16",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "支股票买入。\\n\\n回测时间：2017-07-01 08:00:00 到 2017-10-01 16:00:00  \\n回测标的：SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914  \\n(300工业.300材料.300可选.300消费.300医药.300金融)  \\n回测初始资金：1000万\\n\\n## 3. 策略代码\\n\\n```\"\n \n\n    \"strategy_148\",\n    \"1. # coding=utf-8\\n2. from __future__ import print_function, absolute_import, unicode_literals\\n3. from datetime import datetime\\n4. import numpy as np\\n5. from gm.api import *\\n6. import sys\\n7. try:\\n8. from sklearn import svm\\n9. except:\\n10. print('请安装scikit-learn",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "import svm\\n9. except:\\n10. print('请安装scikit-learn库和带mkl的numpy')\\n11. sys.exit(-1)\\n12. '''\\n13. 本策略选取了七个特征变量组成了滑动窗口长度为15天的训练集,随后训练了一个二分类(上涨/下跌)的支持向量机模型.\\n14. 若没有仓位则在每个星期一的时候输入标的股票近15个交易日的特征变量进行预测,并在预测结果为上涨的时候购买标的.\\n15. 若已经持有仓位则在盈利大于10%的时候止盈,在星期五损失大于2%的时候止损.\\n16. 特征变量为:1.收盘价/均值2.现量/均量3.最高价/均价4.最低价/均价5.现量6.区间收益率7.区间标准差\\n17. 训练数据为:SHSE.600000浦发银行,时间从2016-04-01到2017-07-30\\n18. 回测时间为:2017-07-01 09:00:00到2017-10-01 09:00:00\\n19. '''\\n\\n21. def init(context):\\n22. # 订阅浦发银行的分钟bar行情\\n23. context.symbol = 'SHSE.6000",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " # 订阅浦发银行的分钟bar行情\\n23. context.symbol = 'SHSE.600000'\\n24. subscribe(symbols=context.symbol, frequency='60s')\\n25. start_date = '2016-04-01'  # SVM训练起始时间\\n26. end_date = '2017-07-30'  # SVM训练终止时间\\n\\n28. # 用于记录工作日\\n29. # 获取目标股票的daily历史行情\\n30. recent_data = history(context.symbol, frequency='1d', start_time=start_date, end_time=end_date, fill_missing='last',\\n31. df=True)\\n32. days_value = recent_data['bob'].values\\n33. days_close = recent_data['close'].values\\n34. days = []\\n\\n36. # 获取行情日期列表\\n37. print('准备数据",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n34. days = []\\n\\n36. # 获取行情日期列表\\n37. print('准备数据训练SVM')\\n38. for i in range(len(days_value)):\\n39. days.append(str(days_value[i])[0:10])\\n40. x_all = []\\n41. y_all = []\\n42. for index in range(15, (len(days) - 5)):\\n43. # 计算三星期共15个交易日相关数据\\n44. start_day = days[index - 15]\\n45. end_day = days[index]\\n46. data = history(context.symbol, frequency='1d', start_time=start_day, end_time=end_day, fill_missing='last',\\n47. df=True)\\n48. close = data['close'].values\\n49. max_x = data['high'].values\\n50. min_n = dat",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "\\n49. max_x = data['high'].values\\n50. min_n = data['low'].values\\n51. amount = data['amount'].values\\n52. volume = []\\n53. for i in range(len(close)):\\n54. volume_temp = amount[i] / close[i]\\n55. volume.append(volume_temp)\\n56. close_mean = close[-1] / np.mean(close)  # 收盘价/均值\\n57. volume_mean = volume[-1] / np.mean(volume)  # 现量/均量\\n58. max_mean = max_x[-1] / np.mean(max_x)  # 最高价/均价\\n59. min_mean = min_n[-1] / np.mean(min_n)  # 最低价/均价\\n60. vol = volume[-1]  # 现量\\n61. return_now = close[-1] / close[0]  # ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "]  # 现量\\n61. return_now = close[-1] / close[0]  # 区间收益率\\n62. std = np.std(np.array(close), axis=0)  # 区间标准差\\n\\n64. # 将计算出的指标添加到训练集X\\n65. # features用于存放因子\\n66. features = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std]\\n67. x_all.append(features)\\n\\n69. # 准备算法需要用到的数据\\n70. for i in range(len(days_close) - 20):\\n71. if days_close[i + 20] > days_close[i + 15]:\\n72. label = 1\\n73. else:\\n74. label = 0\\n75. y_all.append(label)\\n76. x_train = x_all[: -1]\\n77. y_train = y_all[: -1]\\n\\n79. # 训练SV",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "all[: -1]\\n77. y_train = y_all[: -1]\\n\\n79. # 训练SVM\\n80. context.clf = svm.SVC(C=0.6, kernel='rbf', gamma=0.001)\\n81. context.clf.fit(x_train, y_train)\\n82. print('训练完成!')\\n\\n84. def on_bar(context, bars):\\n85. bar = bars[0]\\n\\n87. # 获取当前年月日\\n88. today = bar.bob.strftime('%Y-%m-%d')\\n\\n90. # 获取数据并计算相应的因子\\n91. # 于星期一的09:31:00进行操作\\n92. # 当前bar的工作日\\n93. weekday = datetime.strptime(today, '%Y-%m-%d').isoweekday()\\n\\n95. # 获取模型相关的数据\\n96. # 获取持仓\\n97. position = context.account().position(symbol=context.symbol, si",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "ntext.account().position(symbol=context.symbol, side=PositionSide_Long)\\n\\n99. # 如果bar是新的星期一且没有仓位则开始预测\\n100. if not position and weekday == 1:\\n101. # 获取预测用的历史数据\\n102. data = history_n(symbol=context.symbol, frequency='1d', end_time=today, count=15,\\n103. fill_missing='last', df=True)\\n104. close = data['close'].values\\n105. train_max_x = data['high'].values\\n106. train_min_n = data['low'].values\\n107. train_amount = data['amount'].values\\n108. volume = []\\n109. for i in range(len(close)):\\n110. volume_temp",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "109. for i in range(len(close)):\\n110. volume_temp = train_amount[i] / close[i]\\n111. volume.append(volume_temp)\\n112. close_mean = close[-1] / np.mean(close)\\n113. volume_mean = volume[-1] / np.mean(volume)\\n114. max_mean = train_max_x[-1] / np.mean(train_max_x)\\n115. min_mean = train_min_n[-1] / np.mean(train_min_n)\\n116. vol = volume[-1]\\n117. return_now = close[-1] / close[0]\\n118. std = np.std(np.array(close), axis=0)\\n\\n120. # 得到本次输入模型的因子\\n121. features = [close_mean, volume_mean, max_mean, min_mean, ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "s = [close_mean, volume_mean, max_mean, min_mean, vol, return_now, std]\\n122. features = np.array(features).reshape(1, -1)\\n123. prediction = context.clf.predict(features)[0]\\n\\n125. # 若预测值为上涨则开仓\\n126. if prediction == 1:\\n127. # 获取昨收盘价\\n128. context.price = close[-1]\\n129. # 把浦发银行的仓位调至95%\\n130. order_target_percent(symbol=context.symbol, percent=0.95, order_type=OrderType_Market,\\n131. position_side=PositionSide_Long)\\n132. print('SHSE.600000以市价单开多仓到仓位0.95')\\n\\n134. # 当涨幅大于10%,平掉所有仓位止盈\\n135. elif position ",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ")\\n\\n134. # 当涨幅大于10%,平掉所有仓位止盈\\n135. elif position and bar.close / context.price >= 1.10:\\n136. order_close_all()\\n137. print('SHSE.600000以市价单全平多仓止盈')\\n\\n139. # 当时间为周五并且跌幅大于2%时,平掉所有仓位止损\\n140. elif position and bar.close / context.price < 1.02 and weekday == 5:\\n141. order_close_all()\\n142. print('SHSE.600000以市价单全平多仓止损')\\n\\n144. if __name__ == '__main__':\\n145. '''\\n146. 策略ID,由系统生成\\n147. filename文件名,请与本文件名保持一致\\n148. mode实时模式:MODE_LIVE回测模式:MODE_BACKTEST\\n149. token绑定计算机的ID,可在系统设置-密钥管理中生成\\n150. backtest_start_t",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "oken绑定计算机的ID,可在系统设置-密钥管理中生成\\n150. backtest_start_time回测开始时间\\n151. backtest_end_time回测结束时间\\n152. backtest_adjust股票复权方式不复权:ADJUST_NONE前复权:ADJUST_PREV后复权:ADJUST_POST\\n153. backtest_initial_cash回测初始资金\\n154. backtest_commission_ratio回测佣金比例\\n155. backtest_slippage_ratio回测滑点比例\\n156. '''\\n157. run(='',\\n158. filename='main.py',\\n159. mode=MODE_BACKTEST,\\n160. token='token_id',\\n161. backtest_start_time='2017-07-01 09:00:00',\\n162. backtest_end_time='2017-10-01 09:00:00',\\n163. backtest_adjust=ADJUST_PREV,\\n164. bac",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": ":00',\\n163. backtest_adjust=ADJUST_PREV,\\n164. backtest_initial_cash=10000000,\\n165. backtest_commission_ratio=0.0001,\\n166. backtest_slippage_ratio=0.0001)\",\n    \"# 机器学习(股票)\\n\\n分享\\n\\n阅读 104353\\n 更新 2022-05-09 16:56:48\\n\\n* [机器学习](#fd355596e307767d)\\n  + [1. 原理](#4d68e06c45acd2a2)\\n    - [什么是机器学习？](#04cfa6b561edc499)\\n    - [什么是支持向量机？](#275d1ccb0824bc2f)\\n    - [利用支持向量机预测股票涨跌](#e6a2445e80d3389e)\\n    - [参数优化](#c1d8043bae5414dc)\\n  + [2. 策略思路](#cf0127fe1bcb3311)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "11)\\n  + [3. 策略代码](#69a3fc437f0227e3)\\n  + [4. 回测结果与稳健性分析](#3e2df45effccee1c)\\n\\n# 机器学习\\n\\n## 1. 原理\\n\\n### 什么是机器学习？\\n\\n随着计算机技术的发展，投资者不再只局限于传统投资策略，机器学习在资本市场得到广泛应用。机器学习的核心是通过机器模仿人类的思考过程以及思维习惯，通过对现有数据的学习，对问题进行预测和决策。目前，机器学习已在人脸识别、智能投顾、自然语言处理等方面得到广泛应用。\\n\\n机器学习可以分为两类，一类是无监督学习，另一类是监督学习。监督学习是指按照已有的标记进行学习，即已经有准确的分类信息。比如二分类问题，一类是“好”，另一类是“不好”，这种明确地指出分类基准的问题。这类模型包括：神经网络、决策树、支持向量机等。\\n\\n无监督学习是指针对未标记过的数据集进行学习。比如聚类问题，没有准确的标准说明应该聚成几类，只有相对概念。这类模型包括：K\\\\_means聚类、层次聚类法等。\\n\\n### 什么是支持向量机？\\n\\n支持向量机是最典型的一类机器学习模型，常用于解决二分类问题。支持向量机的原",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "什么是支持向量机？\\n\\n支持向量机是最典型的一类机器学习模型，常用于解决二分类问题。支持向量机的原理是在一个样本空间内，找到一个平面，将样本数据分为两个部分，即两个分类，这个平面就叫做超平面。\\n\\n**怎样确定超平面？**\\n\\n假设有一个线性可分的二分类问题如图所示。  \\n![](/uploads/202011/attach_16461d0521da1346.png)\\n\\n已知A、B、C三条线均可以将样本空间分为两类，那么问题来了，应该选择哪一个？\\n\\nSVM模型指出，如果超平面能够将训练样本没有错误地分开，并且两类训练样本中离超平面最近的样本与超平面之间的距离是最大的，则把这个超平面称作最优超平面，即上图中的B平面。两类样本中距离最优超平面的点成为支持向量，支持向量机模型的名字由此得出。  \\n![](/uploads/202011/attach_16461d0732d39ead.png)\\n\\n支持向量机背后的数学原理十分优美，但由于推导过程过于复杂，这里不再赘述。总之，支持向量机的核心就是寻找最优超平面。\\n\\n支持向量机不仅可以解决线性可分问题，也可以解决非线性可分问题。其核心思想是将原始",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "最优超平面。\\n\\n支持向量机不仅可以解决线性可分问题，也可以解决非线性可分问题。其核心思想是将原始样本点映射到高维空间上，将非线性转化为线性可分，在高维空间中找到满足条件的最优超平面，再映射到低维空间中。\\n\\n### 利用支持向量机预测股票涨跌\\n\\n在利用支持向量机进行预测之前，先将数据集分为训练集和测试集。常用的分类方法是将数据及进行8:2分解，0.8部分是训练集，0.2部分是测试集。用训练集训练模型，再用测试集评价模型的准确率等指标。\\n\\n在利用支持向量机预测时，还有很重要的一步是进行参数优化。SVM的参数包括以下几个。\\n\\n| 参数符号 | 参数说明 |\\n| --- | --- |\\n| C | 罚函数，错误项的惩罚系数，默认为1。C越大，对错误样本的惩罚力度越大，准确度越高但泛化能力越低（泛化能力是指拓展到测试集中的准确率）。C越小，允许样本增加一点错误，使泛化能力提高。 |\\n| Kernel | 核函数，包括linear(线型核函数)、poly(多项式核函数)、rbf(高斯核函数)、sigmod(sigmod核函数)。 |\\n| degree | 当核函数选成多项式核函数时对应的阶数。",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "gmod(sigmod核函数)。 |\\n| degree | 当核函数选成多项式核函数时对应的阶数。 |\\n| Gamma | 核函数系数。 |\\n\\n还有一些其他的参数，因为本示例不对其进行优化，所以这里不再赘述了。\\n\\n### 参数优化\\n\\n本示例采用网格搜索算法优化参数，训练好的参数为C = 0.6, gamma = 0.001,训练后的准确率为 0.50。（这个准确率虽然看起来很低，但在现实生活中准确率都处于较低水平，这里暂时用这个优化后的参数进行建模。）\\n\\n## 2. 策略思路\\n\\n第一步：获取原始数据，这里获取2016-04-01到2017-07-30的数据。  \\n第二步：计算SVM模型的输入变量。\\n\\n**x 表示输入的特征值，共7个，分别为：**\\n\\n| 参数符号 | 计算方法 |\\n| --- | --- |\\n| x1 | 最新收盘价/15日收盘价均值 |\\n| x2 | 现量/15日均量 |\\n| x3 | 最新最高价/15日均价 |\\n| x4 | 最新最低价/15日均价 |\\n| x5 | 现量 |\\n| x6 | 15日区间收益率 |\\n| x7 | 15日区间标准",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": " |\\n| x5 | 现量 |\\n| x6 | 15日区间收益率 |\\n| x7 | 15日区间标准差 |\\n\\n**y 表示5个交易日后收盘价是否上涨，**\\n\\n| 参数符号 | 含义 |\\n| --- | --- |\\n| y = 1 | 表示股价上涨 |\\n| y = 0 | 表示股价下跌 |\\n\\n第三步：利用训练好的模型预测股价未来走向。若上涨(y=1)则开仓。\\n\\n第四步：设置止损止盈点。  \\n若已经持有仓位则在盈利大于10%的时候止盈，在星期五损失大于2%的时候止损。\\n\\n回测时间：2017-07-01 09:00:00 到 2017-10-01 09:00:00  \\n回测初始资金：1000万  \\n回测标的：SHSE.600000\\n\\n## 3. 策略代码\\n\\n```\"\n  }\n]",
        "source": "merged_strategy_dataset.txt"
    },
    {
        "text": "RAG金融交易语料库1_核心金融概念金融术语详尽词典引言本词典旨在为金融交易领域的检索增强生成（RAG）系统提供一个全面、权威且结构化的知识库。其结构设计体现了金融信息固有的层次性：首先呈现来自监管机构（如美国证券交易委员会SEC）和专业标准组织（如CFA协会）的权威定义，确保信息的准确性和合规性；其次，整合来自领先教育资源（如Investopedia）的详尽解释、实例和背景分析，深化对概念的理解；最后，补充来自行业实践的术语，提供真实世界的语境。这种分层方法不仅确保了信息的权威性，也提供了丰富的教学和实践价值，旨在为量化分析师、金融开发者和数据科学家提供一个既精确又易于理解的参考标准 1。第一节 市场基础概念资产 (Asset)资产是指任何具有交换价值的有形或无形项目。例如，银行账户、房屋或股票都是资产 3。资产代表了公司所拥有的资源，可以分为流动资产和非流动资产。流动资产，通常被视为短期资产，可以在公司的一个财年内转换成现金，例如现金及现金等价物、应收账款和存货。非流动资产则是指持有期超过一年的长期投资，如不动产、厂房和设备（PP&E）、无形资产（如专利和商标）以及长期投资（如股票和债券）6。证券 (Se",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "不动产、厂房和设备（PP&E）、无形资产（如专利和商标）以及长期投资（如股票和债券）6。证券 (Security)证券是一个广义术语，指代多种可交易的金融工具，这些工具代表了在某一实体中的某种形式的财务价值 5。根据CFA协会的定义，证券是可以交易的金融资产，意图在于盈利或筹集资本 2。证券可以代表在公司中的所有权（如股票），与政府或公司的债权关系（如债券），或所有权权利（如期权）7。一个投资是否被视为证券，从而受到监管，通常由美国证券交易委员会（SEC）的**豪威测试（Howey Test）**来判定。该测试包含四个标准：涉及资金的投资。投资于一个“共同企业（common enterprise）”。投资者期望从投资中获利。任何预期的利润或回报都归因于第三方或发起人的行为 7。证券可大致分为三类：权益证券 (Equity Securities)：代表持有者在公司、合伙企业或信托等实体中的所有权权益。权益证券通常赋予持有人按比例通过投票权对公司进行一定控制的权利 7。债务证券 (Debt Securities)：代表必须偿还的借入资金，其条款规定了贷款规模、利率和到期日或续期日 7。混合证券 (Hybrid S",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "代表必须偿还的借入资金，其条款规定了贷款规模、利率和到期日或续期日 7。混合证券 (Hybrid Securities)：结合了权益和债务证券的某些元素，例如可转换为公司普通股的可转换债券 7。股票 (Stock / Equity Security)股票是一种证券，代表在一家公司中的所有权（即权益），并享有该公司资产和收益的一部分索取权 3。股票主要分为两种类型：普通股 (Common Stock)：通常赋予所有者在股东大会上的投票权，并有权获得股息 5。优先股 (Preferred Stock)：通常没有投票权，但在资产和收益的索取权上高于普通股。优先股提供固定的股息率，其行为类似于债券，因此常被视为固定收益证券 5。债券 (Bond / Debt Security)债券是一种债务证券，代表公司、政府或其他实体借入资金。发行机构在规定时间内偿还贷款本金，并支付一定比例的利息 3。债券是一种规定发行人有义务在特定时间内支付特定金额利息，并在几年后偿还债券持有人票面价值的计息证券 4。市场动态 (Bull vs. Bear Market)牛市 (Bull Market)：指股票价格持续上涨、市场情绪乐观的时期。",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": " Bear Market)牛市 (Bull Market)：指股票价格持续上涨、市场情绪乐观的时期。通常，当一个广泛的市场指数在至少两个月内上涨20%或更多时，即为牛市 3。熊市 (Bear Market)：指股票价格持续下跌、市场情绪悲观的时期。通常，当一个广泛的市场指数在至少两个月内下跌20%或更多时，即为熊市 3。第二节 核心投资与投资组合理论概念金融概念并非孤立存在，而是构成了一个紧密相连的知识网络。例如，理解阿尔法（Alpha）必须结合贝塔（Beta）、资本资产定价模型（CAPM）和有效市场假说（EMH）。同样，多元化是消除非系统性风险的手段，而这正是衡量基金经理能否产生真正阿尔法的先决条件。本节将围绕现代投资组合理论（MPT）的核心概念，揭示它们之间的内在联系。阿尔法 (Alpha, α)定义与内涵: 阿尔法是衡量一项投资在风险调整后的基础上，相对于基准（如市场指数）表现的指标。它通常被认为是投资策略超越市场所获得的“超额回报”或“异常回报率”，代表了策略的“优势” 9。阿尔法是主动投资的产物，可以为正或为负，而贝塔（Beta）则可以通过被动指数投资获得 9。计算与解读:正阿尔法：表示投资组合的表",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "为正或为负，而贝塔（Beta）则可以通过被动指数投资获得 9。计算与解读:正阿尔法：表示投资组合的表现优于其风险水平所预期的回报。负阿尔法：表示投资组合的表现劣于预期回报。零阿尔法：表示投资组合的回报与基准完全一致，基金经理没有增加或减少额外价值 9。在评估阿尔法时，必须使用可比的基准。例如，股票ETF的阿尔法不应与固定收益ETF的阿尔法直接比较 9。理论背景: 阿尔法的概念与**有效市场假说（EMH）**紧密相关。EMH认为，市场价格已反映所有可用信息，因此持续识别并从错误定价中获利是不可能的 9。实证研究表明，长期来看，只有不到10%的主动型共同基金能实现正的阿尔法，这说明获取阿尔法极其困难 9。詹森阿尔法 (Jensen's Alpha): 这是一个更复杂的阿尔法衡量标准，它将资本资产定价模型（CAPM）理论和风险调整措施纳入计算，使用了无风险利率和贝塔值，提供了更深层次的分析 9。贝塔 (Beta, β)定义: 贝塔是衡量一只股票或其他资产相对于整个市场的价格波动性或系统性风险的指标。市场的贝塔值始终为1.0 9。解读:β>1.0: 证券价格理论上比市场更具波动性。例如，贝塔为1.2的科技股，其波动性",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "1.0 9。解读:β>1.0: 证券价格理论上比市场更具波动性。例如，贝塔为1.2的科技股，其波动性比市场高20% 9。β<1.0: 证券价格波动性低于市场。例如，公用事业股通常具有较低的贝塔值 9。β=1.0: 证券价格活动与市场直接相关，不增加额外风险 9。β<0: 证券与市场呈负相关。例如，黄金矿商股或某些反向ETF 9。在CAPM中的作用: 贝塔是**资本资产定价模型（CAPM）**的关键组成部分，该模型用于为风险证券定价并估算资产的预期回报 9。局限性: 贝塔依赖于历史数据，因此在预测长期未来走势方面意义有限。此外，它假设股票回报呈正态分布，这在现实中并不总是成立 9。夏普比率 (Sharpe Ratio)定义与公式: 夏普比率由诺贝尔奖得主威廉·夏普于1966年提出，用于衡量风险调整后的回报。它通过计算每单位风险（以标准差衡量）所获得的超额回报来评估投资的吸引力 9。其计算公式为：Sharpe Ratio=σp​Rp​−Rf​​其中：Rp​ 是投资组合的回报率。Rf​ 是无风险利率（如国库券收益率）。σp​ 是投资组合超额回报的标准差 9。应用与陷阱: 夏普比率越高，通常意味着风险调整后的回报越具",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "。σp​ 是投资组合超额回报的标准差 9。应用与陷阱: 夏普比率越高，通常意味着风险调整后的回报越具吸引力。然而，基金经理可能通过延长回报衡量区间来人为降低波动率估计，从而操纵夏普比率 9。替代指标: 由于夏普比率依赖于正态分布假设，它可能低估“尾部风险”。替代指标包括仅关注下行风险的索提诺比率（Sortino Ratio）和使用贝塔作为风险度量的特雷诺比率（Treynor Ratio） 9。多元化 (Diversification)多元化是一种投资策略，可以概括为“不要把所有鸡蛋放在一个篮子里”。该策略通过将资金分散到不同的投资类别（如股票、债券和现金）中，以期在某个投资表现不佳时，其他投资表现良好，从而降低整体投资组合的非系统性风险 3。主动型基金经理的目标正是在通过多元化消除非系统性风险后，产生真正的阿尔法（即技能回报）9。风险价值 (Value at Risk, VaR)风险价值（VaR）是一种统计技术，用于量化特定投资组合在特定时间范围内的金融风险水平。它估算在正常市场条件下，投资组合在给定置信水平下可能遭受的最大损失 9。VaR是算法交易风险管理中的一个重要工具 23。第三节 关键金融工具期权 (",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "可能遭受的最大损失 9。VaR是算法交易风险管理中的一个重要工具 23。第三节 关键金融工具期权 (Options)期权是一种金融工具，其价值基于股票、指数和ETF等基础证券。与期货不同，期权合约赋予买方在特定时间范围内以预定价格（行权价）购买或出售标的资产的权利，但非义务。期权合约有特定的到期日，持有人必须在此之前行权。期权主要分为：看涨期权 (Call Options): 赋予持有人购买标的资产的权利。看跌期权 (Put Options): 赋予持有人出售标的资产的权利。根据行权方式，期权可分为：美式期权 (American Options): 可在到期日前的任何时间行权。欧式期权 (European Options): 只能在到期日当天行权。期权交易者利用期权进行投机（以较低成本获得杠杆头寸）或对冲（降低投资组合的风险敞口）。期货 (Futures)期货合约是双方同意在未来某一特定日期以预定价格买卖特定标的资产的协议。与期权不同，期货合约对买卖双方都具有约束力，即买方有义务购买，卖方有义务出售 9。期货合约在交易所进行标准化交易，其标的资产可以是商品（如原油、玉米）、货币、股指等 9。合约的结算方式可以",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "约在交易所进行标准化交易，其标的资产可以是商品（如原油、玉米）、货币、股指等 9。合约的结算方式可以是实物交割（如商品期货）或现金结算（如股指期货）9。衍生品 (Derivatives)衍生品是一种金融合约，其价值来源于股票、债券或商品等基础资产的价值 7。期权和期货是两种最常见的衍生品。第四节 财务报表与比率分析核心财务报表财务报表是理解一家公司财务状况和经营成果的关键。主要包括三大报表：资产负债表 (Balance Sheet): 揭示公司在特定时间点“拥有什么”（资产）与“欠什么”（负债）的快照。它遵循会计恒等式：资产=负债+股东权益 6。资产部分详细列出了流动资产（如现金、应收账款、存货）和非流动资产（如厂房设备、无形资产）。负债部分则包括流动负债（如应付账款、短期债务）和长期负债（如长期贷款、债券）6。利润表 (Income Statement): 显示公司在一段时间内的盈利能力。它从总收入（Revenue）开始，减去销售成本（COGS）得到毛利（Gross Profit），再减去运营费用（Operating Expenses）和税费，最终得出净利润（Net Income）6。现金流量表 (Cash",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "ting Expenses）和税费，最终得出净利润（Net Income）6。现金流量表 (Cash Flow Statement): 追踪资金在公司内外的流动情况，分为三个部分：经营活动现金流、投资活动现金流和融资活动现金流 6。关键财务比率财务比率是评估公司业绩和财务健康状况的重要工具：每股收益 (Earnings Per Share, EPS): 公司净利润与流通在外普通股股数的比值，是衡量公司盈利能力的重要指标 6。市盈率 (Price-to-Earnings Ratio, P/E Ratio): 股票市价与每股收益的比值，常用于评估股票估值水平 6。市净率 (Price-To-Book Ratio, P/B Ratio): 股票市价与每股净资产的比值，是另一种衡量估值的指标 6。市盈率相对盈利增长比率 (PEG Ratio): 市盈率与盈利增长率的比值，用于在考虑未来增长的情况下评估估值 6。第五节 非正式与行业特定术语金融行业，特别是交易领域，存在大量非正式的俚语和行话，理解这些术语对于把握市场情绪和行业文化至关重要。Ankle biter (小盘股): 指小市值投资 8。Bear hug (熊抱",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "和行业文化至关重要。Ankle biter (小盘股): 指小市值投资 8。Bear hug (熊抱): 指潜在收购方提出的远高于目标公司股价的收购要约，通常在目标公司管理层不愿出售时使用 27。Dead cat bounce (死猫反弹): 指下跌中的证券价格出现短暂的小幅回升，源于俗语“即使是死猫从高处掉下来也会弹一下”8。Godfather offer (教父要约): 指无法拒绝的收购要约，通常出价极高，以至于目标公司管理层无法说服股东拒绝 8。Killer bee (杀人蜂): 帮助公司抵御收购企图的个人或公司 8。Suicide pill (自杀药丸): 目标公司为抵御（通常是敌意的）收购而采取的使自身吸引力大大降低的防御策略，例如承担巨额债务 8。2_交易策略理论2.1 基础交易范式量化交易是一个系统化的过程，它将交易思想转化为可执行的、自动化的策略。这个过程可以被清晰地划分为三个核心阶段，形成一个完整的生命周期。量化交易生命周期策略识别 (Strategy Identification): 这是量化交易的起点，涉及寻找并验证一个可利用的市场“优势”（edge）。这个阶段的核心是研究，包括寻找策略",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "化交易的起点，涉及寻找并验证一个可利用的市场“优势”（edge）。这个阶段的核心是研究，包括寻找策略思想，评估其是否与现有策略组合相匹配，获取测试所需的数据，并尝试优化策略以获得更高的回报或更低的风险 28。策略思想的来源多种多样，包括学术研究平台（如SSRN、arXiv）、专业金融媒体（如Seeking Alpha）以及交易员社区和博客（如Elite Trader）28。策略回测 (Strategy Backtesting): 在确定策略思想后，必须通过历史数据对其进行严格的测试。回测是评估策略历史表现并发现潜在问题的关键步骤。在这一阶段，必须警惕几个常见陷阱：数据质量: 数据的准确性和清洁度至关重要。错误的数据，如价格尖峰，可能导致回测结果严重失真 28。幸存者偏差 (Survivorship Bias): 如果历史数据集中只包含“幸存”下来的公司（即未退市或破产的公司），那么基于该数据的回测结果会过于乐观，因为它忽略了失败的案例 28。公司行为调整: 股息、股票分割等公司行为会导致股价出现非交易性的跳跃。必须对历史数据进行“后向调整”，以确保回报率计算的准确性 28。执行系统 (Execution Sy",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "必须对历史数据进行“后向调整”，以确保回报率计算的准确性 28。执行系统 (Execution System): 最后一个阶段是将经过验证的策略部署到真实市场中。这包括连接到经纪商的API，实现交易逻辑的自动化，并致力于最小化交易成本（如滑点和佣金）28。交易频率量化策略根据其持仓时间可以分为不同频率：低频交易 (LFT): 通常指持仓时间超过一个交易日的策略 28。高频交易 (HFT): 通常指在日内完成交易的策略，持仓时间从几分钟到几小时不等 28。超高频交易 (UHFT): 指在秒级甚至毫秒级完成交易的策略，这需要对交易技术栈和订单簿动态有深入的了解 28。2.2 趋势跟踪与动量策略趋势跟踪与动量策略是量化交易中最古老、最著名的范式之一。其核心思想是，资产价格在一段时间内表现出的趋势（无论上涨或下跌）很可能会持续下去。理论基础动量策略的理论基础源于两个方面：行为金融学: 投资者对新信息的反应往往是滞后的（underreaction），导致价格调整过程缓慢而持久，从而形成趋势 29。市场结构: 大型基金的资金流动本身会产生并强化趋势。当大量资金涌入或流出某一资产时，会推动价格沿特定方向持续运动 28。因此",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "金流动本身会产生并强化趋势。当大量资金涌入或流出某一资产时，会推动价格沿特定方向持续运动 28。因此，趋势跟踪策略本质上是“搭便车”，跟随市场趋势直到其反转 28。数学模型与实现一个简单的趋势跟踪实现是移动平均线交叉策略，例如当短期移动平均线（如50日线）上穿长期移动平均线（如200日线）时买入，下穿时卖出 23。一个更严谨的数学模型将趋势跟踪的收益与回报时间序列的方差联系起来。一个简化的模型如下：在t时刻的预测信号F(t)定义为当前价格p(t)与过去某个时间点t_0价格的差值：F(t)=p(t)−p(t0​)单日价格回报$\\delta p(t)$定义为：δp(t)=p(t+1)−p(t)如果交易者持有的头寸等于F(t)，则单日的盈亏（P&L）为：$$P&L(t) = F(t) \\delta p(t)$$从t0​到最终日T的总盈亏可以表示为：$$ P&L_{\\text{total}} = \\frac{1}{2} \\left[ \\left( \\sum \\delta p(t) \\right)^2 - \\sum (\\delta p(t))^2 \\right] $$这个公式揭示了一个深刻的特性：趋势跟踪策略的盈亏取决",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "delta p(t))^2 \\right] $$这个公式揭示了一个深刻的特性：趋势跟踪策略的盈亏取决于两个不同时间尺度上的回报方差之差。当长期回报的方差大于短期回报方差之和时，策略盈利 30。在实践中，更常用指数加权移动平均（EMA）来定义趋势信号，因为它能更平滑地反映近期价格变化。此时，预测信号F(t)变为：F(t)=EMAτt−1​(δp(t))其中，\\tau是EMA的时间尺度。使用EMA的P&L具有显著的凸性（Convexity），其收益分布类似于期权：频繁的小额亏损和偶尔的大额盈利。这种正偏度（positively skewed）的特性使得趋势跟踪策略在传统投资组合中具有极佳的风险分散价值，尤其是在市场剧烈波动的“危机”时期 30。学术研究进一步深化了对趋势的建模。例如，使用L1滤波器（一种信号处理技术）可以从充满噪声的价格序列中提取分段线性的趋势，这比传统的L2滤波器（如Hodrick-Prescott滤波器）更能清晰地识别市场趋势的转折点，从而构建更有效的动量策略 32。2.3 均值回归与统计套利均值回归是与趋势跟踪相对立的交易范式。其核心假设是，资产价格或资产组合的价差在短期内可能会偏离其长期均",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "值回归是与趋势跟踪相对立的交易范式。其核心假设是，资产价格或资产组合的价差在短期内可能会偏离其长期均衡水平，但最终会“回归”到这个均值 28。理论基础均值回归现象在金融市场中广泛存在，例如：股票对: 两家业务相似的公司（如可口可乐与百事可乐），其股价在长期内应保持一个相对稳定的比率。当这个比率因短期市场情绪而偏离时，就产生了交易机会。期货与现货: 期货价格与现货价格之间的基差（basis）理论上在合约到期时会收敛于零。波动率: 市场波动率也表现出均值回归的特性，即高波动率时期之后往往是低波动率时期，反之亦然。核心策略：配对交易 (Pairs Trading)配对交易是统计套利最经典的应用。它旨在构建一个市场中性（即不受大盘涨跌影响）的投资组合，通过做多被低估的资产和做空被高估的资产来获利 34。1. 使用协整方法选择交易对 (Pair Selection via Cointegration)这是一种严谨的、基于经济计量学的方法，用于识别具有长期稳定关系的股票对。其步骤如下：单位根检验: 首先，使用增广迪基-福勒检验（ADF Test）等方法，确认两只股票的价格序列都是非平稳的（即I(1)过程）34。协整检验:",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "检验（ADF Test）等方法，确认两只股票的价格序列都是非平稳的（即I(1)过程）34。协整检验: 对通过检验的股票对进行协整检验（如Engle-Granger两步法或Johansen检验）。如果两支股票是协整的，意味着它们之间存在一个长期的均衡关系 34。构建价差序列: 这个均衡关系可以用一个线性组合来表示。这个线性组合的残差序列（即价差）是一个平稳的（即I(0)）均值回归过程。价差$\\epsilon_t可以表示为：\\epsilon_t = P^A_t - \\gamma P^B_t$，其中$\\gamma$是协整系数 34。生成交易信号: 当价差序列偏离其均值（通常为0）超过一定阈值（如2倍标准差）时，就产生交易信号。例如，当价差为-2.5标准差时，做多价差（即买入A，卖出B）；当价差回归到均值附近时，平仓获利 34。实证研究表明，基于协整的配对交易策略可以获得显著且稳定的超额回报。一项针对巴西市场的研究发现，该策略的年化超额回报率为16.38%，夏普比率为1.34，并且与市场指数的相关性极低，表现出良好的市场中性 34。2. 使用随机过程对价差建模奥恩斯坦-乌伦贝克（Ornstein-Uhlenbeck,",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "场中性 34。2. 使用随机过程对价差建模奥恩斯坦-乌伦贝克（Ornstein-Uhlenbeck, OU）过程是描述均值回归现象最经典的连续时间随机模型。其随机微分方程（SDE）为：dSt​=α(μ−St​)dt+σdWt​其中：St​ 是t时刻的价差。μ 是价差的长期均值。α 是回归速度，α越大，价差向均值回归的速度越快。σ 是价差的波动率。dWt​ 是一个维纳过程（布朗运动）35。OU模型在均值回归交易的三个核心步骤中都扮演着重要角色：识别共动资产: 通过历史数据拟合，找到最符合OU过程的资产对。构建价差: 通过最大化似然估计（MLE）等方法，确定最优的对冲比率$\\gamma$，使得构建出的价差序列最符合OU模型的特征 35。设计交易规则: 在OU模型的框架下，可以运用最优控制理论或最优停止理论来推导出理论上最优的开仓和平仓阈值，而不仅仅是依赖于固定的标准差倍数 35。2.4 因子投资策略因子投资是一种系统化的投资方法，旨在通过构建投资组合来捕获特定的、经学术验证的风险溢价（risk premia）。这些溢价来源于资产的某些共同特征或“因子”，而非传统的资产类别划分 38。核心因子及其在公司债券市场的应",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "溢价来源于资产的某些共同特征或“因子”，而非传统的资产类别划分 38。核心因子及其在公司债券市场的应用虽然因子投资最初主要应用于股票市场，但研究表明，这些因子在公司债券等其他资产类别中同样有效。以下是在公司债券市场中得到验证的核心因子：因子 (Factor)在公司债券市场中的定义关键文献来源规模 (Size)基于发行人总的未偿还债务规模。通常，规模较小的发行人债券能提供更高的风险调整后回报。39价值 (Value)比较债券的市场价格（信用利差）与其基本面价值（由评级、久期、违约概率等决定）。价值因子旨在买入信用利差相对于其内在风险而言过高的“廉价”债券。39动量 (Momentum)基于过去的表现。可以是债券自身过去6-12个月的回报（信用动量），也可以是其发行人股票过去的回报（股权动量），因为股价变动通常领先于债价。13低风险 (Low-Risk) / 防御性 (Defensive)投资于风险较低的债券，通常通过选择更高信用评级和更短久期（到期时间）的债券来实现。20质量 (Quality)投资于基本面稳健的公司发行的债券，通常以高盈利能力、低杠杆率等指标来衡量。12实证证据与稳健性学术界对因子投资面临的一",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "公司发行的债券，通常以高盈利能力、低杠杆率等指标来衡量。12实证证据与稳健性学术界对因子投资面临的一个核心挑战是所谓的“因子动物园”（Factor Zoo）现象——即发现了数百个潜在因子，但其中许多可能只是数据挖掘的产物，并不具备真实的预测能力。因此，对因子的验证方法与因子本身同样重要。严谨的因子研究通常包括以下稳健性检验：交易成本: 考虑实际交易成本（如买卖价差）后，因子回报是否依然显著 18。替代定义: 使用不同的方法定义同一个因子，检验结果的一致性 18。风险控制: 确保因子回报不是对已知风险（如市场风险、久期风险）的简单补偿。一种先进的方法是“局部评分”（local scoring）或“纯化”（purification），即在比较债券时，只与具有相似风险特征（如相同评级、久期、行业）的债券进行比较，从而分离出纯粹的因子效应 14。多因子组合: 由于单个因子之间相关性较低，构建一个包含多个因子的投资组合可以显著提高夏普比率，并降低跟踪误差，实现风险分散 18。大量实证研究证实，在公司债券市场中，规模、价值、动量和低风险等因子能够产生经济上和统计上都显著的阿尔法（超额回报），并且这些回报无法被传统的市场风",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "、动量和低风险等因子能够产生经济上和统计上都显著的阿尔法（超额回报），并且这些回报无法被传统的市场风险所解释 18。2.5 市场微观结构策略随着交易频率的提高和数据维度的增加，量化策略的演化前沿已从分析历史价格转向分析**订单簿（Limit Order Book, LOB）**的动态。市场微观结构策略旨在从交易的底层机制——订单的提交、取消和执行过程中，提取预测信号。订单流不平衡 (Order Flow Imbalance, OFI)定义: OFI是衡量在特定时间窗口内，买方发起的订单（通常是市价买单）与卖方发起的订单（市价卖单）之间净差异的指标。一个正的OFI表示买方压力更大，预示价格可能上涨；反之亦然 11。OFI被认为是预测短期价格变动最有效的微观结构指标之一。建模方法:霍克斯过程 (Hawkes Process): 由于订单的到来具有“自我激励”和“相互激励”的特性（一个买单可能引发更多的买单，也可能引发卖单），使用霍克斯过程可以有效地捕捉订单流中的聚类和交叉依赖性，从而更准确地预测OFI 10。混合模型: 结合向量自回归（VAR）模型捕捉线性依赖关系，并用神经网络（NN）模型捕捉残差中的非线性模式，",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "型: 结合向量自回归（VAR）模型捕捉线性依赖关系，并用神经网络（NN）模型捕捉残差中的非线性模式，可以构建出预测能力更强的混合OFI模型 43。高级微观结构概念ClusterLOB: 该策略超越了简单地加总所有订单。它首先利用机器学习算法（如K-means++）对市场中的订单进行聚类，识别出不同类型的市场参与者，例如：定向交易者 (Directional): 坚决推动价格朝一个方向移动。机会主义者 (Opportunistic): 灵活地在市场中寻找短期机会。做市商 (Market-making): 提供流动性，双向报价。然后，通过计算每个集群内部的OFI，可以生成更精细、更具预测力的交易信号。实证表明，基于这种聚类的交易策略，其夏普比率显著优于不进行聚类的基准策略 44。条件订单不平衡 (Conditional Order Imbalance, COI): 该方法基于交易发生的时间邻近性，对交易流进行分解。它首先定义一个极短的时间窗口（如1毫秒），然后根据一个交易在该窗口内是否与其他交易（同股票或不同股票）同时发生，将其分类。通过计算这些不同类别交易的订单不平衡（即COI），可以发现它们与股票回报之间存在",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "同时发生，将其分类。通过计算这些不同类别交易的订单不平衡（即COI），可以发现它们与股票回报之间存在不同的关系。研究发现，这些COI与同期的股票回报有很强的正相关性，为理解高频价格形成机制提供了新的视角 15。2.6 学术研究汇编本节旨在提供一个核心学术文献的摘要汇编，这些文献是理解前述交易策略理论基础的关键。每篇摘要将涵盖研究问题、方法论、核心发现及其对量化交易者的实践意义。Houweling & van Zundert, \"Factor Investing in the Corporate Bond Market\":研究问题: 检验股票市场中成熟的因子（规模、低风险、价值、动量）是否在公司债券市场中同样有效。方法论: 在包含美国投资级和高收益公司债券的综合数据集上，使用统一的方法构建并测试了四个因子的投资组合。核心发现: 所有四个因子在公司债券市场中都能产生经济上和统计上显著的阿尔法。由于因子间相关性低，多因子组合具有显著的多元化优势。结果对交易成本、因子定义和投资组合构建方式具有稳健性。实践意义: 首次系统性地证明了在公司债券这一重要资产类别中进行因子投资的可行性和有效性，为固定收益投资组合管理提供了新",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "统性地证明了在公司债券这一重要资产类别中进行因子投资的可行性和有效性，为固定收益投资组合管理提供了新的量化方法 18。Caldeira & Moura, \"Selection of a Portfolio of Pairs Based on Cointegration\":研究问题: 如何利用协整这一经济计量学工具来系统性地选择配对交易的股票对，并评估该策略的盈利能力。方法论: 采用协整检验（Engle-Granger和Johansen）来识别具有长期均衡关系的股票对，并基于价差的z-score生成交易信号。核心发现: 基于协整的配对交易策略在巴西股票市场产生了年均16.38%的显著超额回报，夏普比率为1.34，且与市场高度不相关，表现出强大的市场中性。实践意义: 为配对交易这一经典统计套利策略提供了严谨的理论基础和可行的实施框架，证明了其在实际市场中的盈利潜力 34。CFM, \"The Convexity of Trend Following\":研究问题: 深入探讨趋势跟踪策略的非线性收益特征。方法论: 通过数学推导，将趋势跟踪策略的盈亏（P&L）与回报时间序列的方差联系起来。核心发现: 趋势跟踪策略的P&L",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "学推导，将趋势跟踪策略的盈亏（P&L）与回报时间序列的方差联系起来。核心发现: 趋势跟踪策略的P&L具有凸性，其收益分布类似于买入一个跨式期权（straddle），表现为频繁的小额亏损和偶尔的大额盈利（正偏度）。实践意义: 解释了为什么趋势跟踪策略在市场发生剧烈、持续的波动时表现优异，并使其成为传统投资组合的有效风险分散工具 30。3_量化交易库引言在量化金融领域，开源库是研究和实践的基石。这些库并非单一的工具，而是构成了一个功能层次分明的生态系统。理解这个生态系统的结构对于量化开发者构建高效、稳健的交易系统至关重要。这些库可以大致分为两个层次：高层回测框架 (Backtesting Frameworks): 这类库提供了一个完整的交易策略回测“生态系统”，包括事件驱动引擎、数据处理、订单管理、业绩分析等。它们的目标是让开发者能够专注于策略逻辑本身，而无需从头构建底层基础设施。Backtrader和Zipline是此类的杰出代表。底层专用工具包 (Specialized Toolkits): 这类库专注于解决特定领域的问题，提供高效、精确的计算功能。它们通常被集成到高层框架中，作为策略的“计算核心”。Quan",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "定领域的问题，提供高效、精确的计算功能。它们通常被集成到高层框架中，作为策略的“计算核心”。QuantLib专注于复杂金融工具的定价和风险管理，而TA-Lib则专注于技术分析指标的计算。一个典型的量化开发“技术栈”通常是：使用Backtrader或Zipline作为顶层框架来组织整个回测流程，并在策略内部调用TA-Lib来计算指标，或调用QuantLib来为衍生品定价。关键金融库对比库名称主要用途核心特性社区/维护状态典型用例Backtrader功能丰富的策略回测与交易框架灵活性高，组件化设计（Cerebro, Data Feeds, Strategy, Analyzers），支持多种数据源和经纪商，绘图功能强大。独立项目，长期由个人维护，社区活跃。开发和测试各种复杂度的股票、期货等交易策略，从简单的移动平均线到复杂的多资产组合。Zipline事件驱动的算法交易回测库最初由Quantopian开发，与PyData生态系统（Pandas）深度集成，支持Pipeline API进行复杂的因子筛选。原项目已停止维护，但有活跃的社区分支zipline-reloaded在持续更新。主要用于美股市场的因子投资策略回测，特",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "但有活跃的社区分支zipline-reloaded在持续更新。主要用于美股市场的因子投资策略回测，特别是需要处理大量横截面数据的场景。QuantLib金融工具定价与风险管理全面的金融数学库，支持各种利率曲线、波动率模型、奇异期权、债券、互换的定价和风险分析。强大的开源社区，持续开发，被业界广泛使用。为复杂的固定收益产品或衍生品定价，计算Greeks，构建收益率曲线。TA-Lib技术分析指标计算包含超过150个常用的技术分析指标，用C语言编写，通过Cython封装，计算效率极高。成熟稳定，是技术分析计算的事实标准。在交易策略中快速、高效地计算SMA, RSI, MACD, Bollinger Bands等技术指标。3.1 Backtrader框架综合指南Backtrader是一个功能全面、开源的Python框架，专为交易策略的回测和实盘交易而设计。其最大的优势在于其灵活性和组件化的设计，允许开发者专注于策略逻辑的开发，而非底层架构的搭建 46。核心生态系统组件Backtrader的架构围绕其核心引擎Cerebro展开，各个组件像插件一样被添加到Cerebro中协同工作 47。Cerebro: 这是Backtra",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "展开，各个组件像插件一样被添加到Cerebro中协同工作 47。Cerebro: 这是Backtrader的大脑。你首先创建一个Cerebro实例，然后将策略、数据、经纪商、资金规模管理器和分析器等所有其他组件注入其中。最后调用cerebro.run()来启动整个回测流程 48。Data Feeds (数据源): 数据源是策略运行的基础，代表了市场数据。Backtrader可以轻松处理多种数据格式，如通过bt.feeds.YahooFinanceData直接获取雅虎财经数据，或通过bt.feeds.GenericCSVData加载本地CSV文件 49。数据源由多个“line”组成，如开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、成交量（volume）等。在策略中，可以通过self.datas.close等方式访问这些数据线 49。Strategy (策略): 这是你定义交易逻辑的地方。你需要创建一个继承自bt.Strategy的类。其中最重要的方法是：__init__(self): 策略的构造函数，在策略实例化时调用一次。通常在这里初始化指标、变量等 49。next(self",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "): 策略的构造函数，在策略实例化时调用一次。通常在这里初始化指标、变量等 49。next(self): 核心的交易逻辑方法。对于每一根K线（bar），next方法会被调用一次，你可以在这里编写买入/卖出决策 49。notify_order(self, order): 订单状态通知方法。每当订单状态发生变化（如提交、接受、完成、取消），此方法会被调用 49。notify_trade(self, trade): 交易通知方法。每当一笔交易（从开仓到平仓）完成时，此方法会被调用，可以用来记录盈亏 49。Indicators (指标): Backtrader内置了大量技术指标，如简单移动平均bt.indicators.SimpleMovingAverage。你可以在策略的__init__方法中实例化指标，然后在next方法中访问指标的值 49。Backtrader的“line”概念在这里也适用，指标的当前值通过索引``访问，前一个值通过[-1]访问 49。Broker, Sizers, Analyzers:Broker: 模拟经纪商，管理账户现金和持仓。可以通过cerebro.broker.setcash()设置初",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "r: 模拟经纪商，管理账户现金和持仓。可以通过cerebro.broker.setcash()设置初始资金，cerebro.broker.setcommission()设置佣金 49。Sizers: 决定每次下单的数量。例如，bt.sizers.FixedSize可以设置每次交易固定股数 49。Analyzers: 用于评估策略表现。例如，bt.analyzers.SharpeRatio和bt.analyzers.DrawDown可以计算夏普比率和最大回撤 50。代码示例：移动平均线交叉策略以下是一个完整且注释详细的移动平均线交叉策略示例。该策略在短期均线上穿长期均线时买入，下穿时卖出。Pythonimport backtrader as bt\nimport datetime\n\n# 定义策略\nclass MAcrossStrategy(bt.Strategy):\n    # 定义策略参数，可用于优化\n    params = (\n        ('fast_period', 10),\n        ('slow_period', 20),\n    )\n\n    def __init__(self):\n  ",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "ow_period', 20),\n    )\n\n    def __init__(self):\n        # 获取收盘价数据线\n        self.dataclose = self.datas.close\n        \n        # 初始化指标\n        self.fast_ma = bt.indicators.SimpleMovingAverage(\n            self.data.close, period=self.params.fast_period\n        )\n        self.slow_ma = bt.indicators.SimpleMovingAverage(\n            self.data.close, period=self.params.slow_period\n        )\n        \n        # 使用Crossover指标来检测交叉信号\n        self.crossover = bt.indicators.CrossOver(self.fast_ma, self.slow_ma)\n\n    ",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "cators.CrossOver(self.fast_ma, self.slow_ma)\n\n    def next(self):\n        # 如果没有持仓\n        if not self.position:\n            # 如果短期均线上穿长期均线 (crossover > 0)\n            if self.crossover > 0:\n                # 计算买入数量 (全仓买入)\n                size = self.broker.get_cash() / self.data.close\n                self.buy(size=size)\n        # 如果有持仓\n        elif self.crossover < 0:\n            # 如果短期均线下穿长期均线，则平仓\n            self.close()\n\nif __name__ == '__main__':\n    # 1. 创建Cerebro引擎\n    cerebro = bt.Cerebro()\n\n    # 2",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "1. 创建Cerebro引擎\n    cerebro = bt.Cerebro()\n\n    # 2. 添加策略\n    cerebro.addstrategy(MAcrossStrategy)\n\n    # 3. 加载数据\n    data = bt.feeds.YahooFinanceData(\n        dataname='AAPL',\n        fromdate=datetime.datetime(2018, 1, 1),\n        todate=datetime.datetime(2020, 12, 31)\n    )\n    cerebro.adddata(data)\n\n    # 4. 设置初始资金和佣金\n    cerebro.broker.setcash(100000.0)\n    cerebro.broker.setcommission(commission=0.001) # 0.1%\n\n    # 5. 添加分析器\n    cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe_ratio')\n    ce",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "nalyzers.SharpeRatio, _name='sharpe_ratio')\n    cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')\n    cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')\n\n    # 6. 运行回测\n    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())\n    results = cerebro.run()\n    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())\n\n    # 7. 打印分析结果\n    strat = results\n    print('Sharpe Ratio:', strat.analyzers.sharpe_ratio.get_analysis()['sharperatio'])\n    print('Max Drawdown:', strat",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": ")['sharperatio'])\n    print('Max Drawdown:', strat.analyzers.drawdown.get_analysis()['max']['drawdown'], '%')\n    print('Annualized Return:', strat.analyzers.returns.get_analysis()['rnorm100'], '%')\n\n    # 8. 绘制图表\n    cerebro.plot()\n3.2 Zipline算法交易库Zipline是一个事件驱动的Python算法交易库，最初由知名的众包对冲基金平台Quantopian开发并用作其核心回测引擎 27。这段历史对于理解Zipline的特性至关重要：它与PyData生态系统（特别是Pandas）深度集成，并拥有强大的Pipeline API，非常适合进行大规模的横截面因子分析，这正是Quantopian平台的典型用例。自Quantopian于2020年关闭以来，原生的Zipline项目停止了官方维护。然而，由于其强大的功能和广泛的用户基础，社区接管了维护工作，推出了zipline-relo",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "官方维护。然而，由于其强大的功能和广泛的用户基础，社区接管了维护工作，推出了zipline-reloaded等分支，使其能够兼容最新版本的Python和相关库 27。这种发展历程也催生了将Zipline策略迁移到其他平台（如用于实盘交易的pylivetrader或功能更全面的QuantConnect）的需求和工具 52。核心组件Zipline的算法结构非常简洁，主要由两个必须定义的函数构成 27：initialize(context): 此函数在算法开始前被调用一次。context是一个类似Python字典的对象，用于在整个算法运行期间存储和传递状态变量（如持仓、参数等）。你可以在这里设置要交易的资产、调度函数（schedule_function）等 27。handle_data(context, data): 这是算法的核心逻辑所在。对于回测中的每一个时间点（例如每一天或每一分钟），handle_data函数会被调用一次。data对象包含了当前时间点的市场数据（OHLCV），你可以用它来做出交易决策 27。数据摄取 (Data Ingestion)Zipline使用一种名为“数据包”（bundle）的机制来",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "据摄取 (Data Ingestion)Zipline使用一种名为“数据包”（bundle）的机制来管理历史数据。一个数据包是定价数据、调整数据（如股息、拆分）和资产元数据的集合。在使用Zipline之前，你需要通过其命令行工具“摄取”一个数据包。例如，摄取来自Quandl的数据包（现由Nasdaq托管）的命令是：$ zipline ingest -b quandl这会将数据下载并存储在本地，以供后续回测使用 27。代码示例：双移动平均线交叉策略以下是Zipline中经典的双移动平均线交叉策略的实现：Pythonfrom zipline.api import order_target, record, symbol, history\n\ndef initialize(context):\n    # 定义要交易的资产\n    context.asset = symbol('AAPL')\n\ndef handle_data(context, data):\n    # 获取100天和300天的历史价格数据\n    # data.history() 返回一个Pandas DataFrame\n    hist = hist",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "ata.history() 返回一个Pandas DataFrame\n    hist = history(bar_count=300, frequency=\"1d\", field='price')\n    \n    # 计算短期和长期移动平均线\n    short_mavg = hist[context.asset].rolling(window=100).mean().iloc[-1]\n    long_mavg = hist[context.asset].rolling(window=300).mean().iloc[-1]\n\n    # 交易逻辑\n    if short_mavg > long_mavg:\n        # order_target会下单以达到目标持股数\n        order_target(context.asset, 100)\n    elif short_mavg < long_mavg:\n        order_target(context.asset, 0)\n\n    # 使用record()记录变量以便后续分析和绘图\n    record(AAPL=data.c",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "  # 使用record()记录变量以便后续分析和绘图\n    record(AAPL=data.current(context.asset, 'price'),\n           short_mavg=short_mavg,\n           long_mavg=long_mavg)\n要运行此算法，可以将其保存为dma.py文件，然后使用Zipline的命令行界面：$ zipline run -f dma.py --start 2014-1-1 --end 2018-1-1 -o dma.pickle --no-benchmark回测结束后，性能数据和record记录的变量将保存在dma.pickle文件中，可以使用Pandas进行分析 27。Zipline生态系统与迁移对于希望将Zipline策略用于实盘交易或迁移到其他平台的用户，了解其生态系统至关重要。pylivetrader: 一个旨在使Zipline兼容实盘交易的库，它替换了quantopian API为pylivetrader API 52。pipeline-live: 用于在实盘环境中运行Zipline的Pipeline API 52。",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "。pipeline-live: 用于在实盘环境中运行Zipline的Pipeline API 52。迁移到QuantConnect: QuantConnect为从Zipline迁移的用户提供了详细的API映射指南，这对于希望转向一个功能更全面、支持多资产和实盘交易的平台的用户来说是一个宝贵的资源。Zipline与QuantConnect API映射参考Zipline APIQuantConnect API描述quantopian.algorithm.interface.BarData.currentSlice[symbol]获取当前模拟时间的资产数据。quantopian.algorithm.interface.BarData.historyself.History(symbols, bar_count)获取指定长度的历史数据窗口。quantopian.algorithm.date_rules.every_day()self.DateRules.EveryDay(symbol)创建一个每天触发的规则。quantopian.algorithm.order(asset, amount)self.Order(sym",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "opian.algorithm.order(asset, amount)self.Order(symbol, amount)按固定股数下单。quantopian.algorithm.order_percent(asset, percent)self.SetHoldings(symbol, percent)按投资组合价值的百分比下单。zipline.finance.slippage.NoSlippage()NullSlippageModel.Instance设置无滑点模型。资料来源: 533.3 QuantLib金融建模工具包QuantLib是一个全面、开源的金融工程库，其核心是用C++编写的，并提供了Python等多种语言的接口。它并非一个回测框架，而是一个专注于金融工具定价、建模和风险管理的底层数学工具包 56。QuantLib在业界和学术界都享有盛誉，是处理复杂固定收益产品和衍生品的标准工具之一。核心能力QuantLib的功能极其强大和广泛，其核心能力包括：日期和日历 (Dates and Calendars): 精确处理金融市场中的各种节假日、计息约定和日程安排，这是金融计算的基础 57。利率和收益率曲",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "s): 精确处理金融市场中的各种节假日、计息约定和日程安排，这是金融计算的基础 57。利率和收益率曲线 (Term Structures): 构建和校准各种复杂的收益率曲线，如分段常数远期利率曲线、三次样条曲线等，并支持多曲线引导 57。金融工具 (Instruments): 支持对大量金融工具进行建模，包括但不限于：固定收益: 债券、互换（Swaps）、远期利率协议（FRAs）。期权: 从简单的欧式、美式期权到复杂的奇异期权，如障碍期权、亚式期权等 25。信用衍生品: 信用违约互换（CDS）。定价引擎 (Pricing Engines): 提供了多种定价方法，包括解析公式（如Black-Scholes）、数值方法（如二叉树、有限差分法）和蒙特卡洛模拟 58。随机过程 (Stochastic Processes): 内置了多种用于模拟资产价格路径的随机过程，如几何布朗运动（GBM）、赫斯顿模型（Heston）、奥恩斯坦-乌伦贝克过程（OU）等 57。代码示例：使用Black-Scholes和二叉树为欧式期权定价以下代码展示了如何使用QuantLib Python来为一份欧式看涨期权定价，并比较了解析解（Bla",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "以下代码展示了如何使用QuantLib Python来为一份欧式看涨期权定价，并比较了解析解（Black-Scholes-Merton模型）和数值解（二叉树模型）的结果。这个例子清晰地展示了QuantLib的模块化设计思想：定义市场环境、定义金融工具、选择定价引擎、最后计算价格。Pythonimport QuantLib as ql\nimport matplotlib.pyplot as plt\n\n# 1. 设置市场和期权参数\n# 定义日期\ncalculation_date = ql.Date(8, 5, 2015)\nql.Settings.instance().evaluationDate = calculation_date\nmaturity_date = ql.Date(15, 1, 2016)\n\n# 定义期权参数\noption_type = ql.Option.Call\nspot_price = 127.62\nstrike_price = 130.0\nrisk_free_rate = 0.001\ndividend_rate = 0.0163\nvolatility = 0.20\n\n# 定义日历和计息方式",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "idend_rate = 0.0163\nvolatility = 0.20\n\n# 定义日历和计息方式\nday_count = ql.Actual365Fixed()\ncalendar = ql.UnitedStates()\n\n# 2. 构建欧式期权对象\npayoff = ql.PlainVanillaPayoff(option_type, strike_price)\nexercise = ql.EuropeanExercise(maturity_date)\neuropean_option = ql.VanillaOption(payoff, exercise)\n\n# 3. 构建Black-Scholes-Merton过程 (描述市场环境)\nspot_handle = ql.QuoteHandle(ql.SimpleQuote(spot_price))\nflat_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calculation_date, risk_free_rate, day_count)\n)\ndividend_yield = ql.YieldT",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "free_rate, day_count)\n)\ndividend_yield = ql.YieldTermStructureHandle(\n    ql.FlatForward(calculation_date, dividend_rate, day_count)\n)\nflat_vol_ts = ql.BlackVolTermStructureHandle(\n    ql.BlackConstantVol(calculation_date, calendar, volatility, day_count)\n)\nbsm_process = ql.BlackScholesMertonProcess(spot_handle, dividend_yield, flat_ts, flat_vol_ts)\n\n# 4. 使用解析引擎 (Black-Scholes) 定价\nengine_analytic = ql.AnalyticEuropeanEngine(bsm_process)\neuropean_option.setPricingEngine(engine_analytic)\nbs_price = european_o",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "icingEngine(engine_analytic)\nbs_price = european_option.NPV()\nprint(f\"Black-Scholes-Merton Price: {bs_price:.4f}\")\n\n# 5. 使用数值引擎 (二叉树) 定价并展示收敛性\ndef binomial_price(process, steps):\n    # 使用Cox-Ross-Rubinstein (crr) 二叉树模型\n    engine_binomial = ql.BinomialVanillaEngine(process, \"crr\", steps)\n    european_option.setPricingEngine(engine_binomial)\n    return european_option.NPV()\n\nsteps_range = range(10, 201, 5)\nprices = [binomial_price(bsm_process, s) for s in steps_range]\n\n# 6. 绘图展示二叉树价格向BSM价格收敛\nplt.figure(figsi",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "ps_range]\n\n# 6. 绘图展示二叉树价格向BSM价格收敛\nplt.figure(figsize=(10, 6))\nplt.plot(steps_range, prices, 'o-', label=\"Binomial Tree Price\")\nplt.axhline(bs_price, color='r', linestyle='--', label=\"BSM Analytic Price\")\nplt.xlabel(\"Number of Steps in Binomial Tree\")\nplt.ylabel(\"Option Price\")\nplt.title(\"Convergence of Binomial Tree Price to BSM Price\")\nplt.legend()\nplt.grid(True)\nplt.show()\n这个例子完美地说明了QuantLib的强大之处：它不仅能提供精确的解析解，还能方便地使用各种数值方法进行计算和验证，并清晰地展示了数值方法随着步数增加向理论解收敛的过程，这是金融工程中的一个核心概念 26。3.4 TA-Lib技术分析函数库TA-Lib（Technic",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "，这是金融工程中的一个核心概念 26。3.4 TA-Lib技术分析函数库TA-Lib（Technical Analysis Library）是一个广泛使用的开源库，提供了超过150种技术分析指标的计算功能，如移动平均线（MA）、相对强弱指数（RSI）、平滑异同移动平均线（MACD）和布林带（Bollinger Bands）等 62。其核心库用C语言编写，并通过Cython和NumPy为Python提供了高效的接口，计算速度比早期的SWIG封装快2-4倍，使其成为量化交易中进行技术分析计算的事实标准 64。安装指南TA-Lib的Python包装器依赖于底层的C库，因此其安装比普通的Python包稍显复杂。以下是针对不同操作系统的综合安装指南：通用方法 (使用Anaconda): 这是最简单、最推荐的方法，适用于所有平台。Anaconda发行版可以简化依赖管理。安装Anaconda或Miniconda。打开Anaconda Prompt（Windows）或终端（macOS/Linux）。通过conda-forge频道安装：conda install -c conda-forge ta-lib 63。Windows",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "道安装：conda install -c conda-forge ta-lib 63。Windows (手动安装):确保已安装Python和PIP。安装Visual Studio Build Tools，因为需要C编译器。从非官方Python二进制文件网站（如Gohlke's）下载与你的Python版本和系统架构（32/64位）匹配的TA-Lib .whl文件。在下载目录下运行 pip install ta-lib-<version>-...-win_amd64.whl 62。macOS (使用Homebrew):安装Homebrew包管理器。安装C库：brew install ta-lib。安装Python包装器：pip install ta-lib 62。Linux (Debian/Ubuntu):安装编译工具：sudo apt-get install build-essential。下载TA-Lib C库源码并编译安装：Bashwget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz\ntar -xzf ta-lib-0.",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "/ta-lib/ta-lib-0.4.0-src.tar.gz\ntar -xzf ta-lib-0.4.0-src.tar.gz\ncd ta-lib/\n./configure --prefix=/usrmakesudo make install```3.  安装Python包装器：pip install TA-Lib 63。函数类别TA-Lib的函数被清晰地划分为多个类别，便于查找和使用 64：Overlap Studies (重叠指标): 如SMA, EMA, Bollinger Bands (BBANDS)，这些指标通常与价格图绘制在同一图表上。Momentum Indicators (动量指标): 如ADX, MACD, RSI, STOCH，用于衡量价格变动的速度和强度。Volume Indicators (成交量指标): 如On Balance Volume (OBV)，用于衡量资金流入流出。Volatility Indicators (波动率指标): 如Average True Range (ATR)，用于衡量市场波动性。Pattern Recognition (形态识别): 包含大量K线形态识别",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": ")，用于衡量市场波动性。Pattern Recognition (形态识别): 包含大量K线形态识别函数，如CDL2CROWS (Two Crows), CDLHAMMER (Hammer)。Statistic Functions (统计函数): 如BETA, CORREL (相关系数), LINEARREG (线性回归)。代码示例TA-Lib的使用非常直观。以下代码展示了如何计算简单移动平均线（SMA）以及如何探索库中的所有可用函数。Pythonimport numpy as np\nimport talib\n\n# 1. 计算简单移动平均线 (SMA)\n# 创建一个包含100个随机数的NumPy数组，模拟收盘价数据\nclose_prices = np.random.random(100) * 10 + 100 # 价格在100-110之间\n\n# 使用talib.SMA函数计算20周期的SMA\n# 第一个参数是输入数据 (必须是NumPy数组)\n# 第二个参数是时间周期\nsma_20 = talib.SMA(close_prices, timeperiod=20)\n\nprint(\"Original Close ",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "ose_prices, timeperiod=20)\n\nprint(\"Original Close Prices (first 5):\", close_prices[:5])\nprint(\"Calculated SMA-20 (last 5):\", sma_20[-5:])\n# 注意：SMA输出数组的前(timeperiod-1)个值将是NaN\n\n# 2. 探索TA-Lib函数\n# 获取所有可用函数的列表\nall_functions = talib.get_functions()\nprint(f\"\\nTotal available functions: {len(all_functions)}\")\nprint(\"First 10 functions:\", all_functions[:10])\n\n# 按组获取所有函数\nfunction_groups = talib.get_function_groups()\nprint(\"\\nFunction Groups and their functions:\")\nfor group, functions in function_groups.items():\n    p",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "group, functions in function_groups.items():\n    print(f\"--- {group} ---\")\n    print(functions[:5]) # 只打印每组的前5个函数以保持简洁\n这段代码首先生成模拟的收盘价数据，然后调用talib.SMA计算移动平均线 62。接着，它演示了如何使用talib.get_functions()和talib.get_function_groups()来动态地发现和组织库中所有可用的分析工具，这对于开发者探索和集成新指标非常有用 64。结论本报告为金融交易领域的检索增强生成（RAG）系统构建了一个全面、深入且结构化的语料库。通过对核心金融概念、交易策略理论和主流开源量化库的系统性梳理，本报告旨在为量化分析师、开发者和研究人员提供一个权威、实用且易于集成的知识基础。分析揭示了几个关键的结构性特征。首先，金融知识本身具有层次性，从监管机构的权威定义到行业实践的非正式术语，一个有效的知识库必须反映并利用这种层次结构，而非简单地扁平化信息。其次，金融概念和交易策略并非孤立存在，而是构成了一个相互关联的复杂网络。例如，阿尔法（Alph",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "信息。其次，金融概念和交易策略并非孤立存在，而是构成了一个相互关联的复杂网络。例如，阿尔法（Alpha）的价值只有在贝塔（Beta）、资本资产定价模型（CAPM）和有效市场假说（EMH）的背景下才能被充分理解；而趋势跟踪和均值回归这两种看似对立的策略范式，因其风险收益特征的互补性，在组合构建中可能产生协同效应。在策略理论方面，报告展示了量化策略从基于价格的简单启发式方法（如移动平均线交叉）到基于严格数学模型（如协整和随机过程）再到基于高频订单簿数据的市场微观结构分析（如OFI和COI）的演化路径。这一演化过程凸显了对数据维度和模型复杂性的要求日益提高。特别是在因子投资领域，报告强调了方法论的重要性，即区分真实信号与统计噪音的稳健性检验和因子“纯化”技术，是应对“因子动物园”挑战的关键。在量化库的评估中，报告明确了不同库在技术栈中的定位：Backtrader和Zipline作为高层回测框架，负责流程的组织和管理；而QuantLib和TA-Lib作为底层专用工具包，提供核心的数学计算和指标分析功能。此外，报告还强调了开源库的“谱系”和社区维护状态对于技术选型和项目风险评估的至关重要性，特别是像Zipline这样经",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "了开源库的“谱系”和社区维护状态对于技术选型和项目风险评估的至关重要性，特别是像Zipline这样经历了从商业支持到社区维护转变的库。综上所述，本语料库不仅提供了大量高质量的文本和代码资料，更重要的是，它通过揭示金融交易领域的内在结构、理论演进和工具生态，为构建一个能够进行深度、关联性推理的先进RAG系统奠定了坚实的基础。未来的工作可以在此基础上，进一步整合实时市场数据流和更复杂的机器学习模型，以应对瞬息万变的金融市场带来的挑战。",
        "source": "gemini_knowledge.txt"
    },
    {
        "text": "A\nAccount balance/account value\n\nThe net amount held at any given time in an account, after factoring in all debits and credits.\n\nAIM (Alternative Investment Market)\n\nA sub-market of the London Stock Exchange (LSE), allowing smaller companies to raise capital with a more flexible regulatory system than is required for the main market of the LSE. CFDs in AIM-listed shares are not available.\n\nArbitrage\n\nThe process of buying an asset (such as shares) and then immediately selling it so as to profit from the di",
        "source": "knowledge_2.txt"
    },
    {
        "text": "immediately selling it so as to profit from the difference. Arbitrageurs can exploit tiny differences in the quoted price of an identical instrument across different markets using very large-sized trades.\n\nAsk\n\nThe lowest price at which a seller is willing to sell an investment or asset at a given moment. Also known as the offer price.\n\nB\nBackwardation\n\nA theory which says that as a futures contract nears expiry, it will trade at a higher price compared to when it was further from the expiry date. It is a c",
        "source": "knowledge_2.txt"
    },
    {
        "text": "hen it was further from the expiry date. It is a condition that occurs in commodities and futures markets where the price of a given good is higher today than the price in the future. Also see Contango.\n\nBar chart\n\nA style of chart used in technical analysis, where the top of the vertical line represents the highest price traded in a particular instrument, and the bottom part displays the lowest price. The closing price is shown on the right side of the bar, and the opening price is shown on the left side o",
        "source": "knowledge_2.txt"
    },
    {
        "text": " and the opening price is shown on the left side of the bar. A single bar normally represents one day of trading.\n\nBase currency\n\nThe first currency quoted in a currency pair (for example in the GBP/USD currency pair, GBP is the base currency while USD is the quote currency).\n\nBase rate\n\nThe lending rate determined by the central bank of a given country.\n\nBasis point\n\nTypically one hundredth of 1%, for example an interest rate cut of 50 basis points is equal to 0.5%.\n\nBear market\n\nA market distinguished by ",
        "source": "knowledge_2.txt"
    },
    {
        "text": " to 0.5%.\n\nBear market\n\nA market distinguished by falling prices and negative sentiment.\n\nBid\n\nThe highest price a buyer is willing to pay for a product is referred to as the ‘bid’. Also see Ask and Offer.\n\nBid price\n\nThe price at which the buyer is willing to purchase at.\n\nBid-offer spread\n\nThe difference between the buying price (offer/ask) and selling price (bid) of a product.\n\nBlue chip\n\nBlue-chip companies are usually well-established, financially sound and better able to weather downturns. As a result",
        "source": "knowledge_2.txt"
    },
    {
        "text": " and better able to weather downturns. As a result, blue-chip stocks are regarded as less volatile. Companies listed in a country’s top tier stock index, such as the UK’s FTSE 100, are considered blue-chips.\n\nBollinger Bands®\n\nA chart indicator used in technical analysis to measure market volatility, consisting of a single moving average and two standard deviation bands.\n\nBreakout trading\n\nTrading strategies that aim entering CFD trades once the price breaks through a defined resistance or support level. Ne",
        "source": "knowledge_2.txt"
    },
    {
        "text": " through a defined resistance or support level. New ‘buy’ positions are entered into when the price breaks through a resistance level, while new ‘sell’ positions are entered into when the price breaks through a support level. These strategies are based on the view that once the price breaks through a support or resistance level, a new trend is likely to begin.\n\nBroker\n\nAn individual or firm acting as an intermediary to bring together buyers and sellers, typically usually for a small commission or fee.\n\nBull",
        "source": "knowledge_2.txt"
    },
    {
        "text": "cally usually for a small commission or fee.\n\nBull market\n\nA market distinguished by rising prices. Bullish investors have a positive opinion about a market, believing that prices will continue to rise.\n\nBullion\n\nPrecious metals such as gold, silver, platinum or palladium in the form of bars or ingots.\n\nBundesbank\n\nCentral bank of Germany.\n\nBuy limit order\n\nA conditional trading order that indicates a security may be purchased only at the designated price or lower. Also see Take-profit order.\n\nBuy position\n",
        "source": "knowledge_2.txt"
    },
    {
        "text": " lower. Also see Take-profit order.\n\nBuy position\n\nA position in the market that would profit from a rising market price, or make a loss should prices fall.\n\nBuy stop- entry order\n\nWhen you buy a security that is entered at a price above the current offer price. It is triggered when the market price touches or goes through the specified stop price.\n\nC\nCable\n\nA term referring to the sterling/US dollar exchange rate: the rate was originally transmitted between the London and New York exchanges via the transat",
        "source": "knowledge_2.txt"
    },
    {
        "text": " the London and New York exchanges via the transatlantic telegraph cable beginning in the mid-1800s, hence the name.\n\nCAC 40\n\nA market capitalisation weighted index of the largest 40 companies listed on the Paris stock exchange. The CAC index is published by the Societe des Bourse Francaises.\n\nCandlestick chart\n\nAs with a bar chart, this graph shows the high, low, opening and closing prices, and the shape of the candle reflects the relationship between these prices. The candles are either green or red, depe",
        "source": "knowledge_2.txt"
    },
    {
        "text": " prices. The candles are either green or red, depending on whether the closing price is higher than the opening price (green) or below it (red). The main body, or ‘wax’, represents the range between the opening and closing price and the ‘wicks’ show the highs and lows. It shows a visual representation of the prevailing trend and current market sentiment.\n\nCapital\n\nThe wealth, either monetary or in assets, owned by an individual or company.\n\nCarry cost\n\nThe cost incurred as a result of holding a position (eg",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ost incurred as a result of holding a position (eg the carry cost incorporated into the price of a commodity future consists of insurance costs, storage costs, interest charges and other related costs).\n\nCarry trade\n\nA strategy in which a trader sells a certain currency with a low interest rate and uses the funds to purchase a different currency yielding a higher interest rate, attempting to capture the difference between the rates. Common low yielding currencies include the USD and JYP and common high yiel",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ncies include the USD and JYP and common high yielding currencies include the AUD and NZD.\n\nCash market\n\nThe actual, underlying market on which derivatives contracts are based.\n\nCash price\n\nThe price of an asset for immediate delivery. In other words, the actual price of an instrument right now. This term is often used for stock indices, whereas the synonymous term of spot is more often applied to forex and commodity prices. Also see Spot rate.\n\nCentral bank\n\nA government or quasi-governmental organisation ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "\n\nA government or quasi-governmental organisation that manages a country's monetary policy. For example, the UK’s central bank is the Bank of England, and the US central bank is the Federal Reserve.\n\nChannel\n\nAn upward or downward trend on a chart where the boundaries are marked by two straight lines. A break above or below the channel lines signals a potential change in trend.\n\nCharting\n\nA range of techniques that use past price charts, along with other indicators, to anticipate future price movements.\n\nCl",
        "source": "knowledge_2.txt"
    },
    {
        "text": "icators, to anticipate future price movements.\n\nClose out\n\nSelling a buy position or buying back a sell position, which closes the position, so that you no longer have any exposure to changes in the market price.\n\nClosed position\n\nAn equal and opposite transaction (for instance buying 1000 BT shares then selling 1000 BT shares) which results in the position automatically being closed.\n\nClosing price\n\nThe closing price is the last price for a tradable instrument at the time the market closes.\n\nCommission\n\nA ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ent at the time the market closes.\n\nCommission\n\nA fee charged by a broker or agent for carrying out transactions/orders.\n\nCommodity\n\nA physical good, such as food, metal or fuel, that is interchangeable with other commodities of the same type. The quality of a commodity may differ slightly, but it is basically uniform across all producers, as any commodities that are traded on an exchange must meet specific minimum standards. A commodity is any basic good that investors can ‘buy’ or ‘sell’. Some popular com",
        "source": "knowledge_2.txt"
    },
    {
        "text": "at investors can ‘buy’ or ‘sell’. Some popular commodities include: crude oil, coffee, gold, natural gas, silver, corn, sugar, cotton and wheat.\n\nConsumer Price Index (CPI)\n\nAn index that measures changes in the price of goods and services purchased by consumers. The figure measures the average change over time in the price of a sample of various common goods and services purchased by typical urban households.\n\nContango\n\nA situation where the futures price of a product is above the expected future spot pric",
        "source": "knowledge_2.txt"
    },
    {
        "text": "f a product is above the expected future spot price. Also see Backwardation.\n\nContract (unit or lot)\n\nThe standard trading unit on certain exchanges. For stock index, forex and commodity positions, it is the amount of base currency profit or loss per point movement in the market.\n\nContract for difference (CFD)\n\nContracts for difference (CFDs) are derivative products which enable you to trade on the price movement of underlying financial assets (such as indices, shares and commodities). A CFD is an agreement",
        "source": "knowledge_2.txt"
    },
    {
        "text": "es, shares and commodities). A CFD is an agreement to exchange the difference in the value of an asset from the time the contract is opened until the time at which it is closed. With a CFD, you never actually own the asset or instrument you have chosen to trade, but can still benefit from, if the market moves in your favour.\n\nControlled risk\n\nA position which has a strictly limited maximum loss by virtue of a guaranteed stop. Also see Limited risk.\n\nCore inflation\n\nA measure of inflation that excludes items",
        "source": "knowledge_2.txt"
    },
    {
        "text": "lation\n\nA measure of inflation that excludes items that are subject to volatile price movements. Vegetable prices are an example of items where prices fluctuate widely based on seasonal conditions. These products are excluded from the calculation as they can give a false measure of inflation because prices can diverge from the overall trend.\n\nCorporate Action\n\nAny event initiated by a corporation which impacts its shareholders. For some events, shareholders may or must respond to the corporate action or sel",
        "source": "knowledge_2.txt"
    },
    {
        "text": "may or must respond to the corporate action or select from a list of possible actions. Examples of corporate actions include dividend payments, mergers, rights issues and stock splits. Also see Dividend and Rights issue.\n\nCross currency\n\nA pair of currencies traded in forex that do not include the US dollar, for example EUR/JPY.\n\nCross rate\n\nAn exchange rate between two currencies, both of which are not the official currency of the country in which it is quoted. Also refers to currency quotes that don’t inv",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ted. Also refers to currency quotes that don’t involve the US dollar.\n\nCrossed price\n\nA situation where the bid price exceeds the offer price. This is usually indicative of an issue on the venue or of the market being in an auction period.\n\nCurrency pair\n\nRefers to the price quotation of currencies traded in the foreign exchange market. To determine the value of a currency, it must be compared to the currency of another country (example GBP/USD). In currency pairs, the price amount shows how much of the sec",
        "source": "knowledge_2.txt"
    },
    {
        "text": " pairs, the price amount shows how much of the second currency is required to buy one unit of the first currency.\n\nD\nDaily charts\n\nCharts that encapsulate the daily price movement of an instrument, for example a currency pair, index or share.\n\nData releases\n\nGlobal economic statistics that are normally released at regular intervals, often monthly. The data can have a varying impact on the financial market, depending on factors such as when it‘s released and the level of economic insight it provides.\n\nDAX 40",
        "source": "knowledge_2.txt"
    },
    {
        "text": "the level of economic insight it provides.\n\nDAX 40\n\nA market capitalisation weighted index of the top 40 companies listed on the Frankfurt Stock Exchange in Germany. This is referred to as the ’Germany 40’ on our website and trading platform.\n\nDay order\n\nAn order to buy or sell an instrument that will expire automatically at the end of the day if it’s not executed on the day the order has been placed.\n\nDay trading\n\nThe process of entering and closing out trades within the same day or trading session.\n\nDeali",
        "source": "knowledge_2.txt"
    },
    {
        "text": "des within the same day or trading session.\n\nDealing spread\n\nThe difference between the buying and selling price of a contract.\n\nDeposit\n\nThe funds required to initiate and maintain an open CFD trading position. Since CFDs are traded on margin, the deposit is only a fraction of the full value of the trade and is not the total amount that can be lost on a trade.\n\nDepreciation\n\nA fall in the value of an asset.\n\nDiversification\n\nAn investment strategy that aims to manage risk through variety within an investor",
        "source": "knowledge_2.txt"
    },
    {
        "text": " to manage risk through variety within an investor's trading portfolio. Different components are chosen from a range of different industry sectors, so it’s unlikely that all of the investments will fluctuate in the same direction. The idea is that the portfolio as a whole will display more consistent, stable results than any of the individual components in the portfolio.\n\nDividend\n\nThat part of a company’s profit after tax that is distributed to its shareholders. Dividends are usually distributed in cash, b",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ders. Dividends are usually distributed in cash, but can also take the form of stocks. Also known as payouts.\n\nDividends\n\nA dividend is a distribution of a portion of a company's earnings, decided by the board of directors, to a class of its shareholders. Dividends can be issued as cash payments, as shares of stock, or other property.\n\nDove, dovish\n\nThe opposite of hawk, a dove refers to an economic policy advisor supporting monetary policies with lower interest rates as a means of encouraging economic grow",
        "source": "knowledge_2.txt"
    },
    {
        "text": "rest rates as a means of encouraging economic growth.\n\nDow Jones Industrial Average (Dow)\n\nThe Dow is the second oldest stock market index in the US and the most widely used indicator of the overall condition of the US stock market. It measures the performance of a selection of 30 blue-chip, publicly owned companies in the US.\n\nDowntrend\n\nA price trend characterised by a series of lower highs and lower lows.\n\nE\nEconomic driver\n\nChange in the economy that leads to changes in the market price of investments, ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ds to changes in the market price of investments, such as shares, commodities or property.\n\nEconomic indicator\n\nA government-issued statistic that indicates current economic growth and stability. Common indicators include employment rates, gross domestic product (GDP), inflation and retail sales.\n\nElectronic Currency Network (ECN)\n\nA virtual exchange for FX transactions.\n\nElliott wave theory\n\nDeveloped by RN Elliott, the Elliott Wave theory is a method of technical analysis based on the assumption of predic",
        "source": "knowledge_2.txt"
    },
    {
        "text": "chnical analysis based on the assumption of predictability, by identifying a certain flow and structure to the price movement of financial instruments.\n\nEquity\n\nA stock or share representing an ownership interest.\n\nEuro\n\nThe monetary unit of the eurozone, currently used by 19 European Union countries (Germany, France, Italy, Spain, Portugal, Belgium, The Netherlands, Luxembourg, Austria, Ireland, Finland, Greece, Cyprus, Malta, Slovakia, Slovenia, Estonia, Latvia and Lithuania).\n\nEx-dividend date\n\nThe first",
        "source": "knowledge_2.txt"
    },
    {
        "text": "atvia and Lithuania).\n\nEx-dividend date\n\nThe first trading day on which the buyer of a share is no longer entitled to payment of the current dividend.\n\nExchange\n\nA marketplace in which securities, commodities, derivatives and other financial instruments are traded. The core function of an exchange - such as a stock exchange - is to ensure fair and orderly trading, as well as efficient dissemination of price information for any securities trading on that exchange. Exchanges give companies, governments and ot",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ange. Exchanges give companies, governments and other groups a platform to sell securities to the investing public. An exchange may be a physical location where traders meet to conduct business or an electronic platform.\n\nExecute and eliminate order\n\nA limit order to execute at the current market price or worse. If the order is not filled in its entirety down to the specified order level then any remaining balance will be cancelled.\n\nExecution-only stockbroker\n\nStockbroker who offers clients an inexpensive ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "er\n\nStockbroker who offers clients an inexpensive trading facility without advice, research or recommendations pertaining to investment style or policy.\n\nExpiration date\n\nThe last date that a particular contract can be traded.\n\nExpiration/ Expiry\n\nSome CFD markets have a fixed duration. For example futures contracts will expire at a pre-specified date and time in the future. At this point a futures contract is said to have expired and is awaiting settlement. Settlement is when the expired contract is closed",
        "source": "knowledge_2.txt"
    },
    {
        "text": " Settlement is when the expired contract is closed at a level normally relating to the market at the time of expiry.\n\nExposure\n\nThe level of an investment which is at risk. The higher the exposure, the bigger the potential loss or gain.\n\nF\nFair value\n\nThe premium (or discount) of a futures contract against its underlying spot/cash instrument that normally consists of an interest and dividend component. The fair value represents the rational pricing of a futures contract such that no arbitrage opportunity ex",
        "source": "knowledge_2.txt"
    },
    {
        "text": "res contract such that no arbitrage opportunity exists between the futures and cash.\n\nFibonacci\n\nTechnical analysis ratios used in trading to identify future price movements – named after mathematician Leonardo Fibonacci. The most popular Fibonacci tools are retracements and extensions.\n\nFill\n\nThe execution of an order.\n\nFill or kill order\n\nA limit order that will only be executed if it can be filled entirely to your specified order level. Otherwise it will be cancelled.\n\nFinancial Conduct Authority (FCA)\n\n",
        "source": "knowledge_2.txt"
    },
    {
        "text": "be cancelled.\n\nFinancial Conduct Authority (FCA)\n\nThe authority responsible for supervising financial services firms in the UK. One of the FCA’s roles is to regulate the conduct of brokers and dealers in securities, options, shares, spread bets and CFDs so clients get a fair deal.\n\nFinancing costs\n\nCFD share positions carried overnight will incur financing costs for the full consideration of the position. If you open a position with a 5% margin, overnight finance will be based on 100% of the balance. Client",
        "source": "knowledge_2.txt"
    },
    {
        "text": "nance will be based on 100% of the balance. Clients who hold a long position will pay interest; clients who are short may receive interest.\n\nFiscal policy\n\nFiscal policy refers to governments’ spending policies, which have a significant impact on the overall economy. The policy affects government revenue and spending. When a government runs a deficit (spends more than it earns), it is putting more into the economy than it is taking out, adding to gross domestic product (GDP).\n\nFlexible spread\n\nThe differenc",
        "source": "knowledge_2.txt"
    },
    {
        "text": "tic product (GDP).\n\nFlexible spread\n\nThe difference between the bid and offer price that a broker can adjust according to market conditions. Also known as dynamic spread, floating spread or variable spread.\n\nFloating profit/ loss\n\nCurrent profit/loss on open positions calculated at current prices.\n\nForeign exchange\n\nThe forex market is made up of banks, commercial companies, central banks, investment management firms, hedge funds, retail forex brokers and investors. It’s a financial market for trading inter",
        "source": "knowledge_2.txt"
    },
    {
        "text": "vestors. It’s a financial market for trading international currencies. Investors speculate on the relative strength of one currency against another by buying the currency of one country and selling it against another.\n\nForward\n\nA forward trade (or contract) is the price of an asset for delivery at a defined future date, which is also the date of expiry. Most forward trades can be closed prior to the expiry date, to limit any loss or take a profit, for example. FX forwards are a common example of this type o",
        "source": "knowledge_2.txt"
    },
    {
        "text": "e. FX forwards are a common example of this type of contract.\n\nFree margin\n\nFunds on the trading account which may be used to open a position. It’s calculated as account value less necessary margin.\n\nFTSE 100\n\nA market capitalisation weighted index of the top 100 companies listed on the London Stock Exchange. This is often used as an indicator to assess the broader UK market.\n\nFundamental analysis\n\nThis involves analysing and valuing financial assets based on factors such as news, financial statements and e",
        "source": "knowledge_2.txt"
    },
    {
        "text": "n factors such as news, financial statements and earnings forecasts, company strategy and risk assessments, demand and supply forecasts, projections of future economic growth, industry developments and government policy. In fundamental analysis, an investor uses real data to evaluate a stock’s value rather than using charts and technical analysis to make trading decisions.\n\nFutures\n\nA future rate is notionally an agreement to conduct a transaction at some specified time in the future, with the price agreed ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ecified time in the future, with the price agreed now. A futures CFD will automatically expire at a specified time in the future, whereas a spot or cash CFD has no such expiry time. Often the price of a future contract will differ from the cash price. Also see Fair value, Expiration/expiry.\n\nG\nGapping\n\nThe phenomenon of a market trading at a price away from the previous traded price without trades occurring at intervening prices; it more usually, but not necessarily, relates to when a market resumes trading",
        "source": "knowledge_2.txt"
    },
    {
        "text": "essarily, relates to when a market resumes trading after a period of closure. Also see Slippage.\n\nGearing\n\nGearing is a measure of leverage used, usually expressed as a percentage. A highly leveraged trade would require a small initial outlay in comparison to the notional value of the trade, and can be seen as high risk. Small price movements create amplified gains or losses, and therefore losses can exceed deposits made. Also see Leverage.\n\nGood-for-day (day order)\n\nAn order type that will expire if not fi",
        "source": "knowledge_2.txt"
    },
    {
        "text": "y order)\n\nAn order type that will expire if not filled by the end of the day. See also Order to open, Good-till-cancelled, Fill.\n\nGood-till-cancelled (GTC)\n\nUnlike good-for-day orders, GTC orders remain active on the account waiting for a fill unless cancelled before being filled. See also Order to open, Good-for-day, Fill.\n\nGreenback\n\nA slang term for the US dollar.\n\nGross domestic product (GDP)\n\nGDP is the value of goods and services produced in a country including exports, minus imports made. It’s a meas",
        "source": "knowledge_2.txt"
    },
    {
        "text": "including exports, minus imports made. It’s a measurement of a country’s overall economic activity, and can also be a gauge for its standard of living.\n\nGuaranteed stop-loss order (GSLO)\n\nA stop-loss order is an order to buy or sell when the market reaches the 'stop' price, which allows you to limit your losses. Unlike a standard stop-loss order, a guaranteed stop-loss order (GSLO) is unaffected by slippage or gapping and guarantees the price your trade will be closed out at. There is a premium to pay when ",
        "source": "knowledge_2.txt"
    },
    {
        "text": " be closed out at. There is a premium to pay when placing the GSLO with us; however we will refund this in full if the trade is closed out without the GSLO being executed.\n\nH\nHawk, hawkish\n\nAn economic policy advisor who favours relatively higher interest rates to keep inflation under control or curb rapid economic growth. See also Dove.\n\nHedge\n\nA way of reducing the risk of losses that may occur if interest rates, share prices or foreign exchange rates move in the wrong direction. This usually involves the",
        "source": "knowledge_2.txt"
    },
    {
        "text": " in the wrong direction. This usually involves the use of CFD or futures contracts.\n\nHolding costs\n\nPositions that are held open past 17:00 New York time will incur holding costs. These holding costs will be calculated based on the notional potentially size of the position. Also see Financing costs.\n\nI\nIlliquid market\n\nA market with relatively less aggregate volume in the order book. In an illiquid market, a small amount of business often moves prices by a disproportionate amount, and bid and offer prices c",
        "source": "knowledge_2.txt"
    },
    {
        "text": "isproportionate amount, and bid and offer prices can be far apart.\n\nIlliquidity\n\nThe difficulty of changing your assets to cash because of a lack of demand for the asset you're trying to sell. As a market maker, we provide liquidity by constantly quoting a bid and offer spread. Also see Liquidity.\n\nIndex\n\nAn index, such as the FTSE 100 or S&P 500, gauges the prosperity or value of a section of the stock market. It is calculated from the prices of selected stocks, usually using a weighted average. It is not ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ocks, usually using a weighted average. It is not possible to invest directly in an index; instead investors trade in funds or other products that track the movement of an index.\n\nIndustrial production\n\nA monthly economic indicator that measures changes in output for the UK’s industrial sector, including manufacturing, mining and utilities.\n\nInflation\n\nAn increase in the general price of goods and services.\n\nInflation rate\n\nA measure of inflation that occurs in a given period (a year or calendar quarter for",
        "source": "knowledge_2.txt"
    },
    {
        "text": " in a given period (a year or calendar quarter for example). The inflation rate shows us how quickly the general price of goods and services is rising.\n\nInitial Public Offering (IPO)\n\nThe process by which a company is floated on the stock market for the first time. Offering shares to the investment public is a way of raising capital for further expansion. Also known as New issue.\n\nInstant execution\n\nAn order that is executed at the price displayed on the screen. If the price isn’t available a requote can be",
        "source": "knowledge_2.txt"
    },
    {
        "text": "een. If the price isn’t available a requote can be offered as a new two-way price, at which you can resubmit the order or choose to cancel it.\n\nInterbank rates\n\nFX rates quoted to each other by international banks.\n\nInterest\n\nCash adjustments made to reflect the economic effect of owing or receiving the notional amount of equity controlled by a CFD position.\n\nIntraday trading\n\nTrading where positions are opened and then closed out within the same trading day.\n\nJ\nJapanese candlestick charts\n\nJapanese candles",
        "source": "knowledge_2.txt"
    },
    {
        "text": ".\n\nJ\nJapanese candlestick charts\n\nJapanese candlestick charts are similar to bar charts in that each ‘candle’ shows the opening price, closing price, high price and low price for the period. The candles are either green or red, depending on whether the closing price is higher than the opening price (green) or below it (red). The main body, or ‘wax’, represents the range between the opening and closing price and the ‘wicks’ show the highs and lows.\n\nK\nKiwi\n\nA slang term often used to reference the New Zealan",
        "source": "knowledge_2.txt"
    },
    {
        "text": " slang term often used to reference the New Zealand dollar (or NZD), which is New Zealand's base unit of currency.\n\nL\nLast dealing day\n\nThe last day on which you may trade in a particular market. This may or may not coincide with the settlement date for that market.\n\nLeverage\n\nLeverage allows traders to gain a large exposure with a relatively small outlay. This has the effect of amplifying profit or loss. A leverage of 1:100 means that in order to open and maintain a position the necessary margin is one hun",
        "source": "knowledge_2.txt"
    },
    {
        "text": "aintain a position the necessary margin is one hundred times less than the transaction size.\n\nLibor (London InterBank Offered Rate)\n\nThe interest rate charged between banks in London for short-term loans and a key benchmark that influences many other interest rate charges/products. Individual currency denominations have an associated Libor. It is produced for ten currencies with 15 maturities quoted for each, ranging from overnight to 12 months, producing 150 rates each business day.\n\nLimit order\n\nA limit o",
        "source": "knowledge_2.txt"
    },
    {
        "text": "0 rates each business day.\n\nLimit order\n\nA limit order is an order to buy or sell a product at a specific price. A limit order to buy at a target price with CMC Markets is executed at the target price or lower, when the buy price is equal to or lower than the target price. A limit order to sell at a target price with CMC Markets is executed at the target price or higher, when the sell price is equal to or higher than the target price.\n\nLimited risk\n\nA trade which has a strictly limited maximum loss. Also se",
        "source": "knowledge_2.txt"
    },
    {
        "text": "which has a strictly limited maximum loss. Also see Controlled risk.\n\nLine charts\n\nLine charts are created by connecting a series of data points, usually past price closes, with a line. They are the most basic type of charts used in financial markets.\n\nLiquid market\n\nA liquid market has sufficient volume of two-way business for a large transaction to occur with little or no impact on price. Such a market will normally exhibit tight bid-offer spreads.\n\nLiquidity\n\nThe level of continual buy and sell activity ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ity\n\nThe level of continual buy and sell activity making up market demand and indicating the ease with which investors can undertake transactions.\n\nLiquidity providers\n\nA liquidity provider is an individual or institution which acts as a market maker in a given asset class. In the world of Forex the majority of global liquidity is provided by a number of big name investment banks (referred to as Tier 1 liquidity providers).\n\nLog file\n\nAn ongoing journal of your trading activity.\n\nLong position\n\nA position t",
        "source": "knowledge_2.txt"
    },
    {
        "text": "our trading activity.\n\nLong position\n\nA position taken in anticipation of a rising market. To go long means to open a ‘buy’ position.\n\nLong-term trading\n\nIn the context of CFDs, longer-term trading refers to strategies where the average duration of open positions would be between a week and several months.\n\nLoonie\n\nA slang term for the Canadian dollar.\n\nLot size\n\nIt is the standardised quantity of a financial instrument, such as base currency, underlying asset or shares, per contract.The last day on which y",
        "source": "knowledge_2.txt"
    },
    {
        "text": "et or shares, per contract.The last day on which you may trade in a particular market. This may or may not coincide with the settlement date for that market.\n\nLeverage\n\nLeverage allows traders to gain a large exposure with a relatively small outlay. This has the effect of amplifying profit or loss. A leverage of 1:100 means that in order to open and maintain a position the necessary margin is one hundred times less than the transaction size.\n\nLibor (London InterBank Offered Rate)\n\nThe interest rate charged ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "nterBank Offered Rate)\n\nThe interest rate charged between banks in London for short-term loans and a key benchmark that influences many other interest rate charges/products. Individual currency denominations have an associated Libor. It is produced for ten currencies with 15 maturities quoted for each, ranging from overnight to 12 months, producing 150 rates each business day.\n\nLimit order\n\nA limit order is an order to buy or sell a product at a specific price. A limit order to buy at a target price with CM",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ce. A limit order to buy at a target price with CMC Markets is executed at the target price or lower, when the buy price is equal to or lower than the target price. A limit order to sell at a target price with CMC Markets is executed at the target price or higher, when the sell price is equal to or higher than the target price.\n\nLimited risk\n\nA trade which has a strictly limited maximum loss. Also see Controlled risk.\n\nLine charts\n\nLine charts are created by connecting a series of data points, usually past ",
        "source": "knowledge_2.txt"
    },
    {
        "text": " connecting a series of data points, usually past price closes, with a line. They are the most basic type of charts used in financial markets.\n\nLiquid market\n\nA liquid market has sufficient volume of two-way business for a large transaction to occur with little or no impact on price. Such a market will normally exhibit tight bid-offer spreads.\n\nLiquidity\n\nThe level of continual buy and sell activity making up market demand and indicating the ease with which investors can undertake transactions.\n\nLiquidity p",
        "source": "knowledge_2.txt"
    },
    {
        "text": "investors can undertake transactions.\n\nLiquidity providers\n\nA liquidity provider is an individual or institution which acts as a market maker in a given asset class. In the world of Forex the majority of global liquidity is provided by a number of big name investment banks (referred to as Tier 1 liquidity providers).\n\nLog file\n\nAn ongoing journal of your trading activity.\n\nLong position\n\nA position taken in anticipation of a rising market. To go long means to open a ‘buy’ position.\n\nLong-term trading\n\nIn th",
        "source": "knowledge_2.txt"
    },
    {
        "text": "o open a ‘buy’ position.\n\nLong-term trading\n\nIn the context of CFDs, longer-term trading refers to strategies where the average duration of open positions would be between a week and several months.\n\nLoonie\n\nA slang term for the Canadian dollar.\n\nLot size\n\nIt is the standardised quantity of a financial instrument, such as base currency, underlying asset or shares, per contract.\n\nM\nMajor currency pairs\n\nThe most heavily traded currency pairs in the FX market, including: EUR/USD, USD/JPY, GBP/USD and USD/CHF.",
        "source": "knowledge_2.txt"
    },
    {
        "text": " including: EUR/USD, USD/JPY, GBP/USD and USD/CHF.\n\nMargin\n\nCFD trading requires investors to deposit a small percentage of the overall cost that would be required if they were to purchase outright the equivalent product in the physical market. Even though the investor’s outlay is small in comparison to the value of the whole position, the investor will still be exposed to the same potential profit and loss. This means that your potential return on investment is magnified, as are your potential losses. Some",
        "source": "knowledge_2.txt"
    },
    {
        "text": "t is magnified, as are your potential losses. Sometimes called 'variation margin'.\n\nMargin call\n\nA broker's request to an investor using margin to deposit additional funds. Margin calls occur when an account's funds fall to a specific value calculated by the broker, or if one or more of the products bought, effectively with borrowed money, decreased in value past a certain point.\n\nMark-to-market\n\nThe daily adjustment of an account to reflect accrued profits and losses often required to calculate variations ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "and losses often required to calculate variations in margins.\n\nMarket capitalisation (MCAP)\n\nMarket capitalisation refers to the value of a company’s shares. The figure is reached by multiplying the number of shares that have been issued by the current share price. Investors find the MCAP figure useful for determining the size of a company.\n\nMarket execution\n\nAn order that is executed at the best price available in the market, with no requotes.\n\nMarket order\n\nAn order that you use to specify the direction a",
        "source": "knowledge_2.txt"
    },
    {
        "text": "\n\nAn order that you use to specify the direction and size of a trade, but not the price. This ensures your order will be filled as quickly as possible.\n\nMarket-making\n\nThe process of quoting a bid and offer based on speculation, expectation, supply and demand.\n\nMedium-term trading\n\nIn the context of CFDs, this refers to strategies where the trader is prepared to hold positions open for longer than one day but where the average duration of open positions would be no more than a few weeks.\n\nMid-price\n\nThe bid",
        "source": "knowledge_2.txt"
    },
    {
        "text": "d be no more than a few weeks.\n\nMid-price\n\nThe bid plus the offer, divided by two.\n\nMonetary policy\n\nThe action of central banks to set interest rates and control the amount of money in an economy, with the aim of keeping inflation and unemployment at acceptable levels.\n\nMoving average\n\nThe graphical representation of a smoothed-out price action over a set period of time. Moving averages can help identify a trend, points of entry and potential target levels for stops.\n\nMoving Average Convergence Divergence ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "for stops.\n\nMoving Average Convergence Divergence (MACD)\n\nA chart indicator used in technical analysis to indicate a potential bullish or bearish trend reversal.\n\nN\nNasdaq\n\nThe Nasdaq is the second largest stock exchange in the US and traditionally lists many technology companies, such as Microsoft. The movements of the Nasdaq can have a significant effect on UK markets, particularly the techMARK index of technology, media and telephony companies.\n\nNew issue\n\nA company that is floated on the stock market fo",
        "source": "knowledge_2.txt"
    },
    {
        "text": "\n\nA company that is floated on the stock market for the first time. Offering shares to the investing public is a way of raising capital for further expansion. Also known as Initial Public Offering (IPO).\n\nNew York Stock Exchange (NYSE)\n\nThe largest and oldest stock exchange in the US.\n\nNikkei 225\n\nA price-weighted index of the top 225 shares listed on the Tokyo stock exchange.\n\nNon-dealing desk (NDD)\n\nAn execution model that allows you to trade directly with numerous market liquidity providers in order to g",
        "source": "knowledge_2.txt"
    },
    {
        "text": " numerous market liquidity providers in order to get the most competitive bid and ask prices.\n\nNon-farm payrolls\n\nA notable economic indicator normally released on the first Friday of every month by the US Department of Labor. It presents the number of people on the payrolls of all businesses, with the exception of agricultural, local government, private household and non-for-profit. The monthly figure can change significantly, and often leads to a high level of volatility in FX pairs such as EUR/USD, aroun",
        "source": "knowledge_2.txt"
    },
    {
        "text": "l of volatility in FX pairs such as EUR/USD, around the time of the release. Generally, a high reading is seen as positive (or bullish) for the US dollar, while a low reading is seen as negative (or bearish).\n\nO\nOCO (one cancels the other)\n\nLets you place a sell limit and sell stop order on the same stock at the same time. When either order is executed the other will automatically be cancelled. Also applies to a buy limit and buy stop order.\n\nOffer\n\nA current market price is made up of a level at which you ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "t market price is made up of a level at which you can sell and a level at which you can buy. The level at which you can buy is always the higher of the two prices and is called the offer. Also known as bid/bid price, as on B-Bid, you also mentioned it was known as offer/offer price.\n\nOffer price\n\nThe price at which the seller is willing to sell at. Also known as bid/bid price, as on B-Bid, you also mentioned it was known as offer/offer price.\n\nOnline trading\n\nThe act of buying or selling financial instrumen",
        "source": "knowledge_2.txt"
    },
    {
        "text": "\n\nThe act of buying or selling financial instruments via the internet using a broker like CMC Markets’ online trading platform.\n\nOpen position\n\nA long or short position which has not been closed out by an equal and opposite position.\n\nOption\n\nThe right, but not the obligation, to buy (‘call option’) or sell (‘put option’) a specific amount of a given stock, commodity, currency, or index at a specified price (the ‘strike price’) during a specified period of time. For the holder, the potential loss is limited",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ime. For the holder, the potential loss is limited to the price paid to acquire the option. When an option is not exercised, it expires.\n\nOrder / order to open\n\nAn instruction by a customer to a broker/trader to buy or sell should a specified price be reached. The order remains valid until executed or cancelled by the customer.\n\nOrder book\n\nWhen bid and offer prices match, new incoming orders are automatically logged against orders on the book. FTSE 100 stocks have been traded on an electronic order book si",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ks have been traded on an electronic order book since 20 October 1997\n\nOscillator\n\nA leading indicator in chart analysis which shows a potential trend reversal before it occurs.\n\nOut-of-hours\n\nOut-of-hours – or extended hours – trading usually refers to trading on an index outside of its main opening hours. At CMC Markets, you can trade on the UK 100, Germany 30, France 40 and Euro 50, 24-hours-a-day from Sunday evening to Friday evening.\n\nOver-the-counter market (OTC)\n\nRefers to trading that is carried out",
        "source": "knowledge_2.txt"
    },
    {
        "text": "arket (OTC)\n\nRefers to trading that is carried out directly between two parties, without any supervision of an exchange.\n\nP\nPip\n\nNormally used in reference to forex rates, a 'percentage in point' is generally, though not always, the fourth decimal place, ie 0.0001. Traditionally a pip was the smallest point by which a forex rate could move, but this is no longer the case.\n\nPivot points\n\nUsed in technical analysis, pivot points use the previous period’s high, low and close to calculate the current period’s s",
        "source": "knowledge_2.txt"
    },
    {
        "text": " low and close to calculate the current period’s support and resistance levels.\n\nPortfolio\n\nA collection of investments owned by an individual or company.\n\nPosition\n\nAn open trade that you have in the market.\n\nPosition margin\n\nThe amount of equity that a CFD trader is required to pay in order to open a new position.\n\nPosition sizing\n\nThe size of a position within a particular portfolio. It’s also associated with a risk management technique where an investor calculates the size of each new position so that t",
        "source": "knowledge_2.txt"
    },
    {
        "text": "calculates the size of each new position so that the maximum likely loss on the position does not exceed a certain amount or a certain percentage of their capital.\n\nProducer Price Index (PPI)\n\nA statistic that measures changes in the price of finished goods and services sold by producers.\n\nProfit and Loss (P&L)\n\nAbbreviation of profit and loss; an account compiled at the end of an accounting period to show gross and net profit or loss. In CFD trading, it shows money gained or loss incurred on a position.\n\nP",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ws money gained or loss incurred on a position.\n\nPurchasing Managers Index (PMI)\n\nAn indicator of economic activity created through surveys completed by mangers in a number of manufacturing companies. It provides a picture of economic conditions within the manufacturing sector, and is often used by investors to predict future GDP numbers for a country's economy.\n\nQ\nQuantitative easing\n\nA measure adopted by central banks to stimulate an economy when traditional monetary policy measures (like cutting interest",
        "source": "knowledge_2.txt"
    },
    {
        "text": "al monetary policy measures (like cutting interest rates) have failed. The central bank electronically creates funds in its own bank account to purchase previously-issued government bonds, plus private sector and distressed assets (so companies can raise capital). This serves to create more tradable and liquid markets to help stimulate the economy.\n\nQuarterly CFDs\n\nA type of future with periodic expiries spaced three months apart. Prices are normally quoted for the next two or three quarter months. Also see",
        "source": "knowledge_2.txt"
    },
    {
        "text": "for the next two or three quarter months. Also see Rollover.\n\nQuote\n\nThe two-way market price for a given instrument; because it’s two-way, you can buy or sell, according to whether you think prices will rise or fall.\n\nQuote currency\n\nThe second currency in a pair (for example USD is the counter currency in GBP/USD). Also see Base currency.\n\nR\nRange\n\nWhere the price moves within a defined boundary.\n\nRealised profit/loss\n\nThe amount of money you have made or lost on a position once it has been closed. Realis",
        "source": "knowledge_2.txt"
    },
    {
        "text": "lost on a position once it has been closed. Realised profit or loss will add to or subtract from your account cash balance.\n\nRelative strength index (RSI)\n\nA chart indicator used in technical analysis. It identifies when trends are coming to the end of their current direction, as well as overbought and oversold market conditions.\n\nRequote\n\nA requote occurs when you request to execute an order at a specific price that is no longer available and you’re offered a different quote. This can happen during fast-mo",
        "source": "knowledge_2.txt"
    },
    {
        "text": " a different quote. This can happen during fast-moving markets.\n\nResistance level\n\nA term used in technical analysis indicating a price level at which analysis suggests a predominance of selling – and hence a greater likelihood that the price will fail to break through the level.\n\nRetail sales\n\nThis figure represents the total of durable and non-durable goods sales by retailers to consumers. Services are largely excluded from this statistic.\n\nRights issue\n\nAn additional issue of shares by a company to exist",
        "source": "knowledge_2.txt"
    },
    {
        "text": "n additional issue of shares by a company to existing shareholders at an advantageous, discounted price, usually in order to raise new funds for further development or to finance a new acquisition. A two for five rights issue at 145 cents means that the existing shareholder has the right to acquire a further two shares for every five currently held at a new cost of 145 cents per share acquired.\n\nRollover\n\nClosing an expiring futures position and reopening the position in the next tradeable future. In forex,",
        "source": "knowledge_2.txt"
    },
    {
        "text": "e position in the next tradeable future. In forex, the value of the process is measured by the interest rate differential between the two currencies. There’s usually a small cost for rolling over positions.\n\nRunning profit/loss\n\nShows how your open positions are performing: the unrealised money that you would gain or lose on your open positions if they were closed at prevailing market prices.\n\nS\nS&P 500\n\nA market capitalisation weighted index of the top 500 companies listed in the New York stock exchange (N",
        "source": "knowledge_2.txt"
    },
    {
        "text": "companies listed in the New York stock exchange (NYSE) or the NASDAQ. Often used as a gauge of sentiment for the US market.\n\nScalping\n\nA trading strategy that involves placing short-term trades, sometimes less than a minute long, usually to try and capture small price movements.\n\nSector\n\nA distinct subset of a market whose components share similar characteristics. Stocks are often grouped into different sectors depending upon the company's business. For example the FTSE 100 has banking, oil & gas and pharma",
        "source": "knowledge_2.txt"
    },
    {
        "text": "ple the FTSE 100 has banking, oil & gas and pharmaceutical sectors.\n\nSell limit / limit sell\n\nA conditional trading order that indicates an instrument may be sold only at the designated price or higher.\n\nSell stop\n\nAn order to open a sell position at a price lower than the price at the moment of placing the order. It is subject to price depth ladder and can be slipped to the current market price.\n\nSelling short\n\nThis is practice of selling shares that you do not own in the hope that the share price falls be",
        "source": "knowledge_2.txt"
    },
    {
        "text": " not own in the hope that the share price falls before you have to settle the contract. If the price does fall you can then buy the shares at the lower price and pocket the difference. Also see Shorting.\n\nSettlement\n\nThe process of a position closing against a specified market level once the position has gone beyond its last dealing time. Also see Expiry.\n\nShorting\n\nA form of trading where the initial transaction is to sell, for example a CFD position taken in anticipation of a falling market. The position ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "in anticipation of a falling market. The position is closed with a buy trade. The trader will profit if the price falls and lose if it rises. When trading FX it refers to selling the base currency against the quote currency.\n\nSlippage\n\nThe difference between the requested level of an order and the actual price at which it was executed. Slippage can occur during periods of higher volatility when market prices move rapidly or gap. Also see Fill and Gapping.\n\nSpot price\n\nThe price quoted for immediate settleme",
        "source": "knowledge_2.txt"
    },
    {
        "text": "pot price\n\nThe price quoted for immediate settlement or delivery of a currency, index, commodity or share (that is payment for and delivery of a product). It’s the current price at which a commodity or currency can be bought or sold at that specific time.\n\nSpot rate\n\nAn exchange rate for immediate settlement.\n\nSpread\n\nThe difference between the bid and the ask price of a security or asset.\n\nSpread charts\n\nSpread charts show the buy and sell prices plotted into a dual line chart format. A blue line represent",
        "source": "knowledge_2.txt"
    },
    {
        "text": "to a dual line chart format. A blue line represents the buy price and an orange line represents the sell price; the shaded area is the difference between the two, or ‘the spread’.\n\nStochastic\n\nA chart indicator used in technical analysis to determine potential trend reversals, indicating an overbought or oversold market condition.\n\nStock exchange\n\nA market on which securities are traded.\n\nStock index\n\nStock indices are a compilation of a number of stocks into one total price, allowing investors to easily fo",
        "source": "knowledge_2.txt"
    },
    {
        "text": "o one total price, allowing investors to easily follow the performance of certain groups of stocks.\n\nStockbroker\n\nAn exchange member firm which provides advice and dealing services to the public as well as trading on its own account.\n\nStop entry order\n\nStop-entry orders allow you to enter a transaction at a selected target price and within a set time period. A stop-entry order to buy is an order at a price above the prevailing market price. A stop-entry order to sell is an order at a price below the prevail",
        "source": "knowledge_2.txt"
    },
    {
        "text": "r to sell is an order at a price below the prevailing market price. Stop-entry orders are subject to potential slippage.\n\nStop-loss\n\nAn order placed to automatically close your position when the price reaches your specified stop-loss trigger price. A stop-loss order is designed to limit a loss on a position. This is not always guaranteed, however, as market conditions may cause the trade to be executed at a slightly different price, due to market gapping or slippage. Also known as a stop order.\n\nStop order\n",
        "source": "knowledge_2.txt"
    },
    {
        "text": "slippage. Also known as a stop order.\n\nStop order\n\nAn order to close a position when prices pass a certain point. A stop order can be attached to an existing position (known as a stop-loss) or used to initiate a new position (see Order to open).\n\nStrike price\n\nThe price at which a contract can be exercised or settled against in reference to options trading.\n\nSupport\n\nA price level that the market doesn’t fall below for some time. When prices fall to a support level the weight of buying outweighs selling and",
        "source": "knowledge_2.txt"
    },
    {
        "text": "t level the weight of buying outweighs selling and prices tend to be pushed up again. A number of different trend troughs often occur at a support level.\n\nSupport level\n\nA technique used in technical analysis to indicate a price floor at which you would expect the price to 'bounce' off. A price point where it is anticipated buyers will enter the market and 'support' the price. The opposite of this is resistance.\n\nSwissie\n\nA slang term for the Swiss franc.\n\nT\nTake-profit order\n\nAn order to close an open posi",
        "source": "knowledge_2.txt"
    },
    {
        "text": "\nTake-profit order\n\nAn order to close an open position at a more profitable price than the prevailing market price.\n\ntechMARK\n\nThis market groups together technology companies from across the market. It has its own indices: the FTSE techMARK 100 and the FTSE techMARK All-share.\n\nTechnical analysis\n\nA technique used to try and predict future movements of a security, commodity or currency, based solely on past price movements and volume levels. It examines charts and historical performance to forecast prices ",
        "source": "knowledge_2.txt"
    },
    {
        "text": "rts and historical performance to forecast prices by analysing market data, such as historical price trends, averages and volumes.\n\nTick\n\nA single price movement which can be either positive or negative.\n\nTom-next charges\n\nIn foreign exchange, the cost of holding a position overnight. Short for tomorrow-next, it normally incorporates the interest considerations in simultaneously holding and owing the notional and base currencies as well as being influenced by the relative availability of the associated curr",
        "source": "knowledge_2.txt"
    },
    {
        "text": "y the relative availability of the associated currencies.\n\nTrade balance\n\nThis statistic reveals the difference between a country’s exports and imports of goods and services, such as cars, electronics, textiles, banking and insurance.\n\nTrade size\n\nThe size of the underlying position that you are trading. It governs how much you make or lose on a trade for every point of movement in the price of the market.\n\nTrailing stop\n\nTrailing stops are a special type of stop-loss order that trail behind the market pric",
        "source": "knowledge_2.txt"
    },
    {
        "text": " stop-loss order that trail behind the market price when the market moves in your favour.\n\nTransaction costs\n\nThe costs you incur when trading financial products. These costs include commission (on shares), financing and spreads.\n\nTransaction date\n\nThe date a trade occurs.\n\nTreasury\n\nA bond issued by a government. Bonds issued by the UK government are called gilt-edged stocks, commonly referred to as gilts.\n\nTrend\n\nThe general direction in which prices tend to move.\n\nTrend lines\n\nA straight line drawn acros",
        "source": "knowledge_2.txt"
    },
    {
        "text": "to move.\n\nTrend lines\n\nA straight line drawn across a chart that indicates the overall trend. In an upward trend, the line is drawn below, and acts as a support line; the opposite holds true for a downward trend. Once the asset breaks the trend line, the trend is considered to be invalid.\n\nTwo-way price\n\nWhen both a bid (sell) and offer (buy) rate is quoted for a transaction.\n\nU\nUnderlying\n\nA term used in derivatives trading, such as with CFDs. A derivative is a financial instrument whose price is based (de",
        "source": "knowledge_2.txt"
    },
    {
        "text": "is a financial instrument whose price is based (derived) from a different asset. The underlying is the financial instrument (eg, stock, futures, commodity, currency, index) on which a derivative's price is based.\n\nUnemployment claims\n\nThis statistic represents the number of individuals who filed for unemployment insurance for the first time during the past week. This is the US’s earliest jobs-related economic data release.\n\nUptick\n\nA price quoted that is higher than the previous quote.\n\nV\nVolatility\n\nAn exp",
        "source": "knowledge_2.txt"
    },
    {
        "text": "her than the previous quote.\n\nV\nVolatility\n\nAn explanation of how quickly the price of a market or instrument rises or falls. A highly volatile market can be risky for short-term investors as they risk buying at a peak or selling in a trough at a loss.\n\nW\nWall Street\n\nAn alternative, well-known term for the New York Stock Exchange (NYSE), the largest stock exchange in the US.\n\nWorking an order\n\nThe process of having an order working that has not yet been executed. Also known as a pending order.\n\nX\nXD\n\nXD is",
        "source": "knowledge_2.txt"
    },
    {
        "text": "cuted. Also known as a pending order.\n\nX\nXD\n\nXD is a symbol that is used to signify that a security or stock has gone ex-dividend.\n\nY\nYard\n\nA slang trading term for a billion units.\n\nYield\n\nThe income return earned on an investment. There are a number of different types of yield, and in some cases different methods of calculating each type. Yield refers to the dividends received or interest on a security and is usually an annual figure.\n\nYuan\n\nBase unit of currency in China.\n\nZ\nZloty\n\nPolish unit of currenc",
        "source": "knowledge_2.txt"
    },
    {
        "text": "urrency in China.\n\nZ\nZloty\n\nPolish unit of currency.",
        "source": "knowledge_2.txt"
    },
    {
        "text": "www.koolearn.com\n>>>>>> 新东方在线\n>>1\n新东方在线\n全国硕士研究生考试研究中心\n基础精讲\n黄 达\n金融学\n>>>> 黄达金融学基础精讲\n2<<\n  目  录\n导学………………………………………………………………………………………… 1\n第一章 货币与货币制度…………………………………………………………………… 9\n第二章 国际货币体系与汇率制度………………………………………………………\n15\n第三章 信用、利息与信用形式…………………………………………………………\n22\n第五章 金融中介体系……………………………………………………………………\n26\n第六章 存款货币银行……………………………………………………………………\n32\n第七章 中央银行…………………………………………………………………………\n38\n第八章 金融市场…………………………………………………………………………\n41\n第十章 金融体系结构……………………………………………………………………\n45\n第十二章 利率的决定与作用……………………………………………………………\n49\n第十三章 货币需求……………………………",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "与作用……………………………………………………………\n49\n第十三章 货币需求………………………………………………………………………\n55\n第十四章 现代货币创造机制……………………………………………………………\n59\n第十五章 货币供给………………………………………………………………………\n62\n第十七章 开放经济的均衡………………………………………………………………\n66\n第十九章 货币政策………………………………………………………………………\n73\n第二十章 货币政策与财政政策…………………………………………………………\n79\n第二十一章 开放条件下的政策搭配与协调……………………………………………\n83\n第二十七章 金融发展与经济增长………………………………………………………\n86\n第二十八章 金融脆弱性与金融危机……………………………………………………\n91\n第二十九章 金融监管……………………………………………………………………\n95\nwww.koolearn.com\n>>>>>> 新东方在线\n>>3\n>>>>2020 考研刑法学高分通关讲义\n4<<\n《使用说明》\n该讲义与课程配合使用，讲义并非老",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "3\n>>>>2020 考研刑法学高分通关讲义\n4<<\n《使用说明》\n该讲义与课程配合使用，讲义并非老师授课的逐字稿，课程中\n                         扩展及补充内容请同学们做好笔记。\n                                                                                                                      祝学习愉快！\n                                                                                                                      新东方在线\n>>>> 黄达金融学基础精讲\n4<<\n \n2 \n \n导学 \n \n一、金融学考试大纲 \n二、黄达《金融学》教材介绍 \n三、金融学知识点概览 \n四、课程设置与学习方法 \n \n一\n一、金融学考试大纲 \n1、货币与货币制度 \n货币与货币制度 \n国际货币体系 \n欧洲货币一体化 \n2、利息和利率 \n利息 \n利率决定理论 \n利率的",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "货币与货币制度 \n国际货币体系 \n欧洲货币一体化 \n2、利息和利率 \n利息 \n利率决定理论 \n利率的期限结构 \n3、外汇与汇率 \n外汇 \n汇率与汇率制度 \n币值、利率与汇率 \n汇率决定理论 \n4、金融市场与机构 \n金融市场及其要素 \n货币市场和资本市场 \n衍生工具市场 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>1\n \n3 \n金融机构(种类、功能) \n5、商业银行 \n负债业务和资产业务 \n中间业务和表外业务 \n商业银行的风险特征 \n6、现代货币创造机制 \n存款货币的创造机制 \n中央银行职能 \n中央银行体制的货币创造 \n7、货币供求与均衡 \n货币需求理论 \n货币供给 \n货币均衡 \n通货膨胀与通货紧缩 \n8、货币政策 \n货币政策及其目标 \n货币政策工具 \n货币政策的传导机制 \n货币政策的中介指标 \n9、国际收支与国际资本流动 \n国际收支 \n国际储备 \n国际资本流动 \n10、金融监管 \n金融监管理论 \n巴塞尔协议 \n>>>> 黄达金融学基础精讲\n2<<\n \n4 \n金融机构监管 \n金融市场监管 \n \n二\n二、黄达《金融学》教材介绍 \n \n——“大金融思想” \n①宏观+微观 \n②金融+实体经济 \n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": " \n二\n二、黄达《金融学》教材介绍 \n \n——“大金融思想” \n①宏观+微观 \n②金融+实体经济 \n③一般规律+国家禀赋 \n \n三\n三、金融学知识点概览 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>3\n \n5 \n（一）金融学基本范畴 \n第一至四章 \n定义-功能-演进-制度-决定理论-中国问题 \n \n（二）金融中介与金融市场 \n第五至七章 \n \n第八至九章 \n>>>> 黄达金融学基础精讲\n4<<\n \n6 \n \n第十至十一章 \n \n（三）货币均衡与宏观政策 \n第十二至十六章 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>5\n \n7 \n第十七至二十一章 \n \n（四）金融运行的微观机制 \n第二十二至二十五章 \n \n（五）金融发展与稳定机制 \n第二十六至二十九章 \n>>>> 黄达金融学基础精讲\n6<<\n \n8 \n \n \n四\n四、课程设置与学习方法 \n（一）课程内容 \n逐章详解，共二十个课时。 \n0.导学 \n1. 货币与货币制度 \n2. 国际货币体系与汇率制度 \n3. 信用、利息与信用形式 \n（第四章略） \n4.金融中介体系 \n5.存款货币银行（第六+二十五章） \n6.中",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "、利息与信用形式 \n（第四章略） \n4.金融中介体系 \n5.存款货币银行（第六+二十五章） \n6.中央银行 \n7.金融市场（第八+九章） \n8.金融体系结构（第十+十一章） \n9.利率的决定及作用（第十二+二十二章） \n10.货币需求 \n11.现代货币创造机制 \n12.货币供给与货币均衡（第十五+十六章） \n13.货币政策（第十九章） \nwww.koolearn.com\n>>>>>> 新东方在线\n>>7\n \n9 \n14.货币政策与财政政策的配合（第十八+二十+二十六章） \n15.开放经济的均衡（第十七章） \n16.开放条件下的政策搭配与调节（第二十一章） \n（第二十三、二十四章略） \n17.金融发展与经济增长 \n18.金融脆弱性与金融危机 \n19.金融监管 \n（二）学习方法 \n课前预习-课堂笔记-课后整理 \n金融范畴类：定义-功能-演进-制度-决定理论-中国问题 \n金融理论类：古典学派-凯恩斯学派-货币主义学派-现代发展 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n8<<\n \n10 \n \n第一章  货币与货币制度 \n \n \n \n一\n一、货币的起源★ \n从物物交易",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "\n8<<\n \n10 \n \n第一章  货币与货币制度 \n \n \n \n一\n一、货币的起源★ \n从物物交易到通过货币的交易 \n交易的社会成本： \n经济行为的演化总是从交易成本高的趋向交易成本低的。 \n货币的起源，银行的产生，企业的产生等 \n马克思对货币起源的论证： \n劳动价值论 \n价值的表现形式：偶然的价值形式→扩大的价值形式→一般价值形式 \n一般等价物 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>9\n \n11 \n二、货币的演进★ \n币材的特点 \n价值较高； \n易于分割； \n易于保存； \n便于携带。 \n金属货币 \n铸币 \n由国家的印记证明其重量和成色的金属块。 \n格雷欣法则“：劣币驱逐良币” \n两种本币固定的法定比价与波动的市场比价的矛盾 \n铸币税 \n信用货币 \n银行券 \n纸币 \n商业票据 \n支票 \n信用卡 \n \n三\n三、货币的职能★★★ \n赋予交易对象以价格形态 \n购买和支付手段 \n积累和保存价值的手段 \n赋予交易对象以价格形态 \n币值的确定 \n货币购买力 \n>>>> 黄达金融学基础精讲\n10<<\n \n12 \n价格的波动 \n指引着资源的再分配 \n经济效率的体现 \n购买和支付手段 \n货币流",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "10<<\n \n12 \n价格的波动 \n指引着资源的再分配 \n经济效率的体现 \n购买和支付手段 \n货币流通 \n个人 \n公司、企业 \n财政及机关，团体 \n银行等金融机构 \n对外 \n积累和保存价值的手段 \n \n \n四\n四、货币的“定义”★★★ \n从职能视角给货币下定义 \n价值尺度与流通手段的统一是货币。——马克思 \n货币的其他“代名词” \n一般等价物 \n流动性 \n从管理货币的角度定义货币：货币供给层次 \n货币与“选票” \n货币与财富 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>11\n \n13 \n货币与法 \n货币与权力 \n货币与生产关系 \n \n五\n五、货币制度★★★ \n（\n（一）货币制度的内容 \n货币材料的确定 \n货币单位的确定 \n流通中的货币种类 \n货币的铸造、发行与管理 \n货币材料的确定 \n铜本位制 \n金（银）本位制 \n货币单位的确定 \n铸币流通时期：确定一个货币单位所包含的货币金属重量和成色。 \n货币不兑现以后：确定本国货币单位的含金量，或确定本国货币与世界上占主导地位\n的货币（如美元）的固定比价。 \n流通中的货币种类 \n本位币与辅币 \n用法定货币金属按照国家规定的规格经国家造币厂铸成的铸币",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "比价。 \n流通中的货币种类 \n本位币与辅币 \n用法定货币金属按照国家规定的规格经国家造币厂铸成的铸币称为本位币或主币。 \n货币的铸造、发行与管理 \n无限法偿与有限法偿 \n无限法偿，即法律规定的无限制偿付能力。法律保护取得这种能力的货币，即本位币，\n不论每次支付数额多大，不论属于何种性质的支付，即不论是购买商品、支付服务、结清\n债务、缴纳税款等，支付的对方均不得拒绝接受。 \n \n>>>> 黄达金融学基础精讲\n12<<\n \n14 \n（二）金本位制发展史 \n金铸币本位制 \n金块本位制 \n金汇兑本位制 \n金铸币本位制 \n只有金币可以自由铸造，有无限法偿能力； \n银行券可以自由兑现为金铸币； \n黄金自由输出和输入 \n金块本位制 \n市场上不再流通金币，而是流通纸币，法律规定纸币的含金量； \n国家储存金块，作为储备； \n不许自由铸造金币； \n纸币不能自由兑换金币。 \n金汇兑本位制 \n市场上不再流通金币，只流通银行券，国家无需规定货币的含金量。 \n银行券不能兑换黄金，只能兑换实行金币或金块本位制国家的货币。 \n实行金汇兑本位制的国家使其货币与另一实行金币或金块本位制国家的货币保持固\n定汇率，通过无限制地买卖外汇来维持本国货币",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "的国家使其货币与另一实行金币或金块本位制国家的货币保持固\n定汇率，通过无限制地买卖外汇来维持本国货币币值的稳定。 \n（\n（三）人民币制度 \n人民币没有含金量的规定，属于不兑现的信用货币，人民币的发行保证是国家拥有的\n商品物资，黄金外汇储备主要是作为国际收支的准备金。 \n本位币与辅币：人民币主币的单位为元，辅币的单位为角和分。 \n发行机构：中国人民银行 \n人民币汇率：由国家外汇管理局统一制定 \n人民币是我国唯一合法的货币，严禁伪造、变造和破坏国家货币。 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>13\n \n15 \n六、热点问题★★★ \n（\n（一）货币消亡问题 \n马克思、恩格斯的论断 \n无现金社会 \n移动支付与货币需求、货币政策 \n移动支付与家庭金融、普惠金融 \n移动支付与财富分配、数字鸿沟 \n（\n（二）数字货币 \n比特币 \nLibra \n央行数字货币 \n是货币吗？是信用货币吗？ \n有什么样的优势？成本？效率？安全性？ \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n14<<\n \n16 \n \n第二章  国际货币体系与汇率制度 \n \n \n \n一\n一、国际",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "融学基础精讲\n14<<\n \n16 \n \n第二章  国际货币体系与汇率制度 \n \n \n \n一\n一、国际货币体系 \n（\n（一）金本位制下的国际货币体系 \n黄金充当世界货币； \n两种货币兑换以铸币平价为基准； \n外汇收支具有自动调节机制； \n汇率波动以黄金输送点为限。 \n（\n（二）金汇兑本位制下的国际货币体系 \n不完全的金平价 \n本币不能自由兑换成黄金，而是通过兑换外汇间接与黄金联系。 \n钉住汇率制度，即与某一特定强国的货币挂钩。 \n通过持有黄金储备和大量外汇来保持本币稳定。 \n（\n（三）以美元为中心的国际货币体系：布雷顿森林体系 \n“双挂钩”：美元与黄金挂钩，其他国家货币与美元挂钩。 \n实行可调整的固定汇率； \n各国货币自由兑换； \n确定美元为最主要的国际储备资产。 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>15\n \n17 \n “双挂钩”：美元与黄金挂钩，其他国家货币与美元挂钩。 \n实行可调整的固定汇率； \n各国货币自由兑换； \n确定美元为最主要的国际储备资产。 \n特里芬悖论 \n美元对内均衡与对外均衡的矛盾。 \n各国用美元作为结算与储备货币，导致流出美国的货币在海外不断沉淀，对美国来说\n就",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "与对外均衡的矛盾。 \n各国用美元作为结算与储备货币，导致流出美国的货币在海外不断沉淀，对美国来说\n就会发生长期贸易逆差；而美元作为国际货币核心的前提是必须保持美元币值的稳定与坚\n挺，这又要求美国必须是一个长期贸易顺差国。这两个要求互相矛盾，成为一个悖论。 \n（\n（五）多样化的汇率制度安排 \n黄金非货币化 \n多样化的汇率制度安排 \n国际储备体系多元化 \n国际收支调节机制多样化 \n（\n（四）布雷顿森林体系的瓦解：牙买加体系 \n货币局制度 \n联系汇率制度 \n欧洲货币联盟：最优货币区理论 \n美元化 \n货币局制度 \n将本国货币钉住一种强势货币并与之建立固定汇率联系的国际货币安排。 \n这种强势货币被称为锚货币；本国的通货发行，以外汇储备（特别是锚货币的外汇储\n备）为发行保证，保证本币与外币随时可以按固定汇率兑换。 \n实施货币局制度，意味着失去独立施行货币政策的主动权。 \n联系汇率制度：中国香港 \n>>>> 黄达金融学基础精讲\n16<<\n \n18 \n发钞银行（即汇丰银行、渣打银行和中国银行）每发行1 港元，要按7.8 港元：1 美\n元的比例，向外汇基金存入百分之百的外汇储备。 \n中国香港的联系汇率制度只是在发行储备上规定有",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "1 美\n元的比例，向外汇基金存入百分之百的外汇储备。 \n中国香港的联系汇率制度只是在发行储备上规定有港元与美元的刚性比率，而市场交\n易中实行的则是浮动汇率制度。 \n欧洲货币联盟：最优货币区理论（罗伯特·蒙代尔） \n主要内容：在具备一定条件的区域内，各国放弃本国的货币，采取统一的区域货币，\n这样有利于安排汇率，以实现就业、稳定和国际收支平衡的宏观经济目标。 \n基本条件：市场一体化程度；经济对称性水平 \n美元化 \n广义上的美元化：形容任何货币制度以任何形式、任何程度对美元的依附。 \n狭义上的美元化：一个国家以美元代替本国的本币进行流通。在国际货币基金组织确\n定的“无单独法定货币”的13 个国家中，大多数都实行美元化。 \n铸币税 \n货币政策的独立性 \n \n二\n二、汇率与汇率制度 \n（\n（一）汇率与汇率标价 \n汇率： \n国与国之间货币折算的比率。 \n汇率牌价 \n钞买价，汇买价，汇卖价，钞卖价 \n直接标价法与间接标价法 \n一定基数（1 或100）外币相当于多少本币（人民币）。 \n美元标价法 \n一定基数（1 或100）美元相当于多少其他货币。 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>17\n ",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "相当于多少其他货币。 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>17\n \n19 \n（二）汇率分类 \n浮动汇率与固定汇率 \n名义汇率与实际汇率 \n货币的对内价值与对外价值 \n \n三\n三、汇率决定理论 \n影响汇率决定的因素 \n可比的基础（币值的基础） \n外汇的供求 \n铸币平价—国际借贷说—购买力平价—利率平价—汇兑心理说—货币分析法/金融资\n产说 \n（\n（一）铸币平价 \n可比的基础：铸币的含金量——铸币平价或金平价 \n外汇的供求：“黄金输送点” \n汇率波动的范围不超过：铸币平价±输送黄金相关的费用 \n（\n（二）国际借贷说 \n外汇的供求： \n国际商品进出口和资本流动所引起的债权债务关系。 \n国际收支的均衡条件是经常项目差额等于资本项目差额。 \n（\n（三）购买力平价 \n一价定律 \n前提：无贸易摩擦且完全竞争 \n机制：套利 \n结果：若以同一种共同货币标价，则在不同市场上销售的相同商品拥有相同的销售价\n格。 \n可比的基础：购买力——一般物价水平的倒数 \n>>>> 黄达金融学基础精讲\n18<<\n \n20 \n绝对购买力平价 \n实际汇率永远为1 \nA\nB\nP\nr\nP\n=\n \n可比的基础：购买力——一",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "\n20 \n绝对购买力平价 \n实际汇率永远为1 \nA\nB\nP\nr\nP\n=\n \n可比的基础：购买力——一般物价水平的倒数 \n相对购买力平价 \n考虑通货膨胀，名义汇率的贬值率等于两国通货膨胀率之间的差额。 \n1\n1\n1\n0\n0\n0\n/\n/\nA\nB\nA\nB\nP\nP\nr\nr P\nP\n=\n \n现实中能否成立？ \n各国的生产结构、消费结构的差异； \n各国物价指数构建的差异； \n市场的不完全竞争与交易成本等。 \n（\n（四）利率平价 \n远期汇率的决定因素是货币短期存款利率之间的差额。 \n条件：资本流动和资产完全可替代 \n公式：\n1\n1\n0\n/\ne\nt\nt\nt\nE\nE\ni\ni\nE\n+\n=\n−\n \n国内利率等于外国利率减去本国货币的预期升值率。 \n利率高的国家，汇率远期贴水；利率低的国家，汇率远期升水。 \n（\n（五）汇兑心理说 \n外汇的供求：人的主观心理（预期） \n每个人对外币有不同的主观评价，而影响主观评价的因素包括对国际收支、政府收支、\n资本流动、外汇管制措施等多方面的预测评价。 \n（\n（六）现代发展 \n货币分析说 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>19\n \n21 \n将汇率与货币政策相联系，认为",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "oolearn.com\n>>>>>> 新东方在线\n>>19\n \n21 \n将汇率与货币政策相联系，认为汇率受到两国货币供给量的制约。 \n1 1\n1\n1\nk Y\nM\nr\nM\nkY\n=\n×\n \n弹性价格货币分析说 \n汇率超调理论——粘性价格货币分析法 \n特点：商品市场的价格存在粘性，价格调整速度较慢，经济存在由短期平衡向长期均\n衡的过渡。 \n假设：购买力平价短期不成立；总供给曲线短期不是垂直的 \n意义：将短期分析与长期分析相结合；政策指导意义 \n金融资产说 \n关注货币以外的其他各种金融资产供求的分析 \n一国居民的三种资产： \n本国货币；本国债券；外国债券 \n其总额应等于本国所拥有的资产总量 \n（\n（七）总结 \n—铸币平价理论（铸币平价+黄金输送点） \n—国际借贷说（国际收支） \n—购买力平价理论（长期汇率） \n—利率平价（短期汇率） \n—汇兑心理说（主观因素） \n—货币分析说（汇率超调理论） \n—金融资产说 \n四\n四、热点问题 \n（\n（一）人民币汇率制度 \n人民币汇率制度是以市场供求为基础、参考一篮子货币进行调节、有管理的浮动汇率\n制度。 \n>>>> 黄达金融学基础精讲\n20<<\n \n22 \n人民币汇率制度改革 \n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "管理的浮动汇率\n制度。 \n>>>> 黄达金融学基础精讲\n20<<\n \n22 \n人民币汇率制度改革 \n汇率调控的方式； \n中间价的确定和日浮动区间； \n起始汇率的调整（2005 年）。 \n（\n（二）人民币汇率形成机制 \n人民币兑美元中间价 \n=上日中间价+一篮子货币24 小时汇率变化*调整系数+市场供求因素 \n逆周期因子 \n调整短期市场单边预期对汇率决定的影响 \n（\n（三）人民币国际化 \n1.人民币可兑换问题 \n货币兑换的三个层次： \n不可兑换； \n国际收支经常项目下可兑换； \n完全可自由兑换，即在经常项目和资本项目下均可以自由兑换。 \n2.特别提款权（SDR） \n是国际货币基金组织根据会员国认缴的份额分配的，可用于偿还国际货币基金组织债\n务、弥补会员国政府之间国际收支逆差的一种账面资产。 \n记账单位/国际储备 \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>21\n \n23 \n \n第三章  信用、利息与信用形式 \n \n \n \n一\n一、信用 \n（\n（一）什么是信用 \n以信任为基础，以偿还和支付利息为条件的借贷行为。 \n特征： \n价值的单方面让渡：债权债务关系而非等价交",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "信任为基础，以偿还和支付利息为条件的借贷行为。 \n特征： \n价值的单方面让渡：债权债务关系而非等价交换关系。 \n以还本付息为条件 \n所有权与使用权的分离（私有财产的出现是借贷关系存在的前提） \n（\n（二）利息 \n利息是货币所有者（或债权人）因贷出货币或者货币资本而从借款人（或债务人）那\n里获得的报酬。 \n利息是资本收益的一般形态。 \n>>>> 黄达金融学基础精讲\n22<<\n \n24 \n利息是投资人让渡资本使用权而索要的补偿。补偿由两部分组成：对机会成本的补偿\n和对风险的补偿。 \n \n二\n二、现代信用活动 \n（\n（一）信用经济 \n“现代经济是信用经济。” \n以负债经营为主，具有明显的扩张性； \n债权债务关系是最主要和最普遍的经济关系； \n信用货币是最基本的货币形式。 \n信用与金融的区别与联系 \n信用活动包括金融活动，金融活动不包括实物信用。 \n信用活动即是资金融通，金融活动包含信用关系。 \n（\n（二）现代信用形式 \n1.商业信用 \n工商企业之间，买卖行为和借贷行为同时发生，商业票据为主要工具。 \n局限性： \n活动范围局限于工商企业之间； \n信用规模受限于产业资本规模； \n严格的方向性：上游企业→下游企业；工业→",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "范围局限于工商企业之间； \n信用规模受限于产业资本规模； \n严格的方向性：上游企业→下游企业；工业→商业 \n2.银行信用 \n以银行作为信用中介，是一种间接信用； \n是以货币形态提供的信用，无对象的局限。 \n工具：银行票据；支票；信用证 \n直接融资：资金供求双方通过一定的金融工具直接形成债权债务关系或所有权关系的\n融资形式。 \n间接融资：资金供求双方通过金融中介机构简介实现资金融通的活动。 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>23\n \n25 \n3.国家信用 \n政府作为债务人或债权人的借贷活动 \n工具：中央政府债券；地方政府债券；政府担保债券 \n影响： \n调节财政收支，弥补财政赤字；调节经济总量与结构； \n配合其他经济政策的实施 \n增加政府债务负担，削弱未来政府的融资能力 \n巨额债务影响国家信用等级，损害投资人信心 \n出现国家信用危机 \n4.消费信用 \n企业、银行或其他金融机构向消费者提供的用于生活消费的信用 \n形式：分期付款；购房贷款；汽车贷款 \n影响： \n实现宏观经济调节 \n实现微观消费者生命周期的财务安排 \n过度发展引起虚假需求、信用膨胀、债务负担 \n5.国际信用 \n形式：国外",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "观消费者生命周期的财务安排 \n过度发展引起虚假需求、信用膨胀、债务负担 \n5.国际信用 \n形式：国外商业性借贷；国外直接投资 \n特点： \n直接表现为资本在国际间的流动 \n规模大；风险大，并具有双向性；方向上的不对称性 \n \n三\n三、现代信用体系的建立 \n（一）现代信用体系的构成 \n现代信用体系由信用形式、信用机构、信用管理体系、社会征信系统等相互联系和影\n响的各个方面共同构成。 \n>>>> 黄达金融学基础精讲\n24<<\n \n26 \n信用制度：制度保障 \n道德规范 \n法律规范：基础性保障 \n信用机构体系 \n社会征信系统 \n现代信用体系各个组成部分之间相互联系、相互依存，构成一个有机系统。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>25\n \n27 \n \n第五章  金融中介体系 \n \n第\n第四章  金\n金融范畴的形成与发展★ \n（\n（一）金融及其涵盖的领域 \n宽口径、窄口径 \n金融与finance \n（\n（二）金融范畴的界定 \n金融体系：货币制度，金融机构，金融市场，金融工具，制度和调控机制。 \n金融范畴的界定包",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "范畴的界定 \n金融体系：货币制度，金融机构，金融市场，金融工具，制度和调控机制。 \n金融范畴的界定包括两个方面：（1）货币与信用相统一的过程；（2）这个过程及其\n所覆盖的经济领域。 \n \n一\n一、金融中介★★ \n（\n（一）金融中介的分类 \n银行类金融机构 \n>>>> 黄达金融学基础精讲\n26<<\n \n28 \n中央银行 \n存款货币银行（商业银行） \n政策性银行 \n…… \n非银行类金融机构 \n投资银行、券商 \n信托投资公司 \n保险公司 \n基金公司 \n…… \n（\n（二）我国的金融中介体系 \n以中国人民银行为中心，国有商业银行为主体，多种金融机构并存，分业经营、分业\n监督的金融中介机构体系格局。 \n（\n（三）金融服务业的特征 \n1.金融服务业是高风险行业，其金融资产持有率高，权益资本保有率低。 \n2.金融服务业知识密集和人力资本密集的产业，金融信息在金融服务业中发挥着重要\n的作用。金融中介既是金融信息的生产者也是金融信息的使用者。 \n3.金融服务业的资产负债表中，金融资产占比高，实物资产占比少，难以找到一个合\n适的物理单位来度量金融服务的数量，因此金融服务业的产出也就难以确定和计量。 \n4.金融服务多次经历重大变革。",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "单位来度量金融服务的数量，因此金融服务业的产出也就难以确定和计量。 \n4.金融服务多次经历重大变革。信息技术、监管制度和金融创新都在不断重新塑造着\n金融服务业，而且这种趋势还将持续下去。 \n \n二\n二、政策型银行★★ \n由政府设立，以贯彻国家产业政策、区域发展政策等为目标的金融机构，盈利目标居\n次要地位。 \n中国：国家开发银行（2015）、中国农业发展银行、中国进出口银行 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>27\n \n29 \n美国：美国进出口银行、联邦住房信贷银行体系 \n韩国：韩国开发银行、韩国进出口银行、韩国中小企业银行、韩国住宅银行 \n日本：日本输出入银行、日本开发银行、北海道东北开发公库 \n法国：法国农业信贷银行、法国对外贸易银行、中小企业设备信贷银行 \n…… \n \n二\n二、商业银行（我国）★★★ \n国有商业银行 \n中国工商银行、中国农业银行、中国银行、中国建设银行、交通银行。 \n股份制商业银行、邮政储蓄银行、城市商业银行、农村商业银行 \n银行市场化改革与银行股改上市 \n产权问题：成立中央汇金公司，代表国家履行出资人职能。 \n资产负债表：资本充足率、不良资产处置（金融资产管",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "问题：成立中央汇金公司，代表国家履行出资人职能。 \n资产负债表：资本充足率、不良资产处置（金融资产管理公司） \n公司治理结构：股份有限公司 \n明确股东大会、董事会、监事会、高级管理层的权利和责任 \n增资扩股：引入战略投资者 \n内控体系与风险防范机制 \n激励制度等 \n \n三\n三、投资银行、证券公司★★ \n业务范围 \n证券经纪； \n证券投资咨询； \n与证券交易、证券投资活动有关的财务顾问； \n证券承销与保荐； \n证券自营； \n>>>> 黄达金融学基础精讲\n28<<\n \n30 \n证券资产管理； \n其他证券业务。 \n并购 \n美国的投资银行 \n次贷危机对美国投资银行发展的影响 \n美林——被美国银行收购 \n摩根士丹利——银行控股公司 \n高盛——银行控股公司 \n花旗——接受美国财政部注资 \n \n四\n四、保险公司★★ \n保险类别 \n人寿保险、财产保险、责任保险、信用保险、再保险 \n保险公司的保险资金构成了西方国家金融体系长期资本的重要来源。 \n保险资金投资权益类金融产品的比例：保险资金进入资本市场 \n我国养老保险三支柱：基本养老保险，企业年金，个人商业养老保险 \n \n五\n五、基金管理公司、风险投资基金★★ \n基金管理公司（基",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "老保险，企业年金，个人商业养老保险 \n \n五\n五、基金管理公司、风险投资基金★★ \n基金管理公司（基金管理人） \n公募基金与私募基金 \n股票型、债券型、货币型等 \n房地产投资基金（REITS） \n对冲基金（以金融期货、金融期权为标的） \n风险投资基金 \n私募 \n有限合伙制 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>29\n \n31 \n投资初创型、创新型企业 \n风险高、收益高 \n产业投资基金 \n \n六\n六、其他金融机构★★ \n信托公司 \n财务公司 \n汽车金融、消费金融 \n小额贷款 \n“一行两会” \n \n七\n七、国际金融机构★★★ \n（\n（一）国际货币基金组织（IMF）\n） \n1945 年12 月成立，目前成员国达188 个 \n资金来源：会员国认缴的基金份额、介入资金和出售黄金 \n投票权：成员国认缴的份额决定，美国拥有20%的投票权 \n宗旨： \n促进国际货币领域合作，促进汇率稳定，避免竞争性货币贬值 \n促进国际贸易，取消阻碍发展的外汇限制。 \n提供临时性贷款，调节国际收支平衡。 \n（\n（二）世界银行（WB）\n） \n与IMF 均是根据1944 年7 月布雷顿森林会议的决定，于1945 年12 ",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "界银行（WB）\n） \n与IMF 均是根据1944 年7 月布雷顿森林会议的决定，于1945 年12 月27 日成立。\n总部均设在华盛顿，均属于联合国下属专门机构。 \n宗旨 \n提供生产性贷款和投资，协助成员国经济复兴和开发 \n区别（与IMF） \n>>>> 黄达金融学基础精讲\n30<<\n \n32 \nIMF 调节国际货币体系和汇率平衡，提供短期贷款；世行提供用于发展的长期贷款。 \n（\n（三）金砖银行 \n金砖银行所有的管理、章程、条款等等都是基于平等的基础，金砖银行不会由任何一\n个国家控制。金砖银行里五个国家都是各自占了20%的投票权，没有哪个国家占到主导权，\n没有一个国家能够一票否决其他国家的决定。 \n（\n（四）亚洲基础设施开发银行 \n目标： \n不以减贫为目标，而是投资准商业性的基础设施；亚投行是区域开放的 \n影响： \n过剩外汇储备和产能有了“出路”； \n制定国际金融游戏规则； \n推进人民币国际化进程。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>31\n \n33 \n \n第六章  存款货币银行 \n \n \n \n一\n一、存款货币银行的产生和发展",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "线\n>>31\n \n33 \n \n第六章  存款货币银行 \n \n \n \n一\n一、存款货币银行的产生和发展★★ \n（\n（一）存款货币银行的定义 \n存款货币银行是指在金融中介体系中，能够创造存款货币的金融中介机构。存款货币\n银行以经营工商存款、放款为主要业务，并为客户提供多种金融服务。 \n（\n（二）存款货币银行的功能 \n①充当资本家之间的信用中介。 \n②充当资本家之间的支付中介。 \n③变社会各阶层的积蓄和收入为资本。 \n④创造信用流通工具。 \n（\n（三）存款货币银行的产生的必要性★★★ \n交易成本 \n信息不对称 \n——借与贷的中介作用 \n银行会消亡吗？ \n>>>> 黄达金融学基础精讲\n32<<\n \n34 \n二、存款货币银行的类型与组织★★ \n（\n（一）存款货币银行的组织制度 \n总分行制度（最典型的组织形式） \n单元银行制度——不设分支机构 \n代理行制度——解决单元制不设分支机构的矛盾 \n银行控股公司制度 \n \n三\n三、存款保险制度★★★ \n（\n（一）存款保险制度——银行挤兑问题 \n银行会破产吗？ \n存款保险制度是指经营存款业务的金融机构被强制或自愿按照所吸收存款的一定比\n例向存款保险机构缴纳保险费，存款保险机构承诺在",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "存款业务的金融机构被强制或自愿按照所吸收存款的一定比\n例向存款保险机构缴纳保险费，存款保险机构承诺在其遇到财务危机或面临破产时，向其\n提供流动性资助或代为清偿的特殊保险制度。 \n（\n（二）存款保险制度的影响 \n积极vs 消极：经营效率vs 道德风险 \n对存款人来说； \n对投保机构（银行）来说； \n对监管当局来说。 \n（\n（三）存款保险制度的组织形式 \n官方建立存款保险机构，如美、英、加 \n官方与银行界共同建立存款保险机构，如日本 \n官方支持下，银行业合建存款保险机构，如德、法 \n我国：2015 年5 月1 日起，各家银行向保险机构统一缴纳保险费，一旦银行出现危\n机，保险机构将对存款人提供最高50 万元的赔付额。 \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>33\n \n35 \n四、银行热点问题讨论 \n分业经营与混业经营★★★ \n金融创新★★★ \n不良债权★★ \n产融结合★★ \n中国国有商业银行改革★★★ \n影子银行★★★★ \n银行业竞争★★★★ \n（\n（一）分业经营与混业经营★★★ \n以美国为例（以监管法案的变革为线索） \n格拉斯-斯蒂格尔法案，1933 年大萧条，分业经营 \n金融服",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "以美国为例（以监管法案的变革为线索） \n格拉斯-斯蒂格尔法案，1933 年大萧条，分业经营 \n金融服务现代化法案，1999 年，金融自由化 \n多德-弗兰克法案，2010 年，全面金融监管 \n我国：以中国人民银行为中心，国有商业银行为主体，多种金融机构并存，分业经营、\n分业监督的金融中介机构体系格局。 \n（\n（二）影子银行★★★★ \n什么是影子银行： \n影子银行是指游离于银行监管体系之外、可能引发系统性风险和监管套利等问题的信\n用中介体系（包括各类相关机构和业务活动）。 \n银行表外业务、类存贷款业务，P2P，民间集资 \n影子银行对银行业及系统性金融风险的影响 \n对影子银行的监管 \n《关于规范金融机构资产管理业务的指导意见》 \n（\n（三）银行业竞争★★★★ \n利率市场化改革 \n>>>> 黄达金融学基础精讲\n34<<\n \n36 \n一般而言，利率市场化包括两个内容：一是商业银行的存贷款利率市场化；二是中央\n银行通过间接调控的方式影响市场利率。 \n利率走廊 \n也叫利率通道调控，是指中央银行通过设定和变动自己的存贷款利率（利率差为走廊\n宽度），实现对同业拆借利率的调节和控制。 \n \n五\n五、商业银行的业务★★★ \n（\n（",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "利率差为走廊\n宽度），实现对同业拆借利率的调节和控制。 \n \n五\n五、商业银行的业务★★★ \n（\n（一）负债业务与资产业务 \n负债业务 \n形成其资金来源 \n吸收存款，向中央银行借款，银行同业拆借，货币市场及国际市场借款等 \n资产业务 \n将负债业务所聚集的货币资金加以运用以取得收益。 \n贴现(银行票据)，贷款，证券投资(政府债券、政策性债券)，(融资)租赁 \n（\n（二）中间业务和表外业务 \n中间业务 \n不需要运用自己的资金而代理客户业务并收取手续费。 \n各类汇兑业务，代理销售，信息咨询，理财服务等 \n表外业务 \n未列入银行资产负债表内且不影响资产负债总额的业务。 \n或有债权类（担保承诺）、金融服务类（信用卡） \n \n六\n六、商业银行的经营原则★★ \n盈利性 \n商业银行是以经营金融业务获取利润的企业。 \n流动性 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>35\n \n37 \n保证商业银行的清偿能力。 \n安全性 \n管理经营风险、保证资金安全。 \n \n七\n七、商业银行管理★★★ \n（\n（一）资产管理 \n流动性管理（短期→中长期） \n商业贷款理论（真实票据理论） \n可转换性理论 \n预期收入理论 \n（",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": " \n流动性管理（短期→中长期） \n商业贷款理论（真实票据理论） \n可转换性理论 \n预期收入理论 \n（\n（二）负债管理 \n主张以借入资金的办法来保持银行的流动性，从而增加资产业务增加银行收益 \n优势：开创了保持银行流动性的新途径，由单靠吸收存款的被动型符合在方式，发展\n成向外借款的主动型负债方式。 \n缺陷：提高了银行的融资成本；增加了经营风险；忽视资本金的补充 \n（\n（三）资产负债综合管理 \n广义的资产负债管理，是指金融机构按一定的策略进行资金配置来实现流动性、安全\n性和盈利性的目标组合。 \n匹配 \n利率敏感型缺口（利率波动对银行收入的影响） \n久期缺口（负债持续期对银行资产规模的影响） \n \n八\n八、商业银行风险管理 \n（\n（一）风险识别 \n信用风险 \n市场风险 \n>>>> 黄达金融学基础精讲\n36<<\n \n38 \n操作风险 \n流动性风险 \n其他风险 \n（\n（二）风险管理 \n预防风险 \n分散风险 \n转嫁风险 \n对冲风险 \n补偿风险 \n（\n（三）风险管理方法 \nVAR（valueatrisk，在险价值） \n在正常的市场环境下，给定一定的时间区间和置信度水平，预计某种资产或资产组合\n最大损失的方法。 \n \n资产价",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "的市场环境下，给定一定的时间区间和置信度水平，预计某种资产或资产组合\n最大损失的方法。 \n \n资产价值在未来.T 天内有(1-a%)的概率不会下跌超过VaR。 \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>37\n \n39 \n \n第七章  中央银行 \n \n \n \n一\n一、中央银行的产生及类型★★ \n（\n（一）中央银行产生的必要性 \n货币统一发行的必要。 \n银行间债权债务关系清算的要求。 \n商业银行周期性调节的需要。 \n银行业监督、管理、协调的需要。 \n特点：不以盈利为目的；不经营普通存款货币银行业务；相对独立性 \n（\n（二）中央银行的制度类型 \n单一中央银行制度 \n一元式： \n我国：中国人民银行，作为国务院组成部门，是制定和执行货币政策、维护金融稳定、\n提供金融服务的宏观调控部门。 \n二元式： \n美国：12 家联邦储备银行 \n复合中央银行制度：中央银行职能+存款货币银行职能 \n跨国中央银行制度：欧洲中央银行，欧洲货币联盟共同的中央银行 \n>>>> 黄达金融学基础精讲\n38<<\n \n40 \n准中央银行：新加坡、中国香港等 \n \n二\n二、中央银行的职能",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "达金融学基础精讲\n38<<\n \n40 \n准中央银行：新加坡、中国香港等 \n \n二\n二、中央银行的职能★★★ \n（\n（一）发行的银行 \n垄断银行券的发行权，成为全国唯一的现钞发行机构。 \n中国人民银行人民币发行基金保管库 \n商业银行日常现金收付业务 \n（\n（二）银行的银行 \n集中存款准备：法定准备金、超额准备金 \n最后贷款人：再贴现、再抵押、回购协议、直接贷款 \n组织全国的清算 \n（\n（二）国家的银行 \n代理国库：财政部门在央行开立账户管理政府收支。 \n代理国家债券的发行，对国家财政给予信贷支持 \n管理外汇和黄金储备 \n制定和实施货币政策 \n制定并监督执行金融管理法规 \n \n三\n三、中央银行的资产负债表★★★ \n（\n（一）简化的中央银行资产负债表 \n资产 \n国外资产 \n贴现和放款 \n政府债券和财政借款 \n外汇、黄金储备 \n其他资产 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>39\n \n41 \n负债 \n流通中的通货 \n商业银行等金融机构存款 \n国库及公共机构存款 \n对外负债 \n其他负债和资本项目 \n（\n（二）不同国家中央银行资产负债表的差异 \n中国 \n最主要资产项目为国外资产（外汇储备） \n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "目 \n（\n（二）不同国家中央银行资产负债表的差异 \n中国 \n最主要资产项目为国外资产（外汇储备） \n美国与日本 \n最主要资产项目为政府债券 \n \n四\n四、中央银行的独立性问题 \n（\n（一）中央银行应对政府保持独立性 \n中央银行与政府所处地位、行为目标不尽相同。 \n中央银行行使职能要求专业的理论素养和长期的经验积累。 \n经济独立 \n职能独立 \n法律地位 \n（\n（二）中央银行对政府的独立性总是相对的 \n总的来说，政府对中央银行的控制是不断加强的。 \n中央银行的国有化 \n中央银行与财政部的关系 \n不对政府财政透支，不直接认购、包销国债和其他政府债券；不得像地方政府、各级\n政府部门提供贷款 \n \n>>>> 黄达金融学基础精讲\n40<<\n \n42 \n \n第八章  金融市场 \n \n \n一\n一、金融市场及其要素 \n（\n（一）金融市场 \n广义的金融市场，是指资金供求双方借助金融工具进行各种货币资金交易活动的场\n所，是提供资本、配置金融资源的要素类市场。 \n交易对象——货币资金 \n交易主体——个人、企业、各级政府机构、货币当局和金融机构 \n交易工具——债权债务凭证、所有权凭证，衍生工具、外汇和黄金等 \n交易价格 \n（\n（二）金",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "金融机构 \n交易工具——债权债务凭证、所有权凭证，衍生工具、外汇和黄金等 \n交易价格 \n（\n（二）金融资产 \n金融资产的价值大小是由其能够给所有者带来未来收入的量和可能程度决定的。特\n征：流动性，指标：买卖价差； \n期限性； \n风险性，主要有信用风险和市场风险两种 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>41\n \n43 \n收益性 \n功能：帮助实现资金和资源的重新分配；帮助分散和转移风险。 \n（\n（三）金融市场的功能 \n帮助实现资金在盈余部门和短缺部门的调剂 \n风险分散和风险转移 \n确定价格 \n提供流动性 \n降低交易的搜寻成本和信息成本 \n金融市场功能发挥的条件： \n完整的信息：交易决策的基础 \n市场供求决定的价格：资金配置效率的关键 \n \n二\n二、金融市场的类型 \n（\n（一）货币市场 \n以期限在一年以内的金融工具为媒介进行短期资金融通的市场。 \n特点: \n交易期限短; \n交易目的是解决短期资金周转需要; \n交易工具有较强的货币性。 \n票据与票据市场：商业票据、银行承兑汇票 \n中央银行票据：回购与逆回购，货币政策调节工具 \n国库券市场：短期国库券，无风险投资工具 \n可转让大额存单市场（",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "据：回购与逆回购，货币政策调节工具 \n国库券市场：短期国库券，无风险投资工具 \n可转让大额存单市场（CDs）：应对利率管制的金融创新 \n银行间拆借市场 \n（\n（二）资本市场 \n以期限在一年以上的金融工具为媒介进行长期性资金交易活动的场所。 \n>>>> 黄达金融学基础精讲\n42<<\n \n44 \n特点: \n交易工具期限长 \n交易目的是解决长期投资性资金供求需要 \n借贷和筹资规模大，满足长期投资项目需要 \n（\n（三）衍生品市场 \n金融衍生工具：一类其价值依赖于原生性金融工具的金融产品。 \n期货合约、期权、远期、互换合约等 \n风险管理工具 \n对冲基金 \n（\n（四）投资基金市场 \n契约型基金和公司型基金 \n封闭式基金和开放式基金 \n公募基金和私募基金 \n（\n（五）外汇市场 \n外汇市场与货币市场的区别 \n交易工具的不同 \n（\n（六）黄金市场 \n对黄金的需求： \n投资与消费 \n（\n（七）欧洲货币市场 \n欧洲货币，境外货币，在发行国以外的国家和地区流通的货币。 \n特点：经营自由 \n资金来自世界各地 \n利率结构独特 \n借款条件灵活，不限贷款用途，手续简便 \n金融市场国际化 \nwww.koolearn.com\n>>>>>> 新东",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "活，不限贷款用途，手续简便 \n金融市场国际化 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>43\n \n45 \n三、资本市场 \n（一）股票市场 \n交易工具：股票（股份公司发行的权益凭证，代表股东对公司资产的剩余索取权） \n交易场所：证券交易所 \n场外交易市场（OTC，柜台交易） \n主板市场：深市A 股、沪市A 股 \n创业板市场、中小板市场：深市 \n新三板市场 \n科创板市场 \n初级市场（IPO、再融资）与二级市场 \n注册制与核准制 \n退市制度与借壳上市 \n初级市场（IPO、再融资）与二级市场 \n交易价格：报价驱动（做市商制度）与订单驱动 \n集合竞价和连续竞价（价格优先，时间优先） \n证券价格指数：综合指数与成分股指数 \n（\n（二）长期债券市场 \n以期限在1 年以上的债券为主要交易工具的市场。 \n长期政府债券 \n地方政府债务问题 \n公司债券 \n公司债 \n企业债（央企、国企，发改委核准） \n（\n（三）资本市场效率 \n根据有效市场假说，资本市场的有效性，是指市场根据新信息迅速调整证券价格的能\n力。 \n>>>> 黄达金融学基础精讲\n44<<\n \n46 \n \n第十章  金融体系结构 \n \n \n \n一\n一",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": ">>>> 黄达金融学基础精讲\n44<<\n \n46 \n \n第十章  金融体系结构 \n \n \n \n一\n一、金融体系★★★ \n（\n（一）现代金融体系构成要素 \n由货币制度所规范的货币流通——前提 \n金融中介——间接融资 \n金融市场——直接融资 \n金融资产——金融工具 \n制度和调控机制 \n（\n（二）金融体系结构 \n以银行为主导的金融体系结构 \n代表国家：德国、日本 \n特点：全能银行（兼具存贷款、保险、有价证券承销、投资等多种业务） \n股票市场规模较小 \n债券为政府和银行的重要资金来源 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>45\n \n47 \n以市场为主导的金融体系结构 \n代表国家：美国、英国 \n特点：分业经营、分业监管 \n发达的资本市场 \n多样化的金融产品 \n中介与市场相互渗透发展的趋势 \n银行业务证券化发展 \n银行在资本市场中扩充经营范围 \n服务于资本市场的中介机构向传统银行业务领域的扩张 \n \n二\n二、金融功能★★★★ \n（\n（一）金融功能观 \n罗伯特·默顿&兹维·博迪 \n分析不同国家、不同时期金融发展的差异应采用以金融功能为主线的概念框架 \n理由： \n金融功能比金融机构更加稳定。 \n金",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "同时期金融发展的差异应采用以金融功能为主线的概念框架 \n理由： \n金融功能比金融机构更加稳定。 \n金融机构的形式随金融功能而变化。 \n（\n（二）六大金融功能 \n在时间和空间上转移资源 \n提供分散、转移和管理风险的途径 \n提供清算和结算的途径，以完结商品、服务和各种资产的交易 \n提供集中资本和股份分割的机制 \n提供价格信息 \n提供解决“激励”问题的方法 \n现有的金融功能框架式微观分析框架 \n宏观：创造货币，形成货币供给 \n>>>> 黄达金融学基础精讲\n46<<\n \n48 \n三、金融基础设施★ \n（\n（一）金融基础设施的定义 \n金融基础设施是指金融运行的硬件设施和制度安排，主要包括支付体系、法律环境、\n公司治理、会计准则、信用环境、反洗钱以及由金融监管、中央银行最后贷款人职能、投\n资者保护制度组成的金融安全网等。 \n（\n（二）中央银行体制下的支付清算体系 \n狭义的金融基础设施 \n包括提供支付服务的中介机构、管理货币转移的规则、实现支付指令传送机资金清算\n的专业技术手段 \n“清算”与“结算” \n（\n（三）金融市场基础设施 \n在金融工具之间发挥转换功能并提供相关信息支持服务的流程及框架，包括支付系\n统、中央证券托管、",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "设施 \n在金融工具之间发挥转换功能并提供相关信息支持服务的流程及框架，包括支付系\n统、中央证券托管、证券清算系统、中央交易对手和场外衍生品交易信息库。 \n（\n（四）金融业标准 \n金融行业需要共同遵守的统一规范和通用语言，是能对金融业务活动做出明确界定并\n作为衡量相关金融行为的参照系。 \n会计准则 \n风险管理标准 \n统计标准 \n \n四\n四、互联网金融★★★ \n（\n（一）互联网金融的范围 \n众筹 \nP2P 网贷平台 \n第三方支付平台 \n数字货币 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>47\n \n49 \n互联网证券、互联网保险、互联网银行 \n（\n（二）互联网金融的特点 \n成本较低 \n效率较高 \n服务面广 \n风险较大：信用风险大；网络安全风险大 \n管理较难。 \n（\n（三）互联网金融的监管 \n《关于促进互联网金融健康发展的指导意见》，2015 年，鼓励创新、防范风险、趋\n利避害、健康发展的原则。 \n《网络小额贷款业务管理暂行办法》，2020 年，注册资本、股权结构、牌照数量、\n贷款上限等均作出了具体的规定。 \n（\n（四）从金融功能观的角度认识互联网金融 \n为什么互联网金融在我国发展如此迅速，而",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "具体的规定。 \n（\n（四）从金融功能观的角度认识互联网金融 \n为什么互联网金融在我国发展如此迅速，而在英美等国家却没有迅速发展起来？ \n英美等国家发达的资本市场、多种多样的金融机构和金融产品 \n机构投资者为主vs 散户为主 \n门槛更低，成本更低，风险更低的金融需求 \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n48<<\n \n50 \n \n第十二章  利率的决定与作用 \n \n \n \n一\n一、利率及其种类★★★ \n（\n（一）利息与利率 \n利息：货币所有者因贷出货币或者货币资本而从借款人处获得的报酬。 \n利率：利息率，借贷期满所形成的利息额与所贷出的本金额的比率。 \n（\n（二）利率的种类 \n基准利率 \n基准利率是金融市场上具有普遍参照作用的利率，其他利率水平或金融资产价格均可\n根据这一基准利率水平来确定。 \n无风险利率 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>49\n \n51 \n没有通货膨胀、无风险情况下资金市场的平均利率。短期政府债券的利率可以视作无\n风险利率。 \n实际利率 \n是指物价水平不变，从而货币购买力不变条件下的利息率。 \n名义利率 \n是指包括补偿通货膨胀风险的",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "率 \n是指物价水平不变，从而货币购买力不变条件下的利息率。 \n名义利率 \n是指包括补偿通货膨胀风险的利率。 \n（1+r）=(1+i)(1+p)→→r=i+p \n费雪效应 \n假设实际利率不变，名义利率的上升幅度和通货膨胀率完全相等。 \n名义利率=实际利率+通货膨胀率 \n即期利率 \n即期利率是指当期对不同期限的债权债务所标示的利率。 \n远期利率 \n远期利率是指隐含在给定的即期利率中从未来的某一时点到另一时点的利率。 \n长期利率 \n1 年以上信用行为的利率为短期利率。 \n短期利率 \n1 年以上信用行为的利率为长期利率。 \n（1+r2）=（1+r1）（1+r11） \n（\n（三）利率的度量 \n单利与复利 \n复利反映利率的本质特征。 \n现值与终值 \n \n \n \n>>>> 黄达金融学基础精讲\n50<<\n \n52 \n二、利率决定理论★★★★ \n（\n（一）马克思的利率决定论 \n基础：剩余价值在不同资本家之间的分割 \n观点：利息是剩余价值的一部分，剩余价值表现为利润。利息量的多少取决于利润总\n额，利息率取决于平均利润率。 \n利息率的特点： \n随着技术发展，平均利润率下降，利息率也随之下降。 \n相对而言，平均利息率是稳定的。 \n利",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "的特点： \n随着技术发展，平均利润率下降，利息率也随之下降。 \n相对而言，平均利息率是稳定的。 \n利息率的决定具有很大的偶然性。 \n（\n（二）古典学派的利率决定论——实际利率决定理论 \n决定因素：非货币的实际因素——生\n产率和节约 \n生产率：边际投资倾向 \n节约：边际储蓄倾向 \n利率取决于投资与储蓄的均衡。 \n储蓄的利率弹性 \n储蓄的利率弹性不断得到强化 \n投资的利率弹性 \n劳动密集型vs 资本密集型 \n长期投资vs 短期投资 \n（三）凯恩斯的利率决定论——货币理论 \n决定因素：利率决定于货币供求数量 \n流动性偏好：利息是在一定时期内放弃货币、牺牲流动性的报酬。 \n货币供给：中央银行控制——外生变量 \n货币需求：交易动机、预防动机、投机动机 \n流动性陷阱 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>51\n \n53 \n（四）可贷资金理论 \n决定因素：借贷资金的需求与供给 \n借贷资金需求来自某期间的投资流量和该期间人们希望保有的货币余额； \n借贷资金供给则来自同一期间的储蓄流量和该期间货币供给量的变动。 \n利率是使用借贷资金的代价，影响借贷资金供求水平的因素就是利率变动的原因 \n可贷资金理论",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "量的变动。 \n利率是使用借贷资金的代价，影响借贷资金供求水平的因素就是利率变动的原因 \n可贷资金理论从流量的角度研究借贷资金的供求和利率的决定，可以直接用于金融市\n场的利率分析。 \n \n三\n三、利率的风险结构★★★ \n（\n（一）定义 \n具有相同的到期期限但是具有不同违约风险、流动性和税收条件的金融工具收益率之\n间的相互关系。 \n名义利率=实际利率+通货膨胀率+实际利率的风险补偿 \n（\n（二）违约因素 \n债券发行人到期无法或不愿履行事先承诺或约定的利息支付或面值偿付义务的可能\n性。 \n违约风险溢价 \n通常采用信用评级来确定不同债券的违约风险大小。 \n（\n（三）流动性因素 \n流动性：衡量金融资产转换为现金的能力。 \n流动性溢价 \n债券的流动性越强，意味着它转换成现金时所支付的成本越低。因此，投资者通常喜\n欢持有流动性强的债券。 \n（\n（四）税收因素 \n美国国债：信用风险低，流动性高，税收减免较少 \n美国市政债券：信用风险较高，流动性较差，税收减免高 \n>>>> 黄达金融学基础精讲\n52<<\n \n54 \n通常，美国市政债券利率低于美国国债 \n \n四\n四、利率的期限结构★★★★ \n（\n（一）定义 \n在某一时点上，不同",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "政债券利率低于美国国债 \n \n四\n四、利率的期限结构★★★★ \n（\n（一）定义 \n在某一时点上，不同期限资金的收益率与到期期限之间的关系，反映的是长期利率和\n短期利率的关系 \n到期收益率 \n是指债券未来现金流的现值等于当前的债券价格时所决定的利率。 \n收益率曲线 \n同类债券的不同期限的到期收益率构成的曲线。 \n收益率曲线的形态 \n向上倾斜：长期利率高于短期利率 \n向下倾斜：长期利率低于短期利率 \n水平状 \n驼峰状 \n（\n（二）预期理论 \n纯预期理论 \n利率期限结构完全取决于市场对未来利率的预期，长期即期利率是短期预期利率的无\n偏估计 \n上斜的收益率曲线：市场预期未来短期利率会上升 \n下斜的收益率曲线：市场预期未来短期利率会下降 \n水平的收益率曲线：市场预期未来短期利率保持稳定 \n流动性理论 \n短期债券的流动性比长期债券高，长期债券利率包含一定的流动性溢价。 \n上斜曲线：市场预期未来短期利率可能上升也可能不变 \n下斜曲线：市场预期未来短期利率会下降，下降幅度高于无偏预期 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>53\n \n55 \n水平曲线：市场预期未来短期利率会下降，下降幅度等于流动性溢",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": ">>> 新东方在线\n>>53\n \n55 \n水平曲线：市场预期未来短期利率会下降，下降幅度等于流动性溢价 \n偏好理论 \n不同期限资金市场的供求 \n当一个特定期限的资金市场上供求严重不均衡时，交易双方才会转向供求状态并非严\n重不足的其他期限的资金市场。这种资金的流动会影响收益率曲线，使其表现出向上、向\n下、水平或者驼峰状的形态。 \n（\n（三）市场分割理论 \n资金在不同期限市场之间基本是不流动的。不同期限的债券完全不可相互替代，单个\n市场上的利率完全由该市场的供需决定 \n上斜：短期债券市场的均衡利率水平低于长期债券市场的均衡利率水平 \n下斜：短期债券市场的均衡利率水平高于长期债券市场的均衡利率水平 \n水平：短期债券市场的均衡利率水平高于长期债券市场的均衡利率持平 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n54<<\n \n56 \n \n第十三章  货币需求 \n \n \n \n一\n一、古典经济学到马克思★★ \n（\n（一）古典经济学 \n货币数量论 \n商品流通决定货币流通 \n（\n（二）马克思 \n执行流通手段职能的货币量=商品价格总额/同名货币的流通次数 \n商品价格总额=商品价格×流通商",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "克思 \n执行流通手段职能的货币量=商品价格总额/同名货币的流通次数 \n商品价格总额=商品价格×流通商品量 \n货币量取决于价格水平、进入流通的商品数量和货币的流通速度 \n黄金与纸币的区别 \n在金币流通条件下，流通所需要的货币数量是由商品价格总额决定的；而在纸币为唯\n一流通手段的条件下，商品价格水平会随纸币数量的增减而涨跌。 \n黄金的自动调节器功能 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>55\n \n57 \n二、费雪方程式与剑桥方程式★★★ \n（\n（一）费雪方程式 \nMV＝PT \nM 为一定时期内流通货币的平均数量； \nV 为货币流通速度； \nP 为各类商品价格的加权平均数； \nT 为各类商品的交易数量。 \n角度一：P=MV/T \nM 是外生的；V、T 是常数；价格主要取决于流通中货币的数量。 \n角度二：M=PT/V \n货币需求决定于：①名义收入水平PT 引致的交易水平；②经济中影响人们交易方式、\n决定货币流通速度V 的制度因素。 \n（\n（二）剑桥方程式 \nMd= kPY \nk 为以货币形态保有的财富占名义总收入的比例。 \nY 总收入 \n若取k=1/V，则剑桥方程式与费雪方程式在形式上等价",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "保有的财富占名义总收入的比例。 \nY 总收入 \n若取k=1/V，则剑桥方程式与费雪方程式在形式上等价。 \n与费雪交易方程式的区别: \n货币需求分析：交易手段vs 资产功能 \n流量vs 存量：现金交易说vs 现金余额说 \n宏观vs 微观 \n \n三\n三、凯恩斯货币需求理论★★★★ \n流动性偏好理论（货币和债券） \n货币需求动机： \n交易动机 \n>>>> 黄达金融学基础精讲\n56<<\n \n58 \n预防动机 \n投机动机 \nM=M1+M2=L1(Y)+L2(i) \n流动性陷阱 \n当一定时期的利率水平降低到不能再低时，人们就会产生利率上升、债券价格下跌的\n预期，从而货币需求弹性就会变得无限大，即无论增加多少货币，都会被人们储存起来。 \n政策主张 \n货币政策会陷入流动性陷阱，因此应采用积极的财政政策更有效。 \n \n四\n四、后凯恩斯学派的发展★★ \n（1）交易性货币需求和预防性货币需求同样也是利率的函数 \n平方根法则 \n=1/21/2 \n立方根法则 \n=((22 z)/)1/3 \n（2）多样化资产选择对投机性货币需求的影响 \n多样化资产组合选择理论（风险与收益） \n \n五\n五、弗里德曼的现代货币数量论★★★★ \n \nd\nM\n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "多样化资产组合选择理论（风险与收益） \n \n五\n五、弗里德曼的现代货币数量论★★★★ \n \nd\nM\nP\n：实际货币需求 \ny：实际恒久性收入 \nw：非人力财富占个人总财富的比率（继承、投资） \n1\n, , ,\nm\nb\ne\ndp\nr\nr r P dt\n⋅\n：机会成本变量 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>57\n \n59 \nu：综合变数 \n主要观点： \n由于恒久性收入（财富总额）的波动幅度比现期收入小得多，因此货币需求函数相对\n稳定。货币需求对利率不敏感。 \n政策主张： \n货币政策的单一规则：将货币供应量作为唯一的政策工具，并制定货币供应量增长的\n数量法则，使货币增长率同预期的经济增长率保持一致。 \n \n六\n六、货币需求理论发展脉络★★ \n（1）货币需求函数： \nf（Y）→ f（Y，r）→ 不断引入更多的自变量 \n（2）宏观分析：强调购买手段和支付手段 \n（3）微观分析：既有流通职能又有保存价值职能 \n（4）未来变化趋势 \n货币需求的结构将发生变化 \n货币需求的不稳定性增强 \n货币流通速度将发生变化 \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n58<<\n \n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "通速度将发生变化 \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n58<<\n \n60 \n \n第十四章  现代货币创造机制 \n \n \n \n一\n一、现代货币创造机制 \n（\n（一）现代货币都是信用货币★★★ \n信用货币 \n是法律规范的债权债务文书，以信用关系网络（债权债务关系网络）为流通基础。 \n存款货币 \nIMF 定义：除钞票和硬币外的，以银行信用为基础的货币。（例如：银行券、活期存\n款、定期存款等） \n原始存款（R） \n商业银行接受客户的现金存款以及从中央银行获得的再贴现及再贷款资金形成的存\n款 \n派生存款 \n由银行的贷款和投资活动而衍生出来的存款 \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>59\n \n61 \n（二）存款货币的创造★★★ \n必要前提条件： \n各个银行对于自己所吸收的存款只需保留一定比例的准备金 \n不用现金即可完成结算的银行清算体系 \n存款货币创造乘数：\n1\nd\nD\nK\nR\nr\n∆\n=\n=\n∆\n（D 是存款总额） \n影响乘数大小的因素： \n法定准备金率 \n活期存款 \n现金漏损率 \n超额准备金 \n思考：是存款创造贷款还是贷款创造存款？ \n（\n（三）中央银",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "\n活期存款 \n现金漏损率 \n超额准备金 \n思考：是存款创造贷款还是贷款创造存款？ \n（\n（三）中央银行体制下的货币创造过程★★★★ \n现金是怎样进入流通的？ \n当存款货币银行总体向中央银行提取的现金多于存入的现金，是现金发行量的增长，\n简称现金发行。 \n准备存款必须不断地得到补充来保证现金的发行。 \n准备存款的补充 \n向中央银行再贴现和直接取得贷款 \n向中央银行出售自己持有的债券 \n向中央银行出售自己持有的外汇 \n基础货币 \n中央银行发行的债务凭证：B=R+C \nR：商业银行体系持有的存款准备金 \nC：流通于银行体系之外的现金 \n \n>>>> 黄达金融学基础精讲\n60<<\n \n62 \n货币乘数：\n1\nS\nC\nD\nM\nm\nB\nm\nC\nR\nD\nD\n+\n=\n×\n→\n=\n+\n \nB：中央银行的货币供给操作，以及存款货币银行向央行的借款行为 \nC/D：居民、企业的持币行为 \nR/D：法定准备率和超额准备率，取决于存款货币银行的行为。 \n企业行为既有力地作用于R/D，也间接影响B 的形成。 \n评价 \n最节约的货币制度； \n双层次的货币创造结构； \n联结微观金融与宏观金融的关节点。 \n \n \n \n \n \n \n \n \n \n ",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "双层次的货币创造结构； \n联结微观金融与宏观金融的关节点。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>61\n \n63 \n \n第十五章  货币供给 \n \n \n \n一\n一、货币供给★★★ \n（\n（一）货币供给层次 \nIMF 的M 系列 \n通货 \n货币：等于存款货币银行以外的通货加私人部门的活期存款之和 \n准货币：相当于定期存款、储蓄存款与外币存款之和 \n我国货币供给层次的划分 \nM0＝流通中现金 \nM1＝M0＋活期存款（狭义货币） \nM2＝M1＋定期存款＋储蓄存款＋其他存款＋证券公司客户保证金（广义货币） \nM2-M1=准货币 \nM1/M2——货币供给的流动性 \n \n>>>> 黄达金融学基础精讲\n62<<\n \n64 \n（二）货币供给控制工具 \n公开市场操作 \n贴现政策 \n法定准备金率 \n公开市场操作 \n公开市场操作是指货币当局在金融市场上出售或购入财政部和政府机构的证券，特别\n是短期国库券，以影响基础货币。 \n贴现政策 \n贴现政策是指货币当局通过变动自己对商业银行所持票据再贴现的再贴现率来影响\n贷款的数量和基础货币量的政策。 \n法",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "指货币当局通过变动自己对商业银行所持票据再贴现的再贴现率来影响\n贷款的数量和基础货币量的政策。 \n法定准备金率 \n当货币当局提高法定准备金率时，商业银行一定比率的超额准备金就会转化为法定准\n备金，导致商业银行的放款能力降低、货币乘数变小，货币供应就会相应收缩；当降低法\n定准备金率时，则出现相反的调节效果，最终会扩大货币供应量。 \n（\n（三）货币供给是内生的还是外生的 \n货币供给外生论 \n货币主义(弗里德曼) \n观点：货币本源来自中央银行资产负债业务，控制央行新增贷款就可以控制货币供应。 \n货币供给不应简单看作外生变量 \n后凯恩斯学派(J.托宾) \n观点：倒逼机制，货币供给被动适应货币需求。 \n（\n（四）货币是否“超发”？ \n表现：我国M2 货币增长速度超过经济增长速度与通货膨胀率之和。 \n几种讨论： \n①通货膨胀率被低估？产出被低估？ \n②货币窖藏现象？随着金融资产多样化得以改善 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>63\n \n65 \n③货币流通速度减缓？ \n \n二\n二、货币均衡★★★★ \n（\n（一）货币均衡的含义 \n货币均衡是指货币供给与货币需求相适应的状态。 \n判断货币均衡的标",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "★★ \n（\n（一）货币均衡的含义 \n货币均衡是指货币供给与货币需求相适应的状态。 \n判断货币均衡的标志： \n物价水平（P） \n利率（r） \n（\n（二）市场总供求平衡与货币均衡 \n市场总需求AD=C+I+G+X \n总供给AS=总需求AD \n①市场总供给决定货币需求 \n经济体系中到底需要多少货币，从根本取决于有多少实际资源需要货币实现其流转并\n完成生产、交换、分配和消费相互联系的再生产流程。 \n②货币供给决定市场总需求 \n货币供给是社会总需求的载体。社会总需求是人们在一定收入水平约束下，对商品及\n劳务的需求。收入水平决定了人们的总需求，而货币供给又决定了人们的收入水平。 \n \n货币供给的变动能否对实际产出水平发生影响？（图中箭头的方向能不能反过来？） \n（\n（三）货币中性与货币非中性 \n货币面纱——货币中性论 \n货币数量的变动会影响商品价格并使价格总水平变动，但不会改变相对价格从各种商\n品和服务价格对比角度看的价格。 \n>>>> 黄达金融学基础精讲\n64<<\n \n66 \n货币面纱——货币中性论 \n货币数量的变动会影响商品价格并使价格总水平变动，但不会改变相对价格从各种商\n品和服务价格对比角度看的价格。 \n货币幻觉",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "响商品价格并使价格总水平变动，但不会改变相对价格从各种商\n品和服务价格对比角度看的价格。 \n货币幻觉——货币非中性 \n在通货膨胀时期，人们的名义货币收入与实际货币收入之间会产生差距，人们忽视货\n币实际购买力的变化，而仅仅满足于货币名义价值的现象。 \n凯恩斯——货币非中性：货币政策的积极作用 \n弗里德曼——货币中性：单一货币政策 \n货币的短期非中性与长期中性 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>65\n \n67 \n \n第十七章  开放经济的均衡 \n \n \n \n一\n一、国际收支★★★★ \n（\n（一）定义 \n在一定时期内，一国居民与非居民之间的全部经济交易的系统记录。 \n对外的交往 \n货币记录 \n流量概念 \n事后概念 \n（\n（二）国际收支平衡表 \n国际收支平衡表是将每一笔国际收支记录按照特定账户分类和复式记账原则而汇总\n编制的会计报表。 \n账户分类 \n复式记账法 \n记账货币 \n账户分类 \n>>>> 黄达金融学基础精讲\n66<<\n \n68 \n经常项目： \n货物 \n服务 \n收益（初次收入） \n经常转移（二次收入） \n资本和金",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "<<\n \n68 \n经常项目： \n货物 \n服务 \n收益（初次收入） \n经常转移（二次收入） \n资本和金融项目： \n资本账户 \n资本转移和非生产非金融资产的收买和放弃 \n金融账户 \n直接投资、证券投资、衍生工具、其他投资和储备资产 \n账户分类 \n经常项目 \n资本和金融项目 \n错误和遗漏账户 \n（\n（三）国际收支不平衡问题 \n统计口径 \n贸易收支差额：最主要的项目 \n经常项目收支差额：与贸易差额通常同方向，反应一国对外债权债务关系。 \n国际收支总差额（综合账户收支差额）：与国际储备的增减相对应 \n自主性交易 \n企业、单位和个人由于自身的需要而进行的交易，如商品和服务的输出入、赠予、侨\n民汇款和长期资本流出入。 \n补偿性交易 \n在自主性交易产生不平衡时所进行的用以平衡收支的弥补性交易，如向国外银行和国\n际金融机构借用短期资本、进口商取得分期付款的权利以及动用国际储备等。 \n原因 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>67\n \n69 \n临时性不平衡 \n结构性不平衡 \n货币性不平衡 \n周期性不平衡 \n收入性不平衡 \n预期性不平衡 \n币值扭曲 \n（\n（四）国际收支不平衡的调节 \n1.国际收支不平",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "衡 \n收入性不平衡 \n预期性不平衡 \n币值扭曲 \n（\n（四）国际收支不平衡的调节 \n1.国际收支不平衡的自动调节机制 \n货币-价格调节机制 \n当一个国家国际收支发生逆差时（顺差时情况相反），意味着对外支付大于收入，货\n币外流；在其他条件既定的情况下，物价下降，本国出口商品价格也下降，出口增加，贸\n易差额因此而得到改善。 \n2.国际收支调节的弹性分析法 \n马歇尔-勒纳条件 \n进出口需求价格弹性之和大于1 时，本币贬值导致经常项目差额的增加；相反，当进\n出口需求价格弹性之和小于1 时，本币贬值导致经常项目差额减少。 \nEm+Ex>1 \n马歇尔-勒纳条件：Em+Ex>1 \nJ 曲线效应 \n本国货币贬值后，最初发生的情况往往正好相反，经常项目收支状况反而会比原先恶\n化，进口增加而出口减少，经过一段时间，贸易收入才会增加。 \nY=C+I+(X-M) \nX-M=Y-(C+I) \nB=Y-A \n>>>> 黄达金融学基础精讲\n68<<\n \n70 \n政策主张：应当运用紧缩性的财政货币政策来减少总需求，进而减少对进口品的需求，\n已纠正国际收支逆差。 \n3.国际收支调节的货币分析法 \n国际收支本质上是一种货币现象，国际收支逆差是一",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "纠正国际收支逆差。 \n3.国际收支调节的货币分析法 \n国际收支本质上是一种货币现象，国际收支逆差是一国国内名义货币供应量超过了名\n义货币需求量。 \n国际收支失衡只能用货币政策来纠正，如贬值、关税、进口限额、外汇管制等。只有\n当他们的作用是提高货币需求，尤其是提高国内价格水平时，才能改善国际收支。 \n \n二\n二、国际储备★★★ \n（\n（一）定义 \n一国货币当局持有的，能随时用来干预外汇市场，弥补国际收支逆差、维持其货币汇\n率和作为偿债保证，被各国所普遍接受的各种形式资产的总称。 \n（\n（二）构成 \n货币当局持有的黄金 \n外汇储备 \n在IMF 的储备头寸 \n特别提款权 \n其他债权 \n（\n（三）作用 \n应付国际收支失衡 \n维持汇率稳定 \n对外偿债的信用保证，国际偿付能力 \n改革基金，影响货币发行量 \n（\n（四）管理 \n规模管理 \n①货币供给的压力 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>69\n \n71 \n②对外债权形式的资金外溢 \n③汇率波动的损失 \n结构管理 \n①多样性 \n②流动性 \n③盈利性 \n④安全性 \n \n三\n三、国际资本流动★★★ \n（\n（一）定义 \n国际间的资金流动分为两类： ",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "利性 \n④安全性 \n \n三\n三、国际资本流动★★★ \n（\n（一）定义 \n国际间的资金流动分为两类： \n一种是和实际生产、贸易有密切关系的资金流动； \n一种是和实际生产、贸易无直接关系、主要以获取资产差价和金融收益为目的而在国\n际间进行的纯金融性质的流动。（国际游资） \n（\n（二）特点 \n国际金融市场交易量巨大，不再依赖与实体经济而独立增长。 \n国际金融市场很大程度上呈现批发市场的特征，机构投资者是国际资金流动的主要载\n体。 \n衍生品交易比重不断上升，交易虚拟化程度提高。 \n（\n（三）原因 \n国际金融市场资金供给的充足。 \n金融市场一体化促进了资金在全球的配置和套利。 \n资金为规避管制或避险而发生流动。 \n金融创新的促进。 \n国际资金流动管制的放松。 \n \n>>>> 黄达金融学基础精讲\n70<<\n \n72 \n（四）影响 \n正面影响 \n促进了全球范围内资本的优化配置 \n促进了财富效应的传导 \n增强了资金的流动性 \n推动了国际金融市场的一体化 \n负面影响 \n国际资金流动加大了各国维持外部平衡的难度。 \n国际资金流动加大了微观经济主体经营的困难。 \n国际金融市场的衍生工具放大了交易风险。 \n国际资金的流动会影响内部均",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "大了微观经济主体经营的困难。 \n国际金融市场的衍生工具放大了交易风险。 \n国际资金的流动会影响内部均衡的实现。 \n国际资金流动会将一国的经济波动传导到其他国家。 \n（\n（五）我国的利用外资和境外投资 \n外国直接投资(FDI) \n中外合资企业 \n对外借款 \n发行债券和股票(QFII、QDII) \n上市融资 \n \n四\n四、开放经济下的均衡★★★ \n（\n（一）对外收支与货币均衡 \n开放经济下的货币供给 \n固定汇率 \n一国外汇收支顺差，则构成增加货币供给的压力。 \n浮动汇率 \n自动调节机制。 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>71\n \n73 \n中央银行的外汇操作 \n冲销性操作 \n当汇率出现不恰当波动时，中央银行一方面进入外汇市场抛出或补进外汇使汇率达到\n适当水平；与此同时，中央银行通过购买或出售政府债券等国内资产来抵消因干预汇率而\n释放或回笼本国货币的影响，以维持国内货币供应量不变。 \n非冲销性操作 \n央行在买卖外汇、干预市场的同时，并未采取任何抵消因干预汇率而影响本国货币供\n给的措施，从而外汇买卖的结果是国内货币供应量的净增或净减。 \n（\n（二）对外收支与市场总供求 \n来自贸易收支的",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "从而外汇买卖的结果是国内货币供应量的净增或净减。 \n（\n（二）对外收支与市场总供求 \n来自贸易收支的影响 \n来自资本流出入的影响 \n来自非贸易收支的影响 \n外汇收支的调节作用 \n调节社会总产品和国民收入的产出总额及其在分配、使用方面的矛盾。 \n促进技术开发和产业结构调整。 \n转化资源。 \n提高国民收入，增辟财源。 \n国内经济是基础 \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n72<<\n \n74 \n \n第十九章  货币政策 \n \n \n \n一\n一、货币政策★★ \n中央银行在追求可维持的实际产出增长、高就业和物价稳定时所采取的用以影响货币\n和其他金融环境的措施。 \n货币政策包括三个方面的基本内容：①政策目标；②实现目标所运用的政策工具；③\n预期达到的政策效果。从确定目标、运用工具，到实现预期的政策效果，其间还存在着一\n些作用环节，主要包括中介指标和政策传导机制等。 \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>73\n \n75 \n二、货币政策目标★★ \n经济增长、物价稳定、充分就业、国际收支平衡 \n“保持货币币值的稳定，并以此促进经济增长。”——《中华人民共和国中国人民",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "、充分就业、国际收支平衡 \n“保持货币币值的稳定，并以此促进经济增长。”——《中华人民共和国中国人民银\n行法》 \n单一目标or 双重目标or 多重目标 \n利率 \n货币供应量 \n超额准备金 \n基础货币 \n中介指标的选择 \n可控性 \n可测性 \n相关性 \n抗干扰性 \n适应性 \n \n三\n三、货币政策规则★★★ \n相机决策：反周期货币政策：经济趋热，相应紧缩；经济趋冷，相应扩张。 \n单一规则：货币主义 \n泰勒规则： \n*\n*\n*\n(\n)\n(\n)\nr\nr\np\np\ny\ny\nα\nβ\n=\n+\n−\n+\n−\n \nr：联邦基金利率；\n*r ：均衡利率 \n*\n(\n)\np\np\nα\n−\n：对实际通胀的调节 \n*\n(\n)\ny\ny\nβ\n−\n：对实际产出的调节 \n \n>>>> 黄达金融学基础精讲\n74<<\n \n76 \n四、货币政策工具★★★★ \n（\n（一）传统货币政策工具 \n目标：调节货币总量 \n公开市场业务：主动、直接、连续、灵活、短期 \n回购：回收流动性 \n逆回购：释放流动性 \n再贴现政策：利率变动的告示效应；政策主动调节效果有限 \n法定准备金率：最猛烈、货币乘数、固定化预期 \n（\n（二）新型货币政策工具 \n常备借贷便利（SLF） \n中期借",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "金率：最猛烈、货币乘数、固定化预期 \n（\n（二）新型货币政策工具 \n常备借贷便利（SLF） \n中期借贷便利（MLF） \n定向中期借贷便利（TMLF） \n抵押补充贷款（PSL） \n（\n（三）直接信用控制 \n从质和量两个方面，以行政命令或其他方式，直接对金融机构尤其是商业银行的信用\n活动进行控制。 \n存贷款最高利率限制 \n信用配额 \n规定商业银行的流动性比率 \n直接干预 \n（\n（四）间接信用控制 \n中央银行通过道义劝告、窗口指导等办法间接影响商业银行的信用创造。 \n道义劝告 \n指中央银行利用其声望与地位，对商业银行和金融机构经常发出通告，指示或与各金\n融体系的负责人举行面谈，劝告其遵守政府政策，自动采取若干相应措施。 \n窗口指导 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>75\n \n77 \n是指央银行通过劝告和建议来影响商业银行信贷行为，属于温和的、非强制性的货币\n政策工具。 \n \n五\n五、货币政策传导机制★★★★ \n关键指标：利率？货币供给量？资产价格？信贷供给？ \n传导路径 \n理论依据 \n（\n（一）凯恩斯学派 \nM→ r → I→ E→ Y \n关键环节：利率 \n凯恩斯利率决定论：利率由货",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "（\n（一）凯恩斯学派 \nM→ r → I→ E→ Y \n关键环节：利率 \n凯恩斯利率决定论：利率由货币的供求关系决定 \n政策主张： \n流动性陷阱 \n财政政策的重要性 \n（\n（二）托宾q 理\n理论 \nM→r→PE→q→ I→Y \n关键环节：资产价格 \n托宾q 值：企业市场价值与资产重置成本之比 \n（\n（三）财富传导机制 \nM→r→PE→W→ C→Y \n疑问：M→r→PE？ \n（\n（四）货币学派 \nM→E→I→Y \n关键环节：货币供应量 \n货币供给量的变化直接影响支出 \n \n>>>> 黄达金融学基础精讲\n76<<\n \n78 \n货币需求是内生的，货币供给是外生的 \n政策效果： \n短期：价格和产出同时增长 \n长期：物价上涨 \n（\n（五）信贷传导机制理论 \n关键环节：信贷 \n1.银行信贷渠道 \n紧缩性货币政策→R→D→ L→ I→ Y \n特点：商业银行主动调节信贷规模 \n2.个人资产负债表渠道 \nM→r→PE → NCF→H→ L→ I→ Y \n借款人角度 \n利率的上升导致利息等费用支出的增加，现金流减少，资产状况恶化，担保品价值缩\n水。 \n借款人难以获得融资，投资与产出下降。 \n（\n（六）总结 \n \n凯恩斯学派 \n托",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "担保品价值缩\n水。 \n借款人难以获得融资，投资与产出下降。 \n（\n（六）总结 \n \n凯恩斯学派 \n托宾q 理论 \n货币学派 \n信贷传导 \n关键环节 \n利率 \n资产价格 \n货币供应量 \n信用/信贷规模 \n传导路径 \nM→ r → I → \nE → Y \nM→r→PE→q → \nI →Y \nM→E→I →Y \n银行信贷； \n资产负债表 \n理论依据 \n利率决定论 \nq 值决定企业的新\n投资 \n货币供给的外生\n性 \n银行与借款人对信\n贷规模的主动调节 \n主张/缺陷 \n流动性陷阱 \n财政政策 \n利率/货币供应量\n如何影响资产价\n格？ \n货币政策在长期\n只影响物价水平 \n信贷传导的独立性 \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>77\n \n79 \n六、货币政策效应★★ \n影响货币政策效果的因素： \n时滞（内部时滞和外部时滞） \n货币流通速度 \n微观主体的预期 \n政策透明度与信任 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n78<<\n \n80 \n \n第二十章  货币政策与财政政策 \n \n \n \n一\n一、通货膨胀★★★ \n（\n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "8<<\n \n80 \n \n第二十章  货币政策与财政政策 \n \n \n \n一\n一、通货膨胀★★★ \n（\n（一）定义与度量 \n定义 \n商品和服务的货币价格总水平持续地上涨。 \n（\n（二）定义与度量 \n度量 \n居民消费物价指数（CPI） \n（生产价格指数PPI） \n批发物价指数（WPI） \nGNP 或GDP 的冲减指数（deflator） \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>79\n \n81 \n（三）成因 \n需求拉动说 \n总需求大于总供给：投资路径与货币供给路径 \n成本推动说 \n供给因素：工资-价格螺旋上升与垄断利润 \n供求混合推动说 \n（\n（四）社会经济效应 \n强制储蓄效应 \n收入分配效应 \n资产结构调整效应（财富分配效应） \n实物资产和金融资产 \n债务人和债权人 \n（\n（五）通货膨胀与经济增长 \n1.经济增长往往伴随着通货膨胀。 \n2.通货膨胀与就业的关系——菲利普斯曲线 \n通货膨胀与就业交互替代的关系 \n高通货膨胀率、高失业率与低成长并存的滞涨 \n低通货膨胀率、低失业率和高成长结合的新经济时代 \n（\n（五）通货膨胀的对策 \n宏观紧缩政策（紧缩性的货币政策、紧缩性的财政政策） \n反",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "的新经济时代 \n（\n（五）通货膨胀的对策 \n宏观紧缩政策（紧缩性的货币政策、紧缩性的财政政策） \n反垄断政策 \n供给政策 \n指数化 \n \n \n \n>>>> 黄达金融学基础精讲\n80<<\n \n82 \n二、财政政策★★★ \n（\n（一）定义 \n对政府财政支出、税收和借债水平所进行的选择，或对政府财政收入和支出水平所作\n的决策 \n（\n（二）特征 \n自动稳定器 \n财政政策本身具有一种自动调节经济、减少经济波动的机制，在繁荣时自动抑制通胀，\n萧条时自动增加需求。 \n（\n（三）财政赤字与国债 \n财政赤字的统计 \n财政赤字=经常性财政支出-经常性财政收入 \n财政赤字=（经常性财政支出+债务还本付息支出）-（经常性财政收入+债务收入） \nIMF \n财政赤字=（财政支出+净增贷款）-（财政收入+补助总额） \n发行国债是世界各国弥补财政赤字的普遍做法。 \n国债发行警戒线 \n国债依存度 \n国债负担率 \n国债偿债率 \n发债是财政收支作用于货币供给的主要途径。（中央银行通过在二级市场买卖国债来\n吞吐货币。） \n \n三\n三、货币政策与财政政策的配合★★★★ \n（\n（一）组合的基础 \n货币政策与财政政策都是需求管理政策。（短期内更易调节） ",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "策的配合★★★★ \n（\n（一）组合的基础 \n货币政策与财政政策都是需求管理政策。（短期内更易调节） \nwww.koolearn.com\n>>>>>> 新东方在线\n>>81\n \n83 \n由于市场需求的载体是货币，所以调节市场需求就是调节货币供给：金融手段与财政\n手段 \n（\n（二）组合的模式 \n政策配合方式 \n货币政策 \n财政政策 \n“松财政松货币”政策 \n“松财政紧货币”政策 \n“紧财政松货币”政策 \n“紧财政紧货币”政策 \n分析工具：IS-LM 模型 \n经济疲软、萧条时，财政政策的扩张作用强于货币政策的扩张作用； \n经济过热时，治理通货膨胀和虚假繁荣，紧缩性的货币政策优于财政政策； \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n82<<\n \n84 \n \n第二十一章  开放条件下的政策搭配与协调 \n \n \n \n一\n一、开放经济下的均衡★★★★ \n（\n（一）均衡目标 \n内部均衡：经济增长、充分就业、物价稳定 \n外部均衡：国际收支平衡 \n（\n（二）内部均衡与外部均衡的冲突 \n米德冲突 \n固定汇率制度下，汇率工具无法使用，在调节国内均衡与国际均衡时，财政政策、货\n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "衡的冲突 \n米德冲突 \n固定汇率制度下，汇率工具无法使用，在调节国内均衡与国际均衡时，财政政策、货\n币政策会左右为难。 \n表现： \n经济衰退/失业增加与国际收支逆差 \n通货膨胀与国际收支顺差 \n最优指派原则（蒙代尔） \n在固定汇率之下，把内部均衡目标分派给财政政策，外部均衡目标分派给货币政策，\n方能达到经济的全面均衡。 \n克鲁格曼三角形 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>83\n \n85 \n一个国家的金融政策有三个基本目标，即本国货币政策的独立性、汇率的稳定性和资\n本自由流动，不可能同时实现。 \n \n二\n二、蒙代尔-弗\n弗莱明模型（IS-LM-BP 模\n模型）★★★★ \n——开放经济下均衡的调节模型 \n（\n（一）基本假定 \n商品价格不变 \n产出完全由总需求决定 \n本币贬值使产出增加 \n资本流动有两国利率差异决定 \n（\n（二）BP 曲\n曲线 \n国际收支平衡 \n \n国际收支平衡表示为经常账户和资本账户之和的平衡。 \n经常账户的收支由贸易决定，即净出口。 \n资本账户的收支由国内外利率差异决定，国内利率高于国际利率则资本流入，反之，\n则资本流出。ω 表示资本流动程度。 \n（\n（三）典型分",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "决定，国内利率高于国际利率则资本流入，反之，\n则资本流出。ω 表示资本流动程度。 \n（\n（三）典型分析 \n1.资本完全不流动，固定汇率制度下的内外均衡调节 \nω =0，BP 曲线是一条垂直线。 \n国际收支不平衡会得到自动调节。 \n2.资本不完全流动，浮动汇率制度下的内外均衡调节 \nω >0，BP 曲线是一条斜率为正的直线。 \n利率上升能够吸引资本流入，以弥补收入上升带来进口增加造成的贸易逆差。 \n3.资本完全流动，浮动汇率制度下的内外均衡调节 \nω →∞，BP 曲线是一条水平线。 \n>>>> 黄达金融学基础精讲\n84<<\n \n86 \n国际收支与汇率和产出无关，只与国内外利率差异有关。 \n（\n（四）总结 \n不同条件下，国际收支失衡引发的曲线移动 \n资本流动情况 \n汇率制度 \nIS 曲线 \nLM 曲线 \nBP 曲线 \n完全不流动 \n固定 \nX \n√ \nX \n浮动 \n√ \nX \n√ \n不完全流动 \n固定 \nX \n√ \nX \n浮动 \n√ \nX \n√ \n完全流动 \n固定 \nX \n√ \nX \n浮动 \n√ \nX \nX \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": " \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>85\n \n87 \n \n第二十七章  金融发展与经济增长 \n \n \n \n一\n一、金融发展★★★ \n（\n（一）金融发展的定义 \n（戈德史密斯）金融结构的变化。 \n金融结构包括金融工具的结构和金融机构的结构两个方面。一般来说，金融工具的数\n量、种类、先进程度，以及金融机构的数量、种类、效率等的组合，形成了发展程度高低\n不同的金融结构。金融发展程度越高，金融工具和金融机构的数量、种类就越多，金融的\n效率就越高。 \n（\n（二）金融发展的指标 \n金融结构指标 \n>>>> 黄达金融学基础精讲\n86<<\n \n88 \n主要金融资产（如短期债券、长期债券和股票等）占全部金融资产的比重。 \n主要金融机构（如中央银行、商业银行、储蓄机构及保险组织）的相对规模。 \n金融机构发行的金融工具与非金融机构发行的金融工具的比率；在非金融机构发行的\n主要金融工具中，由金融机构持有的份额。这两个比率用以衡量金融机构化程度。 \n各类金融机构的资产分别占全部金融机构总资产的比率，分层比率，用以衡量金融机\n构间的相关程度。 \n金融",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "各类金融机构的资产分别占全部金融机构总资产的比率，分层比率，用以衡量金融机\n构间的相关程度。 \n金融发展与经济增长的相互关系指标★★★★ \n金融相关率：某一时期一国全部金融资产价值与该国经济活动总量的比值。 \n货币化率：一国通过货币进行交换的商品和服务的值占国民生产总值的比重。（货币\n供给量/GDP） \n金融深度：金融体系的负债/GDP \n（\n（三）金融发展的目标 \n通过完善金融系统地功能，提高金融系统资源配置的效率，优化金融体系，并以此促\n进经济增长。 \n \n二\n二、金融发展与经济增长的实证检验★★★★ \n（\n（一）实证研究与规范研究 \n规范分析 \n根据一定的价值判断为基础，提出某些分析处理经济问题的标准，树立经济理论的前\n提，作为制定经济政策的依据，并研究如何才能符合这些标准。 \n实证分析 \n排除了主观价值判断，只对经济现象、经济行为或经济活动及其发展趋势做客观分析，\n只考虑经济事物间相互联系的规律，并根据这些规律来分析和预测人们经济行为的效果。 \n（\n（二）相关关系与因果关系 \n游泳池溺亡率和冰淇淋销量 \n医院和死亡率 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>87\n \n89 \n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "\n医院和死亡率 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>87\n \n89 \n是金融发展促进了经济增长，还是经济增长促进了金融发展？ \n（\n（三）实证结果 \n从纵的方向看，在一国的经济发展过程中，金融资产的增长比国民财富的增长更为迅\n速。 \n从横的方向看，经济欠发达国家的金融相关率比欧洲和北美国家的金融相关率低得\n多。 \n戈德史密斯谨慎地认为尚“无把握建立因果机制”。 \n罗伯特·G.金（Robert G.King）和罗斯·列文（Ross Levine）研究了77 个国家1960-1989\n年的状况，发现金融发展与经济增长存在显著的正相关； \n罗斯·列文和萨拉·泽维斯（Sara Zervos）研究了41 个国家1976-1993 年股票市场\n与长期经济增长的关系，说明股票市场的发展与经济增长正相关。 \n \n三\n三、（经济）金融化★★★ \n（\n（一）定义 \n最近几十年来全球范围内金融资产规模相对于实体经济加速扩张、金融部门影响力持\n续增大的过程。 \n（\n（二）影响 \n主流理论（如前面所述的金融发展理论）关注金融因素对经济发展的促进作用，认为\n金融化有利于增进金融资源配置效率和促进经济发展； ",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "发展理论）关注金融因素对经济发展的促进作用，认为\n金融化有利于增进金融资源配置效率和促进经济发展； \n而非主流理论则更多地强调金融因素对实体经济发展的负面影响。 \n \n四\n四、金融压抑★★★ \n（\n（一）定义 \n（麦金农&肖）发展中国家存在的市场机制作用没有得到充分发挥、金融资产单调、\n金融机构形式单一、过多的金融管制和金融效率低下等现象。 \n \n>>>> 黄达金融学基础精讲\n88<<\n \n90 \n（二）影响 \n原因：经济发展水平+主动政策压抑 \n后果：利率扭曲，导致资源错配和损害经济效率 \n建议：避免实际利率长期处于过低的水平，适当提高利率 \n \n五\n五、金融自由化★★★ \n（\n（一）核心内容 \n放松利率管制； \n缩小指导性信贷计划实施范围； \n减少金融机构审批限制，促进金融同业竞争； \n发行直接融资工具，活跃证券市场； \n放松对汇率和资本流动的限制。 \n（\n（二）经济效应 \n储蓄效应： \n投资效应； \n就业效应； \n收入分配效应； \n稳定效应； \n减少政府干预带来的效率损失和贪污腐化。 \n（\n（三）理论说明 \n（1）货币与实物资本的互补性假说； \n（2）导管效应：投资和存款货币的实际利率在一定条件下成正向",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": " \n（1）货币与实物资本的互补性假说； \n（2）导管效应：投资和存款货币的实际利率在一定条件下成正向关系 \n（1）对实物资本需求越高，对货币的需求也越大。传统理论认为二者是替代品。 \n（2）投资和存款货币的实际利率在一定条件下成正向关系 \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>89\n \n91 \n六、普惠金融★★★ \n（\n（一）定义 \n普惠金融（financial inclusion）是指使用金融服务的个人和企业占到全部个人和企业\n的较高份额。 \n普惠金融制度是指能够利用金融服务的个人和企业占比很高的制度。 \n（普惠金融不是慈善金融） \n特别是弱势群体。在每个人或者企业有金融需求时，都能以合适的价格获得方便及时、\n有尊严和高质量的金融服务。  \n（\n（二）特点 \n针对“小微”群体 \n企业贷款、农业经营性贷款、消费贷款、助学贷款等 \n小微保险 \n大数据产品设计 \n（\n（二）金融排斥 \n金融体系中人们缺乏分享金融服务机会的状态，包括社会中的弱势群体缺乏足够的能\n力和可行的途径接近金融机构，以及在利用金融产品或金融服务方面存在这样或者那样的\n障碍。 \n金融机构为了降低成本，关闭一些偏",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "机构，以及在利用金融产品或金融服务方面存在这样或者那样的\n障碍。 \n金融机构为了降低成本，关闭一些偏远地区甚至中小城市的分支机构，导致这些地区\n因金融机构减少而无法享受到应有的金融服务。  \n（\n（三）如何推动普惠金融发展 \n重视技术进步的作用。 \n创新产品设计与商业模式。 \n普及金融知识和提升金融能力。 \n强化消费者保护和市场监管。 \n \n \n>>>> 黄达金融学基础精讲\n90<<\n \n92 \n \n第二十八章  金融脆弱性与金融危机 \n \n \n \n一\n一、金融脆弱性 \n（\n（一）定义 \n以高负债经营为特点的金融业具有容易失败的特点，泛指一切融资领域中的风险积\n聚。 \n金融脆弱性与风险的区别 \n（\n（二）表现 \n金融机构的脆弱性：信息不对称，经济周期 \n金融市场的脆弱性：金融资产价格的过度波动 \n（\n（三）相关概念 \n安全边界（银行角度） \n银行收取的利息之中包含有必要风险报酬的边界 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>91\n \n93 \n明斯基时刻（资产角度） \n即资产价值崩溃的时刻。明斯基观点主要是经济长时期稳定可能导致债务增加、杠杆\n比率上升，进而从内部滋生爆发金融危机和陷入",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "刻。明斯基观点主要是经济长时期稳定可能导致债务增加、杠杆\n比率上升，进而从内部滋生爆发金融危机和陷入漫长去杠杆化周期的风险。 \n \n二\n二、金融危机 \n（\n（一）定义 \n全部或大部分金融指标的急剧、短暂和超周期的恶化。 \n（\n（二）普遍发生的金融危机 \n金融危机的“自我实现” \n金融机构的资产负债表恶化，引起挤兑；为满足支付，金融机构急于获得现金，不得\n不出售资产；金融机构急于出售资产，导致资产价格暴跌；资产价格暴跌，进一步恶化私\n人部门的资产负债表…… \n（\n（三）金融危机的国际传播 \n金融全球化的表现 \n①金融活动“游戏规则”的全球一体化。 \n②市场参与者的全球一体化。 \n③金融工具的全球一体化。 \n④金融市场的全球一体化。 \n⑤交易币种多样化。 \n⑥利率的趋同化。 \n⑦金融风险的全球化。 \n \n三\n三、金融创新 \n（\n（一）金融创新的动力 \n避免风险的创新 \n技术进步推动的创新 \n>>>> 黄达金融学基础精讲\n92<<\n \n94 \n规避行政管理的创新 \n（\n（二）金融创新的影响 \n①使得金融工具多样化、灵活化。 \n②使金融机构传统的分工格局被突破，彼此业务全面交叉。 \n③增加了各国货币政策的复杂性。 \n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "活化。 \n②使金融机构传统的分工格局被突破，彼此业务全面交叉。 \n③增加了各国货币政策的复杂性。 \n④金融创新本身又有可能带来新的风险。 \n \n四\n四、几次重大的金融危机 \n（\n（一）次贷危机 \n①次级贷款违规发放与违约——银行监管问题 \n②资产证券化与金融衍生品——金融创新问题 \n③灾后救助问题与“大而不能倒”问题——金融监管问题 \n④美国次贷危机引发全球经济危机 \n美国的次贷危机并未演化成为经济危机，但却引发了全球的经济危机。冰岛破产，欧\n债危机。 \n（\n（二）欧债危机 \n①主权债务危机——国家信用、赤字财政问题 \n②加入欧元区失去独立的货币政策——最优货币区理论的挑战 \n（\n（三）2015 年\n年“股灾” \n①融资融券 \n②股权质押 \n③政策市？ \n④资本市场的功能：从融资功能走向价值投资 \n \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>93\n \n95 \n五、金融危机的防范与治理 \n建立危机预警系统 \n稳定金融市场 \n管理国际资本流动 \n重组和改革金融部门 \n推进宏观及结构性改革 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "改革 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n>>>> 黄达金融学基础精讲\n94<<\n \n96 \n \n第二十九章  金融监管 \n \n \n \n一\n一、金融监管 \n（\n（一）定义与原则 \n定义 \n狭义的金融监管是指金融主管当局依据国家法律法规的授权对金融业（包括金融机构\n以及它们在金融市场上的业务活动）实施监督、约束、管制，使它们依法稳健运行的行为\n总称。 \n广义的金融监管除金融主管当局的监管之外，还包括金融机构的内部控制与稽核、行\n业自律性组织的监督以及社会中介组织的监督等。 \n原则 \n依法管理原则。 \n合理、适度竞争原则。 \nwww.koolearn.com\n>>>>>> 新东方在线\n>>95\n \n97 \n自我约束和外部强制相结合的原则。 \n安全稳健与经济效率相结合的原则。 \n（\n（二）理论依据 \n社会利益论 \n金融体系的公共物品特性及正外部性 \n金融风险论 \n金融体系的风险直接影响着货币制度和宏观经济的稳定 \n投资者利益保护论：信息劣势 \n管制供求论与公共选择论 \n（\n（三）监管成本 \n执法成本 \n守法成本：效率损失 \n道德风险 \n（\n（四）金融监管体制 \n单一监管",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "\n（三）监管成本 \n执法成本 \n守法成本：效率损失 \n道德风险 \n（\n（四）金融监管体制 \n单一监管体制：中央银行 \n多头监管体制：美国 \n \n二\n二、银行监管的国际合作 \n《巴塞尔协议》1988 \n《新巴塞尔协议》2004 \n《巴塞尔协议III》2010 \n（\n（一）《巴塞尔协议》1988 \n①资本的构成 \n核心资本（一级资本）：股本和公开准备金，至少50%；附属资本：未公开的准备金、\n资产重估准备金、普通准备金等。 \n②风险加权资产的计算 \n>>>> 黄达金融学基础精讲\n96<<\n \n98 \n协议规定了资产负债表上的资产和表外科目的风险度量标准。 \n③资本标准比率目标 \n银行的资本对风险加权化资产的标准比率为8%，其中核心资本至少为4% \n（\n（二）《新巴塞尔协议》2004 \n三大支柱： \n①最低资本要求 \n风险加权资产的计算：信用风险+市场风险、操作风险 \n②监管当局的监督 \n四大原则：内部控制、外部监测、能高则高、及早干预 \n③市场纪律 \n核心：信息披露 \n（\n（三）《巴塞尔协议III》\n》2010 \n①资本要求 \n核心资本比率中，将普通股比率由2%→4.5%，核心资本比率由4%→6%。 \n资本留存缓",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "①资本要求 \n核心资本比率中，将普通股比率由2%→4.5%，核心资本比率由4%→6%。 \n资本留存缓冲2.5%（由普通股补充）；反周期缓冲0-2.5% \n②杠杆率要求 \n③宏观审慎监督框架与系统重要性银行 \n④流动性监管标准 \n流动性覆盖比率和净稳定融资比率 \n（\n（四）《巴塞尔协议》的发展特点 \n①基于风险的资本监管，提高资本监管的敏感度。 \n②从资产方监管扩展到资产负债表所有要素的监管。 \n③从单家银行的稳定性拓展到整个金融体系的稳定，涉及流动性监管及系统性风险 \n④从金融体系的稳定性拓展到金融体系与实体经济的联系。 \n \n \nwww.koolearn.com\n>>>>>> 新东方在线\n>>97\n \n99 \n三、我国的金融监管体制 \n中国人民银行 \n中国证券监督管理委员会“证监会”：信息披露监管为中心 \n中国银行保险监督管理委员会“银保监会”：资本金监管为中心 \n国务院金融稳定发展委员会 \n行业协会： \n中国银行间市场交易商协会 \n中国证券投资基金业协会 \n总\n总结 \n（1）金融范畴类 \n功能与定义→制度与演进→决定理论→中国问题 \n例：货币、汇率、信用、利率 \n（2）人物事件类 \n例：格雷欣法则、特里芬",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "演进→决定理论→中国问题 \n例：货币、汇率、信用、利率 \n（2）人物事件类 \n例：格雷欣法则、特里芬悖论、米德冲突、明斯基时刻 \n历史背景+现象描述+理论推导+结论与发展 \n（3）理论机制类 \n（早期）古典主义→凯恩斯主义（后）→弗里德曼货币主义→现代观点 \n例：汇率决定理论、利率决定理论、货币需求理论、货币政策传导机制 \n金融功能观 \n均衡分析法 \n \n>>>> 黄达金融学基础精讲\n98<<\nwww.koolearn.com\n>>>>>> 新东方在线\n>>99\n>>>> 黄达金融学基础精讲\n100<<\n",
        "source": "金融学课程讲义.pdf"
    },
    {
        "text": "# 经典量化金融论文与文章来源\n\n## 建议来源\n1.  **Investopedia**: 金融术语和策略入门的最佳网站。内容清晰易懂，非常适合作为知识库的基础。\n2.  **SSRN (Social Science Research Network)**: 大量金融经济学的工作论文首发地，可以找到许多前沿研究。\n3.  **arXiv q-fin (Quantitative Finance)**: 物理学和计算机学者发表量化金融论文的平台，数学和模型性较强。\n4.  **Google Scholar**: 学术论文的搜索引擎，可以用来查找被广泛引用的经典文献。\n\n## 值得搜索和了解的核心理论与论文\n\n-   **Efficient Market Hypothesis (有效市场假说)**\n    -   *作者*: Eugene Fama\n    -   *核心思想*: 资产价格已完全反映所有可用信息，因此无法持续获得超额回报。这是许多被动投资策略的理论基础。\n\n-   **Capital Asset Pricing Model (CAPM - 资本资产定价模型)**\n    -   *作者*: Wil",
        "source": "paper.txt"
    },
    {
        "text": "ricing Model (CAPM - 资本资产定价模型)**\n    -   *作者*: William Sharpe, John Lintner, Jan Mossin\n    -   *核心思想*: 描述了系统性风险和资产预期回报之间的关系。Alpha 和 Beta 就是这个模型的重要组成部分。\n\n-   **Black-Scholes-Merton Model (布莱克-斯科尔斯-默顿模型)**\n    -   *作者*: Fischer Black, Myron Scholes, Robert Merton\n    -   *核心思想*: 革命性的期权定价公式，为衍生品市场奠定了数学基础。\n\n-   **A Random Walk Down Wall Street (漫步华尔街)**\n    -   *作者*: Burton Malkiel (这是一本书)\n    -   *核心思想*: 向大众普及了随机游走理论和有效市场假说，认为股价短期是不可预测的。\n\n-   **Pairs Trading (统计套利)**\n    -   *文献*: \"Statistical Arbitrage in th",
        "source": "paper.txt"
    },
    {
        "text": "统计套利)**\n    -   *文献*: \"Statistical Arbitrage in the U.S. Equity Market\" by Marco Avellaneda\n    -   *核心思想*: 寻找两个历史走势高度相关的资产，在其价差偏离历史均值时进行对冲交易，属于典型的均值回归策略。\n\n-   **Momentum Strategy (动量策略)**\n    -   *文献*: \"Returns to Buying Winners and Selling Losers: Implications for Stock Market Efficiency\" by Jegadeesh and Titman\n    -   *核心思想*: 证明了在3到12个月的时间尺度上，过去表现好的股票在未来一段时间内会继续表现良好（动量效应）。",
        "source": "paper.txt"
    },
    {
        "text": "import pandas as pd\nimport numpy as np\n\ndef calculate_sharpe_ratio(prices, risk_free_rate=0.02):\n    \"\"\"\n    使用 Pandas 和 NumPy 计算年化夏普比率。\n\n    参数:\n    prices (pd.Series): 包含资产每日收盘价的时间序列。\n    risk_free_rate (float): 年化无风险利率。\n\n    返回:\n    float: 年化夏普比率。\n    \"\"\"\n    # 1. 计算每日回报率\n    # 使用 Pandas 的 pct_change() 函数可以轻松计算每日百分比变化\n    daily_returns = prices.pct_change().dropna()\n\n    # 2. 计算超额回报率\n    # 假设每日的无风险利率是年化利率除以252个交易日\n    daily_risk_free_return = risk_free_rate / 252\n    excess_returns = daily_returns - dail",
        "source": "code.txt"
    },
    {
        "text": "te / 252\n    excess_returns = daily_returns - daily_risk_free_return\n\n    # 3. 计算年化夏普比率\n    # 年化超额回报 = 平均超额回报 * 252\n    # 年化波动率 = 超额回报的标准差 * sqrt(252)\n    avg_excess_return = excess_returns.mean()\n    std_dev_excess_return = excess_returns.std()\n    \n    # 防止除以零\n    if std_dev_excess_return == 0:\n        return 0.0\n\n    sharpe_ratio = (avg_excess_return / std_dev_excess_return) * np.sqrt(252)\n    \n    return sharpe_ratio\n\nif __name__ == '__main__':\n    # 创建一个示例价格序列\n    data = {\n        'price': [100, 102, 1",
        "source": "code.txt"
    },
    {
        "text": "个示例价格序列\n    data = {\n        'price': [100, 102, 101, 103, 105, 104, 106, 108, 110, 109]\n    }\n    dates = pd.to_datetime(pd.date_range(start='2023-01-01', periods=10))\n    price_series = pd.Series(data['price'], index=dates)\n\n    # 计算夏普比率\n    sharpe = calculate_sharpe_ratio(price_series, risk_free_rate=0.02)\n    \n    print(f\"示例价格序列:\\n{price_series}\\n\")\n    print(f\"计算出的年化夏普比率为: {sharpe:.4f}\")\n\n\n# 安装: pip install backtrader\nimport backtrader as bt\nimport datetime\n\n# 1. 创建策略 (Strategy)\nclass SmaCrossStrategy(",
        "source": "code.txt"
    },
    {
        "text": "time\n\n# 1. 创建策略 (Strategy)\nclass SmaCrossStrategy(bt.Strategy):\n    # 定义策略参数\n    params = (\n        ('fast_ma', 10),  # 快速MA周期\n        ('slow_ma', 50),  # 慢速MA周期\n    )\n\n    def __init__(self):\n        # 获取收盘价数据\n        self.dataclose = self.datas[0].close\n        \n        # 初始化订单状态\n        self.order = None\n\n        # 计算移动平均线\n        self.fast_ma = bt.indicators.SimpleMovingAverage(\n            self.datas[0], period=self.params.fast_ma\n        )\n        self.slow_ma = bt.indicators.SimpleMovingAverage(\n    ",
        "source": "code.txt"
    },
    {
        "text": ".slow_ma = bt.indicators.SimpleMovingAverage(\n            self.datas[0], period=self.params.slow_ma\n        )\n        \n        # 计算交叉信号\n        self.crossover = bt.indicators.CrossOver(self.fast_ma, self.slow_ma)\n\n    def next(self):\n        # 如果已有持仓，则不操作\n        if self.position:\n            # 如果出现向下交叉，则平仓\n            if self.crossover < 0:\n                self.close()\n        # 如果没有持仓\n        elif self.crossover > 0:\n            # 出现向上交叉，买入\n            self.buy()\n\n# 2. 主程序\nif __name__ == '__main__':\n    #",
        "source": "code.txt"
    },
    {
        "text": "f.buy()\n\n# 2. 主程序\nif __name__ == '__main__':\n    # 创建Cerebro引擎\n    cerebro = bt.Cerebro()\n\n    # 添加策略\n    cerebro.addstrategy(SmaCrossStrategy)\n\n    # 准备数据\n    # 这里使用 Backtrader 自带的示例数据\n    datapath = ('https://raw.githubusercontent.com/mementum/backtrader/master/datas/orcl-1995-2014.txt')\n    data = bt.feeds.YahooFinanceCSVData(\n        dataname=datapath,\n        fromdate=datetime.datetime(2000, 1, 1),\n        todate=datetime.datetime(2003, 12, 31),\n        reverse=False\n    )\n    \n    # 将数据添加到Cerebro\n    ",
        "source": "code.txt"
    },
    {
        "text": " reverse=False\n    )\n    \n    # 将数据添加到Cerebro\n    cerebro.adddata(data)\n\n    # 设置初始资金\n    cerebro.broker.setcash(100000.0)\n    # 设置佣金\n    cerebro.broker.setcommission(commission=0.001)\n\n    # 打印初始价值\n    print(f'初始资金: {cerebro.broker.getvalue():.2f}')\n\n    # 运行回测\n    cerebro.run()\n\n    # 打印最终价值\n    print(f'最终资金: {cerebro.broker.getvalue():.2f}')\n    \n    # 绘制图表\n    cerebro.plot(style='candlestick', barup='green', bardown='red')",
        "source": "code.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13968\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 20\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_tra",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "eck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n  ",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "   run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_circulating_market_cap_percent'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n  ",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "  # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n  ",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "ities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_ind",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.c",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "t_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stoc",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "rt_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # ",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "sts = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": " # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n##",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "####  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 7)\n    security_list = financial_data_filter_dayu(security_list, valuation.capitalization, 200000)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio_lyr, 20)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 3",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "l_data_filter_dayu(security_list, indicator.roe, 3)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ###",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": ", security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_li",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": " 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "nt_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - le",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_prop",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) o",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "ending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = Tr",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, securit",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": " = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].nam",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "ta[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\n",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            t",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "t_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/75 财务因子策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13382\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n'''\n投资程序：\n霍华．罗斯曼强调其投资风格在于为投资大众建立均衡、且以成长为导向的投资组合。选股方式偏好大型股，\n管理良好且为领导产业趋势，以及产生实际报酬率的公司；不仅重视公司产生现金的能力，也强调有稳定成长能力的重要。\n总市值大于等于50亿美元。\n良好的财务结构。\n较高的股东权益报酬。\n拥有良好且持续的自由现金流量。\n稳定持续的营收成长率。\n优于比较指数的盈余报酬率。\n'''\n\nimport pandas as pd\nimport numpy as np\nimport jqdata\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    #策略参数设置\n    #操作的股票列表\n    g.buy_list = []\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    # 每月第5个交易日进行操作\n    # 开盘前运行\n    run_monthly(before_market_open,5,time='befo",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "运行\n    run_monthly(before_market_open,5,time='before_open', reference_security='000300.XSHG') \n    # 开盘时运行\n    run_monthly(market_open,5,time='open', reference_security='000300.XSHG')\n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    #获取要操作的股票列表\n    temp_list = get_stock_list(context)\n\n    #获取满足条件的股票列表\n    temp_list = get_stock_list(context)\n    log.info('满足条件的股票有%s只'%len(temp_list))\n    #按市值进行排序\n    g.buy_list = get_check_stocks_sort(context,temp_list)\n\n## 开盘时运行函数\ndef market_open(context):\n    #卖出不",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "st)\n\n## 开盘时运行函数\ndef market_open(context):\n    #卖出不在买入列表中的股票\n    sell(context,g.buy_list)\n    #买入不在持仓中的股票，按要操作的股票平均资金\n    buy(context,g.buy_list)\n#交易函数 - 买入\ndef buy(context, buy_lists):\n    # 获取最终的 buy_lists 列表\n    # 买入股票\n    if len(buy_lists)>0:\n        #分配资金\n        cash = context.portfolio.available_cash/(len(buy_lists)*1.0)\n        # 进行买入操作\n        for s in buy_lists:\n            order_value(s,cash)\n       \n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    hold_stock = context.portfoli",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "获取 sell_lists 列表\n    hold_stock = context.portfolio.positions.keys()\n    for s in hold_stock:\n        #卖出不在买入列表中的股票\n        if s not in buy_lists:\n            order_target_value(s,0)   \n\n#按市值进行排序   \n#从大到小\ndef get_check_stocks_sort(context,check_out_lists):\n    df = get_fundamentals(query(valuation.circulating_cap,valuation.pe_ratio,valuation.code).filter(valuation.code.in_(check_out_lists)),date=context.previous_date)\n    #asc值为0，从大到小\n    df = df.sort('circulating_cap',ascending=0)\n    out_lists = list(df['",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "lating_cap',ascending=0)\n    out_lists = list(df['code'].values)\n    return out_lists\n    \n'''\n1.总市值≧市场平均值*1.0。\n2.最近一季流动比率≧市场平均值（流动资产合计/流动负债合计）。\n3.近四季股东权益报酬率（roe）≧市场平均值。\n4.近五年自由现金流量均为正值。（cash_flow.net_operate_cash_flow - cash_flow.net_invest_cash_flow）\n5.近四季营收成长率介于6%至30%（）。    'IRYOY':indicator.inc_revenue_year_on_year, # 营业收入同比增长率(%)\n6.近四季盈余成长率介于8%至50%。(eps比值)\n'''\ndef get_stock_list(context):\n    temp_list = list(get_all_securities(types=['stock']).index)    \n    #剔除停牌股\n    all_data = get_current_data()\n  ",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "  \n    #剔除停牌股\n    all_data = get_current_data()\n    temp_list = [stock for stock in temp_list if not all_data[stock].paused]\n    #获取多期财务数据\n    panel = get_data(temp_list,4)\n    #1.总市值≧市场平均值*1.0。\n    df_mkt = panel.loc[['circulating_market_cap'],3,:]\n    df_mkt = df_mkt[df_mkt['circulating_market_cap']>df_mkt['circulating_market_cap'].mean()]\n    l1 = set(df_mkt.index)\n    \n    #2.最近一季流动比率≧市场平均值（流动资产合计/流动负债合计）。\n    df_cr = panel.loc[['total_current_assets','total_current_liability'],3,:]\n    #替换零的数值\n    df_c",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "otal_current_liability'],3,:]\n    #替换零的数值\n    df_cr = df_cr[df_cr['total_current_liability'] != 0]\n    df_cr['cr'] = df_cr['total_current_assets']/df_cr['total_current_liability']\n    df_cr_temp = df_cr[df_cr['cr']>df_cr['cr'].mean()]\n    l2 = set(df_cr_temp.index)\n\n    #3.近四季股东权益报酬率（roe）≧市场平均值。\n    l3 = {}\n    for i in range(4):\n        roe_mean = panel.loc['roe',i,:].mean()\n        df_3 = panel.iloc[:,i,:]\n        df_temp_3 = df_3[df_3['roe']>roe_mean]\n        if i == 0:    \n            l3 = set(df_temp_3",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "     if i == 0:    \n            l3 = set(df_temp_3.index)\n        else:\n            l_temp = df_temp_3.index\n            l3 = l3 & set(l_temp)\n    l3 = set(l3)\n\n    #4.近五年自由现金流量均为正值。（cash_flow.net_operate_cash_flow - cash_flow.net_invest_cash_flow）\n    y = context.current_dt.year\n    l4 = {}\n    for i in range(1,6):\n        df = get_fundamentals(query(cash_flow.code,cash_flow.statDate,cash_flow.net_operate_cash_flow , \\\n                                    cash_flow.net_invest_cash_flow),statDate=str(y-i))\n ",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "sh_flow.net_invest_cash_flow),statDate=str(y-i))\n        if len(df) != 0:\n            df['FCF'] = df['net_operate_cash_flow']-df['net_invest_cash_flow']\n            df = df[df['FCF']>0]\n            l_temp = df['code'].values\n            if len(l4) != 0:\n                l4 = set(l4) & set(l_temp)\n            l4 = l_temp\n        else:\n            continue\n    l4 = set(l4)\n    #print 'test'\n    #print l4\n    #5.近四季营收成长率介于6%至30%（）。    'IRYOY':indicator.inc_revenue_year_on_year, # 营业收入同比增长率(%)\n    l5 = {}\n    fo",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "ue_year_on_year, # 营业收入同比增长率(%)\n    l5 = {}\n    for i in range(4):\n        df_5 = panel.iloc[:,i,:]\n        df_temp_5 = df_5[(df_5['inc_revenue_year_on_year']>6) & (df_5['inc_revenue_year_on_year']<30)]\n        if i == 0:    \n            l5 = set(df_temp_5.index)\n        else:\n            l_temp = df_temp_5.index\n            l5 = l5 & set(l_temp)\n    l5 = set(l5)\n    \n    #6.近四季盈余成长率介于8%至50%。(eps比值)\n    l6 = {}\n    for i in range(4):\n        df_6 = panel.iloc[:,i,:]\n        df_temp = df_6[(df_6['eps']>0.08)",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "c[:,i,:]\n        df_temp = df_6[(df_6['eps']>0.08) & (df_6['eps']<0.5)]\n        if i == 0:    \n            l6 = set(df_temp.index)\n        else:\n            l_temp = df_temp.index\n            l6 = l6 & set(l_temp)\n    l6 = set(l6)\n    \n    return list(l1 & l2 &l3 & l4 & l5 & l6)\n    \n#去极值（分位数法）  \ndef winsorize(se):\n    q = se.quantile([0.025, 0.975])\n    if isinstance(q, pd.Series) and len(q) == 2:\n        se[se < q.iloc[0]] = q.iloc[0]\n        se[se > q.iloc[1]] = q.iloc[1]\n    return se\n    \n#获取多期财务数据内容\nd",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "c[1]] = q.iloc[1]\n    return se\n    \n#获取多期财务数据内容\ndef get_data(pool, periods):\n    q = query(valuation.code, income.statDate, income.pubDate).filter(valuation.code.in_(pool))\n    df = get_fundamentals(q)\n    df.index = df.code\n    stat_dates = set(df.statDate)\n    stat_date_stocks = { sd:[stock for stock in df.index if df['statDate'][stock]==sd] for sd in stat_dates }\n\n    def quarter_push(quarter):\n        if quarter[-1]!='1':\n            return quarter[:-1]+str(int(quarter[-1])-1)\n        else:\n           ",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "+str(int(quarter[-1])-1)\n        else:\n            return str(int(quarter[:4])-1)+'q4'\n\n    q = query(valuation.code,valuation.code,valuation.circulating_market_cap,balance.total_current_assets,balance.total_current_liability,\\\n    indicator.roe,cash_flow.net_operate_cash_flow,cash_flow.net_invest_cash_flow,indicator.inc_revenue_year_on_year,indicator.eps\n              )\n\n    stat_date_panels = { sd:None for sd in stat_dates }\n\n    for sd in stat_dates:\n        quarters = [sd[:4]+'q'+str(int(sd[5:7])/3)]\n  ",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "    quarters = [sd[:4]+'q'+str(int(sd[5:7])/3)]\n        for i in range(periods-1):\n            quarters.append(quarter_push(quarters[-1]))\n        nq = q.filter(valuation.code.in_(stat_date_stocks[sd]))\n        pre_panel = { quarter:get_fundamentals(nq, statDate = quarter) for quarter in quarters }\n        for thing in pre_panel.values():\n            thing.index = thing.code.values\n        panel = pd.Panel(pre_panel)\n        panel.items = range(len(quarters))\n        stat_date_panels[sd] = panel.transpose(2",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": ")\n        stat_date_panels[sd] = panel.transpose(2,0,1)\n\n    final = pd.concat(stat_date_panels.values(), axis=2)\n\n    return final.dropna(axis=2)\n    \n    \n    ",
        "source": "99策略代码/07 穿越牛熊基业长青的价值精选策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11165\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport talib\nimport pandas as pd\nimport numpy as np\nimport datetime\nfrom datetime import timedelta\nimport math\nfrom numpy import nan\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000001.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    #",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    g.num_stock = 10\n    g.index = '000001.XSHG'\n    g.index2 = '000300.XSHG'#沪深300\n    g.index8 = '399006.XSHE'#创业板指数\n    # g.index2 = '000016.XSHG'#上证50\n    # g.index8 = '399333.XSHE'#中小板R \n    g.risk_ratio = 0.10\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    ",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "sion=0.0003, min_commission=5), type='stock')\n    run_monthly(rebalence,1,time = '14:50')\n\n    \n## 开盘前运行函数     \n# def before_trading_start(context):\n    \n    \n## 开盘时运行函数\ndef handle_data(context, data):\n    if market_not_safe(g.index2,g.index8):\n        # if len(context.portfolio.positions) >0:\n        clear_position(context)\n        return\n    # if g.days%g.period == 0:\n    #     if [context.current_dt.hour,context.current_dt.minute] == [14,50]:\n        # rebalence(context)\n    # g.days = g.days+1\n    # for",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "balence(context)\n    # g.days = g.days+1\n    # for stock in context.portfolio.positions:\n    #     if can_sell(stock):\n    #         order_target_value(stock,0)\n \ndef rebalence(context):\n    # if not market_not_safe(g.index2,g.index8):\n    \n    stocklist = select_stock(context)\n    #卖出\n    for stock in context.portfolio.positions:\n        if stock not in stocklist:\n            order_target_value(stock,0)\n    stock_values = calPosition(context,stocklist)\n    for stock in stock_values:\n        curPrice = attr",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "for stock in stock_values:\n        curPrice = attribute_history(stock, 1, '1m', ('close'),fq='pre')['close'].values\n        curValue = context.portfolio.positions[stock].total_amount * curPrice\n        target_value = stock_values[stock]\n        if abs(target_value - curValue)>0.2:\n            order_target_value(stock,target_value)\n    \ndef select_stock(context):\n    stocklist = get_index_stocks(g.index)\n    stock_list = filter_specials(stocklist)\n    stock_list = filter_new_and_sub_new(stock_list)\n    stock",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "ist = filter_new_and_sub_new(stock_list)\n    stock_list = filter_big_amout_of_increase(stock_list)\n    factor_dict = {}\n    for stock in stock_list:\n        temp = []\n        temp.append(get_smart_money_factor(stock))\n        factor_dict[stock] = temp\n    df_factor = pd.DataFrame(factor_dict).T \n    df_factor = df_factor.dropna()\n    df_factor.columns = ['smart_money_factor']\n    df = df_factor.sort('smart_money_factor')\n    print df.head()\n    # stock_list = list(df.index.values)[:int(len(df)*0.1)]\n    sto",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "= list(df.index.values)[:int(len(df)*0.1)]\n    stock_list = list(df.index.values)[:10]\n    \n    return stock_list\n    \n\ndef filter_big_amout_of_increase(stocklist,ratio = 0.2):\n    stock_dict = {}\n    for stock in stocklist:\n        stock_dict[stock] = get_growth_rate(stock)\n    sort_list = sorted(stock_dict.items(),key = lambda x:x[1])\n    stock_list = sort_list[:int(len(sort_list)*(1-ratio))]\n    stock_list = [stock[0] for stock in stock_list]\n    return stock_list\n\ndef filter_new_and_sub_new(stocklist,da",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "tock_list\n\ndef filter_new_and_sub_new(stocklist,days = 60):\n    stock_list = []\n    for stock in stocklist:\n        start_date = get_security_info(stock).start_date\n        if (datetime.date.today()-start_date)>timedelta(60):\n            stock_list.append(stock)\n    return stock_list\n\n\n\ndef get_smart_money_factor(stock,count_day = 1):\n    \n    df = attribute_history(stock,count_day*230,'1m',['open','close','volume'])\n    df['zdf'] = abs(df['close']/df['open']-1)\n    df['smart'] = df['zdf']/(df['volume'].app",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "]-1)\n    df['smart'] = df['zdf']/(df['volume'].apply(math.sqrt))\n    df = df.sort('smart',ascending = False)\n    df['cum_vol'] = df['volume'].cumsum()\n    df['cum_vol'] = df['cum_vol']/df.ix[-1,'cum_vol']\n    df_smart = df[df['cum_vol']<=0.2]\n    all_vol = df['volume'].sum()\n    all_smartvol = df_smart['volume'].sum()\n    VWAP_smart = (df_smart['volume']*df_smart['close']/all_smartvol).sum()\n    VWAP_all = (df['volume']*df['close']/all_vol).sum()\n    try:\n        factor = VWAP_smart/VWAP_all\n    except:\n   ",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "      factor = VWAP_smart/VWAP_all\n    except:\n        factor = nan\n    return factor\n\n\n\n    \ndef filter_specials(stock_list):\n    curr_data = get_current_data()\n    stock_list = [stock for stock in stock_list if \\\n                  (not curr_data[stock].paused)  # 未停牌\n                  and (not curr_data[stock].is_st)  # 非ST\n                  and ('ST' not in curr_data[stock].name)\n                  and ('*' not in curr_data[stock].name)\n                  and ('退' not in curr_data[stock].name)\n            ",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "nd ('退' not in curr_data[stock].name)\n                  and (curr_data[stock].low_limit < curr_data[stock].day_open < curr_data[stock].high_limit)  # 未涨跌停\n                  ]\n\n    return stock_list\n\ndef market_not_safe(index2,index8):\n    gr_index2 = get_growth_rate(index2)\n    gr_index8 = get_growth_rate(index8)\n    if gr_index2 <= 0 and  gr_index8 <= 0:\n        return True\n\ndef get_growth_rate(security, n=20):\n    lc = get_close_price(security, n)\n    c = get_close_price(security, 1, '1m')\n    \n    #判断是数据",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "get_close_price(security, 1, '1m')\n    \n    #判断是数据是否为空\n    if not isnan(lc) and not isnan(c) and lc != 0:\n        return (c - lc) / lc\n    else:\n        log.error(\"数据非法, security: %s, %d日收盘价: %f, 当前价: %f\" %(security, n, lc, c))\n        return 0\n        \n\ndef can_buy(security,short=5,long=20):\n    #检查均线是否多头\n    ma_short = attribute_history(security, short, '1d', ('close'), True).mean()['close']\n    ma_long = attribute_history(security, long, '1d', ('close'), True).mean()['close']\n    cur_price = get_close_pr",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "True).mean()['close']\n    cur_price = get_close_price(security,1,'1m')\n    yes_price = get_close_price(security,1)\n    if ma_short >= ma_long and cur_price > yes_price:\n        return True\n        \n\n\n\n\ndef get_close_price(security, n, unit='1d'):\n    return attribute_history(security, n, unit, ('close'), True,fq='pre')['close'][0]\n   \ndef clear_position(context):\n    if len(context.portfolio.positions)>0:\n        for stock in context.portfolio.positions:\n            order_target_value(stock,0)\n        log.i",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "         order_target_value(stock,0)\n        log.info('大盘止损,全盘清仓')\n\n\ndef calPosition(context, buylist):\n    # 每次调仓，用 positionAdjustFactor 来控制承受的风险，最大损失为总仓位 * positionAdjustFactor\n    positionAdjustValue = context.portfolio.total_value * g.risk_ratio\n    Ajustvalue_per_stock = float(positionAdjustValue)/len(buylist)\n\n    hStocks = history(1, '1m', 'close', buylist, df=False)\n\n    risk_value = {}\n    # 计算组合后的 ATR，此处假设资金是平均分配。\n    for stock in buylist:\n        curATR = 2*float(fun_getATR(stock))\n        if cur",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "curATR = 2*float(fun_getATR(stock))\n        if curATR != 0 :\n            risk_value[stock] = hStocks[stock]*Ajustvalue_per_stock/curATR\n        else:\n            risk_value[stock] = 0\n\n    total_value = sum([risk_value[stock] for stock in risk_value])\n    if total_value > context.portfolio.total_value:\n        tempdict = {}\n        for stock in buylist:\n            tempdict[stock] = context.portfolio.total_value*(risk_value[stock]/total_value)\n        risk_value = tempdict\n    return risk_value   \n\n\ndef fun",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "alue = tempdict\n    return risk_value   \n\n\ndef fun_getATR(stock):\n    ATRlag = 14\n\n    # 计算ATR及Keltner Band \n    try:\n        hStock = attribute_history(stock, ATRlag+10, '1d', ('close','high','low') , df=False)\n    except:\n        log.info('%s 获取历史数据失败' %stock)\n        return 0\n    close_ATR = fun_normalizeData(hStock['close'])\n    high_ATR = fun_normalizeData(hStock['high'])\n    low_ATR = fun_normalizeData(hStock['low'])\n    try:\n        ATR = talib.ATR(high_ATR, low_ATR, close_ATR, timeperiod=ATRlag)\n   ",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "gh_ATR, low_ATR, close_ATR, timeperiod=ATRlag)\n    except:\n        return 0\n\n    return ATR[-1]\n\ndef fun_normalizeData(myData):\n    # 去极值\n    std = np.std(myData)\n    MA = np.mean(myData)\n    for i in range(len(myData)):\n        if myData[i] > MA + 3*std:\n            myData[i] = MA + 3*std\n        elif myData[i] < MA - 3*std:\n            myData[i] = MA - 3*std\n    return myData    \n\n",
        "source": "99策略代码/38 一个简单的跟踪聪明钱策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12916\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport time\n#import statsmodels.api as sm\nfrom sklearn import linear_model\nfrom sklearn.preprocessing import Imputer\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    \n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level(",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    set_option('use_real_price',True) # 用真实价格交易\n    log.set_level('order','error')    # 设置报错等级\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    set_pas()    #1设置策略参数\n    set_variables() #2设置中间变量\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "urity为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n\n\ndef set_pas():\n    g.tc = 7  # 设置调仓天数\n    g.num_stocks = 5  # 设置每次调仓选取的股票数量\n    # 定义股票池，上证180指数成分股\n    g.index='000010.XSHG'\n    g.stocks = get_index_st",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": " g.index='000010.XSHG'\n    g.stocks = get_index_stocks(g.index)\n\n\n#设置中间变量\ndef set_variables():\n    g.t = 0 #记录回测运行的天数\n    g.if_trade = False #当天是否交易\n    \n#设置回测条件\n\n\n\ndef calAt(stock,date,n):\n    #计算股票stock的n日均线因子\n    #用于计算当期因子值\n    #输入参数：stock：股票代码；date:计算日期；n:计算日期前n天\n    price = get_price(stock,end_date=date, frequency='daily', fields='close', skip_paused=True, fq='pre', count=n)\n    At = mean(price)\n    Atadjust = At/price.tail(1)\n    Atadjust = Atadjust.iloc[0,0]\n    return Atadjust\n#返回值\n\ndef calAtevery(s",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "oc[0,0]\n    return Atadjust\n#返回值\n\ndef calAtevery(stock,flagDate,n):\n    #计算股票stock的n日均线因子\n    #用于计算 训练集 的函数\n    date = flagDate\n    price = get_price(stock,end_date=flagDate, frequency='daily', fields='close', skip_paused=True, fq='pre', count=n)\n    At = mean(price)\n    Atadjust = At/price.tail(1)\n    return Atadjust\n#返回pandas对象\n\n#计算训练集\ndef calATlist(stock,date,n):\n    lastDate = date\n    #lastDate = datetime.datetime.strptime(date, '%Y-%m-%d')\n    #输入时间为date\n    delta = datetime.timedelta(days=7)\n    last",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "te\n    delta = datetime.timedelta(days=7)\n    lastDate = lastDate - delta\n    #往前推一周 计算训练用 AT因子，（因为要用前一周的因子和当周的收益率回归）\n    At = []\n    for i in range(25):\n        temp = calAtevery(stock,lastDate,n)\n        At.append(temp.iloc[0,0])\n        lastDate = lastDate - delta\n    return At\n \ndef calEstYeild(stock,date):\n    k = [3, 5, 10, 20, 30, 60,90,120, 180, 240, 270, 300]\n    ATlist=[]\n    #计算 前25个单位时间内各长度的均线因子 以及 收益率\n    df = pd.DataFrame()\n    for item in k:\n        df['%s'%item]=calATlist(stock,date,item)\n  ",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "       df['%s'%item]=calATlist(stock,date,item)\n    #将收益率序列添加到最后一列    \n        df['rflist']=calRFlist(stock,date)\n        \n    #计算用于 预测输入的因子值\n    st = [1,2,3,4,5,6,7,8,9,10,11,12]\n    for i,item in enumerate(k):\n        st[i] = calAt(stock,date,item)\n        \n        #线性回归部分\n    \n    #imp = Imputer(missing_values='NaN',strategy='mean',axis=0,verbose=0,copy=True)\n    #df = imp.fit_transform(df)\n    #df = pd.DataFrame(df)\n    #df.columns = ['3','5','10','20','30','60','90','120','180','240','270','300','rflis",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "30','60','90','120','180','240','270','300','rflist']\n    \n    #log.info(df)\n    \n    y = df['rflist']\n    x = df[['3','5','10','20','30','60','90','120','180','240','270','300']]\n    clf = linear_model.LinearRegression()\n    clf.fit(x,y)\n    yhat = clf.predict(st)\n    #x = sm.add_constant(x)#添加截距项\n    #est = sm.OLS(y,x).fit()\n    #est.summary() #看统计量结果\n    #est.params #查看回归参数\n    #预测收益率\n    #yhat = est.predict(st)\n    return yhat\n   \ndef calRFlist(stock,date):\n    #计算收益率序列\n    nowDate = date\n    #nowDate =",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "e):\n    #计算收益率序列\n    nowDate = date\n    #nowDate = datetime.datetime.strptime(date, '%Y-%m-%d')\n    delta = datetime.timedelta(days=7)\n    rflist = []\n    for i in range(25):\n        weekprice = get_price(stock,end_date=nowDate,frequency='daily',fields=['close','open'],count=5,skip_paused=True)\n        cp = weekprice.iloc[1,-1]\n        op = weekprice.iloc[2,1]\n        rf = (cp-op)/op\n        rflist.append(rf)\n        nowDate = nowDate - delta\n    return rflist   \n\ndef SortStockList(stocks,date):\n    df = pd",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "st   \n\ndef SortStockList(stocks,date):\n    df = pd.DataFrame()\n    for stock in stocks:\n        df['%s'%stock] = calEstYeild(stock,date)\n    df = df.T\n    stockListSorted = df.sort(columns=0)\n    return stockListSorted\n\ndef set_slip_fee(context):\n    # 将滑点设置为0\n    set_slippage(FixedSlippage(0)) \n    # 根据不同的时间段设置手续费\n    dt=context.current_dt\n    log.info(type(context.current_dt))\n    \n    if dt>datetime.datetime(2013,1, 1):\n        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0003, min_cost=5)) \n    ",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "_cost=0.0003, sell_cost=0.0003, min_cost=5)) \n        \n    elif dt>datetime.datetime(2011,1, 1):\n        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))\n            \n    elif dt>datetime.datetime(2009,1, 1):\n        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))\n                \n    else:\n        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))    \n\n\n## 开盘前运行函数     \ndef before_market_open(context):\n    if g.t%g.tc==0:\n        #每g.tc天，交易一次行\n  ",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "ext):\n    if g.t%g.tc==0:\n        #每g.tc天，交易一次行\n        g.if_trade=True \n        # 设置手续费与手续费\n        # set_slip_fee(context)\n    \n## 开盘时运行函数\ndef market_open(context):\n    log.info(g.t, g.tc, g.if_trade)\n    date = context.current_dt\n    if g.if_trade == True:\n        # 依本策略的买入信号，得到应该买的股票列表\n        MS_should_buy = SortStockList(g.stocks,date).tail(5).index\n        log.info(MS_should_buy)\n        # 计算现在的总资产，以分配资金，这里是等额权重分配 返回一个数\n        MonPerStock=context.portfolio.portfolio_value/g.num_stocks\n        # 得到当前",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "tfolio.portfolio_value/g.num_stocks\n        # 得到当前持仓中可卖出的股票\n        if len(context.portfolio.positions)>0:\n            #当持仓不为零时，剔除持仓股票中停牌股即可 返回list\n            holding = context.portfolio.positions\n        else:\n            # 当持仓为0时，可卖出股票为0 返回list\n            holding = []\n        # 对于不需要持仓的股票，全仓卖出\n        for stock in holding:\n            if stock not in MS_should_buy:\n                order_target_value(stock, 0)\n        # 对于需要持仓的股票，按分配到的份额买入\n        for stock in MS_should_buy:\n            order_target_valu",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "ck in MS_should_buy:\n            order_target_value(stock, MonPerStock)\n    g.if_trade = False\n    \n## 收盘后运行函数  \ndef after_market_close(context):\n    g.t+=1\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n\n    pass\n",
        "source": "99策略代码/15 基于多期限的选股策略（一）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12666\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/1667\n# 标题：二八轮动小市值优化版 v2.0.7 [更新于2016.11.16]\n# 作者：Morningstar\nimport math\nimport numpy as np\nimport pandas as pd\nfrom pandas import DataFrame,Series\nimport pickle\nimport time\nimport datetime\nimport jqdata\nimport talib as tb\nimport sklearn\nfrom sklearn.decomposition import PCA\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import AdaBoostClass",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "gressor\nfrom sklearn.ensemble import AdaBoostClassifier,GradientBoostingClassifier,RandomForestRegressor,RandomForestClassifier\nfrom sklearn import cross_validation, metrics,svm,preprocessing  \nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.cross_validation import train_test_split\nfrom sklearn.grid_search import GridSearchCV \nfrom sklearn.svm import SVR  \nfrom sklearn.externals import joblib\nfrom sklearn.model_selection import learning_curve\nfrom sklearn.linear_model import LinearRegression\n'''",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "m sklearn.linear_model import LinearRegression\n'''\n二八小市值择时买卖\n\n配置指定频率的调仓日，在调仓日每日指定时间，计算沪深300指数和中证500指数当前的20日涨\n幅，如果2个指数的20日涨幅有一个为正，则进行选股调仓，之后如此循环往复。\n\n止损策略：\n\n    大盘止损：(可选)\n        1. 每分钟取大盘前130日的最低价和最高价，如果最高大于最低的两倍则清仓，停止交易。\n        2. 每分钟判断大盘是否呈现三只黑鸦止损，如果是则当天清仓并停止交易，第二天停止交\n           易一天。\n\n    个股止损：(可选)\n        每分钟判断个股是否从持仓后的最高价回撤幅度，如果超过个股回撤阈值，则平掉该股持仓\n\n    二八止损：(必需)\n        每日指定时间，计算沪深300指数和中证500指数当前的20日涨幅，如果2个指数涨幅都为负，\n        则清仓，重置调仓计数，待下次调仓条件满足再操作\n'''\nfrom six import StringIO\nimport tradestat\n#import ind\nfr",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "ix import StringIO\nimport tradestat\n#import ind\nfrom ind import *\n#from blacklist import *\n\n# blacklist.py\n# 建议在研究里建立文件blacklist.py，然后将这段代码拷贝进blacklist.py\n# 模拟运行的时候只需要更新研究里的数据即可，这样可在不修改模拟运行代码的情况下\n# 修改黑名单\n\n# 配置股票黑名单\n# 列出当且极不适宜购买的股票\n# 注：1. 黑名单有时效性，回测的时候最好不使用，模拟交易建议使用\n#     2. 用一模块或者大数据分析收集这类股票，定时更新\ndef get_blacklist():\n    # 黑名单一览表，更新时间 2016.7.10 by 沙米\n    # 科恒股份、太空板业，一旦2016年继续亏损，直接面临暂停上市风险\n    blacklist = [\"600656.XSHG\",\"300372.XSHE\",\"600403.XSHG\",\"600421.XSHG\",\"600733.XSHG\",\"300399.XSHE\",\n                 \"",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "G\",\"600733.XSHG\",\"300399.XSHE\",\n                 \"600145.XSHG\",\"002679.XSHE\",\"000020.XSHE\",\"002330.XSHE\",\"300117.XSHE\",\"300135.XSHE\",\n                 \"002566.XSHE\",\"002119.XSHE\",\"300208.XSHE\",\"002237.XSHE\",\"002608.XSHE\",\"000691.XSHE\",\n                 \"002694.XSHE\",\"002715.XSHE\",\"002211.XSHE\",\"000788.XSHE\",\"300380.XSHE\",\"300028.XSHE\",\n                 \"000668.XSHE\",\"300033.XSHE\",\"300126.XSHE\",\"300340.XSHE\",\"300344.XSHE\",\"002473.XSHE\"]\n    return blacklist\n\ndef before_trading_start(context):\n    cur_time = ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "def before_trading_start(context):\n    cur_time = context.previous_date\n    cur_time = datetime.datetime.strftime(cur_time,'%Y-%m-%d')\n    \n    print(g.data_.index[0],cur_time)\n    print(g.data_.index[0]==cur_time)\n    g.stocks = g.data_.where(g.data_==1).loc[cur_time,:].dropna(axis = 0).index.values\n    \n\ndef after_trading_end(context):\n    #log.info(\"==> after trading end @ %s\", str(context.current_dt))\n    g.trade_stat.report(context)\n\n    reset_day_param()\n    \n    # 得到当前未完成订单\n    orders = get_open_orde",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "()\n    \n    # 得到当前未完成订单\n    orders = get_open_orders()\n    for _order in orders.values():\n        log.info(\"canceled uncompleted order: %s\" %(_order.order_id))\n    pass\n\ndef initialize(context):\n    log.info(\"==> initialize @ %s\", str(context.current_dt))\n    \n    # 设置手续费率\n    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))\n    # 设置基准指数：沪深300指数 '000300.XSHG'\n    set_benchmark('000300.XSHG')\n    # 设定滑点为百分比\n    # 没有调用set_slippage函数, 系统默认的滑点是PriceRelatedSlippage(0.00246)\n    #set_slippa",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "认的滑点是PriceRelatedSlippage(0.00246)\n    #set_slippage(PriceRelatedSlippage(0.004))\n    # 使用真实价格回测(模拟盘推荐如此，回测请注释)\n    set_option('use_real_price', True)\n\n    # 加载统计模块\n    g.trade_stat = tradestat.trade_stat()\n\n    # 配置策略参数\n    # 此配置主要为之前的小市值策略，保证之前的收益回撤\n    # 如果想要更改，最好新建个函数，调整参数测试其他策略\n    set_param()\n    # 调仓日计数器，单位：日\n    g.day_count = 0\n    # 缓存股票持仓后的最高价\n    g.last_high = {}\n    #定义股票池\n    # 如下参数不能更改\n    if g.is_market_stop_loss_by_price:\n        # 记录当日是否满足大盘价格止损条件，每日盘后重置\n        g.is_day_stop_loss_by_price ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "价格止损条件，每日盘后重置\n        g.is_day_stop_loss_by_price = False\n\n    # 缓存三黑鸦判断状态\n    g.is_last_day_3_black_crows = False\n    if g.is_market_stop_loss_by_3_black_crows:\n        g.cur_drop_minute_count = 0\n\n    if g.is_rank_stock:\n        if g.rank_stock_count > g.pick_stock_count:\n            g.rank_stock_count = g.pick_stock_count\n\n    if g.is_stock_stop_loss or g.is_stock_stop_profit:\n        # 缓存当日个股250天内最大的3日涨幅，避免当日反复获取，每日盘后清空\n        g.pct_change = {}\n\n    if g.is_market_stop_loss_by_28_index:\n        g.minut",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "g.is_market_stop_loss_by_28_index:\n        g.minute_count_28index_drop = 0\n\n    if g.is_equity_curve_protect:\n        # 记录当日是否满足资金曲线保护条件，每日盘后重置\n        g.is_day_curve_protect = False\n    g.time1 = time.time()\n    file = StringIO(read_file('pre_result_csv.csv'))\n    #print(StringIO(file))\n    g.data_ = pd.read_csv(file,index_col = 0)\n    # 打印策略参数\n    log_param()\ndef set_param():\n    # 调仓频率，单位：日\n    g.period = 3\n    # 配置调仓时间（24小时分钟制）\n    g.adjust_position_hour = 14\n    g.adjust_position_minute = 50\n    # 配置选股",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": " = 14\n    g.adjust_position_minute = 50\n    # 配置选股参数\n\n    # 备选股票数目\n    g.pick_stock_count = 100\n    \n    # 配置选股参数\n    # 是否根据PE选股\n    g.pick_by_pe = False\n    # 如果根据PE选股，则配置最大和最小PE值\n    if g.pick_by_pe:\n        g.max_pe = 200\n        g.min_pe = 0\n\n    # 是否根据EPS选股\n    g.pick_by_eps = False\n    # 配置选股最小EPS值\n    if g.pick_by_eps:\n        g.min_eps = 0\n    \n    # 配置是否过滤创业板股票\n    g.filter_gem = False\n    # 配置是否过滤黑名单股票，回测建议关闭，模拟运行时开启\n    g.filter_blacklist = False\n\n    # 是否对股票评分\n    g.is_rank_stock = False\n    if ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "\n    # 是否对股票评分\n    g.is_rank_stock = False\n    if g.is_rank_stock:\n        # 参与评分的股票数目\n        g.rank_stock_count = 20\n\n    # 买入股票数目\n    g.buy_stock_count = 5\n    \n    # 配置二八指数\n    #g.index2 = '000300.XSHG'  # 沪深300指数，表示二，大盘股\n    #g.index8 = '000905.XSHG'  # 中证500指数，表示八，小盘股\n    g.index2 = '000016.XSHG'  # 上证50指数\n    g.index8 = '399333.XSHE'  # 中小板R指数\n    #g.index8 = '399006.XSHE'  # 创业板指数\n    \n    # 判定调仓的二八指数20日增幅\n    #g.index_growth_rate = 0.00\n    g.index_growth_rate = 0.01\n    \n    #设定特征参数\n    g.bbands =",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "growth_rate = 0.01\n    \n    #设定特征参数\n    g.bbands = True\n    g.ema = True\n    g.cci = True\n    g.kd = True\n    g.dif = True\n    g.macd = True\n    g.rsi = True\n    g.bais = True\n    # 配置是否根据大盘历史价格止损\n    # 大盘指数前130日内最高价超过最低价2倍，则清仓止损\n    # 注：关闭此止损，收益增加，但回撤会增加\n    g.is_market_stop_loss_by_price = False\n    if g.is_market_stop_loss_by_price:\n        # 配置价格止损判定指数，默认为上证指数，可修改为其他指数\n        g.index_4_stop_loss_by_price = '000001.XSHG'\n\n    # 配置三黑鸦判定指数，默认为上证指数，可修改为其他指数\n    g.index_4_stop_loss_by_3_black_crows = '00000",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "\n    g.index_4_stop_loss_by_3_black_crows = '000001.XSHG'\n\n    # 配置是否开启大盘三黑鸦止损\n    # 个人认为针对大盘判断三黑鸦效果并不好，首先有效三只乌鸦难以判断，准确率实际来看也不好，\n    # 其次，分析历史行情看一般大盘出现三只乌鸦的时候，已经严重滞后了，使用其他止损方式可能会更好\n    g.is_market_stop_loss_by_3_black_crows = False\n    if g.is_market_stop_loss_by_3_black_crows:\n        g.dst_drop_minute_count = 60\n\n    # 是否根据28指数值实时进行止损\n    g.is_market_stop_loss_by_28_index = False\n    if g.is_market_stop_loss_by_28_index:\n        # 配置当日28指数连续为跌的分钟计数达到指定值则止损\n        g.dst_minute_count_28index_drop = 30\n\n   ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "\n        g.dst_minute_count_28index_drop = 30\n\n    # 配置是否个股止损\n    g.is_stock_stop_loss = False\n    # 配置是否个股止盈\n    g.is_stock_stop_profit = False\n    \n    # 配置是否开启资金曲线保护\n    g.is_equity_curve_protect = False\n    if g.is_equity_curve_protect:\n        # 配置资金曲线参数\n        g.value_list = []\n    \n    \ndef log_param():\n    log.info(\"调仓日频率: %d日\" %(g.period))\n    log.info(\"调仓时间: %s:%s\" %(g.adjust_position_hour, g.adjust_position_minute))\n\n    log.info(\"备选股票数目: %d\" %(g.pick_stock_count))\n\n    log.info(\"是否根据PE选股: %s\" %",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": ".pick_stock_count))\n\n    log.info(\"是否根据PE选股: %s\" %(g.pick_by_pe))\n    if g.pick_by_pe:\n        log.info(\"选股最大PE: %s\" %(g.max_pe))\n        log.info(\"选股最小PE: %s\" %(g.min_pe))\n\n    log.info(\"是否根据EPS选股: %s\" %(g.pick_by_eps))\n    if g.pick_by_eps:\n        log.info(\"选股最小EPS: %s\" %(g.min_eps))\n    \n    log.info(\"是否过滤创业板股票: %s\" %(g.filter_gem))\n    log.info(\"是否过滤黑名单股票: %s\" %(g.filter_blacklist))\n    if g.filter_blacklist:\n        log.info(\"当前股票黑名单：%s\" %str(get_blacklist()))\n\n    log.info(\"是否对股票评分选股: %s\" %(g.is_rank",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "list()))\n\n    log.info(\"是否对股票评分选股: %s\" %(g.is_rank_stock))\n    if g.is_rank_stock:\n        log.info(\"评分备选股票数目: %d\" %(g.rank_stock_count))\n\n    log.info(\"买入股票数目: %d\" %(g.buy_stock_count))\n\n    log.info(\"二八指数之二: %s - %s\" %(g.index2, get_security_info(g.index2).display_name))\n    log.info(\"二八指数之八: %s - %s\" %(g.index8, get_security_info(g.index8).display_name))\n    log.info(\"判定调仓的二八指数20日增幅: %.1f%%\" %(g.index_growth_rate*100))\n\n    log.info(\"是否开启大盘历史高低价格止损: %s\" %(g.is_market_stop_loss_by_price))\n    if g.is_mark",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "(g.is_market_stop_loss_by_price))\n    if g.is_market_stop_loss_by_price:\n        log.info(\"大盘价格止损判定指数: %s - %s\" %(g.index_4_stop_loss_by_price, get_security_info(g.index_4_stop_loss_by_price).display_name))\n\n    log.info(\"是否开启大盘三黑鸦止损: %s\" %(g.is_market_stop_loss_by_3_black_crows))\n    if g.is_market_stop_loss_by_3_black_crows:\n        log.info(\"大盘三黑鸦止损判定指数: %s - %s\" %(g.index_4_stop_loss_by_3_black_crows, get_security_info(g.index_4_stop_loss_by_3_black_crows).display_name))\n        log.info(\"三黑鸦止损开启需要当日大盘为",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "s).display_name))\n        log.info(\"三黑鸦止损开启需要当日大盘为跌的分钟计数达到: %d\" %(g.dst_drop_minute_count))\n\n    log.info(\"是否根据28指数值实时进行止损: %s\" %(g.is_market_stop_loss_by_28_index))\n    if g.is_market_stop_loss_by_28_index:\n        log.info(\"根据28指数止损需要当日28指数连续为跌的分钟计数达到: %d\" %(g.dst_minute_count_28index_drop))        \n\n    log.info(\"是否开启个股止损: %s\" %(g.is_stock_stop_loss))\n    log.info(\"是否开启个股止盈: %s\" %(g.is_stock_stop_profit))\n    \n    log.info(\"是否开启资金曲线保护: %s\" %(g.is_equity_curve_protect))\n\n# 重置当日参数，仅针对需要当日需要重置的参数\ndef reset_",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "urve_protect))\n\n# 重置当日参数，仅针对需要当日需要重置的参数\ndef reset_day_param():\n    if g.is_market_stop_loss_by_price:\n        # 重置当日大盘价格止损状态\n        g.is_day_stop_loss_by_price = False\n\n    # 重置三黑鸦状态\n    g.is_last_day_3_black_crows = False\n    if g.is_market_stop_loss_by_3_black_crows:\n        g.cur_drop_minute_count = 0\n        \n    if g.is_market_stop_loss_by_28_index:\n        g.minute_count_28index_drop = 0\n\n    if g.is_stock_stop_loss or g.is_stock_stop_profit:\n        # 清空当日个股250天内最大的3日涨幅的缓存\n        g.pct_change.clear",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "# 清空当日个股250天内最大的3日涨幅的缓存\n        g.pct_change.clear()\n\n    # 重置资金曲线保护状态    \n    if g.is_equity_curve_protect:\n        g.is_day_curve_protect = False\n\n# 按分钟回测\ndef handle_data(context, data):\n    if g.is_market_stop_loss_by_price:\n        if market_stop_loss_by_price(context, g.index_4_stop_loss_by_price):\n            return\n\n    if g.is_market_stop_loss_by_3_black_crows:\n        if market_stop_loss_by_3_black_crows(context, g.index_4_stop_loss_by_3_black_crows, g.dst_drop_minute_count):\n            return\n\n  ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": ", g.dst_drop_minute_count):\n            return\n\n    if g.is_market_stop_loss_by_28_index:\n        if market_stop_loss_by_28_index(context, g.dst_minute_count_28index_drop):\n            return\n\n    if g.is_stock_stop_loss:\n        stock_stop_loss(context, data)\n\n    if g.is_stock_stop_profit:\n        stock_stop_profit(context, data)\n        \n    if g.is_equity_curve_protect:\n        if equity_curve_protect(context):\n            return\n\n    # 获得当前时间\n    hour = context.current_dt.hour\n    minute = context.curr",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": " context.current_dt.hour\n    minute = context.current_dt.minute\n\n    # 每天尾盘记录总资产\n    if g.is_equity_curve_protect:\n        if hour == 14 and minute == 59:\n            g.value_list.append(context.portfolio.total_value)\n\n    # 每天指定时间检查是否调仓并处理\n    if hour == g.adjust_position_hour and minute == g.adjust_position_minute:\n        do_handle_data(context, data)\n\ndef do_handle_data(context, data):\n    log.info(\"调仓日计数 [%d]\" %(g.day_count))\n    # 回看指数前20天的涨幅\n    gr_index2 = get_growth_rate(g.index2)\n    gr_index8 = g",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "dex2 = get_growth_rate(g.index2)\n    gr_index8 = get_growth_rate(g.index8)\n    log.info(\"当前%s指数的20日涨幅 [%.2f%%]\" %(get_security_info(g.index2).display_name, gr_index2*100))\n    log.info(\"当前%s指数的20日涨幅 [%.2f%%]\" %(get_security_info(g.index8).display_name, gr_index8*100))\n\n    if gr_index2 <= g.index_growth_rate and gr_index8 <= g.index_growth_rate:\n        clear_position(context)\n        g.day_count = 0\n    else: #if  gr_index2 > g.index_growth_rate or ret_index8 > g.index_growth_rate:\n        if g.day_count %",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "x8 > g.index_growth_rate:\n        if g.day_count % g.period == 0 and g.day_count >= 0:\n            log.info(\"==> 满足条件进行调仓\")\n            buy_stocks = g.stocks\n            log.info(\"选股后可买股票: %s\" %(buy_stocks))\n            adjust_position(context, buy_stocks)\n        g.day_count += 1\n\ndef market_stop_loss_by_price(context, index):\n    # 大盘指数前130日内最高价超过最低价2倍，则清仓止损\n    # 基于历史数据判定，因此若状态满足，则当天都不会变化\n    # 增加此止损，回撤降低，收益降低\n\n    if not g.is_day_stop_loss_by_price:\n        h = attribute_history(index, 160, unit='1d', f",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "    h = attribute_history(index, 160, unit='1d', fields=('close', 'high', 'low'), skip_paused=True)\n        low_price = h.low.min()\n        high_price = h.high.max()\n        #if high_price > 2 * low_price:\n        if high_price > 2.2 * low_price \\\n            and h['close'][-1] < h['close'][-4] \\\n            and h['close'][-1]> h['close'][-100]:\n            # 当日第一次输出日志\n            log.info(\"==> 大盘止损，%s指数前130日内最高价超过最低价2倍, 最高价: %f, 最低价: %f\" %(get_security_info(index).display_name, high_price, low_price))\n    ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "(index).display_name, high_price, low_price))\n            g.is_day_stop_loss_by_price = True\n\n    if g.is_day_stop_loss_by_price:\n        clear_position(context)\n        g.day_count = 0\n\n    return g.is_day_stop_loss_by_price\n\n# 资金曲线保护  \ndef equity_curve_protect(context):\n    if not g.is_day_curve_protect:\n        cur_value = context.portfolio.total_value\n        if len(g.value_list) >= 20:\n            last_value = g.value_list[-20]\n            #avg_value = sum(g.value_list[-20:]) / 20\n            if cur_va",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "sum(g.value_list[-20:]) / 20\n            if cur_value < last_value*0.99:\n                log.info(\"==> 启动资金曲线保护, 20日前资产: %f, 当前资产: %f\" %(last_value, cur_value))\n                g.is_day_curve_protect = True\n\n    if g.is_day_curve_protect:\n        clear_position(context)\n        del g.value_list[:]\n        g.day_count = -1\n\n    return g.is_day_curve_protect\n\ndef market_stop_loss_by_3_black_crows(context, index, n):\n    # 前日三黑鸦，累计当日大盘指数涨幅<0的分钟计数\n    # 如果分钟计数超过值n，则开始进行三黑鸦止损\n    # 避免无效三黑鸦乱止损\n    if g.is_last_da",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "值n，则开始进行三黑鸦止损\n    # 避免无效三黑鸦乱止损\n    if g.is_last_day_3_black_crows:\n        if get_growth_rate(index, 1) < 0:\n            g.cur_drop_minute_count += 1\n\n        if g.cur_drop_minute_count >= n:\n            if g.cur_drop_minute_count == n:\n                log.info(\"==> 当日%s增幅 < 0 已超过%d分钟，执行三黑鸦止损\" %(get_security_info(index).display_name, n))\n\n            clear_position(context)\n            g.day_count = 0\n            return True\n\n    return False\n\ndef is_3_black_crows(stock):\n    # talib.CDL3BLACKCROWS\n\n    # 三",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "_crows(stock):\n    # talib.CDL3BLACKCROWS\n\n    # 三只乌鸦说明来自百度百科\n    # 1. 连续出现三根阴线，每天的收盘价均低于上一日的收盘\n    # 2. 三根阴线前一天的市场趋势应该为上涨\n    # 3. 三根阴线必须为长的黑色实体，且长度应该大致相等\n    # 4. 收盘价接近每日的最低价位\n    # 5. 每日的开盘价都在上根K线的实体部分之内；\n    # 6. 第一根阴线的实体部分，最好低于上日的最高价位\n    #\n    # 算法\n    # 有效三只乌鸦描述众说纷纭，这里放宽条件，只考虑1和2\n    # 根据前4日数据判断\n    # 3根阴线跌幅超过4.5%（此条件忽略）\n\n    h = attribute_history(stock, 4, '1d', ('close','open'), skip_paused=True, df=False)\n    h_close = list(h['close'])\n    h_open = list(h['open'])\n\n    if len(h_close) < 4 or len(h",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": " list(h['open'])\n\n    if len(h_close) < 4 or len(h_open) < 4:\n        return False\n    \n    # 一阳三阴\n    if h_close[-4] > h_open[-4] \\\n        and (h_close[-1] < h_open[-1] and h_close[-2]< h_open[-2] and h_close[-3] < h_open[-3]):\n        #and (h_close[-1] < h_close[-2] and h_close[-2] < h_close[-3]) \\\n        #and h_close[-1] / h_close[-4] - 1 < -0.045:\n        return True\n    return False\n    \n\ndef market_stop_loss_by_28_index(context, count):\n    # 回看指数前20天的涨幅\n    gr_index2 = get_growth_rate(g.index2)\n   ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "天的涨幅\n    gr_index2 = get_growth_rate(g.index2)\n    gr_index8 = get_growth_rate(g.index8)\n\n    if gr_index2 <= g.index_growth_rate and gr_index8 <= g.index_growth_rate:\n        if (g.minute_count_28index_drop == 0):\n            log.info(\"当前二八指数的20日涨幅同时低于[%.2f%%], %s指数: [%.2f%%], %s指数: [%.2f%%]\" \\\n                %(g.index_growth_rate*100, get_security_info(g.index2).display_name, gr_index2*100, get_security_info(g.index8).display_name, gr_index8*100))\n\n            #log.info(\"当前%s指数的20日涨幅 [%.2f%%]\" %(get_secu",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "      #log.info(\"当前%s指数的20日涨幅 [%.2f%%]\" %(get_security_info(g.index2).display_name, gr_index2*100))\n            #log.info(\"当前%s指数的20日涨幅 [%.2f%%]\" %(get_security_info(g.index8).display_name, gr_index8*100))\n        g.minute_count_28index_drop += 1\n    else:\n        # 不连续状态归零\n        if g.minute_count_28index_drop < count:\n            g.minute_count_28index_drop = 0\n\n    if g.minute_count_28index_drop >= count:\n        if g.minute_count_28index_drop == count:\n            log.info(\"==> 当日%s指数和%s指数的20日增幅低于[%.2f",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "            log.info(\"==> 当日%s指数和%s指数的20日增幅低于[%.2f%%]已超过%d分钟，执行28指数止损\" \\\n                %(get_security_info(g.index2).display_name, get_security_info(g.index8).display_name, g.index_growth_rate*100, count))\n\n        clear_position(context)\n        g.day_count = 0\n        return True\n        \n    return False\n\n# 个股止损\ndef stock_stop_loss(context, data):\n    for stock in context.portfolio.positions.keys():\n        cur_price = data[stock].close\n\n        if g.last_high[stock] < cur_price:\n            g.last_hig",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "st_high[stock] < cur_price:\n            g.last_high[stock] = cur_price\n\n        threshold = get_stop_loss_threshold(stock, g.period)\n        #log.debug(\"个股止损阈值, stock: %s, threshold: %f\" %(stock, threshold))\n        if cur_price < g.last_high[stock] * (1 - threshold):\n            log.info(\"==> 个股止损, stock: %s, cur_price: %f, last_high: %f, threshold: %f\" \n                %(stock, cur_price, g.last_high[stock], threshold))\n\n            position = context.portfolio.positions[stock]\n            if close_positi",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "folio.positions[stock]\n            if close_position(position):\n                g.day_count = 0\n\n# 个股止盈\ndef stock_stop_profit(context, data):\n    for stock in context.portfolio.positions.keys():\n        position = context.portfolio.positions[stock]\n        cur_price = data[stock].close\n        threshold = get_stop_profit_threshold(stock, g.period)\n        #log.debug(\"个股止盈阈值, stock: %s, threshold: %f\" %(stock, threshold))\n        if cur_price > position.avg_cost * (1 + threshold):\n            log.info(\"==> 个",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "ost * (1 + threshold):\n            log.info(\"==> 个股止盈, stock: %s, cur_price: %f, avg_cost: %f, threshold: %f\" \n                %(stock, cur_price, g.last_high[stock], threshold))\n\n            position = context.portfolio.positions[stock]\n            if close_position(position):\n                g.day_count = 0\n\n# 获取个股前n天的m日增幅值序列\n# 增加缓存避免当日多次获取数据\ndef get_pct_change(security, n, m):\n    pct_change = None\n    if security in g.pct_change.keys():\n        pct_change = g.pct_change[security]\n    else:\n        h = a",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "e = g.pct_change[security]\n    else:\n        h = attribute_history(security, n, unit='1d', fields=('close'), skip_paused=True)\n        pct_change = h['close'].pct_change(m) # 3日的百分比变比（即3日涨跌幅）\n        g.pct_change[security] = pct_change\n    return pct_change\n        \n# 计算个股回撤止损阈值\n# 即个股在持仓n天内能承受的最大跌幅\n# 算法：(个股250天内最大的n日跌幅 + 个股250天内平均的n日跌幅)/2\n# 返回正值\ndef get_stop_loss_threshold(security, n = 3):\n    pct_change = get_pct_change(security, 250, n)\n    #log.debug(\"pct of security [%s]: %s\", pct)\n    maxd = pct_chang",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "t of security [%s]: %s\", pct)\n    maxd = pct_change.min()\n    #maxd = pct[pct<0].min()\n    avgd = pct_change.mean()\n    #avgd = pct[pct<0].mean()\n    # maxd和avgd可能为正，表示这段时间内一直在增长，比如新股\n    bstd = (maxd + avgd) / 2\n\n    # 数据不足时，计算的bstd为nan\n    if not isnan(bstd):\n        if bstd != 0:\n            return abs(bstd)\n        else:\n            # bstd = 0，则 maxd <= 0\n            if maxd < 0:\n                # 此时取最大跌幅\n                return abs(maxd)\n\n    return 0.079 # 默认配置回测止损阈值最大跌幅为-9.9%，阈值高貌似回撤降低\n\n# 计算个股止盈阈值\n# 算",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "9 # 默认配置回测止损阈值最大跌幅为-9.9%，阈值高貌似回撤降低\n\n# 计算个股止盈阈值\n# 算法：个股250天内最大的n日涨幅\n# 返回正值\ndef get_stop_profit_threshold(security, n = 3):\n    pct_change = get_pct_change(security, 250, n)\n    maxr = pct_change.max()\n    \n    # 数据不足时，计算的maxr为nan\n    # 理论上maxr可能为负\n    if (not isnan(maxr)) and maxr != 0:\n        return abs(maxr)\n    return 0.30 # 默认配置止盈阈值最大涨幅为30%\n\n# 获取股票n日以来涨幅，根据当前价计算\n# n 默认20日\ndef get_growth_rate(security, n=20):\n    lc = get_close_price(security, n)\n    #c = data[security].close\n    c = get_close_price(secu",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": " data[security].close\n    c = get_close_price(security, 1, '1m')\n    \n    if not isnan(lc) and not isnan(c) and lc != 0:\n        return (c - lc) / lc\n    else:\n        log.error(\"数据非法, security: %s, %d日收盘价: %f, 当前价: %f\" %(security, n, lc, c))\n        return 0\n\n# 获取前n个单位时间当时的收盘价\ndef get_close_price(security, n, unit='1d'):\n    return attribute_history(security, n, unit, ('close'), True)['close'][0]\n\n# 开仓，买入指定价值的证券\n# 报单成功并成交（包括全部成交或部分成交，此时成交量大于0），返回True\n# 报单失败或者报单成功但被取消（此时成交量等于0），返回False\ndef open_position(sec",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "或者报单成功但被取消（此时成交量等于0），返回False\ndef open_position(security, value):\n    order = order_target_value_(security, value)\n    if order != None and order.filled > 0:\n        # 报单成功并有成交则初始化最高价\n        cur_price = get_close_price(security, 1, '1m')\n        g.last_high[security] = cur_price\n        return True\n    return False\n\n# 平仓，卖出指定持仓\n# 平仓成功并全部成交，返回True\n# 报单失败或者报单成功但被取消（此时成交量等于0），或者报单非全部成交，返回False\ndef close_position(position):\n    security = position.security\n    order = order_target_value_(security, 0) # 可能会因停牌失败",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "rder = order_target_value_(security, 0) # 可能会因停牌失败\n    if order != None:\n        if order.filled > 0:\n            # 只要有成交，无论全部成交还是部分成交，则统计盈亏\n            g.trade_stat.watch(security, order.filled, position.avg_cost, position.price)\n\n        if order.status == OrderStatus.held and order.filled == order.amount:\n            # 全部成交则删除相关证券的最高价缓存\n            if security in g.last_high:\n                g.last_high.pop(security)\n            else:\n                log.warn(\"last high price of %s not found\" %(security)",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "warn(\"last high price of %s not found\" %(security))\n            return True\n\n    return False\n\n# 清空卖出所有持仓\ndef clear_position(context):\n    if context.portfolio.positions:\n        log.info(\"==> 清仓，卖出所有股票\")\n        for stock in context.portfolio.positions.keys():\n            position = context.portfolio.positions[stock]\n            close_position(position)\n\n# 自定义下单\n# 根据Joinquant文档，当前报单函数都是阻塞执行，报单函数（如order_target_value）返回即表示报单完成\n# 报单成功返回报单（不代表一定会成交），否则返回None\ndef order_target_value_(security, value):\n    if val",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "f order_target_value_(security, value):\n    if value == 0:\n        log.debug(\"Selling out %s\" % (security))\n    else:\n        log.debug(\"Order %s to value %f\" % (security, value))\n        \n    # 如果股票停牌，创建报单会失败，order_target_value 返回None\n    # 如果股票涨跌停，创建报单会成功，order_target_value 返回Order，但是报单会取消\n    # 部成部撤的报单，聚宽状态是已撤，此时成交量>0，可通过成交量判断是否有成交\n    return order_target_value(security, value)\n\n\n# 过滤停牌股票\ndef filter_paused_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "_data()\n    return [stock for stock in stock_list if not current_data[stock].paused]\n\n# 过滤ST及其他具有退市标签的股票\ndef filter_st_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list \n        if not current_data[stock].is_st \n        and 'ST' not in current_data[stock].name \n        and '*' not in current_data[stock].name \n        and '退' not in current_data[stock].name]\n        \n# 过滤涨停的股票\ndef filter_limitup_stock(context, stock_list):\n    last_prices = history(1, unit='1m",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "stock_list):\n    last_prices = history(1, unit='1m', field='close', security_list=stock_list)\n    current_data = get_current_data()\n    \n    # 已存在于持仓的股票即使涨停也不过滤，避免此股票再次可买，但因被过滤而导致选择别的股票\n    return [stock for stock in stock_list if stock in context.portfolio.positions.keys() \n        or last_prices[stock][-1] < current_data[stock].high_limit]\n    #return [stock for stock in stock_list if stock in context.portfolio.positions.keys() \n    #    or last_prices[stock][-1] < current_data[stock].high_limit * 0.995]\n",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "ck][-1] < current_data[stock].high_limit * 0.995]\n\n# 过滤跌停的股票\ndef filter_limitdown_stock(context, stock_list):\n    last_prices = history(1, unit='1m', field='close', security_list=stock_list)\n    current_data = get_current_data()\n    \n    return [stock for stock in stock_list if stock in context.portfolio.positions.keys() \n        or last_prices[stock][-1] > current_data[stock].low_limit]\n    #return [stock for stock in stock_list if last_prices[stock][-1] > current_data[stock].low_limit]\n    #return [stock ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "current_data[stock].low_limit]\n    #return [stock for stock in stock_list if stock in context.portfolio.positions.keys() \n    #    or last_prices[stock][-1] > current_data[stock].low_limit * 1.005]\n    \n# 过滤黑名单股票\ndef filter_blacklist_stock(context, stock_list):\n    blacklist = get_blacklist()\n    return [stock for stock in stock_list if stock not in blacklist]\n\n# 过滤创业版股票\ndef filter_gem_stock(context, stock_list):\n    return [stock for stock in stock_list if stock[0:3] != '300']\n\n# 过滤20日增长率为负的股票\ndef filter_b",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "stock[0:3] != '300']\n\n# 过滤20日增长率为负的股票\ndef filter_by_growth_rate(stock_list, n):\n    return [stock for stock in stock_list if get_growth_rate(stock, n) > 0]\n\n# 股票评分\ndef rank_stocks(data, stock_list):\n    dst_stocks = {}\n    for stock in stock_list:\n        h = attribute_history(stock, 130, unit='1d', fields=('close', 'high', 'low'), skip_paused=True)\n        low_price_130 = h.low.min()\n        high_price_130 = h.high.max()\n\n        avg_15 = data[stock].mavg(15, field='close')\n        cur_price = data[stock].",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "5, field='close')\n        cur_price = data[stock].close\n\n        #avg_15 = h['close'][-15:].mean()\n        #cur_price = get_close_price(stock, 1, '1m')\n\n        score = (cur_price-low_price_130) + (cur_price-high_price_130) + (cur_price-avg_15)\n        #score = ((cur_price-low_price_130) + (cur_price-high_price_130) + (cur_price-avg_15)) / cur_price\n        dst_stocks[stock] = score\n        \n    df = pd.DataFrame(dst_stocks.values(), index=dst_stocks.keys())\n    df.columns = ['score']\n    df = df.sort(colum",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "\n    df.columns = ['score']\n    df = df.sort(columns='score', ascending=True)\n    return df.index\n\n\n# 过滤新股\ndef filter_new_stock(stock_list):\n    stocks = get_all_securities(['stock'])\n    stocks = stocks[(context.current_dt.date() - stocks.start_date) > datetime.timedelta(90)].index\n    return stocks\n\n# 选股\n# 选取指定数目的小市值股票，再进行过滤，最终挑选指定可买数目的股票\ndef pick_stocks(context, data):\n    q = query(valuation.code)\n    if g.pick_by_pe:\n        q = q.filter(\n            valuation.pe_ratio > g.min_pe, \n            valuatio",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "luation.pe_ratio > g.min_pe, \n            valuation.pe_ratio < g.max_pe\n            )\n\n    if g.pick_by_eps:\n        q = q.filter(\n            indicator.eps > g.min_eps,\n            #valuation.turnover_ratio > 3\n            )\n\n    q = q.order_by(\n                valuation.market_cap.asc()\n            ).limit(\n                g.pick_stock_count\n            )\n    \n    df = get_fundamentals(q)\n    stock_list = list(df['code'])\n\n    if g.filter_gem:\n        stock_list = filter_gem_stock(context, stock_list)\n   ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "k_list = filter_gem_stock(context, stock_list)\n        \n    if g.filter_blacklist:\n        stock_list = filter_blacklist_stock(context, stock_list)\n        \n    stock_list = filter_paused_stock(stock_list)\n    stock_list = filter_st_stock(stock_list)\n    stock_list = filter_limitup_stock(context, stock_list)\n    stock_list = filter_limitdown_stock(context, stock_list)\n\n    # 根据20日股票涨幅过滤效果不好，故注释\n    #stock_list = filter_by_growth_rate(stock_list, 20)\n    \n    if g.is_rank_stock:\n        if len(stock_list) > ",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": " if g.is_rank_stock:\n        if len(stock_list) > g.rank_stock_count:\n            stock_list = stock_list[:g.rank_stock_count]\n\n        #log.debug(\"评分前备选股票: %s\" %(stock_list))\n        if len(stock_list) > 0:\n            stock_list = rank_stocks(data, stock_list)\n        #log.debug(\"评分后备选股票: %s\" %(stock_list))\n    \n    # 选取指定可买数目的股票\n    if len(stock_list) > g.buy_stock_count:\n        stock_list = stock_list[:g.buy_stock_count]\n    return stock_list\n\n# 根据待买股票创建或调整仓位\n# 对于因停牌等原因没有卖出的股票则继续持有\n# 始终保持持仓数目为g.buy_sto",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "建或调整仓位\n# 对于因停牌等原因没有卖出的股票则继续持有\n# 始终保持持仓数目为g.buy_stock_count\ndef adjust_position(context, buy_stocks):\n    for stock in context.portfolio.positions.keys():\n        if stock not in buy_stocks:\n            log.info(\"stock [%s] in position is not buyable\" %(stock))\n            position = context.portfolio.positions[stock]\n            close_position(position)\n        else:\n            log.info(\"stock [%s] is already in position\" %(stock))\n    \n    # 根据股票数量分仓\n    # 此处只根据可用金额平均分配购买，不能保证每个仓位平均分配\n    position_count =",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": " 此处只根据可用金额平均分配购买，不能保证每个仓位平均分配\n    position_count = len(context.portfolio.positions)\n    if g.buy_stock_count > position_count:\n        value = context.portfolio.cash / (g.buy_stock_count - position_count)\n\n        for stock in buy_stocks:\n            if context.portfolio.positions[stock].total_amount == 0:\n                if open_position(stock, value):\n                    if len(context.portfolio.positions) == g.buy_stock_count:\n                        break\n\n\n",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "k\n\n\n",
        "source": "99策略代码/51 HS300--随机森林拐点识别.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15815\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 期货日频多品种，MA双均线+百分比追踪止损\n# 建议给予1000000元，2012年1月1日至今回测\n# 导入函数库\nfrom jqdata import * \nimport talib\nfrom math import isnan\n\ndef initialize(context):\n    # 设置参数\n    set_parameter(context)\n    # 设定基准银华日利，在多品种的回测当中基准没有参考意义\n    set_benchmark('511880.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    ### 期货相关设定 ###\n    # ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "_level('order', 'error')\n    ### 期货相关设定 ###\n    # 设定账户为金融账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='futures')])\n    # 期货类每笔交易时的手续费是：买入时万分之1,卖出时万分之1,平今仓为万分之1\n    set_order_cost(OrderCost(open_commission=0.0001, close_commission=0.0001,close_today_commission=0.0001), type='index_futures')\n    # 设定保证金比例\n    set_option('futures_margin_rate', 0.15)\n    # 设置滑点（单边万5，双边千1）\n    set_slippage(PriceRelatedSlippage(0.001),type='future')\n    # 开盘前运行\n    run_daily( before_mark",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "e='future')\n    # 开盘前运行\n    run_daily( before_market_open, time='before_open', reference_security=get_future_code('RB'))\n    # 开盘时运行\n    run_weekly(market_open, 1,time='open', reference_security=get_future_code('RB'))\n#    run_monthly(market_open, 11,time='open', reference_security=get_future_code('RB'))\n    # 交易运行 \n    # 交易运行 \n    run_weekly(Trade, 1, time='open', reference_security=get_future_code('RB'))\n#    run_monthly(Trade, 11, time='open', reference_security=get_future_code('RB'))\n    # 收盘后运行\n    run",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "ecurity=get_future_code('RB'))\n    # 收盘后运行\n    run_daily( after_market_close, time='after_close', reference_security=get_future_code('RB'))\n    \n    \n    \n\n   # 参数设置函数\ndef set_parameter(context):\n    \n    #######变量设置########\n    g.LastRealPrice = {} # 最新真实合约价格字典(用于吊灯止损）\n    g.HighPrice = {} # 各品种最高价字典（用于吊灯止损）\n    g.LowPrice = {} # 各品种最低价字典（用于吊灯止损）\n    g.future_list = []  # 设置期货品种列表\n    g.TradeLots = {}  # 各品种的交易手数信息\n    g.PriceArray = {} # 信号计算价格字典\n    g.Price_dict = {} # 各品种价格列表字典\n    g.Times = {} # 计数器（用于",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "ce_dict = {} # 各品种价格列表字典\n    g.Times = {} # 计数器（用于防止止损重入）\n    g.Reentry_long = False # 止损后重入标记\n    g.Reentry_short = False # 止损后重入标记\n    g.MappingReal = {} # 真实合约映射（key为symbol，value为主力合约）\n    g.MappingIndex = {} # 指数合约映射 （key为 symbol，value为指数合约\n    g.StatusTimer = {} # 当前状态计数器\n    g.ATR = {}\n    g.CurrentPrice = {}\n    g.Price_DaysAgo = {}\n    g.Momentum = {}\n    g.ClosePrice = {}\n\n    #######参数设置########\n    g.BackWindow = 15 # 回溯窗口长度\n    g.Range = 0.3\n    # 交易的期货品种信息\n    g.instruments = ['AL','NI','CU','P",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "# 交易的期货品种信息\n    g.instruments = ['AL','NI','CU','PB','AG',\n                    'RU','MA','PP','TA','L','V',\n                    'M','P','Y','OI','C','CS','JD','SR',\n                    'HC','J','I','SF','RB','ZC','FG']\n    # 价格列表初始化\n    set_future_list(context)\n\n\ndef set_future_list(context):\n    for ins in g.instruments:\n        idx = get_future_code(ins)\n        dom = get_dominant_future(ins)\n        # 填充映射字典\n        g.MappingIndex[ins] = idx\n        g.MappingReal[ins] = dom\n        g.StatusTimer[ins] = 0",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "pingReal[ins] = dom\n        g.StatusTimer[ins] = 0\n        #设置主力合约已上市的品种基本参数\n        if dom == '':\n            pass\n        else:\n            if dom not in g.future_list:\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n                \n\n'''\n换月模块逻辑（ins是期货品种的symbol（如‘RB’），dom或future指合约（如'RB1610.XSGE'）,idx指指数合约（如’RB8888.XSGE‘）\n    1.在第一天开始时，将所有期货品种最初的主力合约写入MappingReal与MappingIndex当中\n    2.每天开盘获取一遍ins对应的主",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "写入MappingReal与MappingIndex当中\n    2.每天开盘获取一遍ins对应的主力合约，判断是否在MappingReal中，若不在，则执行replace模块\n    3.replace模块中，卖出原来持有的主力合约，等量买入新合约；修改MappingReal\n'''\n## 开盘前运行函数\ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    send_message('开始交易')\n    \n    # 过滤无主力合约的品种，传入并修改期货字典信息\n    for ins in g.instruments:\n        dom = get_dominant_future(ins)\n        if dom == '':\n            pass\n        else:\n            # 判断是否执行replace_old_futures\n            if ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "       # 判断是否执行replace_old_futures\n            if dom == g.MappingReal[ins]:\n                pass\n            else:\n                replace_old_futures(context,ins,dom)\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n        \n            g.TradeLots[dom] = get_lots(context.portfolio.starting_cash/len(g.instruments),ins)\n            \n\n## 开盘时运行函数\ndef market_open(context):\n    # 输出函数运行时间\n    #log.info('函",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "ket_open(context):\n    # 输出函数运行时间\n    #log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    # 以下是主循环\n    for ins in g.instruments:\n        # 过滤空主力合约品种\n        if g.MappingReal[ins] != '':\n            IndexFuture = g.MappingIndex[ins]\n            RealFuture = g.MappingReal[ins]\n            # 获取当月合约交割日期\n            end_date = get_CCFX_end_date(RealFuture)\n            # 当月合约交割日当天不开仓\n            if (context.current_dt.date() == end_date):\n                return\n            else:\n                g",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "        return\n            else:\n                g.LastRealPrice[RealFuture] = attribute_history(RealFuture,1,'1d',['close'])['close'][-1]\n                # 获取价格list\n                #if g.StatusTimer[ins] == 0:\n                g.PriceArray[IndexFuture] = attribute_history(IndexFuture,g.BackWindow+5,'1d',['close','open','high','low'])\n                \n                # 如果没有数据，返回\n                if len(g.PriceArray[IndexFuture]) < 1:\n                    return\n                else: \n                    g.Clos",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "\n                else: \n                    g.ClosePrice[ins] = g.PriceArray[IndexFuture]['close']\n                    g.CurrentPrice[ins] = g.ClosePrice[ins][-1]\n                    g.Price_DaysAgo[ins] = g.ClosePrice[ins][-g.BackWindow]\n                    \n                    g.close = np.array(g.PriceArray[IndexFuture]['close'])\n                    g.high = np.array(g.PriceArray[IndexFuture]['high'])\n                    g.low = np.array(g.PriceArray[IndexFuture]['low'])\n                    g.ATR[IndexFu",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "xFuture]['low'])\n                    g.ATR[IndexFuture] = talib.ATR(g.high,g.low,g.close, g.BackWindow)[-1]\n                    \n                    # g.Momentum[ins] = g.CurrentPrice[ins]/g.Price_DaysAgo[ins] -1\n                    g.Momentum[ins] = g.CurrentPrice[ins]/g.Price_DaysAgo[ins] -1\n\n                    \n                    \n                    \n\n           \n## 收盘后运行函数\ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    # 得到当天所有成交记录",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "+str(context.current_dt.time())))\n    # 得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n    \n## 交易模块 \ndef Trade(context):\n    # 定义每周买卖的列表\n    log.info(g.ClosePrice.keys())\n    BuyList = []\n    SellList = []\n    # 将字典进行排序，并将数值前五品种的symbol写入列表\n    a = sorted(g.Momentum.items(), key=lambda x: x[1],reverse = True)\n    for i in range(int(g.Range*len(g.Ma",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "se = True)\n    for i in range(int(g.Range*len(g.MappingReal.keys()))):\n        BuyList.append(a[i][0])\n        SellList.append(a[-i-1][0])\n       \n        \n    for ins in g.instruments:\n        RealFuture = g.MappingReal[ins]\n        IndexFuture = g.MappingIndex[ins]\n        if RealFuture in g.LastRealPrice.keys():\n            if ins in BuyList and context.portfolio.long_positions[RealFuture].total_amount == 0:\n                if context.portfolio.long_positions[RealFuture].total_amount != 0:\n              ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "ions[RealFuture].total_amount != 0:\n                    log.info('空头有持仓：%s'%(RealFuture))\n                order_target(RealFuture,0,side='short')\n                order_target(RealFuture,g.TradeLots[RealFuture],side='long')\n                g.HighPrice[RealFuture] = g.LastRealPrice[RealFuture]\n                g.LowPrice[RealFuture] = False\n                log.info('正常买多合约：%s'%(RealFuture))\n        \n            elif ins in SellList and context.portfolio.short_positions[RealFuture].total_amount == 0:\n          ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "ositions[RealFuture].total_amount == 0:\n                if context.portfolio.short_positions[RealFuture].total_amount != 0:\n                    log.info('多头有持仓：%s'%(RealFuture))\n                order_target(RealFuture,0,side ='long')\n                order_target(RealFuture,g.TradeLots[RealFuture],side='short')\n                g.LowPrice[RealFuture] = g.LastRealPrice[RealFuture]\n                g.HighPrice[RealFuture] = False\n                log.info('正常卖空合约：%s'%(RealFuture))\n            elif ins not in BuyL",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "%s'%(RealFuture))\n            elif ins not in BuyList and RealFuture in context.portfolio.long_positions.keys():\n                order_target(RealFuture,0,side ='long')\n            elif ins not in SellList and RealFuture in context.portfolio.short_positions.keys():\n                order_target(RealFuture,0,side ='short')\n            else:\n                TrailingStop(context,RealFuture,IndexFuture)\n         #防重入模块yunxi\n        Dont_Re_entry(context,RealFuture,ins)     \n\n        \n        \n# 追踪止损后,防止立刻重入模块\n# ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "e,ins)     \n\n        \n        \n# 追踪止损后,防止立刻重入模块\n# 因为追踪止损条件领先于金叉死叉，所以在止损后，要防止系统再次高位入场\ndef Dont_Re_entry(context,future,ins):\n    # 防重入模块：上一次止损后20根bar内不交易，但如果出现价格突破事件则20根bar的限制失效\n    #设置最高价与最低价（注意：需要错一位，不能算入当前价格）\n    if ins in g.ClosePrice.keys():\n        g.Highest_high_2_20 = g.ClosePrice[ins][-21:-1].max()\n        g.Lowest_low_2_20 = g.ClosePrice[ins][-21:-1].min()\n    \n        if  g.Reentry_long == True:\n            if g.Times[future] > 20 or g.CurrentPrice[ins] > g.Highest_high_2_20 :\n                g.Re",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "[ins] > g.Highest_high_2_20 :\n                g.Reentry_long = False\n        if  g.Reentry_short == True:\n            if g.Times[future] > 20 or g.CurrentPrice[ins] < g.Lowest_low_2_20 :\n                g.Reentry_short = False\n        \n\n# 追踪止损模块（百分比止损）\ndef TrailingStop(context,RealFuture,IndexFuture):\n    \n    # 记录多空仓位\n    long_positions = context.portfolio.long_positions\n    short_positions = context.portfolio.short_positions\n    \n    # 通过for循环逐一平仓（多头）\n    if RealFuture in long_positions.keys():\n        if",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "if RealFuture in long_positions.keys():\n        if long_positions[RealFuture].total_amount > 0:\n            if g.HighPrice[RealFuture]:\n                g.HighPrice[RealFuture] = max(g.HighPrice[RealFuture], g.LastRealPrice[RealFuture])\n                if g.LastRealPrice[RealFuture]  < g.HighPrice[RealFuture]-g.ATR[IndexFuture]:\n                    log.info('多头止损:\\t' +  RealFuture)\n                    order_target(RealFuture,0,side = 'long')\n                    g.Reentry_long = True\n                    \n    ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "   g.Reentry_long = True\n                    \n    # 通过for循环逐一平仓（空头）\n    if RealFuture in short_positions.keys():\n        if short_positions[RealFuture].total_amount > 0:\n            if g.LowPrice[RealFuture]:\n                g.LowPrice[RealFuture] = min(g.LowPrice[RealFuture], g.LastRealPrice[RealFuture])\n                if g.LastRealPrice[RealFuture]  > g.LowPrice[RealFuture]+g.ATR[IndexFuture]:\n                    log.info('空头止损:\\t' + RealFuture)\n                    order_target(RealFuture,0,side = 'short",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "           order_target(RealFuture,0,side = 'short')\n                    g.Reentry_short = True\n\n\n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约        \ndef replace_old_futures(context,ins,dom):\n    \n    LastFuture = g.MappingReal[ins]\n    \n    if LastFuture in context.portfolio.long_positions.keys():\n        lots_long = context.portfolio.long_positions[LastFuture].total_amount\n        order_target(LastFuture,0,side='long')\n        order_target(dom,lots_long,side='long')\n        print('主力合约更换，平多仓换新仓')\n    \n    if LastFut",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "        print('主力合约更换，平多仓换新仓')\n    \n    if LastFuture in context.portfolio.short_positions.keys():\n        lots_short = context.portfolio.short_positions[dom].total_amount\n        order_target(LastFuture,0,side='short')\n        order_target(dom,lots_short,side='short')\n        print('主力合约更换，平空仓换新仓')\n\n    g.MappingReal[ins] = dom     \n            \n'''增加删除过去合约'''\n        \n        \n# 获取当天时间正在交易的期货主力合约函数\ndef get_future_code(symbol):\n    future_code_list = {'A':'A8888.XDCE', 'AG':'AG8888.XSGE', 'AL':'AL8888.XSGE",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "A8888.XDCE', 'AG':'AG8888.XSGE', 'AL':'AL8888.XSGE', 'AU':'AU8888.XSGE',\n                        'B':'B8888.XDCE', 'BB':'BB8888.XDCE', 'BU':'BU8888.XSGE', 'C':'C8888.XDCE', \n                        'CF':'CF8888.XZCE', 'CS':'CS8888.XDCE', 'CU':'CU8888.XSGE', 'ER':'ER8888.XZCE', \n                        'FB':'FB8888.XDCE', 'FG':'FG8888.XZCE', 'FU':'FU8888.XSGE', 'GN':'GN8888.XZCE', \n                        'HC':'HC8888.XSGE', 'I':'I8888.XDCE', 'IC':'IC8888.CCFX', 'IF':'IF8888.CCFX', \n                        '",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "X', 'IF':'IF8888.CCFX', \n                        'IH':'IH8888.CCFX', 'J':'J8888.XDCE', 'JD':'JD8888.XDCE', 'JM':'JM8888.XDCE', \n                        'JR':'JR8888.XZCE', 'L':'L8888.XDCE', 'LR':'LR8888.XZCE', 'M':'M8888.XDCE', \n                        'MA':'MA8888.XZCE', 'ME':'ME8888.XZCE', 'NI':'NI8888.XSGE', 'OI':'OI8888.XZCE', \n                        'P':'P8888.XDCE', 'PB':'PB8888.XSGE', 'PM':'PM8888.XZCE', 'PP':'PP8888.XDCE', \n                        'RB':'RB8888.XSGE', 'RI':'RI8888.XZCE', 'RM':'RM888",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "RB':'RB8888.XSGE', 'RI':'RI8888.XZCE', 'RM':'RM8888.XZCE', 'RO':'RO8888.XZCE', \n                        'RS':'RS8888.XZCE', 'RU':'RU8888.XSGE', 'SF':'SF8888.XZCE', 'SM':'SM8888.XZCE', \n                        'SN':'SN8888.XSGE', 'SR':'SR8888.XZCE', 'T':'T8888.CCFX', 'TA':'TA8888.XZCE', \n                        'TC':'TC8888.XZCE', 'TF':'TF8888.CCFX', 'V':'V8888.XDCE', 'WH':'WH8888.XZCE', \n                        'WR':'WR8888.XSGE', 'WS':'WS8888.XZCE', 'WT':'WT8888.XZCE', 'Y':'Y8888.XDCE', \n                  ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "T8888.XZCE', 'Y':'Y8888.XDCE', \n                        'ZC':'ZC8888.XZCE', 'ZN':'ZN8888.XSGE','AP':'AP8888.XZCE'}\n    try:\n        return future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n\n\n# 获取交易手数函数（ATR倒数头寸）\ndef get_lots(cash,symbol):\n    future_coef_list = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10,\n                        'CF':5, 'CS':10, 'CU':5, 'ER':10,\n                        'FB':500, 'FG':20, 'FU':50, 'GN':10,\n                  ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "500, 'FG':20, 'FU':50, 'GN':10,\n                        'HC':10, 'I':100, 'IC':200, 'IF':300,\n                        'IH':300, 'J':100, 'JD':5, 'JM':60,\n                        'JR':20, 'L':5, 'LR':10, 'M':10,\n                        'MA':10, 'ME':10, 'NI':1, 'OI':10,\n                        'P':10, 'PB':5, 'PM':50, 'PP':5,\n                        'RB':10, 'RI':20, 'RM':10, 'RO':10,\n                        'RS':10, 'RU':10, 'SF':5, 'SM':5,\n                        'SN':1, 'SR':10, 'T':10000, 'TA':5,\n       ",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "       'SN':1, 'SR':10, 'T':10000, 'TA':5,\n                        'TC':100, 'TF':10000, 'V':5, 'WH':20,\n                        'WR':10, 'WS':50, 'WT':10, 'Y':10,\n                        'ZC':100, 'ZN':5,'AP':10}\n    RealFuture = get_dominant_future(symbol)\n    IndexFuture = get_future_code(symbol)\n    # 获取价格list\n    Price_dict = attribute_history(IndexFuture,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0:\n        return\n    else:\n        open_future = Price_dict.iloc[-1]\n    # 返回手数\n    if I",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "n_future = Price_dict.iloc[-1]\n    # 返回手数\n    if IndexFuture in g.ATR.keys():\n        # 每次使用10%资金开仓交易\n        # 合约价值的表达式是：g.ATR[IndexFuture]*future_coef_list[symbol]\n        return cash*0.1/(g.ATR[IndexFuture]*future_coef_list[symbol])\n    else:# 函数运行之初会出现没将future写入ATR字典当中的情况\n        return cash*0.0001/future_coef_list[symbol]\n\n\n# # 获取交易手数函数(无ATR版本）\n# def get_lots(cash,symbol):\n#     # 获取合约规模(Contract Size)，也称交易单位\n#     future_Contract_Size = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n#                         'B",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "5, 'AL':5, 'AU':1000,\n#                         'B':10, 'BB':500, 'BU':10, 'C':10,\n#                         'CF':5, 'CS':10, 'CU':5, 'ER':10,\n#                         'FB':500, 'FG':20, 'FU':50, 'GN':10,\n#                         'HC':10, 'I':100, 'IC':200, 'IF':300,\n#                         'IH':300, 'J':100, 'JD':5, 'JM':60,\n#                         'JR':20, 'L':5, 'LR':10, 'M':10,\n#                         'MA':10, 'ME':10, 'NI':1, 'OI':10,\n#                         'P':10, 'PB':5, 'PM':50, 'PP':5,\n#",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "                'P':10, 'PB':5, 'PM':50, 'PP':5,\n#                         'RB':10, 'RI':20, 'RM':10, 'RO':10,\n#                         'RS':10, 'RU':10, 'SF':5, 'SM':5,\n#                         'SN':1, 'SR':10, 'T':10000, 'TA':5,\n#                         'TC':100, 'TF':10000, 'V':5, 'WH':20,\n#                         'WR':10, 'WS':50, 'WT':10, 'Y':10,\n#                         'ZC':100, 'ZN':5,'AP':10}\n#     future = get_dominant_future(symbol)\n#     # 获取价格list\n#     Price_dict = attribute_history(futur",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "取价格list\n#     Price_dict = attribute_history(future,10,'1d',['open'])\n#     # 如果没有数据，返回\n#     if len(Price_dict) == 0:\n#         return\n#     else:\n#         # 获得最新开盘价，计算能够下单多少手\n#         open_price = Price_dict.iloc[-1]\n#     # 返回手数（价格*合约规模=名义价值）\n#     # 保证金使用，控制在33%\n#     # 合约保证金的表达式是：open_price*future_Contract_Size[symbol]*g.MarginRate\n#     return cash*0.33/(open_price*future_Contract_Size[symbol]*g.MarginRate)\n\n\n# 获取金融期货合约到期日\ndef get_CCFX_end_date(fature_code):\n    # 获取金融期货合约到期日\n    return get_security",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "e_code):\n    # 获取金融期货合约到期日\n    return get_security_info(fature_code).end_date",
        "source": "99策略代码/17 商品期货截面动量模型，真的靠谱吗？.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11549\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n'''\n一 策略名称：低PB价值投资策略\n二 策略概述：致力于筛选低市净率且财务指标向好的A股，做价值投资\n三 策略基本内容：\n    1 选股：过滤筛选A股列表，并对符合条件的股票进行排序，主要包括：\n        1.1 状态过滤：过滤停盘、退市、ST及开盘涨停股；\n        1.2 财务筛选：筛选流通股本小于25亿股、市净率小于0.85、且营业收入同比增长率、净利润同比增长率、净资产收益率ROE\n                      都大于0的股票，对初步筛选后的股票按市净率从小到大筛选出前10只股票（最多10只）；\n        1.3 排序：对选出的股票按净资产收益率ROE、市净率、净利润同比增长率、总市值四项指标所占权重比例重新排序\n    2 择时：对排序第一的股票当天开盘即买入\n    3 仓位管理：最多同时持有一只股票，且只做满仓买入或全仓卖出操作\n    4 止盈止",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "即买入\n    3 仓位管理：最多同时持有一只股票，且只做满仓买入或全仓卖出操作\n    4 止盈止损：每分钟判断个股从持仓后的最大涨跌幅度及最高价回撤幅度，若超过设定阈值，则清仓\n四 策略回测概述：\n    1 回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n    2 初始资金：100000元\n    3 策略收益：1465.70% ，策略年化收益：99.19% ，Alpha：0.908 ，Beta：0.357 ，Sharpe：3.149 ，胜率：100% ，最大回测：15.860%\n五 策略还需改进项：\n    1 空仓时间较多，大概占了回测周期的三分之一时间，有待改善\n    2 探索是否有更适合该策略的仓位管理方法\n    3 引进动态量化因子，解决目前筛选参数均为常量而导致在其他回测周期收益效果并不理想的问题\n\n版本：1.3.1.180318\n日期：2018.3.18\n作者：王文纲\n'''\n\n# 导入函数库\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "qdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点(固定值0.02元)，买卖时都会加减价差的一半，比如固定值0.02元，买卖时自动加减0.01元\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易（每天获得当天的除权价格，往前取前基于当天日期的前复权价格）\n    set_option('use_real_price', True) \n    # 设定成交量比例为100%（根据实际行情限制每个订单的成交量，成交量不超过：每日成交量*每日成交量比例）\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "o', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率、卖出频率\n    g.buy_refresh_rate , g.sell_refresh_rate = 1 , 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 1\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days , g.sell_trade_days =",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "交易频率计数器\n    g.buy_trade_days , g.sell_trade_days = 0 , 0\n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    # 股票筛选初始化（是否过滤停盘、是否过滤退市、是否过滤ST）\n    g.filter_paused , g.filter_delisted , g.filter_st = True , True , True\n    # 股票池\n    g.security_universe_index = [\"all_a_securities\"]\n    g.security_universe_user_securities = []\n    # 股票筛选排序初始化（总排序准则： desc-降序、asc-升序）\n    g.check_out_lists_ascending = 'desc'\n    # 出场初始化(设定是否卖出buy_lists中的股票、设定固定出仓的数量或者百分比)\n    g.sell_wil",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "设定是否卖出buy_lists中的股票、设定固定出仓的数量或者百分比)\n    g.sell_will_buy , g.sell_by_amount , g.sell_by_percent = True , None , None\n    # 入场初始化（设定是否可重复买入、单只股票最大买入金额（元）或股数（股））\n    g.filter_holded , g.max_buy_value , g.max_buy_amount = True , None , None\n\n    # 关闭提示\n    log.set_level('order', 'error')\n    # 运行函数\n    run_daily(sell_every_day,'every_bar') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股并排序\n    run_daily(trade, 'open') #交易（无择时）\n    run_daily(selled_security_l",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": ", 'open') #交易（无择时）\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n    \n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    return\n\n## 风控\ndef risk_management(context):\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in s",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": ":\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    # 获取 sell_lists 列表\n    risk_init_sl = context.portfolio.positions.keys()\n    risk_sell_lists = context.portfolio.positions.keys()\n    # 止盈：收益率≥30%时坚定持有，直到最高收益回落4%时清仓该股票（特殊情况下也能起止损作用）\n    if len(risk_sell_lists) > 0:\n        for security in risk_sell_lists:\n            # 计算单只股票股价从建仓至当前的最高价与最低价，取每分钟数据\n            df_price = get_price(security, start_date=context.portfolio.positions[security].init_time, end_date=conte",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "olio.positions[security].init_time, end_date=context.current_dt, frequency='1m', fields=['high','low'])\n            highest_price = df_price['high'].max()\n            lowest_price = df_price['low'].min()    \n            # 单只股票股价从建仓至当前的最高价与最低价相差百分比≥30%且最高收益回落4%时清仓该股票，取每分钟数据\n            if (highest_price - lowest_price) / lowest_price >= 0.3 \\\n                    and (highest_price - context.portfolio.positions[security].price) / highest_price >= 0.04:\n                # 卖出该股所有股票\n                order_target_v",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "         # 卖出该股所有股票\n                order_target_value(security, 0)\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,risk_init_sl)\n    return\n\n## 股票筛选并排序\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 过滤ST股票\n    g.check_out_lists = st_fi",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "rities)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 过滤停牌股票\n    g.check_out_lists = paused_filter(context, g.check_out_lists)\n    # 过滤涨停股票\n    g.check_out_lists = high_limit_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 经过以上筛选后的股票根据市净率大小按升序排出前10只股票\n    df_check_out_lists = get_fundamentals(query(\n           ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "ck_out_lists = get_fundamentals(query(\n            valuation.code, valuation.pb_ratio\n        ).filter(\n            # 这里不能使用 in 操作, 要使用in_()函数\n            valuation.code.in_(g.check_out_lists)\n        ).order_by(\n            # 按市净率升序排列，排序准则：desc-降序、asc-升序\n            valuation.pb_ratio.asc()\n        ).limit(\n            # 最多返回10个\n            10\n            #前一个交易日的日期\n        ), date=context.previous_date)\n    # 筛选结果加入g.check_out_lists中\n    g.check_out_lists = df_check_out_lists['code']\n    # 排序    \n    inpu",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "= df_check_out_lists['code']\n    # 排序    \n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n    # 获取 buy_lists 列表\n    buy_lists = g.check_out_lists\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n       ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "   # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n#######################",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "security_list[stock] += 1\n\n##################################  选股排序函数群 ##################################\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n   ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "   for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.filter_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "t_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    # 流通股本小于250000万股\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.circulating_cap, 250000)\n    # 市净率小于0.85\n    security_list = financial_data_filter_xiaoyu(security_list, valuati",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "inancial_data_filter_xiaoyu(security_list, valuation.pb_ratio, 0.85)\n    # 营业收入同比增长率(%)：检验上市公司去年一年挣钱能力是否提高的标准\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 0)\n    # 净利润同比增长率：（当期的净利润-上月（上年）当期的净利润）/上月（上年）当期的净利润=净利润同比增长率\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 0)\n    # 净资产收益率ROE：归属于母公司股东的净利润*2/（期初归属于母公司股东的净资产+期末归属于母公司股东的净资产）\n    security_list = financial_data_filter_dayu(security_list, indicator.roe",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "cial_data_filter_dayu(security_list, indicator.roe, 0)\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    #desc-降序、asc-升序\n    input_dict = {\n        indicator.roe:('desc',0.7), #净资产收益率ROE，从大到小，权重0.7\n        valuation.pb_ratio:('asc',0.05), #市净率，从小到大，权重0.05\n        indicator.inc_net_profit_year_on_year:('desc',0.2), #净利润同比增长率，从大到小，权重0.2\n        valuation.market_cap:('desc',0.05), #总市值，从大到小，权重0.05\n        }\n    # 返回结果\n    return input_dict\n\n## 排序\ndef check_st",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "  # 返回结果\n    return input_dict\n\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "ore 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.p",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "itions.keys()\n    sell_lists = context.portfolio.positions.keys()\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    # 卖出符合条件的股票\n    if len(sell_lists)>0:\n        for security in sell_lists:\n            # 计算单只股票股价从建仓至当前的最高价与最低价，取每分钟数据\n            df_price = get_price(security, start_date=context.portfolio.positions[security].init_time, end_date=context.current_dt, frequency='1m', fields=['high','low'])\n           ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "frequency='1m', fields=['high','low'])\n            highest_price = df_price['high'].max()\n            lowest_price = df_price['low'].min() \n            #单只股票股价从建仓至当前的最高价与最低价相差百分比<30%且持有天数达到83天时，清仓该股票\n            if (highest_price - lowest_price) / lowest_price < 0.3 and max_hold_days(context, security, 83): \n                sell_by_amount_or_percent_or_none(context, security, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    # 获取卖出的股票列表, 并加入到 g.selled_security_list 中\n    selled_security_list_",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "g.selled_security_list 中\n    selled_security_list_dict(context,init_sl)\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum)\n        \n        for stock in buy_lists:\n            if len(context.portfolio.pos",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "uy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n## 是否可重复买入\ndef holded_fil",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "rderStyle())\n    return\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = ",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "d_sl:\n            g.selled_security_list[stock] = 0\n\n###################################  其他函数群 ##################################\n\n\n'''\n------------------------------  版本更新说明  ----------------------------------\n\n更新：\n\n2018.03.18  低PB价值投资策略_1.3.1.180318\n    优化代码排版，新增策略概述\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：1465.70% ，策略年化收益：99.19% ，Alpha：0.908 ，Beta：0.357 ，Sharpe：3.149 ，胜率：100% ，最大回测：15.860%\n\n2018.03.11  低PB价值投资策略_1.3.0.180311 \n    剔除股东权益合计大于25亿元的选股指标，\n    新增营业收入同比增长率、净利润同比增长率、净资产收益率ROE都大于0的选股指标\n    新增对财",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "  新增营业收入同比增长率、净利润同比增长率、净资产收益率ROE都大于0的选股指标\n    新增对财务筛选后的股票按市净率从小到大再次做筛选\n    去除入场函数筛选\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：1465.70% ，策略年化收益：99.19% ，Alpha：0.908 ，Beta：0.357 ，Sharpe：3.149 ，胜率：100% ，最大回测：15.860%\n\n2018.03.09  低PB价值投资策略_1.2.0.180309\n    去除个股止损条件，并将止盈条件中的最大涨幅更改为最大涨跌幅，可兼顾止损状态\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：1068.39% ，策略年化收益：85.11% ，Alpha：0.740 ，Beta：0.578 ，Sharpe：2.705 ，胜率：93.3% ，最大回测：21.182%\n\n2018.03.04  低PB价值投资策略_1.1.2.180304\n    卖出未卖出成功的股票函数sell_every_day的调用频次由'open'改为'every_bar'\n回测周",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "成功的股票函数sell_every_day的调用频次由'open'改为'every_bar'\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：1032.76% ，策略年化收益：83.68% ，Alpha：0.727 ，Beta：0.569 ，Sharpe：2.723 ，胜率：81.3% ，最大回测：21.91%\n\n2018.03.04  低PB价值投资策略_1.1.1.180304\n    添加完善注释\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：1032.76% ，策略年化收益：83.68% ，Alpha：0.727 ，Beta：0.569 ，Sharpe：2.723 ，胜率：81.3% ，最大回测：21.91%\n\n2018.03.04  低PB价值投资策略_1.1.0.180304\n    将个股最大持仓比重由0.5调整为1，最大建仓数量由3调整为1，并添加完善注释\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：1032.76% ，策略年化收益：83.68% ，Alpha：0.727 ，Beta：0",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "\n策略收益：1032.76% ，策略年化收益：83.68% ，Alpha：0.727 ，Beta：0.569 ，Sharpe：2.723 ，胜率：81.3% ，最大回测：21.91%\n\n2018.03.04  低PB价值投资策略_1.0.0.180304\n    首次脱离向导式框架，修改原个股止盈条件，调整为个股达到最大设定涨幅后坚定持有，直到低于设定的回撤幅度时止盈\n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：729.21% ，策略年化收益：69.87% ，Alpha：0.590 ，Beta：0.562 ，Sharpe：2.618 ，胜率：78.9% ，最大回测：12.994%\n\n2018.01.31  低PB价值投资策略_0.1.5.180131\n    委托买入类型由等权重买入'by_cap_mean'改为按股票总市值比例买入'by_market_cap_percent' \n回测周期：2014-01-01 到 2018-01-30 ，按分钟回测\n策略收益：711.27%，策略年化收益：68.95% ，Alpha：0.582 ，Beta：0.553 ，Sharpe：2",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "%，策略年化收益：68.95% ，Alpha：0.582 ，Beta：0.553 ，Sharpe：2.543 ，胜率：79.4% ，最大回测：13.375%\n\n2018.01.02  低PB价值投资策略_0.1.4.180102\n    复制向导式框架生成的程序，开始研究\n回测周期：2014-01-01 到 2017-12-16 ，按分钟回测\n策略收益：589.68%，策略年化收益：64.75% ，Alpha：0.547 ，Beta：0.560 ，Sharpe：2.405 ，胜率：81.8% ，最大回测：12.971%\n\n-------------------------------------------------------------------------------\n'''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "source": "99策略代码/31 低PB价值投资策略分享.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11681\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport math \nimport pandas as pd\n\n\nlog.set_level('order', 'error')\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    # 000001(股票:平安银行)\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    \n    run_monthly(handle, 1,'before_open')\n    set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commis",
        "source": "99策略代码/97 银行翻倍策略.txt"
    },
    {
        "text": "ost(OrderCost(open_tax=0, close_tax=0, open_commission=0.0003, close_commission=0.0013, close_today_commission=0, min_commission=0), type='stock')\n    set_slippage(FixedSlippage(0.02))   \n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle(context):\n\n    buylist = check_stock(context) \n   \n    for  stock in context.portfolio.positions:\n        if stock not in buylist:\n            order_target_value(stock, 0)\n   \n    for stock in buylist:\n        order_target_value(stock, context.portfolio.total_value/le",
        "source": "99策略代码/97 银行翻倍策略.txt"
    },
    {
        "text": "rget_value(stock, context.portfolio.total_value/len(buylist))\n\ndef check_stock(context):\n    \n    stock_list =['000001.XSHE', '002142.XSHE', '002807.XSHE', '002839.XSHE', '600000.XSHG', '600015.XSHG', '600016.XSHG', '600036.XSHG', '600908.XSHG', '600919.XSHG', '600926.XSHG', '601009.XSHG', '601128.XSHG', '601166.XSHG', '601169.XSHG', '601229.XSHG', '601288.XSHG', '601328.XSHG', '601398.XSHG', '601818.XSHG', '601838.XSHG', '601939.XSHG', '601988.XSHG', '601997.XSHG', '601998.XSHG', '603323.XSHG']\n    df=pd.D",
        "source": "99策略代码/97 银行翻倍策略.txt"
    },
    {
        "text": "7.XSHG', '601998.XSHG', '603323.XSHG']\n    df=pd.DataFrame(index =stock_list, columns =['ROE','PB'])\n    for stk1 in stock_list:\n        P = get_fundamentals_continuously(query(indicator.code, valuation.pb_ratio).filter(valuation.code==stk1),count=250)\n        RO = get_fundamentals_continuously(query(indicator.code, indicator.roe).filter(valuation.code==stk1),count=250)\n        df['PB'][stk1]=P['pb_ratio'].values.mean()\n        df['ROE'][stk1] = RO['roe'].values.mean()/100\n      \n    df = df[df['ROE'] > -1]",
        "source": "99策略代码/97 银行翻倍策略.txt"
    },
    {
        "text": "lues.mean()/100\n      \n    df = df[df['ROE'] > -1]\n    \n    \n    \n    df[\"double_time\"] =  df.apply(lambda row: round(math.log(2.0 * row['PB'] , (1.0+row['ROE'])),2), axis=1)\n    #翻倍期最小的银行股\n    df = df.sort(\"double_time\")\n\n    print context.current_dt.strftime('%Y-%m-%d') +' 选股为 '+ str(df.index[:5].values)[1:-1]\n    return df.index[:5]#这里的数字表示买入的标的 数量，默认是5\n\n\n",
        "source": "99策略代码/97 银行翻倍策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15280\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 1\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "k_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_dail",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "ly(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = []\n    g.security_universe_user_securities ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "ndex = []\n    g.security_universe_user_securities = [[\"600030.XSHG\"]]\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = True\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_managemen",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "rue\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.op",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": ", 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n  ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "rse_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "xt, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dic",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "ck_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "     # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in buy_lists if situation_filter_dayu(security, 'close', 10)]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_da",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "lled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 0)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pb_ratio, 1.5)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "tion_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "ilter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "tfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if n_day_chg_dayu(security, 5, 0.5)]\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n   ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "io.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n              ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "ock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n  ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": ") == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n      ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_securi",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": ".selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.port",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "[s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n    ",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "xt, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            curr",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(conte",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "ty_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(contex",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "t(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_li",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": " concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/99 一个中信证券的向导策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13090\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in c",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "urities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_fil",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_ou",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "s = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n  ",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_l",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "k_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.gross_profit_margin, 20)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.circulating_market_cap, 500)\n    security_list = financial_data_filter_dayu(security_list, valuation.pe_ratio, 40)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": ", security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "rity_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "ys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "ty_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,b",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "     # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_b",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "ount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a =",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": " 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_lis",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "sitions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "ck for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n ",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "ly_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (curren",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "= [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x i",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "     temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "      security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n  ",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "y_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/34 成长策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14847\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport talib_real,bot_seller\nfrom jqlib.technical_analysis import *\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": "'order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    g.security = '002848.XSHE'\n    subscribe(g.security, 'tick')\n    g.N=5\n    g.QF=talib_real.QuantFactory()\n    g.QF.add(talib_real.KD_Real(g.security,N=g.N,M1=3,M2=3))\n    # g.QF.add(talib_real.SKDJ_Real(g.security,N=5,M=3))\n    g.seller=None\n    g.ready_to_buy=True\n    \n",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": "))\n    g.seller=None\n    g.ready_to_buy=True\n    \n    \n## 开盘前运行函数     \ndef before_trading_start(context):\n    # 输出运行时间\n    # log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    g.QF.before_market_open(context)\n    if g.seller is not None:\n        g.seller.before_market_open(context)\n\n \n## 收盘后运行函数  \ndef after_trading_end(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    g.QF.after_market_close(context)\n    # log.info(g.real_check.to_string())",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": "(context)\n    # log.info(g.real_check.to_string())\n    \n    if not g.ready_to_buy:\n        orders = get_orders()\n        order_successful=False\n        for order in orders.values():\n            if order.security == g.security and order.is_buy and order.status in [OrderStatus.filled,OrderStatus.canceled,OrderStatus.rejected,OrderStatus.held] and order.filled>0:\n                g.seller = bot_seller.MonkeySeller(g.security, order.price, order.filled,stop_loss=0.04,moving_stop_loss=0.03)\n                order_",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": "0.04,moving_stop_loss=0.03)\n                order_successful=True\n        if not order_successful:\n            g.ready_to_buy=True\n            \n    if g.seller is not None:\n        g.seller.after_market_close(context)\n    \ndef handle_tick(context, tick):\n    g.QF.handle_tick(context,tick)\n    if g.ready_to_buy:\n        buy(context)\n    if g.seller is not None and g.seller.handle_tick(context,tick):\n        sell(context)\n        \ndef buy(context):\n    if g.QF.check():\n        accer=ACCER(g.security, check_da",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": ".check():\n        accer=ACCER(g.security, check_date=context.previous_date.strftime('%Y-%m-%d'), N = g.N)\n        if accer[g.security]<-0.01:\n            # 记录这次买入\n            log.info(str('买入下单时间:' + str(context.current_dt)))\n            # 用所有 cash 买入股票\n            order_value(g.security, context.portfolio.available_cash)\n    \n            g.ready_to_buy=False\n\n\ndef sell(context):\n    # 记录这次卖出\n    log.info(str('卖出下单时间:' + str(context.current_dt)+'    卖出理由：'+g.seller.sell_reason()))\n    # 卖出所有股票,使这只股票的最终持有量为0",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": ".seller.sell_reason()))\n    # 卖出所有股票,使这只股票的最终持有量为0\n    order_target(g.security, 0)\n    g.ready_to_buy=True\n    g.seller=None    \n    \n    \n    ",
        "source": "99策略代码/40 kdj指标配合accer过滤.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13402\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801110\",\"801120\",\"801150\",\"801200\",\"801210\",\"801750\",\"801780\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "y_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.op",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "ntext):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n#",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.che",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "ntext, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in b",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "##\n        buy_lists = [security for security in buy_lists if MA_judge_duotou(security, 8, 89)]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": " # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financia",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": " ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 3)\n    security_list = financial_data_filter_dayu(security_list, indicator.operation_profit_to_total_revenue, 3)\n    security_list = financial_data_filter_dayu(security_list, valuation.circulating_market_cap, 3)\n    security_list = financial_data_filter_dayu(security_list, valuation.capitalization, 5)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_fi",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "  return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    security_list = [security for security in security_list if ipo_days_dayu(context, security, 600)]\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "ter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    #",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "##\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if MA_judge_kongtou(security, 8, 89)]\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for sto",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "  # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_li",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "agement:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n          ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "x_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef c",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "# 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n  ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "s()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "ent_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "se_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n   ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "ndustry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    ",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "cept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/32 测试策略1.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13969\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000001.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "k_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_dail",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ly(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000002.XSHG\"]\n    g.security_universe_use",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ndex = [\"000002.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_managemen",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "rue\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.op",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": ", 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n  ",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "rse_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "xt, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dic",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ck_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "     # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "sh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(c",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "###\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 25)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 20)\n    security_list = financial_data_filter_dayu(security_list, indicator.operation_profit_to_total_revenue, 4)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "on_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n ",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "olio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# ",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ecurity_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_list",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_valu",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.Dat",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "put_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ding = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "lse\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            ",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "l)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_li",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "   security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list i",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "ecurity_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for ",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "rse_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        re",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "n(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": " return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/87 选股策略说明——张燕兰 16318320.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11103\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n#发布自聚宽社区\n\nimport talib\nimport pandas as pd\nimport numpy as np\nimport math\nfrom sklearn.svm import SVR  \nfrom sklearn.model_selection import GridSearchCV  \nfrom sklearn.model_selection import learning_curve\n\n\ndef initialize(context):\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.000, open_commission=0.0000, close_commission=0.0000, min_commission=0",
        "source": "99策略代码/91 Stoch（KDJ）——大盘择时.txt"
    },
    {
        "text": "=0.0000, close_commission=0.0000, min_commission=0), type='stock')\n    # 设定滑点为固定值\n    set_slippage(FixedSlippage(0.00))\n    \n    # 定义一个全局变量, 保存要操作的证券                                                                                           \n    context.stocks = ['399300.XSHE']\n    # 设置我们要操作的股票池\n    set_universe(context.stocks)\n\n    \n# 初始化此策略\ndef handle_data(context, data):\n    # 取得当前的现金\n    cash = context.portfolio.cash\n    # 循环股票列表\n    for stock in context.stocks:\n        # 获取股票的数据\n        h = attribute_hi",
        "source": "99策略代码/91 Stoch（KDJ）——大盘择时.txt"
    },
    {
        "text": "stocks:\n        # 获取股票的数据\n        h = attribute_history(stock, 60, '1d', ('high','low','close'))\n        # 创建STOCH买卖信号，包括最高价，最低价，收盘价和快速线（一般取为9），慢速线\n        # 注意：STOCH函数使用的price必须是narray\n        slowk, slowd = talib.STOCH(h['high'].values,h['low'].values,h['close'].values,\n                                            fastk_period=17,slowk_period=9,\n                                            slowk_matype=0,slowd_period=7,slowd_matype=0)\n        # 获得最近的kd值\n        \n        print(slowk)\n        # print(slowk[-6",
        "source": "99策略代码/91 Stoch（KDJ）——大盘择时.txt"
    },
    {
        "text": "    \n        print(slowk)\n        # print(slowk[-6:-1])\n        # MA_stoch_5 = slowk[-5:].mean()\n        \n        # print(MA_stoch_5)\n        # MA_stoch_now=slowk[-1]\n        # 获取当前股票的数据\n        current_position = context.portfolio.positions[stock].amount\n        # 获取当前股票价格\n        current_price = data[stock].price\n        # 当slowk > 90 or slowd > 90，且拥有的股票数量>=0时，卖出所有股票\n        if (slowk[-1] < 80 and slowk[-2] > 80 and current_position >= 0) or (slowk[-1] > 20 and slowk[-1] < 80 and slowk[-1] < slowd[-1] an",
        "source": "99策略代码/91 Stoch（KDJ）——大盘择时.txt"
    },
    {
        "text": "20 and slowk[-1] < 80 and slowk[-1] < slowd[-1] and current_position >= 0):\n            order_target(stock, 0)\n        # 当slowk < 10 or slowd < 10, 且拥有的股票数量<=0时，则全仓买入\n        elif (slowk[-1] > 20 and slowk[-2] < 20 and current_position <= 0) or (slowk[-1] > 20 and slowk[-1] > 80 and slowk[-1] > slowd[-1] and current_position <= 0):\n            # 买入股票\n            order_value(stock, cash)\n            # 记录这次买入\n            log.info(\"Buying %s\" % (stock))\n",
        "source": "99策略代码/91 Stoch（KDJ）——大盘择时.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14449\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入聚宽函数库\nimport jqdata\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 通过模型预测2017-05-13 到 2018-03-24的收盘价格\n    context.labels = [3484.4731,3419.8232,3405.0974,3417.4797,3433.4858,3396.5896,3391.5007,3423.003,3421.6697,3465.112,3471.467,3465.7864,3487.3418,3491.7178,3546.959,3436.56,3514.53,3529.1199,3557.9495,3601.758,3541.025,3491.9634,3536.0886,3536.858,3547.974,3528.3457,3542.721,3578.8118,3650",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "536.858,3547.974,3528.3457,3542.721,3578.8118,3650.272,3683.9583,3663.6384,3694.049,3699.703,3662.5566,3607.9272,3622.7446,3611.0764,3639.1382,3616.0864,3664.207,3621.2336,3639.712,3707.037,3601.1592,3597.3801,3699.4297,3723.4106,3726.5364,3743.6357,3741.419,3706.606,3683.4072,3748.0212,3733.877,3769.4783,3748.6301,3744.3965,3713.9695,3733.689,3742.2969,3683.7659,3691.0076,3593.5571,3709.6367,3742.3257,3708.5461,3717.597,3745.0974,3761.5957,3754.7583,3776.6123,3761.9675,3735.6716,3799.6272,3764.0454,3800.44",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "23,3761.9675,3735.6716,3799.6272,3764.0454,3800.448,3830.6057,3815.3823,3863.0005,3908.6187,3810.4922,3817.296,3846.0645,3825.2102,3788.061,3874.5283,3854.4138,3820.1802,3850.1833,3858.4153,3857.99,3847.9673,3850.671,3825.7795,3836.8047,3834.4863,3835.9675,3838.4946,3866.0347,3879.392,3895.466,3906.8342,3914.512,3939.9197,3906.9272,3936.1904,3934.7993,3902.4858,3918.806,3951.7837,3966.8457,4007.3047,4015.1685,4024.8362,4025.7075,4017.6519,4003.1348,3986.678,4004.0417,4041.1533,4079.7434,4088.711,4160.403,41",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "4004.0417,4041.1533,4079.7434,4088.711,4160.403,4160.6655,4145.7754,4104.3496,4112.224,4167.823,4125.745,4262.363,4285.2695,4177.9688,4153.7603,4104.226,4033.8774,4081.047,4040.2146,4026.65,4024.3823,4071.1711,4007.6072,3994.592,4024.8647,4094.205,4038.3335,4040.5596,4036.214,4008.3818,3997.3276,4016.4563,4036.231,4076.2664,4043.742,4079.1006,4068.2737,4041.2944,4060.8088,4032.3176,4079.996,4142.461,4081.8547,4164.163,4211.9136,4179.7275,4208.5596,4199.5635,4216.003,4306.757,4294.753,4307.5894,4276.661,4303",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "4216.003,4306.757,4294.753,4307.5894,4276.661,4303.402,4321.5454,4375.543,4401.335,4366.192,4352.632,4368.7324,4271.167,4283.705,4230.268,4257.1523,4299.1123,4228.6143,4157.212,4082.6318,3922.8433,3931.488,3972.2476,3888.1587,4036.5857,4044.2336,4151.31,4116.5684,4052.486,4041.2666,4024.7532,4014.3164,4079.2344,4044.7148,4038.3608,4129.4355,4178.1733,4108.99,4090.9297,4088.3188,4071.6282,4079.1306,4063.0908,4103.768,4068.3186,3979.124,3865.6921,3936.0256,3869.5344,3906.2402,3898.3296,3917.3855,3856.9749,387",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "9.5344,3906.2402,3898.3296,3917.3855,3856.9749,3877.4792,3846.8347,3943.2932,3960.0173,3897.677,3877.7727,3852.6196,3791.1196,3766.4897,3795.0635,3783.1785,3768.4807,3812.6948,3816.6575,3771.9333,3743.5732,3753.6853,3776.6038,3763.3572,3820.007,3878.4482,3826.642,3859.9102,3865.516,3908.1729,3892.5042,3886.5645,3840.99,3892.7214,3937.22,3888.6008,3871.1763,3814.2075,3804.7695,3816.1355,3815.977,3740.9553,3784.1594,3760.4597,3787.7817,3813.8044,3811.6921,3827.662,3775.4116,3760.547,3809.9937,3765.7212,3763.5",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": ".662,3775.4116,3760.547,3809.9937,3765.7212,3763.5486,3764.579,3660.5212,3564.6982,3605.7383,3592.9866,3589.3928,3494.2688,3489.3257,3437.5164,3493.3125,3437.318,3355.9753,3408.8022,3466.5505,3404.5852,3445.302,3472.906,3414.7698,3429.539,3479.1172,3484.4563,3474.8198,3472.6768,3462.7024,3408.558,3450.1145,3544.4707,3579.5774,3568.074,3595.3762,3544.1062,3587.7869,3509.163,3462.2117,3410.8735,3377.351,3367.894,3388.9998,3370.033,3433.4487,3389.0122,3431.4001,3385.0483,3356.17,3354.9207,3356.1194,3361.0208,3",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": ",3385.0483,3356.17,3354.9207,3356.1194,3361.0208,3404.1577,3381.7974,3389.3867,3368.8357,3396.3364,3416.04]\n    # 定义一个全局变量, 保存要操作的股票\n    # 沪深300\n    g.security = '399300.XSHE'\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 运行函数\n    run_daily(market_open, time='every_bar')\n    # context.labels 数据的读取位置记录\n    context.index  =0\n    # 存储上一周期预测值\n    context.pr_predict_value = 0\n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef market_open(contex",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef market_open(context):\n    security = g.security\n    # 获取股票的收盘价\n    close_data = attribute_history(security, 5, '1d', ['close'])\n    # 取得上一时间点价格\n    current_price = close_data['close'][-1]\n    # 取得当前的现金\n    cash = context.portfolio.cash\n    # 获取当天预测的收盘价\n    predict_value = context.labels[context.index]\n    # 获取当天的误差率\n    error = abs(predict_value-current_price)/current_price\n    # 上一周期预测值初始值\n    if context.pr_predict_value == 0:\n        context.pr_predict_value = current_price",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": ":\n        context.pr_predict_value = current_price\n    # 当前预测的值 大于 上一周期预测的收盘价 则买入\n    if predict_value>context.pr_predict_value:\n        order_value(security, cash)\n        log.info(\"Buying %s\" % (security))\n    else:\n    #负责进行卖出\n        order_target(security, 0)\n        log.info(\"Selling %s\" % (security))\n    # 对预测的收盘价进行缓存\n    context.pr_predict_value = predict_value\n    # 指向下一个预测收盘价的数据位置\n    context.index = context.index+1\n   ",
        "source": "99策略代码/30 基于LSTM模型预测股票价格走势.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11964\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 2\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'asc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded ",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "y_initialize():\n    # 是否可重复买入\n    g.filter_holded = True\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in cont",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "ties))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.c",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "ck_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "st)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_l",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": " pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n ",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in buy_lists if MA_judge_jincha(security, 5, 10)]\n        ### _入场函数筛",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "_judge_jincha(security, 5, 10)]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_secur",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filte",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "eturn security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    security_list = [security for security in security_list if MA_judge_jincha(security, 5, 10)]\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "ext, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if MA_judge_sicha(security, 5, 10)]\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "   if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = hold",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "       return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "cknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stock",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "############################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": " 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "     return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "f len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock ",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "t_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in s",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "st):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n    ",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": " == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/90 MA均线金叉买入，死叉卖出.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13065\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/10272\n# 标题：【量化课堂】RSRS(阻力支撑相对强度)择时策略（下）\n# 作者：JoinQuant量化课堂\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/10246\n# 标题：【量化课堂】RSRS(阻力支撑相对强度)择时策略（下）\n# 作者：JoinQuant量化课堂\n\n# 导入函数库\nimport statsmodels.api as sm\nfrom pandas.stats.api import ols\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定上证指数作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "HG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      ",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n\n    # 设置RSRS指标中N, M的值\n    g.N = 18\n    g.M = 1100\n    g.init = True\n    \n    # 要操作的股票：平安银行（g.为全局变量）\n    g.security = '160706.XSHE'\n    \n    # 买入阈值\n    g.buy = 0.7\n    g.sell ",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": ".XSHE'\n    \n    # 买入阈值\n    g.buy = 0.7\n    g.sell = -0.7\n    g.ans = []\n    g.ans_rightdev= []\n    \n    # 计算2005年1月5日至回测开始日期的RSRS斜率指标\n    prices = get_price(g.security, '2005-01-05', context.previous_date, '1d', ['high', 'low'])\n    highs = prices.high\n    lows = prices.low\n    g.ans = []\n    for i in range(len(highs))[g.N:]:\n        data_high = highs.iloc[i-g.N+1:i+1]\n        data_low = lows.iloc[i-g.N+1:i+1]\n        X = sm.add_constant(data_low)\n        model = sm.OLS(data_high,X)\n        results = model.",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "del = sm.OLS(data_high,X)\n        results = model.fit()\n        g.ans.append(results.params[1])\n        #计算r2\n        g.ans_rightdev.append(results.rsquared)\n        \n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message('美好的一天~')\n\n    \n## 开盘时运行函数\ndef market_open(context):\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    security = g.security\n    # 取得",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "ent_dt.time()))\n    security = g.security\n    # 取得当前的现金\n    cash = context.portfolio.available_cash\n\n    # 填入各个日期的RSRS斜率值\n\n    security = g.security\n    beta=0\n    r2=0\n    \n    if g.init:\n        g.init = False\n    else:\n        # RSRS斜率指标定义\n        prices = attribute_history(security, g.N, '1d', ['high','low','volume'])\n        highs = prices.high\n        lows = prices.low\n        \n        X = sm.add_constant(lows)\n        model = sm.OLS(highs, X)\n        beta = model.fit().params[1]\n        g.ans.append(",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "beta = model.fit().params[1]\n        g.ans.append(beta)\n        #计算r2\n        r2=model.fit().rsquared\n        g.ans_rightdev.append(r2)\n    # 计算标准化的RSRS指标\n    # 计算均值序列 \n\n    h = attribute_history(security,g.N, '1d', ['volume'])\n    volume=h.volume\n    #cut = g.ans[-g.M:]\n    #section=[cut[i]*(volume[i]/sum(volume)*g.N) for i in range(g.N)]\n    section = g.ans[-g.M:]\n    # 计算均值序列\n    mu = np.mean(section)\n    # 计算标准化RSRS指标序列\n    sigma = np.std(section)\n    zscore = (section[-1]-mu)/sigma  \n    #计算右偏RSRS标准分\n ",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "core = (section[-1]-mu)/sigma  \n    #计算右偏RSRS标准分\n    #zscore_rightdev= zscore*beta*r2\n    #zscore_rightdev= zscore*(sum(volume[-1])/sum(volume)*g.N)\n    zscore_rightdev= zscore*beta*r2*(sum(volume[-9:])/sum(volume)*g.N/len(volume[-9:]))\n    print(zscore_rightdev)\n    # 如果上一时间点的RSRS斜率大于买入阈值, 则全仓买入\n    if zscore_rightdev > g.buy:\n        # 记录这次买入\n        log.info(\"标准化RSRS斜率大于买入阈值, 买入 %s\" % (security))\n        # 用所有 cash 买入股票\n        order_value(security, cash)\n    # 如果上一时间点的RSRS斜率小于卖出阈值, 则空仓卖出\n    elif zscore",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "\n    # 如果上一时间点的RSRS斜率小于卖出阈值, 则空仓卖出\n    elif zscore_rightdev < g.sell and context.portfolio.positions[security].closeable_amount > 0:\n        # 记录这次卖出\n        log.info(\"标准化RSRS斜率小于卖出阈值, 卖出 %s\" % (security))\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(security, 0)\n \n## 收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade)",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "des.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')",
        "source": "99策略代码/77 RSRS大盘择时优化.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13017\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/6596\n# 标题：【新手入门教程】简单市值轮动策略\n# 作者：JoinQuant-TWist\n\ndef initialize(context):\n    g.stocksnum = 10 # 持有最小市值股票数\n    g.period = 10 # 轮动频率\n    run_daily(daily,time='every_bar')# 周期循环daily\n    g.days = 1 # 记录策略进行到第几天，初始为1\n\ndef daily(context):\n    # 判断策略进行天数是否能被轮动频率整除余1\n    if g.days % g.period == 1:\n\n        # 获取当前时间\n        date=context.current_dt.strftime(\"%Y-%m-%d\")\n ",
        "source": "99策略代码/59 小市值轮动，修改了内容，剔除了停牌股，同时PE要求为正的股票。.txt"
    },
    {
        "text": "    date=context.current_dt.strftime(\"%Y-%m-%d\")\n        # 获取上证指数和深证综指的成分股代码并连接，即为全A股市场所有股票\n        scu = get_index_stocks('000001.XSHG')+get_index_stocks('399106.XSHE')\n         # 得到是否停牌信息的dataframe，停牌的1，未停牌得0\n        suspened_info_df = get_price(list(scu), start_date=context.current_dt, end_date=context.current_dt, frequency='daily', fields='paused')['paused'].T\n         # 过滤停牌股票 返回dataframe\n        unsuspened_index = suspened_info_df.iloc[:,0]<1\n         # 得到当日未停牌股票的代码list:\n        unsuspened_stocks = su",
        "source": "99策略代码/59 小市值轮动，修改了内容，剔除了停牌股，同时PE要求为正的股票。.txt"
    },
    {
        "text": "# 得到当日未停牌股票的代码list:\n        unsuspened_stocks = suspened_info_df[unsuspened_index].index\n        # 选出在scu内的股票的股票代码，并按照当前时间市值从小到大排序,剔除PE为负值得股票\n        df = get_fundamentals(query(\n                valuation.code,valuation.market_cap,valuation.pe_ratio\n            ).filter(\n                valuation.code.in_(unsuspened_stocks), valuation.pe_ratio>1\n            ).order_by(\n                valuation.market_cap.asc()\n            ), date=date\n            )\n\n        # 取出前g.stocksnum名的股票代码，并转成list类型，buylist为选中的股票\n  ",
        "source": "99策略代码/59 小市值轮动，修改了内容，剔除了停牌股，同时PE要求为正的股票。.txt"
    },
    {
        "text": " # 取出前g.stocksnum名的股票代码，并转成list类型，buylist为选中的股票\n        buylist =list(df['code'][:g.stocksnum])\n\n        # 对于每个当下持有的股票进行判断：现在是否已经不在buylist里，如果是则卖出\n        for stock in context.portfolio.positions:\n            if stock not in buylist: #如果stock不在buylist\n                order_target(stock, 0) #调整stock的持仓为0，即卖出\n\n        # 将资金分成g.stocksnum份\n        position_per_stk = context.portfolio.cash/g.stocksnum\n        # 用position_per_stk大小的g.stocksnum份资金去买buylist中的股票\n        for stock in buylist:\n            order_value(",
        "source": "99策略代码/59 小市值轮动，修改了内容，剔除了停牌股，同时PE要求为正的股票。.txt"
    },
    {
        "text": "    for stock in buylist:\n            order_value(stock, position_per_stk)\n    else:\n        pass # 什么也不做\n\n    g.days = g.days + 1 # 策略经过天数增加1",
        "source": "99策略代码/59 小市值轮动，修改了内容，剔除了停牌股，同时PE要求为正的股票。.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15002\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n'''\n策略思路：\n选股：财务指标选股\n择时：RSRS择时\n持仓：有开仓信号时持有10只股票，不满足时保持空仓\n\n'''\n# 导入函数库\nimport statsmodels.api as sm\nfrom pandas.stats.api import ols\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    set_parameter(context)\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "# 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    #run_daily(after_marke",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "00.XSHG')\n      # 收盘后运行\n    #run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n    \n'''\n==============================参数设置部分================================\n'''\ndef set_parameter(context):\n    # 设置RSRS指标中N, M的值\n    #统计周期\n    g.N = 18\n    #统计样本长度\n    g.M = 1100\n    #首次运行判断\n    g.init = True\n    #持仓股票数\n    g.stock_num = 10\n    #风险参考基准\n    g.security = '000300.XSHG'\n    # 设定策略运行基准\n    set_benchmark(g.security)\n    #记录策略运行天数\n    g.days = 0\n    #set_benchmark(g.stock)\n    # 买入阈值",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": " g.days = 0\n    #set_benchmark(g.stock)\n    # 买入阈值\n    g.buy = 0.7\n    g.sell = -0.7\n    #用于记录回归后的beta值，即斜率\n    g.ans = []\n    #用于计算被决定系数加权修正后的贝塔值\n    g.ans_rightdev= []\n    \n    # 计算2005年1月5日至回测开始日期的RSRS斜率指标\n    prices = get_price(g.security, '2005-01-05', context.previous_date, '1d', ['high', 'low'])\n    highs = prices.high\n    lows = prices.low\n    g.ans = []\n    for i in range(len(highs))[g.N:]:\n        data_high = highs.iloc[i-g.N+1:i+1]\n        data_low = lows.iloc[i-g.N+1:i+1]\n        X = sm.add_cons",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "w = lows.iloc[i-g.N+1:i+1]\n        X = sm.add_constant(data_low)\n        model = sm.OLS(data_high,X)\n        results = model.fit()\n        g.ans.append(results.params[1])\n        #计算r2\n        g.ans_rightdev.append(results.rsquared)\n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    #log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    g.days += 1\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message('策略正常，运行第%s天~'%g.days)\n\n## 开盘时运行函数\ndef market_open(context):\n    security",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "\n## 开盘时运行函数\ndef market_open(context):\n    security = g.security\n    # 填入各个日期的RSRS斜率值\n    beta=0\n    r2=0\n    if g.init:\n        g.init = False\n    else:\n        #RSRS斜率指标定义\n        prices = attribute_history(security, g.N, '1d', ['high', 'low'])\n        highs = prices.high\n        lows = prices.low\n        X = sm.add_constant(lows)\n        model = sm.OLS(highs, X)\n        beta = model.fit().params[1]\n        g.ans.append(beta)\n        #计算r2\n        r2=model.fit().rsquared\n        g.ans_rightdev.append(r2)\n ",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "fit().rsquared\n        g.ans_rightdev.append(r2)\n    \n    # 计算标准化的RSRS指标\n    # 计算均值序列    \n    section = g.ans[-g.M:]\n    # 计算均值序列\n    mu = np.mean(section)\n    # 计算标准化RSRS指标序列\n    sigma = np.std(section)\n    zscore = (section[-1]-mu)/sigma  \n    #计算右偏RSRS标准分\n    zscore_rightdev= zscore*beta*r2\n    \n    # 如果上一时间点的RSRS斜率大于买入阈值, 则全仓买入\n    if zscore_rightdev > g.buy:\n        # 记录这次买入\n        log.info(\"市场风险在合理范围\")\n        #满足条件运行交易\n        trade_func(context)\n    # 如果上一时间点的RSRS斜率小于卖出阈值, 则空仓卖出\n    elif (zscore_ri",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": " # 如果上一时间点的RSRS斜率小于卖出阈值, 则空仓卖出\n    elif (zscore_rightdev < g.sell) and (len(context.portfolio.positions.keys()) > 0):\n        # 记录这次卖出\n        log.info(\"市场风险过大，保持空仓状态\")\n        # 卖出所有股票,使这只股票的最终持有量为0\n        for s in context.portfolio.positions.keys():\n            order_target(s, 0)\n            \n#策略选股买卖部分    \ndef trade_func(context):\n    #获取股票池\n    df = get_fundamentals(query(valuation.code,valuation.pb_ratio,indicator.roe))\n    #进行pb,roe大于0筛选\n    df = df[(df['roe']>0) & (df['pb_ratio']>0)].sort('pb_ratio')",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "f['roe']>0) & (df['pb_ratio']>0)].sort('pb_ratio')\n    #以股票名词作为index\n    df.index = df['code'].values\n    #取roe倒数\n    df['1/roe'] = 1/df['roe']\n    #获取综合得分\n    df['point'] = df[['pb_ratio','1/roe']].rank().T.apply(f_sum)\n    #按得分进行排序，取指定数量的股票\n    df = df.sort('point')[:g.stock_num]\n    pool = df.index\n    log.info('总共选出%s只股票'%len(pool))\n    #得到每只股票应该分配的资金\n    cash = context.portfolio.total_value/len(pool)\n    #获取已经持仓列表\n    hold_stock = context.portfolio.positions.keys() \n    #卖出不在持仓中的股票\n    for s in hold_st",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "tions.keys() \n    #卖出不在持仓中的股票\n    for s in hold_stock:\n        if s not in pool:\n            order_target(s,0)\n    #买入股票\n    for s in pool:\n        order_target_value(s,cash)\n#打分工具\ndef f_sum(x):\n    return sum(x)\n        \n## 收盘后运行函数  \ndef after_market_close(context):\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    #打印账户总资产\n    log.info('今日账户总资产：%s'%round(context.portfolio.total_value,2))\n    #log.info('###################################",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "    #log.info('##############################################################')\n",
        "source": "99策略代码/05 兄台且慢，去天台排队不如看看这个策略先.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13848\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport talib\nfrom prettytable import PrettyTable \nimport pandas \nimport datetime\nimport time\nfrom jqdata import *\n\ndef initialize(context):\n    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))\n    set_option('use_real_price', True)\n    set_benchmark('000300.XSHG')\n    log.set_level('order', 'error')\n    log.set_level('history', 'error')\n    g.buy_stock_count = 1\n    g.hour = 9\n   ",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "ror')\n    g.buy_stock_count = 1\n    g.hour = 9\n    g.minute = 30\n    \ndef handle_data(context, data):\n    hour = context.current_dt.hour\n    minute = context.current_dt.minute\n    buy_stocks = []\n    if hour == g.hour and minute == g.minute:\n        buy_stocks = select_stocks(context,data)\n        print '前一个交易日港资（北向资金）净买额最高的股票：\\n'\n        for stock in buy_stocks:\n            print show_stock(stock)\n        adjust_position(context, buy_stocks)\n        print get_portfolio_info_text(context,buy_stocks)\n       ",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "et_portfolio_info_text(context,buy_stocks)\n        \ndef select_stocks(context,data):\n    date = context.current_dt.strftime(\"%Y-%m-%d\")\n    today = datetime.datetime.strptime(date, \"%Y-%m-%d\").date()\n    yesterday = shifttradingday(today ,shift = -1)\n    print '前一个交易日:',yesterday \n    q = query(finance.STK_EL_TOP_ACTIVATE).filter(finance.STK_EL_TOP_ACTIVATE.day == yesterday )\n    df = finance.run_query(q)\n    df['net'] = df.buy - df.sell\n    df = df.sort(columns = ['net'] , axis = 0, ascending = False)\n    ",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "umns = ['net'] , axis = 0, ascending = False)\n    df = df[(df.link_id != 310003 ) & (df.link_id != 310004 )]\n    stock_list = list(df['code'])\n    # 过滤掉停牌的和ST的\n    #stock_list = filter_paused_and_st_stock(stock_list)\n    #过滤掉创业板\n    #stock_list = filter_gem_stock(context, stock_list)\n    # 过滤掉上市超过1年的\n    #stock_list = filter_old_stock(context, stock_list)\n    # 过滤掉现在涨停或者跌停的\n    #stock_list = filter_limit_stock(context, stock_list)\n    #stock_list = filter_limit_stock(context, data, stock_list)\n    #选取前N只股票放",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "mit_stock(context, data, stock_list)\n    #选取前N只股票放入“目标股票池”\n    stock_list = stock_list[:g.buy_stock_count]  \n    return stock_list\n        \ndef filter_paused_and_st_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list if not current_data[stock].paused \n    and not current_data[stock].is_st and 'ST' not in current_data[stock].\n    name and '*' not in current_data[stock].name and '退' not in current_data[stock].name]\n    \ndef filter_gem_stock(context, stock_list):\n",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "]\n    \ndef filter_gem_stock(context, stock_list):\n    return [stock for stock in stock_list  if stock[0:3] != '300']\n\ndef filter_old_stock(context, stock_list):\n    tmpList = []\n    for stock in stock_list :\n        days_public=(context.current_dt.date() - get_security_info(stock).start_date).days\n        # 上市未超过1年\n        if  days_public < 365 :\n            tmpList.append(stock)\n    return tmpList\n    \ndef filter_limit_stock(context, data, stock_list):\n    tmpList = []\n    current_data = get_current_data()",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "tmpList = []\n    current_data = get_current_data()\n    for stock in stock_list:\n        # 未涨停，也未跌停\n        if (data[stock].low_limit < data[stock].close < data[stock].high_limit) and (current_data[stock].low_limit < data[stock].close < current_data[stock].high_limit):\n            tmpList.append(stock)\n    return tmpList\n    \ndef adjust_position(context, buy_stocks):\n    # 现持仓的股票，如果不在“目标池”中，且未涨停，就卖出\n    if len(context.portfolio.positions)>0:\n        last_prices = history(1, '1m', 'close', security_list=conte",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "es = history(1, '1m', 'close', security_list=context.portfolio.positions.keys())\n        for stock in context.portfolio.positions.keys():\n            if stock not in buy_stocks :\n                curr_data = get_current_data()\n                if last_prices[stock][-1] < curr_data[stock].high_limit:\n                    order_target_value(stock, 0)\n    # 依次买入“目标池”中的股票            \n    for stock in buy_stocks:\n        position_count = len(context.portfolio.positions)\n        if g.buy_stock_count > position_count",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "ons)\n        if g.buy_stock_count > position_count:\n            value = context.portfolio.cash / (g.buy_stock_count - position_count)\n            if context.portfolio.positions[stock].total_amount == 0:\n                order_target_value(stock, value)\n                \ndef shifttradingday(date,shift):\n    #获取N天前的交易日日期\n    # 获取所有的交易日，返回一个包含所有交易日的 list,元素值为 datetime.date 类型.\n    tradingday = get_all_trade_days()\n    # 得到date之后shift天那一天在列表中的行标号 返回一个数\n    shiftday_index = list(tradingday).index(date)+shift\n    #",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "y_index = list(tradingday).index(date)+shift\n    # 根据行号返回该日日期 为datetime.date类型\n    return tradingday[shiftday_index]\n\ndef show_stock(stock):\n    '''\n    获取股票代码的显示信息    \n    :param stock: 股票代码，例如: '603822.SH'\n    :return: str，例如：'603822 嘉澳环保'\n    '''\n    return u\"%s %s\" % (stock[:6], get_security_info(stock).display_name)\n    \ndef get_portfolio_info_text(context,new_stocks,op_sfs=[0]):\n    # new_stocks是需要持仓的股票列表\n    sub_str = ''\n    table = PrettyTable([\"仓号\",\"股票\", \"持仓\", \"当前价\", \"盈亏率\",\"持仓比\"])  \n    for sf_id i",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "\"股票\", \"持仓\", \"当前价\", \"盈亏率\",\"持仓比\"])  \n    for sf_id in range(len(context.subportfolios)):\n        cash = context.subportfolios[sf_id].cash\n        p_value = context.subportfolios[sf_id].positions_value\n        total_values = p_value +cash\n        if sf_id in op_sfs:\n            sf_id_str = str(sf_id) + ' *'\n        else:\n            sf_id_str = str(sf_id)\n        for stock in context.subportfolios[sf_id].long_positions.keys():\n            position = context.subportfolios[sf_id].long_positions[stock]\n          ",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "portfolios[sf_id].long_positions[stock]\n            if sf_id in op_sfs and stock in new_stocks:\n                stock_str = show_stock(stock) + ' *'\n            else:\n                stock_str = show_stock(stock)\n            stock_raite = (position.total_amount * position.price) / total_values * 100\n            table.add_row([sf_id_str,\n                stock_str,\n                position.total_amount,\n                position.price,\n                \"%.2f%%\"%((position.price - position.avg_cost) / position.a",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "((position.price - position.avg_cost) / position.avg_cost * 100), \n                \"%.2f%%\"%(stock_raite)]\n                )\n        if sf_id < len(context.subportfolios) - 1:\n            table.add_row(['----','---------------','-----','----','-----','-----'])\n        sub_str += '[仓号: %d] [总值:%d] [持股数:%d] [仓位:%.2f%%] \\n'%(sf_id,\n            total_values,\n            len(context.subportfolios[sf_id].long_positions)\n            ,p_value*100/(cash+p_value))\n    print '子仓详情:\\n' + sub_str + str(table)\n",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": " print '子仓详情:\\n' + sub_str + str(table)\n",
        "source": "99策略代码/73 跟着港资（北向资金）买A股.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13162\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport numpy as np\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    set_slippage(FixedSlippage(0.02))\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是",
        "source": "99策略代码/52 布林带1.txt"
    },
    {
        "text": "0.02))\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n   \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='00",
        "source": "99策略代码/52 布林带1.txt"
    },
    {
        "text": "_close, time='after_close', reference_security='000300.XSHG')\n    \n\n    \n## 开盘时运行函数\ndef market_open(context):\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    security ='600519.XSHG'\n    # 获取股票的收盘价\n    price= attribute_history(security, 20, '1d', ['close'],skip_paused=True)\n    \n    #获取可以现金\n    \n    cash=context.portfolio.available_cash\n    \n    #获取当前仓位信息   \n    current_position=context.portfolio.positions[security].closeable_amount\n    \n    # 可以运用numpy自带的函数计算过去20日的移动平均线作为中轨\n    mid=n",
        "source": "99策略代码/52 布林带1.txt"
    },
    {
        "text": "  \n    # 可以运用numpy自带的函数计算过去20日的移动平均线作为中轨\n    mid=np.mean(price)\n    \n    #可以运用numpy自带函数计算昨日20日的标准差\n    std=np.std(price)\n    \n    #用upper保存昨日上轨线\n    upper=mid+2*std\n    \n    #用lower保存昨日下轨线\n    lower=mid-2*std\n    \n    #获取当前收盘价\n    p=price['close'][-1]\n    \n    if p>upper[-1] and current_position<=0:\n        order_value(security, cash)\n    elif p<lower[-1] and current_position>=0:\n        order_target_value(security,0)\n   \n \n## 收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_",
        "source": "99策略代码/52 布林带1.txt"
    },
    {
        "text": "e(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n",
        "source": "99策略代码/52 布林带1.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13364\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 5\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 10\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_tra",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "eck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n  ",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "   run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securiti",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "er_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_univers",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "ext, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # ",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "atements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.chec",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lis",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "ntext, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "rade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financia",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "########################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognit",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "rn security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        valuation.market_cap:('asc',50),\n        }\n    # 返回结果\n    return input_dict\n\n##########################",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        f",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "   \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    ",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "sk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n    ",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "< g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "##  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,Fa",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "      # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return T",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "ity]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for st",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "ns.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "ata = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stoc",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "t_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities)",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == ",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "ist, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_lis",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "en(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/53 小市值策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/10747\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securitie",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "lio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.secu",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_fi",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_l",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "t_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "de_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 #####################",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "#####################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 200)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio, 35)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 10)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(c",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "rn security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    security_list = [security for security in security_list if MA_judge_duotou(security, 5, 20)]\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ###",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": ", security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_li",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": " 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "nt_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - le",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_prop",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) o",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "ending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = Tr",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, securit",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": " = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].nam",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "ta[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\n",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            t",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "t_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/70 蓝筹&均线.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13976\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "k_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_dail",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "ly(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\",\"000002.XSHG\",\"399106.XSHE\"]",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "ndex = [\"000300.XSHG\",\"000002.XSHG\",\"399106.XSHE\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801040\",\"801120\",\"801150\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize()",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    op",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "urities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(con",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤S",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "text, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_reco",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "   # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_r",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "  # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_ref",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "##\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = T",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "st_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_qujian(security_list, valuation.pe_ratio, (0,25))\n    security_list = financial_data_filter_qujian(securit",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "curity_list = financial_data_filter_qujian(security_list, valuation.pe_ratio_lyr, (0,25))\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 0)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_annual, 0)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_annual, 0)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 0)\n    security_list = fina",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "_revenue_year_on_year, 0)\n    security_list = financial_data_filter_dayu(security_list, valuation.circulating_cap, 1000)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 5)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "ity_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    retur",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n   ",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "   if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n           ",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "olio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ########################",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "##################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['scor",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": ",b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n    ",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": " = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfol",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "k in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list =",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "   current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n  ",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securiti",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in se",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "ies\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/60 投资期末作业.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14084\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\nfrom six import StringIO\nimport cPickle as pickle\nimport time\nimport datetime\nfrom multiprocessing.dummy import Pool as ThreadPool\nfrom jqfactor import Factor,calc_factors\nimport pandas as pd\nimport statsmodels.api as sm\nimport scipy.stats as st\nimport pickle\n# 初始化函数，设定基准等等\ndef initialize(context):\n    \n    g.index='000300.XSHG'\n    pkl_file_read = read_file(\"MyPackage_Final",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "HG'\n    pkl_file_read = read_file(\"MyPackage_Final.pkl\")\n    load_Package = pickle.load(StringIO(pkl_file_read))\n    g.univ_dict,g.ic_df,g.Effect_factor_dict=load_Package    \n    g.trade_date_list=sort(list(g.univ_dict.keys()))[:-1]\n    g.N=30\n    \n    set_benchmark(g.index)\n    set_option('use_real_price', True)\n    log.set_level('order', 'error')\n    set_order_cost(OrderCost(close_tax=0.001,open_commission=0.0003,close_commission=0.0003,min_commission=5),type='stock')\n    set_slippage(FixedSlippage(0))\n  ",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "ype='stock')\n    set_slippage(FixedSlippage(0))\n    \ndef before_trading_start(context):\n    g.trade_signal=False\n    #看是否在调仓日\n    date=context.current_dt.date()\n    if date in g.trade_date_list:\n        g.trade_signal=True\n\ndef handle_data(context,data):\n    # 如果今天不是调仓日，就洗洗睡\n    if g.trade_signal==False:\n        return\n    # 今天是调仓日，就是干！\n    date=context.current_dt.date()\n    ic=g.ic_df.loc[date,:]\n    \n    univ=g.univ_dict[date]\n    factor_df=pd.DataFrame()\n    for key,value in g.Effect_factor_dict.items():",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "    for key,value in g.Effect_factor_dict.items():\n        factor_df=factor_df.append(value.loc[date,univ].to_frame(key).T)\n    \n    stock_list=factor_df.multiply(ic,axis=0).sum().to_frame('a').sort('a',ascending=False).index[0:g.N]\n    holding_list=filter_specials(stock_list,context)\n    rebalance(context,holding_list)\n    \ndef filter_specials(stock_list,context):\n    current_data=get_current_data()\n    stock_list=[stock for stock in stock_list if \\\n                (not current_data[stock].paused)\n        ",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "         (not current_data[stock].paused)\n                and (not current_data[stock].is_st)\n                and ('ST' not in current_data[stock].name)\n                and ('*' not in current_data[stock].name)\n                and ('退' not in current_data[stock].name)\n                and (current_data[stock].low_limit<current_data[stock].day_open<current_data[stock].high_limit)\n                and get_security_info(stock).start_date<context.previous_date-datetime.timedelta(365)\n                ]\n    return ",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "etime.timedelta(365)\n                ]\n    return stock_list   \n    \ndef rebalance(context,holding_list):\n    every_stock = context.portfolio.portfolio_value/len(holding_list)  # 每只股票购买金额\n    # 空仓只有买入操作\n    if len(list(context.portfolio.positions.keys()))==0:\n        # 原设定重scort始于回报率相关打分计算，回报率是升序排列\n        for stock_to_buy in list(holding_list): \n            order_target_value(stock_to_buy,every_stock)\n    else :\n        # 不是空仓先卖出持有但是不在购买名单中的股票\n        for stock_to_sell in list(context.portfolio.positions.k",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "tock_to_sell in list(context.portfolio.positions.keys()):\n            if stock_to_sell not in list(holding_list):\n                order_target_value(stock_to_sell, 0)\n        # 因order函数调整为顺序调整，为防止先行调仓股票由于后行调仓股票占金额过大不能一次调整到位，这里运行两次以解决这个问题\n        for stock_to_buy in list(holding_list): \n            order_target_value(stock_to_buy, every_stock)\n        for stock_to_buy in list(holding_list): \n            order_target_value(stock_to_buy, every_stock)    \n    \n\n\n",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "\n",
        "source": "99策略代码/41 多因子模型（三）-交易回测.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11736\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/1810\n# 标题：【量化课堂】基于协整的搬砖策略\n# 作者：JoinQuant量化课堂\n\nimport numpy as np\nimport pandas as pd\n\n#===========================================\n\ndef initialize(context):\n    set_params()\n    set_variables()\n    set_backtest()\n\n# ---代码块1. 设置参数\ndef set_params():\n    # 股票1\n    g.security1 = '603288.XSHG' \n    # 股票2\n    g.security2 = '600036.XSHG'\n    # 基准\n    g.benchmark = '6000",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": "2 = '600036.XSHG'\n    # 基准\n    g.benchmark = '600036.XSHG'\n    # 回归系数\n    g.regression_ratio = 1.000#0.9574#0.9938\n    # 股票1默认仓位\n    g.p = 0.5\n    # 股票2默认仓位\n    g.q = 0.5\n    # 算z-score天数\n    g.test_days = 120\n\n# ---代码块2. 设置变量\ndef set_variables():\n    # 现在状态\n    g.state = 'empty'\n\n# ---代码块3. 设置回测\ndef set_backtest():\n    # 设置基准\n    set_benchmark(g.benchmark)\n    # 只报错\n    log.set_level('order', 'error')\n    # 真实价格\n    set_option('use_real_price', True) \n    # 无滑点\n    set_slippage(FixedSlippage(0.))\n\n#=======",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": " 无滑点\n    set_slippage(FixedSlippage(0.))\n\n#==============================================\n    \n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    new_state = get_signal()\n    change_positions(new_state,context)\n\n# ---代码块4.计算z-score\ndef z_test():\n    # 获取两支股票历史价格\n    prices1 = np.array(attribute_history(g.security1, g.test_days, '1d', ['close']).close)\n    prices2 = np.array(attribute_history(g.security2, g.test_days, '1d', ['close']).close)\n    # 根据回归比例算它们的平稳序列 Y-a.X\n    stable_",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": "e']).close)\n    # 根据回归比例算它们的平稳序列 Y-a.X\n    stable_series = prices2 - g.regression_ratio*prices1\n    # 算均值\n    series_mean = mean(stable_series)\n    # 算标准差\n    sigma = np.std(stable_series)\n    # 算序列现值离均值差距多少\n    diff = stable_series[-1] - series_mean\n    # 返回z值\n    return(diff/sigma)\n\n# ---代码块5.获取信号\n# 返回新的状态，是一个string\ndef get_signal():\n    z_score = z_test()\n    if z_score > 1:\n        # 状态为全仓第一支\n        return('buy1')\n    # 如果小于负标准差\n    if z_score < -1:\n        # 状态为全仓第二支\n        return('buy2')\n    # 如果在正负",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": "     # 状态为全仓第二支\n        return('buy2')\n    # 如果在正负标准差之间\n    if -1 <= z_score <= 1:\n        # 如果差大于0\n        if z_score >= 0:\n            # 在均值上面\n            return('side1')\n        # 反之\n        else:\n            # 在均值下面\n            return('side2')\n\n# ---代码块6.根据信号调换仓位\n# 输入是目标状态，输入为一个string\ndef change_positions(new_state,context):\n    # 总值产价值\n    total_value = context.portfolio.portfolio_value\n    # 如果新状态是全仓股票1\n    if new_state == 'buy1':\n        # 全卖股票2\n        order_target(g.security2, 0)\n        # 全买股票1\n  ",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": "   order_target(g.security2, 0)\n        # 全买股票1\n        order_value(g.security1, total_value)\n        # 旧状态更改\n        g.state = 'buy1'\n    # 如果新状态是全仓股票2\n    if new_state == 'buy2':\n        # 全卖股票1\n        order_target(g.security1, 0)\n        # 全买股票2\n        order_value(g.security2, total_value)\n        # 旧状态更改\n        g.state = 'buy2'\n    # 如果处于全仓一股票状态，但是z-score交叉0点\n    if (g.state == 'buy1' and new_state == 'side2') or (g.state == 'buy2' and new_state == 'side1'):\n        # 按照p,q值将股票仓位调整为默认值\n        order_",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": "ide1'):\n        # 按照p,q值将股票仓位调整为默认值\n        order_target_value(g.security1, g.p * total_value)\n        order_target_value(g.security2, g.q * total_value)\n        # 代码里重复两遍因为要先卖后买，而我们没有特地确定哪个先哪个后\n        order_target_value(g.security1, g.p * total_value)\n        order_target_value(g.security2, g.q * total_value)\n        # 状态改为‘平’\n        g.state = 'even'\n",
        "source": "99策略代码/19 招行_海天配对策略（学习招行伊利配对）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/10757\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 10\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_tra",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "eck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n  ",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "   run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_hold",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": " buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securiti",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "olio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.sec",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "k_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_f",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "et_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "ade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ####################",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "######################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 20)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    security_list = [security for security in security_list if MA_judge_duotou(security, 5, 10)]\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "urity_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        valuation.circulating_market_cap:('desc',1),\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.position",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_se",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "y_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n              ",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "on)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        id",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n     ",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "     a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfoli",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": " in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = ",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if ",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "T股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_l",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "  current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n   ",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "ontext.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securitie",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in sec",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "es\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/26 向导式-1.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14326\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error') \n    \n    ### 融资融券相关设定 ###\n    # 设置账户类型: 融资融券账户\n    set_subportfolios([SubPortfolioConfig(cash=conte",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "  set_subportfolios([SubPortfolioConfig(cash=context.portfolio.cash, type='stock_margin')])\n    \n    ## 融资相关设定\n    # 设定融资利率: 年化8%, 默认8%\n    set_option('margincash_interest_rate', 0.08)\n    # 设置融资保证金比率: 150%, 默认100%\n    set_option('margincash_margin_rate', 1.5)\n    \n    ## 融券相关设定\n    # 设定融券利率: 年化10%, 默认10%\n    set_option('marginsec_interest_rate', 0.10)\n    # 设定融券保证金比率: 150%, 默认100%\n    set_option('marginsec_margin_rate', 1.5)\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'51030",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "ity为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    # run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n\n\n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message('美好的一天~')\n\n    # 要操作的股票（g.为全局变量）\n    # 融资买入的股票代码（中国银行）\n    g.rz_stock = '601988.XSHG'\n    # 融券卖出的股票代码（平安银行）\n    g.rq_stock = '002048.XSHE'\n    \n    g.p_mean = 2.8539\n    g.p_std = 0.00149\n    g.beta = 0.0567\n\n## 开盘时运行函数\ndef handle_data(context, data):\n    # 确定时间是周几\n    weekday = context.current_dt.isoweekday()\n    log.info(\"今天是周 %s\" % weekday)\n    # 融资买入的股票代码（中国银行）\n    rz_stock = g.rz_stock\n    # 融券卖出的股票代码（平安银行）\n    rq_stock ",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "k = g.rz_stock\n    # 融券卖出的股票代码（平安银行）\n    rq_stock = g.rq_stock\n    data1 = attribute_history(rz_stock, 1, '1d', ['close'])['close'][0]\n    data2 = attribute_history(rq_stock, 1, '1d', ['close'])['close'][0]\n    portf = data1 - g.beta*data2\n    ava_margin = context.portfolio.subportfolios[0].available_margin\n    print(ava_margin)\n    print(portf,g.p_mean * (1+2*g.p_std))\n    short_closeable_rz = context.portfolio.short_positions[g.rz_stock].closeable_amount\n    short_closeable_rq = context.portfolio.short_po",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "   short_closeable_rq = context.portfolio.short_positions[g.rq_stock].closeable_amount\n    long_closeable_rz = context.portfolio.long_positions[g.rz_stock].closeable_amount\n    long_closeable_rq = context.portfolio.long_positions[g.rq_stock].closeable_amount\n    # if portf > g.p_mean * (1+2*g.p_std) and portf < g.p_mean * (1+5*g.p_std):\n    #     # margincash_close(rz_stock, long_closeable_rz*0.5)\n    #     order(rz_stock, long_closeable_rz,side='short')\n    #     marginsec_close(rq_stock, short_closeable_r",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": " #     marginsec_close(rq_stock, short_closeable_rq)\n    if portf > g.p_mean * (1+2*g.p_std):\n        order(rz_stock, -long_closeable_rz,side='long')\n        marginsec_close(rq_stock, short_closeable_rq)\n    if portf < g.p_mean * (1-2*g.p_std) and ava_margin>0:\n        order(rz_stock, 50000,side='long')\n        marginsec_open(rq_stock, 50000*g.beta)\n    # if portf > g.p_mean * (1+10*g.p_std):\n    #     order(rq_stock, 30000*g.beta,side='long')\n    #     marginsec_open(rz_stock, 30000)\n    # if portf < g.p_m",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "insec_open(rz_stock, 30000)\n    # if portf < g.p_mean * (1+2*g.p_std) and ava_margin > 0:\n    #     order(rq_stock, -long_closeable_rq,side='long')\n    #     marginsec_close(rz_stock, short_closeable_rz)\n        \n    # 操作判定\n    # if weekday in (1, 2):\n    #     # 融资操作\n    #     log.info(\"融资买入10000股中国银行\")\n    #     margincash_open(rz_stock, 10000)\n\n    #     # 融券操作\n    #     log.info(\"融券卖出10000股平安银行\")\n    #     marginsec_open(rq_stock, 10000)\n        \n    # elif weekday == 3:\n    #     # 融资操作\n    #     log.i",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "lif weekday == 3:\n    #     # 融资操作\n    #     log.info(\"卖券还款10000股中国银行\")\n    #     margincash_close(rz_stock, 10000)\n\n    #     # 融券操作\n    #     log.info(\"买券还券10000股平安银行\")\n    #     marginsec_close(rq_stock, 10000)\n        \n    # elif weekday == 4:\n    #     # 融资操作\n    #     log.info(\"直接还钱10000元\")\n    #     margincash_direct_refund(10000)\n\n    #     # 融券操作\n    #     log.info(\"买入10000股平安银行, 然后直接还券10000股平安银行\")\n    #     order(rq_stock, 10000, side='long')\n    #     marginsec_direct_refund(rq_stock, 10000) \n\n##",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "     marginsec_direct_refund(rq_stock, 10000) \n\n## 收盘后运行函数  \ndef after_market_close(context):\n    # 查看融资融券账户相关相关信息(更多请见API-对象-SubPortfolio)\n    p = context.portfolio.subportfolios[0]\n    log.info('- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -')\n    log.info('查看融资融券账户相关相关信息(更多请见API-对象-SubPortfolio)：')\n    log.info('总资产：',p.total_value)\n    log.info('净资产：',p.net_value)\n    log.info('总负债：',p.total_liability)\n    log.info('融资负债：',p.cash_liability)\n    log.info('融券负债：',p.sec_liability)\n    log.in",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": ")\n    log.info('融券负债：',p.sec_liability)\n    log.info('利息总负债：',p.interest)\n    log.info('可用保证金：',p.available_margin)\n    log.info('维持担保比例：',p.maintenance_margin_rate)\n    log.info('账户所属类型：',p.type)\n    log.info('##############################################################')\n\n\n    \n    \n    \n",
        "source": "99策略代码/50 简单配对交易.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11372\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in c",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "urities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_fil",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_ou",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "s = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n  ",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_l",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "k_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 20)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_r",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "al_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 30)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio, 30)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 5)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    inp",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "ct\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if l",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": ")\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n#",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "r(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            ",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "rame(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) a",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "  if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s ",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.fi",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "listed_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_s",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_secu",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef ind",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "urn  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, securi",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "ty_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/61 向导式策略生成器生成的成长股精选策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15426\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport pandas as pd\nimport numpy as np\nimport math\nfrom sklearn.svm import SVR  \nfrom sklearn.model_selection import GridSearchCV  \nfrom sklearn.model_selection import learning_curve\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nimport jqdata\n\n#初始化函数\ndef initialize(context):\n    set_params()\n    set_backtest()\n    run_daily(trade, 'every_bar')\n\n#设置参",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "backtest()\n    run_daily(trade, 'every_bar')\n\n#设置参数函数，调仓    \ndef set_params():\n    g.days = 0\n    g.refresh_rate = 10\n    g.stocknum = 10\n\n#测试函数    \ndef set_backtest():\n    set_benchmark('000001.XSHG')#基准指数\n    set_option('use_real_price', True)\n    log.set_level('order', 'error')\n\n#设置交易函数    \ndef trade(context):\n    if g.days % 10 == 0:    #若持有10天，进行调仓\n        sample = get_index_stocks('000001.XSHG', date = None)  #获得股票池\n        q = query(valuation.code, valuation.market_cap, balance.total_assets - balance",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "luation.market_cap, balance.total_assets - balance.total_liability,\n                  balance.total_assets / balance.total_liability, income.net_profit, income.net_profit + 1, \n                  indicator.inc_revenue_year_on_year, balance.development_expenditure).filter(valuation.code.in_(sample))\n        df = get_fundamentals(q, date = None)\n        df.columns = ['code', 'log_mcap', 'log_NC', 'LEV', 'NI_p', 'NI_n', 'g', 'log_RD'] #回归的各因子\n        \n        #对因子取log\n        df['log_mcap'] = np.log(df['log_mca",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "因子取log\n        df['log_mcap'] = np.log(df['log_mcap'])\n        df['log_NC'] = np.log(df['log_NC'])\n        df['NI_p'] = np.log(np.abs(df['NI_p']))\n        df['NI_n'] = np.log(np.abs(df['NI_n'][df['NI_n']<0]))\n        df['log_RD'] = np.log(df['log_RD'])\n        df.index = df.code.values\n        del df['code']\n        df = df.fillna(0)\n        df[df>10000] = 10000\n        df[df<-10000] = -10000\n        industry_set = ['801010', '801020', '801030', '801040', '801050', '801080', '801110', '801120', '801130', \n ",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "01050', '801080', '801110', '801120', '801130', \n                  '801140', '801150', '801160', '801170', '801180', '801200', '801210', '801230', '801710',\n                  '801720', '801730', '801740', '801750', '801760', '801770', '801780', '801790', '801880','801890'] #申万一级指数\n        \n        for i in range(len(industry_set)):\n            industry = get_industry_stocks(industry_set[i], date = None)\n            s = pd.Series([0]*len(df), index=df.index)\n            s[set(industry) & set(df.index)]=1\n   ",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "            s[set(industry) & set(df.index)]=1\n            df[industry_set[i]] = s\n            \n            #回归X,Y\n        X = df[['log_NC', 'LEV', 'NI_p', 'NI_n', 'g', 'log_RD','801010', '801020', '801030', '801040', '801050', \n                '801080', '801110', '801120', '801130', '801140', '801150', '801160', '801170', '801180', '801200', \n                '801210', '801230', '801710', '801720', '801730', '801740', '801750', '801760', '801770', '801780', \n                '801790', '801880', '801890']]\n  ",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "\n                '801790', '801880', '801890']]\n        Y = df[['log_mcap']]\n        X = X.fillna(0)\n        Y = Y.fillna(0)\n        \n        #支持向量回归（Support Vector Regression)\n        svr = SVR(kernel='rbf', gamma=0.1) \n        model = svr.fit(X, Y)  #将XY带入SVR\n        factor = Y - pd.DataFrame(svr.predict(X), index = Y.index, columns = ['log_mcap']) #获取残差值\n        factor = factor.sort_index(by = 'log_mcap')\n        stockset = list(factor.index[:10])     #按残差大小分成10组\n        sell_list = list(context.portfoli",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "差大小分成10组\n        sell_list = list(context.portfolio.positions.keys())\n        for stock in sell_list:\n            if stock not in stockset[:g.stocknum]:    #如果股票不在该档就卖出\n                stock_sell = stock\n                order_target_value(stock_sell, 0)\n            \n        if len(context.portfolio.positions) < g.stocknum:  #如果持仓天数小于10，持仓期平均cash剩余\n            num = g.stocknum - len(context.portfolio.positions)\n            cash = context.portfolio.cash/num\n        else:\n            cash = 0\n            num =",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "      else:\n            cash = 0\n            num = 0\n        for stock in stockset[:g.stocknum]:   #如果持仓股票仍在该档，则不卖出\n            if stock in sell_list:\n                pass\n            else:\n                stock_buy = stock\n                order_target_value(stock_buy, cash)\n                num = num - 1\n                if num == 0:\n                    break\n        g.days += 1                            #按天进行\n    else:\n        g.days = g.days + 1    \n            ",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "      ",
        "source": "99策略代码/43 无模型评估的多因子模型.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/10778\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport pandas as pd\nimport numpy as np\nimport math\nfrom sklearn.svm import SVR  \nfrom sklearn.model_selection import GridSearchCV  \nfrom sklearn.model_selection import learning_curve\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nimport jqdata\n\ndef initialize(context):\n    set_params()\n    set_backtest()\n    run_daily(trade, 'every_bar')\n    \ndef set",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "t()\n    run_daily(trade, 'every_bar')\n    \ndef set_params():\n    g.days = 0\n    g.refresh_rate = 10\n    g.stocknum = 10\n    \ndef set_backtest():\n    set_benchmark('000001.XSHG')\n    set_option('use_real_price', True)\n    log.set_level('order', 'error')\n    \ndef trade(context):\n    if g.days % 10 == 0:\n        sample = get_index_stocks('000001.XSHG', date = None)\n        q = query(valuation.code, valuation.market_cap, balance.total_assets - balance.total_liability,\n                  balance.total_assets / ba",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "ility,\n                  balance.total_assets / balance.total_liability, income.net_profit, income.net_profit + 1, \n                  indicator.inc_revenue_year_on_year, balance.development_expenditure).filter(valuation.code.in_(sample))\n        df = get_fundamentals(q, date = None)\n        df.columns = ['code', 'log_mcap', 'log_NC', 'LEV', 'NI_p', 'NI_n', 'g', 'log_RD']\n        \n        df['log_mcap'] = np.log(df['log_mcap'])\n        df['log_NC'] = np.log(df['log_NC'])\n        df['NI_p'] = np.log(np.abs(df",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "f['log_NC'])\n        df['NI_p'] = np.log(np.abs(df['NI_p']))\n        df['NI_n'] = np.log(np.abs(df['NI_n'][df['NI_n']<0]))\n        df['log_RD'] = np.log(df['log_RD'])\n        df.index = df.code.values\n        del df['code']\n        df = df.fillna(0)\n        df[df>10000] = 10000\n        df[df<-10000] = -10000\n        industry_set = ['801010', '801020', '801030', '801040', '801050', '801080', '801110', '801120', '801130', \n                  '801140', '801150', '801160', '801170', '801180', '801200', '801210',",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": " '801160', '801170', '801180', '801200', '801210', '801230', '801710',\n                  '801720', '801730', '801740', '801750', '801760', '801770', '801780', '801790', '801880','801890']\n        \n        for i in range(len(industry_set)):\n            industry = get_industry_stocks(industry_set[i], date = None)\n            s = pd.Series([0]*len(df), index=df.index)\n            s[set(industry) & set(df.index)]=1\n            df[industry_set[i]] = s\n            \n        X = df[['log_NC', 'LEV', 'NI_p', 'NI_n',",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": " \n        X = df[['log_NC', 'LEV', 'NI_p', 'NI_n', 'g', 'log_RD','801010', '801020', '801030', '801040', '801050', \n                '801080', '801110', '801120', '801130', '801140', '801150', '801160', '801170', '801180', '801200', \n                '801210', '801230', '801710', '801720', '801730', '801740', '801750', '801760', '801770', '801780', \n                '801790', '801880', '801890']]\n        Y = df[['log_mcap']]\n        X = X.fillna(0)\n        Y = Y.fillna(0)\n        \n        svr = SVR(kernel='rbf",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "Y.fillna(0)\n        \n        svr = SVR(kernel='rbf', gamma=0.1) \n        model = svr.fit(X, Y)\n        factor = Y - pd.DataFrame(svr.predict(X), index = Y.index, columns = ['log_mcap'])\n        factor = factor.sort_index(by = 'log_mcap')\n        stockset = list(factor.index[:10])\n        sell_list = list(context.portfolio.positions.keys())\n        for stock in sell_list:\n            if stock not in stockset[:g.stocknum]:\n                stock_sell = stock\n                order_target_value(stock_sell, 0)\n  ",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "              order_target_value(stock_sell, 0)\n            \n        if len(context.portfolio.positions) < g.stocknum:\n            num = g.stocknum - len(context.portfolio.positions)\n            cash = context.portfolio.cash/num\n        else:\n            cash = 0\n            num = 0\n        for stock in stockset[:g.stocknum]:\n            if stock in sell_list:\n                pass\n            else:\n                stock_buy = stock\n                order_target_value(stock_buy, cash)\n                num = nu",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "et_value(stock_buy, cash)\n                num = num - 1\n                if num == 0:\n                    break\n        g.days += 1\n    else:\n        g.days = g.days + 1    \n            ",
        "source": "99策略代码/03 机器学习多因子策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15265\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom jqdata import *\n\ndef initialize(context):\n    \n##### 修改股票 #####\n    g.security = '510310.XSHG'\n    set_benchmark('000300.XSHG')\n    set_option('use_real_price', True) \n    set_option('order_volume_ratio', 1)\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \\\n                             open_commission=0.0003, close_commission=0.0003,\\\n                             close_today_commission=0,",
        "source": "99策略代码/83 沪深300ETF-1060双均线.txt"
    },
    {
        "text": "                         close_today_commission=0, min_commission=5), type='stock')\n    run_daily(trade, 'every_bar')\n\n\ndef trade(context):\n    \n##### 修改参数 #####\n    security = g.security\n    close_data = attribute_history(security,10, '1d', ['close'],df=False)\n    ma1 = close_data['close'].mean()\n    close_data = attribute_history(security,60,'1d', ['close'],df=False)\n    ma2 = close_data['close'].mean()\n    close_price=close_data['close'][-1]\n    cash = context.portfolio.cash\n    \n##### 修改条件 #####\n    if ",
        "source": "99策略代码/83 沪深300ETF-1060双均线.txt"
    },
    {
        "text": "ntext.portfolio.cash\n    \n##### 修改条件 #####\n    if ma1 > ma2:\n        order_value(security, cash)\n    elif ma1 < ma2 and context.portfolio.positions[security].closeable_amount > 0:\n        order_target(security, 0)\n\n",
        "source": "99策略代码/83 沪深300ETF-1060双均线.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13941\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "anagement_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securitie",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "r_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "xt, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "tements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "heck_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_list",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "text, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "ade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "#######################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 5)\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 30)\n    security_list = financial_data_filter_dayu(security_list, valuation.pe_ratio, 3)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 4)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n  ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "or.roe, 4)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "#\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        indicator.inc_net_profit_year_on_year:('desc',30),\n        valuation.market_cap:('desc',20),\n        valuation.pe_ratio:('desc',25),\n        indicator.roe:('desc',25),\n        }\n    # 返回结果\n    return input_dict\n\n",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": ",25),\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if le",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "#\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        r",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "text.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##############",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "############################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n     ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": ".concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            ret",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(se",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": " context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "elisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n       ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "         current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "niverse(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n   ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n ",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "t, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数\n",
        "source": "99策略代码/36 投资学作业——简单多因子选股策略改进.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11593\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/1810\n# 标题：【量化课堂】基于协整的搬砖策略\n# 作者：JoinQuant量化课堂\n\nimport numpy as np\nimport pandas as pd\n\n#===========================================\n\ndef initialize(context):\n    set_params()\n    set_variables()\n    set_backtest()\n\n# ---代码块1. 设置参数\ndef set_params():\n    # 股票1\n    g.security1 = '600887.XSHG' \n    # 股票2\n    g.security2 = '600036.XSHG'\n    # 基准\n    g.benchmark = '6000",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": "2 = '600036.XSHG'\n    # 基准\n    g.benchmark = '600036.XSHG'\n    # 回归系数\n    g.regression_ratio = 1.000#0.9574#0.9938\n    # 股票1默认仓位\n    g.p = 0.5\n    # 股票2默认仓位\n    g.q = 0.5\n    # 算z-score天数\n    g.test_days = 120\n\n# ---代码块2. 设置变量\ndef set_variables():\n    # 现在状态\n    g.state = 'empty'\n\n# ---代码块3. 设置回测\ndef set_backtest():\n    # 设置基准\n    set_benchmark(g.benchmark)\n    # 只报错\n    log.set_level('order', 'error')\n    # 真实价格\n    set_option('use_real_price', True) \n    # 无滑点\n    set_slippage(FixedSlippage(0.))\n\n#=======",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": " 无滑点\n    set_slippage(FixedSlippage(0.))\n\n#==============================================\n    \n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    new_state = get_signal()\n    change_positions(new_state,context)\n\n# ---代码块4.计算z-score\ndef z_test():\n    # 获取两支股票历史价格\n    prices1 = np.array(attribute_history(g.security1, g.test_days, '1d', ['close']).close)\n    prices2 = np.array(attribute_history(g.security2, g.test_days, '1d', ['close']).close)\n    # 根据回归比例算它们的平稳序列 Y-a.X\n    stable_",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": "e']).close)\n    # 根据回归比例算它们的平稳序列 Y-a.X\n    stable_series = prices2 - g.regression_ratio*prices1\n    # 算均值\n    series_mean = mean(stable_series)\n    # 算标准差\n    sigma = np.std(stable_series)\n    # 算序列现值离均值差距多少\n    diff = stable_series[-1] - series_mean\n    # 返回z值\n    return(diff/sigma)\n\n# ---代码块5.获取信号\n# 返回新的状态，是一个string\ndef get_signal():\n    z_score = z_test()\n    if z_score > 1:\n        # 状态为全仓第一支\n        return('buy1')\n    # 如果小于负标准差\n    if z_score < -1:\n        # 状态为全仓第二支\n        return('buy2')\n    # 如果在正负",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": "     # 状态为全仓第二支\n        return('buy2')\n    # 如果在正负标准差之间\n    if -1 <= z_score <= 1:\n        # 如果差大于0\n        if z_score >= 0:\n            # 在均值上面\n            return('side1')\n        # 反之\n        else:\n            # 在均值下面\n            return('side2')\n\n# ---代码块6.根据信号调换仓位\n# 输入是目标状态，输入为一个string\ndef change_positions(new_state,context):\n    # 总值产价值\n    total_value = context.portfolio.portfolio_value\n    # 如果新状态是全仓股票1\n    if new_state == 'buy1':\n        # 全卖股票2\n        order_target(g.security2, 0)\n        # 全买股票1\n  ",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": "   order_target(g.security2, 0)\n        # 全买股票1\n        order_value(g.security1, total_value)\n        # 旧状态更改\n        g.state = 'buy1'\n    # 如果新状态是全仓股票2\n    if new_state == 'buy2':\n        # 全卖股票1\n        order_target(g.security1, 0)\n        # 全买股票2\n        order_value(g.security2, total_value)\n        # 旧状态更改\n        g.state = 'buy2'\n    # 如果处于全仓一股票状态，但是z-score交叉0点\n    if (g.state == 'buy1' and new_state == 'side2') or (g.state == 'buy2' and new_state == 'side1'):\n        # 按照p,q值将股票仓位调整为默认值\n        order_",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": "ide1'):\n        # 按照p,q值将股票仓位调整为默认值\n        order_target_value(g.security1, g.p * total_value)\n        order_target_value(g.security2, g.q * total_value)\n        # 代码里重复两遍因为要先卖后买，而我们没有特地确定哪个先哪个后\n        order_target_value(g.security1, g.p * total_value)\n        order_target_value(g.security2, g.q * total_value)\n        # 状态改为‘平’\n        g.state = 'even'\n",
        "source": "99策略代码/02 我好像破解了聚宽擂台排第一的策略？！.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13973\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n#策略概述：以ROE为筛选标准，选择沪深300中满足条件的股票作为股票池\n#采用CAPM模型，利用选单因子回归，计算出阿尔法值，选出阿尔法值最大的前16支股票进行投资\nimport numpy as np\nfrom scipy import stats\nimport pylab\n\n'''\n============================================================================\n初始化\n============================================================================\n'''\n\ndef initialize(context):\n    set_params()        #1设置策略参数\n    set_variables()     #2设置中间变量\n    set",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": " #1设置策略参数\n    set_variables()     #2设置中间变量\n    set_backtest()    # 3设置回测条件\n    run_daily(stop, time='after_close')\n    \n#1设置策略参数\ndef set_params():\n    g.index = '000300.XSHG'\n    #每次取alpha最小的16支股票\n    g.num = 16\n    #每次回归调用前days天的数据\n    g.days = 121\n    g.tc = 10\n    g.N = 121          # 需要前多少天的数据\n    g.rf=0.04/252           #无风险利率，用于计算超额收益\n    g.ROE_requirement=10 #ROE大于10%\n    \n#2设置中间变量\ndef set_variables():\n    g.t=0               #记录连续回测天数\n    g.if_trade=False    #当天是否交易\n    g.feasible_stocks=[]\n    \n#3设",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "False    #当天是否交易\n    g.feasible_stocks=[]\n    \n#3设置回测条件\ndef set_backtest():\n    set_benchmark('000300.XSHG')\n    set_option('use_real_price',True) # 用真实价格交易\n    log.set_level('order','error')    # 设置报错等级\n    \n'''\n=====================================================================\n每天回测前\n=====================================================================\n'''\ndef before_trading_start(context):\n    if g.t % g.tc ==0:\n        #每g.tc天，交易一次\n        g.if_trade=True \n        # 设置手续费与手续费\n        set_slip_fee(cont",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "rue \n        # 设置手续费与手续费\n        set_slip_fee(context) \n        \n        \n        # 获得ROE大于设定的值的股票池\n        a=query(indicator.code,indicator.roe\n        # 筛选 ROE大于设定的值\n        ).filter(indicator.roe > g.ROE_requirement\n        # 排序 按ROE从大到小排\n        ).order_by(indicator.roe.desc()\n        ).limit(1000)\n        ROE_securities=get_fundamentals(a)\n        securities_list=list(ROE_securities.code)\n\n\n        g.feasible_stocks = set_feasible_stocks(securities_list,g.N,context)\n    g.t+=1\n    \n#4 剔除股票池中在样本期间停牌的股票\n",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": ",g.N,context)\n    g.t+=1\n    \n#4 剔除股票池中在样本期间停牌的股票\ndef set_feasible_stocks(stock_list,days,context):\n    # 得到是否停牌信息的dataframe，停牌的1，未停牌得0\n    suspened_info_df = get_price(list(stock_list), start_date=context.current_dt, end_date=context.current_dt, frequency='daily', fields='paused')['paused'].T\n    # 过滤停牌股票 返回dataframe\n    unsuspened_index = suspened_info_df.iloc[:,0]<1\n    # 得到当日未停牌股票的代码list:\n    unsuspened_stocks = suspened_info_df[unsuspened_index].index\n    # 进一步，筛选出前days天未曾停牌的股票list:\n    feasible_stocks",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "   # 进一步，筛选出前days天未曾停牌的股票list:\n    feasible_stocks=[]\n    current_data=get_current_data()\n    for stock in unsuspened_stocks:\n        if not(isnan(attribute_history(stock, days, unit='1d',fields=('close'),skip_paused=True).iloc[0,0])):\n            feasible_stocks.append(stock)\n    return feasible_stocks    \n\n#5 根据不同的时间段，设置滑点与手续费\ndef set_slip_fee(context):\n    # 将滑点设置为0\n    set_slippage(FixedSlippage(0)) \n    # 根据不同的时间段设置手续费\n    dt=context.current_dt\n    log.info(type(context.current_dt))\n    \n    if dt>date",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "info(type(context.current_dt))\n    \n    if dt>datetime.datetime(2013,1, 1):\n        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)) \n        \n    elif dt>datetime.datetime(2011,1, 1):\n        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))\n            \n    elif dt>datetime.datetime(2009,1, 1):\n        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))\n                \n    else:\n        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, m",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "ission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))\n\n\n'''\n=====================================================================\n每天回测时\n=====================================================================\n'''\ndef handle_data(context, data):\n    to_sell, to_buy = get_signal(context)\n    sell_and_buy_stocks(context, to_sell, to_buy)\n\n#6 将股票价格转化为超额收益率，输入为days天的股票收盘价，输出为days-1天的超额收益率\ndef price2ret(price):\n    ret = []\n    rf = g.rf\n    for i in range(len(price)-1):\n        ret.append((price[i+1] - pric",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "n(price)-1):\n        ret.append((price[i+1] - price[i])/price[i] - rf)\n    return ret\n\n#7 获得调仓信号\ndef get_signal(context):\n    if g.if_trade == True:\n        num = g.num\n    #stocks为ROE筛选过后的股票代码list\n        stocks = g.feasible_stocks\n    #取days个交易日的数据\n        days = g.days\n    #security为沪深300的指数代码\n        security = g.index\n    #取得沪深300指数的收盘价\n        marketporfolio = attribute_history(security, days, '1d', 'close')\n    #计算沪深300指数的收益率\n        marketreturn = price2ret(marketporfolio['close'])\n        alpha=[]\n",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "ice2ret(marketporfolio['close'])\n        alpha=[]\n    #用for循环计算通过ROE筛选的股票池中的每个股票的alpha\n        for stock in stocks:\n            stockprice = attribute_history(stock, days, '1d', 'close')\n            stockreturn = price2ret(stockprice['close'])\n            beta, stockalpha, r_value, p_value, slope_std_error = stats.linregress(marketreturn, stockreturn)\n            alpha.append([stock,stockalpha])\n    #对每只股票的alpha进行排序\n        sortedalpha = sorted(alpha,key=lambda X:X[1])\n    #取alpha最大的num支股票——————————————\n   ",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "bda X:X[1])\n    #取alpha最大的num支股票——————————————\n        targetstocks = sortedalpha[(-num):]\n    #——————————————————————————————————\n        targetstock = []\n        taralpha = []\n    #用for循环得到目标股票的代码和对应的alpha\n        for k1 in range(len(targetstocks)):\n            targetstock.append(targetstocks[k1][0])\n            taralpha.append(targetstocks[k1][1])\n        taralpha = [(max(taralpha) - p)/(max(taralpha) - min(taralpha)) for p in taralpha]\n        totalalpha = sum(taralpha)\n        \n    #计算每个股票的持仓权重：根据alpha",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": " = sum(taralpha)\n        \n    #计算每个股票的持仓权重：根据alpha来分配\n        weights = [x/totalalpha for x in taralpha]\n    #得到当前以持有的股票池\n        present = context.portfolio.positions\n    #得到当前股票池中的股票代码\n        stocksnow = present.keys()\n   \n        if len(stocksnow)>0:\n            valuenow = []\n            stockandvalue = {}\n            for stock in stocksnow:\n                s_amount = context.portfolio.positions[stock].sellable_amount\n                l_s_p = context.portfolio.positions[stock].last_sale_price\n           ",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "folio.positions[stock].last_sale_price\n                valuenow = s_amount*l_s_p\n                stockandvalue[stock] = valuenow\n    #得到当前股票组合和剩余资金总和\n        capital = context.portfolio.portfolio_value\n    #得到按照目标权重配股时对应的股票配资\n        tarcapallocation = [capital*x for x in weights]\n        tarstoandcap = dict(zip(targetstock, tarcapallocation))\n        to_sell = {}\n    #若当前持有股票市值大于目标市值，则进行卖出\n        for stock in stocksnow:\n            if stock in targetstock:\n                gap = tarstoandcap[stock] - stock",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "\n                gap = tarstoandcap[stock] - stockandvalue[stock]\n                if gap<0:\n                    to_sell[stock] = tarstoandcap[stock]\n            else:\n                to_sell[stock] = 0\n    \n    #按照目标配比对目标股票组合进行买入\n        to_buy = {}\n        for stock in targetstock:\n            to_buy[stock] = tarstoandcap[stock]\n        #print(to_sell, to_buy)\n        return to_sell, to_buy\n    else:\n        return {},{}\n        \n#8 调整仓位\ndef sell_and_buy_stocks(context, to_sell, to_buy):\n    if g.if_trade:",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "ocks(context, to_sell, to_buy):\n    if g.if_trade:\n        for stock in to_sell.keys():\n            order_target_value(stock, to_sell[stock])\n        for stock in to_buy.keys():\n            order_target_value(stock, to_buy[stock])\n    g.if_trade = False\n\n#9 止损\ndef stop(context):\n    # 循环查看持仓的每个股票\n    for stock in context.portfolio.positions:\n        # 如果股票收盘价格除以平均成本小于0.7，即亏损超过30%\n        if (context.portfolio.positions[stock].price/context.portfolio.positions[stock].avg_cost < 0.7): \n            # 调整stock的持",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "s[stock].avg_cost < 0.7): \n            # 调整stock的持仓为0，即卖出\n            order_target(stock, 0) \n            #剩余资金用于买国债\n            cash=context.portfolio.available_cash\n            order_target_value('000012.XSHG',cash)\n            # 输出日志：股票名 止损\n            print \"\\n%s 止损\" % stock\n    \n\n",
        "source": "99策略代码/71 【投资学】CAPM单因子回归模型+ROE股票池（含止损）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13940\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "anagement_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securitie",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "r_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "xt, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "tements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "heck_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_list",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "text, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "ade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "#######################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 5)\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 30)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 4)\n    security_list = financial_data_filter_dayu(security_list, valuation.pe_ratio, 3)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n  ",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "_ratio, 3)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return ",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "#\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.po",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    ",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "t, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_li",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "knum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return ",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": ") == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "ding = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock f",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": " g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        ",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": ", security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "tock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_l",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['st",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "        temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_i",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/35 投资学作业——简单多因子选股策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11024\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securitie",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "lio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.secu",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_fi",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_l",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "t_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "de_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 #####################",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "#####################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.operation_profit_to_total_revenue, 10)\n    security_list = financial_data_",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "l_revenue, 10)\n    security_list = financial_data_filter_dayu(security_list, valuation.pb_ratio, 2)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, ",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": " 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": " sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": " holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": " Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascen",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "  # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_fi",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "ept:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] =",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "ed_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "tock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": " in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n ",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n  ",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "# 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/63 向导式.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14594\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\ndef initialize(context):\n    run_daily(period,time='every_bar')\n    g.stocksnum=6\ndef period(context):\n      scu=get_index_stocks('000001.XSHG')+get_index_stocks('399106.XSHE')\n      q=query(valuation.code).filter(valuation.code.in_(scu)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)\n      df=get_fundamentals(q)\n      stocklist=list(df['code'])\n      m=get_current_data()\n      buylist=stocklis",
        "source": "99策略代码/11 酒股地中短线策略.txt"
    },
    {
        "text": "\n      m=get_current_data()\n      buylist=stocklist\n      for stock in context.portfolio.positions:\n          if stock not in buylist: #如果stock不在buylist\n              order_target(stock, 0)\n      for stk in buylist:\n          order_value(stk,15000)\n      for stk in context.portfolio.positions:\n          cost=context.portfolio.positions[stk].price\n          close_data = attribute_history(stk,3, '1d', ['close'])\n          close_data2 = attribute_history(stk,5, '1d', ['close'])\n          close_data3 = attribut",
        "source": "99策略代码/11 酒股地中短线策略.txt"
    },
    {
        "text": " '1d', ['close'])\n          close_data3 = attribute_history(stk,7, '1d', ['close'])\n          MA10 = close_data['close'].mean()\n          MA15 = close_data2['close'].mean()\n          MA20 = close_data3['close'].mean()\n          price = close_data['close'][-1]\n          ret=price/cost-1\n          if ret>0.05:\n              order_value(stk,-90000)\n          elif ret>0.1:\n              order_value(stk,-70000)\n          elif ret>0.15:\n              order_value(stk,-50000)  \n          if MA10>price:\n            ",
        "source": "99策略代码/11 酒股地中短线策略.txt"
    },
    {
        "text": "tk,-50000)  \n          if MA10>price:\n              order_value(stk,50000)\n          elif MA15>price:\n              order_value(stk,70000)\n          elif MA20>price:\n              order_value(stk,90000)\n          \n          \n              \n          \n\n\n          \n          \n              \n          \n     \n              \n    ",
        "source": "99策略代码/11 酒股地中短线策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11948\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport math \nimport pandas as pd\nfrom six import StringIO\n\n\n#log.set_level('order', 'error')\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    # 000001(股票:平安银行)\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    \n   # run_monthly(handle, 1,'before_open')\n    run_daily(handle)\n    \n    set_ord",
        "source": "99策略代码/96 沪港两地上市的银行股翻倍策略报告.txt"
    },
    {
        "text": "fore_open')\n    run_daily(handle)\n    \n    set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0.0003, close_commission=0.0013, close_today_commission=0, min_commission=0), type='stock')\n    set_slippage(FixedSlippage(0.02))   \n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle(context):\n\n    g.buylist = check_stock(context) \n    for  stock in context.portfolio.positions:\n        if stock not in g.buylist:\n            order_target_value(stock, 0)\n            \n    value = context.portfolio",
        "source": "99策略代码/96 沪港两地上市的银行股翻倍策略报告.txt"
    },
    {
        "text": "ock, 0)\n            \n    value = context.portfolio.total_value/len(g.buylist)\n    print context.portfolio.available_cash\n    for stock in g.buylist:\n        \n        order_target_value(stock, value )\n\ndef check_stock(context):\n    date = context.current_dt.strftime('%Y-%m-%d')\n    df = read_file('new1.csv')\n    data = pd.read_csv(StringIO(df))\n    try:\n        buylist = list(data.loc[:,date])\n        g.buylist = buylist\n        print g.buylist\n        return g.buylist\n    except:\n        return g.buylist\n",
        "source": "99策略代码/96 沪港两地上市的银行股翻倍策略报告.txt"
    },
    {
        "text": " g.buylist\n    except:\n        return g.buylist\n",
        "source": "99策略代码/96 沪港两地上市的银行股翻倍策略报告.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12925\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport jqdata\nimport copy\nimport numpy as np\nimport pandas as pd\nimport random as ran \nfrom datetime import datetime,timedelta\nimport sklearn\nimport talib as tl\nimport math\n\ndef initialize(context):\n    log.set_level('order', 'error')\n    set_benchmark('000906.XSHG')\n    set_option('use_real_price', True)\n    \n    context.maichu=[]\n    g.buyList = []\n    g.curPflInfo1 = {}\n\n    g.b1=0\n    g.holdSize = 5",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": " g.curPflInfo1 = {}\n\n    g.b1=0\n    g.holdSize = 50\n    g.stpPftPrice = 0.01\n    g.stpLosRate = -0.03\n\ndef filter_paused_and_st_stock(context,stock_list):\n\n    current_data = get_current_data()\n    return [stock for stock in stock_list if not current_data[stock].paused \n    and not current_data[stock].is_st and 'ST' not in current_data[stock].\n    name and '*' not in current_data[stock].name and '退' not in current_data[stock].name]\n    \ndef selectstk(context,stklist,data):\n    \n    buyList = []\n\n    for stk",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": ",stklist,data):\n    \n    buyList = []\n\n    for stk in stklist:\n        close = history(80,'1d','close',stk,fq='none')\n        close = list(close[stk])\n        close.append(data[stk].close)\n        N=29\n        M=19\n        bias,biasma = calculation(N,M,stk,close)\n        # print(bias,biasma)\n        #bias_ql金叉买入\n        if bias[-2] < biasma[-2] and bias[-1] > biasma[-1]:\n            buyList.append(stk)\n        #bias_ql死叉卖出\n        if bias[-2] > biasma[-2] and bias[-1] < biasma[-1]:\n            for stk in g.",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": "d bias[-1] < biasma[-1]:\n            for stk in g.curPflInfo1.keys() :\n                if stk in context.portfolio.positions.keys() :\n                    if stk not in context.maichu:\n                        context.maichu.append(stk)\n    return buyList\n    \n# BIAS_QL计算:\ndef calculation(N,M,stk,close):\n    N=N\n    M=M\n    close = close\n    bias = []\n    biasma = []\n    \n    for i in range(N):\n        bias1 = math.ceil((close[len(close)-i-1] - MAcalcu(close,i,N)) / MAcalcu(close,i,N) * 100*10000 ) / 10000 \n ",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": ",N)) / MAcalcu(close,i,N) * 100*10000 ) / 10000 \n        if bias1 > 0 :\n            bias1 = math.ceil(bias1 * 1000) / 1000\n        if bias1 < 0 :\n            bias1 = math.floor(bias1*1000) / 1000\n        bias.append(bias1)\n    \n    bias=list(reversed(bias))\n    for i in range(M):\n        biasma1 = MAcalcu(bias,i,M)\n        if biasma1 > 0:\n            biasma1 = math.ceil(biasma1*1000) / 1000\n        if biasma1 < 0 :\n            biasma1 = math.floor(biasma1*1000) / 1000\n        biasma.append(biasma1)\n    bias",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": "00) / 1000\n        biasma.append(biasma1)\n    biasma=list(reversed(biasma))\n\n    return bias,biasma\n    \ndef MAcalcu(x,j,n):\n    avg = 0 \n    if n <= len(x):\n        for i in range(n):\n            avg += x[len(x)-i-j-1]\n        return avg/n\n        \ndef before_trading_start(context):\n    g.allStocksmacdkdj = ['000906.XSHG']\n        \ndef handle_data(context, data):\n    current_data = get_current_data()\n\n    if context.current_dt.hour == 14 and context.current_dt.minute == 58 :\n        buylist = []\n        bu",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": "_dt.minute == 58 :\n        buylist = []\n        buylist = selectstk(context,g.allStocksmacdkdj,data)\n        for stk in buylist:\n            if stk not in context.portfolio.positions.keys() :\n                cash = context.portfolio.available_cash\n                order_target_value(stk,cash)#200w\n                stkInfo2 ={}\n                stkInfo2['holddays'] = 1\n                stkInfo2['show']= 1\n                stkInfo2['K1']= 1\n                stkInfo2['N1']= 1\n                stkInfo2['y']= 0.05\n    ",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": "['N1']= 1\n                stkInfo2['y']= 0.05\n                stkInfo2['i1']= 1\n                stkInfo2['zhiying']= 1\n                stkInfo2['zhangfu']= 1\n                stkInfo2['zhangfucishu'] = 0\n                g.curPflInfo1[stk] = stkInfo2\n    \n    popList3 = []\n    if context.current_dt.hour == 14 and context.current_dt.minute == 59 :\n        for stk in g.curPflInfo1.keys() :\n            if stk in context.portfolio.positions.keys() :\n                if stk in context.maichu:\n                    or",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": "  if stk in context.maichu:\n                    order_target(stk, 0)\n                    popList3.append(stk)\n        for stk in popList3 :\n            if stk in g.curPflInfo1.keys() :\n                g.curPflInfo1.pop(stk)\n            if stk in context.maichu:\n                context.maichu.remove(stk)",
        "source": "99策略代码/21 果核量化出品 -- BIAS_QL乖离率策略指数择时1.0.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13324\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n'''\n策略思路：\n选择标的为同仁堂600085\n选取标的的7个特征变量一年的数据作为训练集，训练支持向量机模型\n训练样本的标签是后5个交易日的涨跌情况，涨了就是1，跌了就是0，\n每周三进行调仓,将拟合模型进行未来5天涨跌幅预测，为1时买入，否则空仓\n选取的特征值为：\n收盘价/区间均收盘价均值\n现量/区间均量\n最高价/区间最高价均值\n最低价/区间最低价均值\n成交量比值（相对前一日）\n区间收益率\n区间标准差\n注意：\n示例策略只为说明思路和用法，存在特征值量纲不统一、标的单一等问题，策略开发需要再次基础上更为精细化处理。\n'''\nfrom sklearn import svm\nimport numpy as np\n\n#初始化\ndef initialize(context):\n    #设置标的\n    g.stock = '600085.XSHG'\n    #设置基准\n    set_benchmark(",
        "source": "99策略代码/98 机器学习SVM用法示例策略.txt"
    },
    {
        "text": "stock = '600085.XSHG'\n    #设置基准\n    set_benchmark(g.stock)\n    #过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    #设置数据长度\n    g.days = 22\n    #设置定时任务\n    run_weekly(trade_func,3, time='open')\n#定时任务函数\ndef trade_func(context):\n    prediction = svm_prediction(context)\n    if prediction == 1:\n        cash  = context.portfolio.total_value\n        order_target_value(g.stock,cash)\n    else:\n        order_target_value(g.stock,0)\n        \n#结果预测\ndef svm_prediction(context):\n    #获取标的的历史数据\n    stoc",
        "source": "99策略代码/98 机器学习SVM用法示例策略.txt"
    },
    {
        "text": "f svm_prediction(context):\n    #获取标的的历史数据\n    stock_data = get_price(g.stock, frequency='1d',end_date=context.previous_date,count=252)\n    date_value = stock_data.index\n    close = stock_data['close'].values\n    #用于记录日期的列表\n    date_list = []\n    # 获取行情日期列表\n    #转换日期格式\n    for i in range(len(date_value)):\n        date_list.append(str(date_value[i])[0:10])\n    \n    x_all = []\n    y_all = []\n    #获取特征变量x\n    for i in date_list[g.days:-5]:\n        features_temp = get_features(context,date=i,count=g.days)\n      ",
        "source": "99策略代码/98 机器学习SVM用法示例策略.txt"
    },
    {
        "text": "= get_features(context,date=i,count=g.days)\n        x_all.append(features_temp)\n    #获取特征变量y  \n    for i in range(g.days,len(date_list)-5):    \n        if close[i+5]>close[i]:\n            label = 1\n        else:\n            label = 0    \n        y_all.append(label)\n    x_train = x_all[: -1]\n    y_train = y_all[:-1]\n    clf = svm.SVC()\n    clf.fit(x_train, y_train)\n    print('训练完成!')\n    #进行预测\n    prediction = clf.predict(x_all[-1])[0]\n    return prediction\n    \n#获取特征值\ndef get_features(context,date,count=252",
        "source": "99策略代码/98 机器学习SVM用法示例策略.txt"
    },
    {
        "text": "   \n#获取特征值\ndef get_features(context,date,count=252):\n    #获取数据\n    df_price = get_price(g.stock,end_date=date,count=count,fields=['open','close','low','high','volume','money','avg','pre_close'])  \n    close = df_price['close'].values\n    low = df_price['low'].values\n    high = df_price['high'].values\n    volume = df_price['volume'].values\n    #特征变量设置\n    #收盘价/均值\n    close_mean = close[-1]/np.mean(close)\n    #现量/均量\n    volume_mean = volume[-1]/np.mean(volume)\n    #最高价/均价\n    high_mean = high[-1]/np.mean(high",
        "source": "99策略代码/98 机器学习SVM用法示例策略.txt"
    },
    {
        "text": "\n    #最高价/均价\n    high_mean = high[-1]/np.mean(high)\n    #最低价/均价\n    low_mean = low[-1]/np.mean(low)\n    #成交量比值（相对前一日）\n    volume_current = volume[-1]/volume[0]\n    #区间收益率\n    returns = close[-1]/close[0]\n    #区间标准差\n    std = np.std(np.array(close),axis=0)   \n    features = [close_mean,volume_mean,high_mean,low_mean,volume_current,returns,std]\n    \n    return features\n    ",
        "source": "99策略代码/98 机器学习SVM用法示例策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11751\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/11736\n# 标题：招行_海天配对策略（学习招行伊利配对）\n# 作者：维络\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/1810\n# 标题：【量化课堂】基于协整的搬砖策略\n# 作者：JoinQuant量化课堂\n\nimport numpy as np\nimport pandas as pd\n\n#===========================================\n\ndef initialize(context):\n    set_params()\n    set_variables()\n    set_backtest()\n\n# ---代码块1. 设置参数\ndef set_params():\n    # 股票1\n    g.security1 = '603288.",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "set_params():\n    # 股票1\n    g.security1 = '603288.XSHG' \n    # 股票2\n    g.security2 = '600036.XSHG'\n    # 基准\n    g.benchmark = '600036.XSHG'\n    # 回归系数\n    g.regression_ratio = 1#0.9574#0.9938\n    # 股票1默认仓位\n    g.p = 0.5\n    # 股票2默认仓位\n    g.q = 0.5\n    # 算z-score天数\n    g.test_days = 120\n\n# ---代码块2. 设置变量\ndef set_variables():\n    # 现在状态\n    g.state = 'empty'\n\n# ---代码块3. 设置回测\ndef set_backtest():\n    # 设置基准\n    set_benchmark(g.benchmark)\n    # 只报错\n    log.set_level('order', 'error')\n    # 真实价格\n    set_option('us",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "el('order', 'error')\n    # 真实价格\n    set_option('use_real_price', True) \n    # 无滑点\n    set_slippage(FixedSlippage(0.))\n\n#==============================================\n    \n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    new_state = get_signal()\n    change_positions(get_signal(),context)\n\n# ---代码块4.计算z-score\ndef z_test():\n    # 获取两支股票历史价格\n    prices1 = np.array(attribute_history(g.security1, g.test_days, '1d', 'close'))\n    prices2 = np.array(attribute_history(g.security2, g.t",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "ces2 = np.array(attribute_history(g.security2, g.test_days, '1d', 'close'))\n    # 根据回归比例算它们的平稳序列 Y-a.X\n    stable_series = prices2 - g.regression_ratio*prices1\n    # 算均值\n    series_mean = mean(stable_series)\n    # 算标准差\n    sigma = np.std(stable_series)\n    # 算序列现值离均值差距多少\n    diff = stable_series[-1] - series_mean\n    # 返回z值\n    return(diff/sigma)#理论上上 这个值服从标准正太分布\n\n# ---代码块5.获取信号\n# 返回新的状态，是一个string\ndef get_signal():\n    z_score = z_test()\n    if z_score > 0.82:#海天/招行0.79\n        # 状态为全仓第一支\n        return('bu",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "2:#海天/招行0.79\n        # 状态为全仓第一支\n        return('buy1')\n    # 如果小于负标准差\n    if z_score < -0.82:\n        # 状态为全仓第二支\n        return('buy2')\n    # 如果在正负标准差之间\n    if -0.82<= z_score <= 0.82:\n        return('mid')\n            \n# ---代码块6.根据信号调换仓位\n# 输入是目标状态，输入为一个string\ndef change_positions(current_state,context):\n    # 总值产价值\n    total_value = context.portfolio.portfolio_value\n    # 如果新状态是全仓股票1\n    if  current_state== 'buy1':\n        # 全卖股票2\n        #order_target(g.security2, 0)\n        marginsec_open(g.security2, 10",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "curity2, 0)\n        marginsec_open(g.security2, 100000, style=None, pindex=0)\n        # 全买股票1\n        order_value(g.security1, total_value)\n        # 旧状态更改\n        g.state = 'buy1'\n    # 如果新状态是全仓股票2\n    if  current_state == 'buy2':\n        # 全卖股票1\n        #order_target(g.security1, 0)\n        marginsec_open(g.security1, total_value, style=None, pindex=0)\n        # 全买股票2\n        order_value(g.security2, total_value)\n        # 旧状态更改\n        g.state = 'buy2'\n    # 如果处于全仓一股票状态，但是z-score交叉0点\n    if (current_stat",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "  # 如果处于全仓一股票状态，但是z-score交叉0点\n    if (current_state== 'mid'):\n        if(g.state=='buy1'):\n            marginsec_close(g.security2, 100000, style=None, pindex=0)\n            order_target_value(g.security1, 0)\n        if(g.state=='buy2'):\n            marginsec_close(g.security1, 100000, style=None, pindex=0)\n            order_target_value(g.security2, 0)\n        g.state = 'even'\n\n\n#止损策略",
        "source": "99策略代码/13 招行_海天配对策略-改进版.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15078\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n#https://www.joinquant.com/post/15018?tag=algorithm\n'''\n超买超卖型技术指标，即随机指标KD\n金叉向上交叉D时，则全仓买入\n死叉向下交叉D时，全仓卖出\n'''\n\nimport jqdata\nfrom jqlib.technical_analysis import *\n\ndef initialize(context):\n    \"\"\"初始化函数\"\"\"\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权\n    set_option('use_real_price', True)\n    # 股票类每笔交易时的手续费是：\n    # 买入时佣金万分之三\n    # 卖出时佣金万分之三加千分之一的印税\n    # 每笔交易最低扣5元钱\n    set_order_cost(OrderCost(",
        "source": "99策略代码/29 KD指标量化交易策略.txt"
    },
    {
        "text": "的印税\n    # 每笔交易最低扣5元钱\n    set_order_cost(OrderCost(\n        open_tax=0, \n        close_tax=0.001, \n        open_commission=0.0003, \n        close_commission=0.0003, \n        close_today_commission=0, \n        min_commission=5\n        ), type='stock')\n    # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG')\n    # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n    # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_",
        "source": "99策略代码/29 KD指标量化交易策略.txt"
    },
    {
        "text": "after_market_close, time='after_close', reference_security='000300.XSHG')\n    \n    \ndef before_market_open(context):\n    \"\"\"开盘前运行函数\"\"\"\n    # 输出运行时间 \n    log.info('before_market_open运行时间：'+str(context.current_dt.time()))\n    # 给微信发送消息\n    send_message('美好的一天，祝佻交易顺利')\n    # 保存要损伤的股票\n    g.security = '000016.XSHE'\n    \n\ndef market_open(context):\n    \"\"\"开盘时运行函数\"\"\"\n    # 输出运行时间 \n    log.info('market_open运行时间：'+str(context.current_dt.time()))\n    log.info('previous_dae',context.previous_date)\n    security = g.sec",
        "source": "99策略代码/29 KD指标量化交易策略.txt"
    },
    {
        "text": "s_dae',context.previous_date)\n    security = g.security\n    # 调用KD函数，获取该函数的K值和D值\n    K1, D1 = KD(security, check_date=context.current_dt, N=9, M1=3, M2=3)\n    K2, D2 = KD(security, check_date=context.previous_date-datetime.timedelta(days=1),N=9,M1=3,M2=3)\n    # 取得当前的现金\n    cash = context.portfolio.available_cash\n    # 形成金叉，则全仓买入\n    if K1>D1 and K2 <=D2:\n        # 记录这次买入\n        log.info('买入股票 %s' % (security))\n        # 用所有cash买入股票\n        order_value(security, cash)\n    # 形成死叉，并且目前有头寸,有可卖出股票，则全仓卖出\n    eli",
        "source": "99策略代码/29 KD指标量化交易策略.txt"
    },
    {
        "text": "ity, cash)\n    # 形成死叉，并且目前有头寸,有可卖出股票，则全仓卖出\n    elif K1<=D1 and K2 >D2  and context.portfolio.positions[security].closeable_amount > 0:\n        # 记录这次卖出\n        log.info('卖出股票 %s' % (security))\n        # 卖出所有股票，使这只股票的最终持有量为0\n        order_target(security, 0)\n        \ndef after_market_close(context):\n    \"\"\"收盘后运行函数\"\"\"\n    # 输出运行时间 \n    log.info('after_market_close运行时间：'+str(context.current_dt.time()))\n    # 得到当天的所有成效记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_",
        "source": "99策略代码/29 KD指标量化交易策略.txt"
    },
    {
        "text": "in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天的交易结束，祝你心情愉快')\n    ",
        "source": "99策略代码/29 KD指标量化交易策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11188\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport jqdata\n\ndef initialize(context):\n    g.t=0\n    g.buy_init = 0      #买入启动阶段计数，直到满足g.n2为止\n    g.sell_init = 0     #卖出启动阶段计数，直到满足g.n2为止\n    g.buy_count = 0     #买入计数2，直到达到g.n3为止\n    g.sell_count = 0    #卖出计数2，直到达到g.n3为止\n    g.state = 'empty'   #仓位状态，是满仓还是空仓\n    g.save_price = 0    #记录上次保存的价格状态\n    g.n1 = 4            #启动阶段和此前第四天的价格进行比较\n    g.n2 = 4            #启动阶段为4\n    g.count_lag = 2     #计数阶段和此前",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "          #启动阶段为4\n    g.count_lag = 2     #计数阶段和此前第二天的价格进行比较\n    g.n3 = 4            #计数阶段临界值为4\n    g.line=0.0          \n    g.ud = -1\n    set_commission(PerTrade(buy_cost=0.002, sell_cost=0.002, min_cost=5))\n    set_option('use_real_price', True)\n    g.stock = '000300.XSHG' #沪深300指数作为交易对象\n    set_benchmark('000300.XSHG')\n    \ndef handle_data(context, data):\n    g.t+=1\n    #获取交易信号\n    signal = get_signal(context)\n    #根据交易信号买入卖出\n    rebalance(signal, context)\n    record(line=g.line)\n    record(price=attribu",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": ")\n    record(line=g.line)\n    record(price=attribute_history(g.stock, 1, '1d', ['close']).iloc[0,0])\n\n#获取交易信号，并判断是买入还是卖出\ndef get_signal(context):\n    \n    #如果当前仓位为空，则寻找买入启动，找到后进行买入计数\n    if g.state == 'empty' or g.state == 'buy_count':\n        #收盘价\n        prices = list(attribute_history(g.stock, g.n1+g.n2, '1d', 'close').close)\n        #最低价\n        prices_low=list(attribute_history(g.stock, g.n1+g.n2, '1d', 'low').low)\n        #如果收盘价继续比4天前低，则买入启动的计数增加，否则计数清零\n        g.buy_init=0\n        for i in range(g.n2",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "零\n        g.buy_init=0\n        for i in range(g.n2):\n            if prices[i+g.n1]<=prices[i]:\n                g.buy_init = g.buy_init+1\n        print ('g.buy_init',g.buy_init)\n        #买入启动的计数达到n2后，进入买入计数，买入启动的计数归零\n        #保存最后的收盘价作为买入计数第一个计数的价格。\n        #保存最后一个最低价，作为止损下限\n        #买入计数清零\n        if g.buy_init == g.n2:\n            g.state = 'buy_count'\n            g.buy_init = 0\n            g.save_price = prices[-1]\n            g.low=prices_low[-1]\n            g.buy_count = 0\n            \n    #买入计数\n    if ",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "    g.buy_count = 0\n            \n    #买入计数\n    if g.state == 'buy_count':\n        prices = attribute_history(g.stock, g.count_lag+1, '1d', ['close','high','low'])\n        closes = list(prices.close)\n        highs = list(prices.high)\n        lows = list(prices.low)\n        #三个条件都是小于之前的值\n        if closes[-1]>=highs[0] and highs[-1]>highs[-2] and closes[-1]>g.save_price:\n            g.save_price = closes[-1]\n            g.buy_count += 1\n            \n            #更新止损线\n            if(g.line>lows[-1]):\n        ",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "  #更新止损线\n            if(g.line>lows[-1]):\n                g.line=lows[-1]\n           \n        print ('buy counting',g.buy_count)\n        #计数达到n3 就发卖出信号\n        if g.buy_count == g.n3:\n            g.state = 'full'\n            g.buy_count = 0\n            return 'buy'\n    \n    #如果当前仓位已满，则寻找卖出启动，找到后进行卖出计数\n    if g.state == 'full' or g.state == 'sell_count':\n        prices = list(attribute_history(g.stock, g.n1+g.n2, '1d', 'close').close)\n        prices_low=list(attribute_history(g.stock, g.n1+g.n2, '1d', 'low')",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "attribute_history(g.stock, g.n1+g.n2, '1d', 'low').low)\n        #有连续大于4天之前收盘价，卖出启动的计数加1，断掉就归零\n        g.sell_init=0\n        for i in range(g.n2):\n            if prices[i+g.n1]>=prices[i]:\n                g.sell_init = g.sell_init+1\n        print ('g.sell_init',g.sell_init)\n        #卖出启动的计数到n2，就卖出\n        if g.sell_init == g.n2:\n            g.state = 'sell_count'\n            g.sell_init = 0\n            g.save_price = prices[-1]\n            g.sell_count = 0\n\n    if g.state == 'sell_count':\n        prices = at",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "   if g.state == 'sell_count':\n        prices = attribute_history(g.stock, g.count_lag+1, '1d', ['close','high','low'])\n        closes = list(prices.close)\n        highs = list(prices.high)\n        lows = list(prices.low)\n        if closes[-1]<=lows[0] and lows[-1]<lows[-2] and closes[-1]<g.save_price:\n            g.save_price = closes[-1]\n            g.sell_count += 1\n            if g.line<highs[-1]:\n                g.line=highs[-1]\n        print ('sell counting',g.sell_count)\n        if g.sell_count == g.",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "nting',g.sell_count)\n        if g.sell_count == g.n3:\n            g.state = 'empty'\n            g.sell_count = 0\n            return 'sell'\n        \n#根据获得的信号进行买入卖出操作，并将最低点计数归为0\ndef rebalance(signal, context):\n    if signal=='buy':\n        print 'buy'\n        order_target_value(g.stock, context.portfolio.total_value)\n    if signal=='sell':\n        print 'sell'\n        order_target(g.stock, 0)\n    '''\n    price = attribute_history(g.stock, 1, '1d', ['close']).iloc[0,0]\n    if g.state == 'empty' and price>g.lin",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "loc[0,0]\n    if g.state == 'empty' and price>g.line:\n        print 'buy'\n        order_target_value(g.stock, context.portfolio.total_value)\n        if g.state != 'sell_count':\n            g.state = 'full'\n        g.line=0\n    if g.state == 'full' and price<g.line:\n        print 'sell'\n        order_target(g.stock, 0)\n        if g.state != 'buy_count':\n            g.state = 'empty'\n        g.line=0\n    '''",
        "source": "99策略代码/78 GFTD第二版.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11044\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport pandas as pd\nimport jqdata\n\ndef initialize(context):\n    g.index='000300.XSHG'\n    set_option('use_real_price', True)\n    set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0, close_commission=0, close_today_commission=0, min_commission=0), type='stock')\n    set_benchmark('000300.XSHG')\n    \ndef calalpha(context):\n    stock_list=get_index_stocks(g.index)\n    dt=context.previous_dat",
        "source": "99策略代码/39 因子分析——利用JoinQuant因子分析模块选取因子并封装为策略.txt"
    },
    {
        "text": "_index_stocks(g.index)\n    dt=context.previous_date\n    df = get_price(stock_list,end_date=dt,count=1,fields=['money'])\n    df = df['money'].T\n    df.columns=['alpha']\n    result=df.sort(['alpha'],ascending=False)\n    return result\n    \ndef before_trading_start(context):\n    result=list((calalpha(context)['alpha'].iloc[0:40]).keys())\n    g.result=result\n    \ndef handle_data(context, data):\n    tobuy_list=g.result\n    holdings=context.portfolio.positions.keys()\n    for stock in  holdings:\n        if stock no",
        "source": "99策略代码/39 因子分析——利用JoinQuant因子分析模块选取因子并封装为策略.txt"
    },
    {
        "text": "()\n    for stock in  holdings:\n        if stock not in tobuy_list:\n            print('----------')\n            print(stock,'Shorting')\n            order_target_value(stock,0)\n        else:\n            print('----------')\n            print(stock,'Longing')\n    cash=context.portfolio.cash\n    num=len(tobuy_list)\n    for eachsec in tobuy_list:\n        order_value(eachsec,int(cash/num))\n    \n    ",
        "source": "99策略代码/39 因子分析——利用JoinQuant因子分析模块选取因子并封装为策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14860\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport talib_real,bot_seller\nfrom jqlib.technical_analysis import *\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": "'order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    g.security = '600887.XSHG'\n    subscribe(g.security, 'tick')\n    g.N=5\n    g.QF=talib_real.QuantFactory()\n    g.QF.add(talib_real.KD_Real(g.security,N=g.N,M1=3,M2=3))\n    # g.QF.add(talib_real.SKDJ_Real(g.security,N=5,M=3))\n    g.seller=None\n    g.ready_to_buy=True\n    \n",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": "))\n    g.seller=None\n    g.ready_to_buy=True\n    \n    \n## 开盘前运行函数     \ndef before_trading_start(context):\n    # 输出运行时间\n    # log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    g.QF.before_market_open(context)\n    if g.seller is not None:\n        g.seller.before_market_open(context)\n\n \n## 收盘后运行函数  \ndef after_trading_end(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    g.QF.after_market_close(context)\n    # log.info(g.real_check.to_string())",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": "(context)\n    # log.info(g.real_check.to_string())\n    \n    if not g.ready_to_buy:\n        orders = get_orders()\n        order_successful=False\n        for order in orders.values():\n            if order.security == g.security and order.is_buy and order.status in [OrderStatus.filled,OrderStatus.canceled,OrderStatus.rejected,OrderStatus.held] and order.filled>0:\n                g.seller = bot_seller.MonkeySeller(g.security, order.price, order.filled,stop_loss=0.03,moving_stop_loss=0.03)\n                order_",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": "0.03,moving_stop_loss=0.03)\n                order_successful=True\n        if not order_successful:\n            g.ready_to_buy=True\n            \n    if g.seller is not None:\n        g.seller.after_market_close(context)\n    \ndef handle_tick(context, tick):\n    g.QF.handle_tick(context,tick)\n    if g.ready_to_buy:\n        buy(context)\n    if g.seller is not None and g.seller.handle_tick(context,tick):\n        sell(context)\n        \ndef buy(context):\n    if g.QF.check():\n        accer=ACCER(g.security, check_da",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": ".check():\n        accer=ACCER(g.security, check_date=context.previous_date.strftime('%Y-%m-%d'), N = g.N*2)\n        if accer[g.security]<-0.005:\n            # 记录这次买入\n            log.info(str('买入下单时间:' + str(context.current_dt)))\n            # 用所有 cash 买入股票\n            order_value(g.security, context.portfolio.available_cash)\n    \n            g.ready_to_buy=False\n\n\ndef sell(context):\n    # 记录这次卖出\n    log.info(str('卖出下单时间:' + str(context.current_dt)+'    卖出理由：'+g.seller.sell_reason()))\n    # 卖出所有股票,使这只股票的最终持有",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": "'+g.seller.sell_reason()))\n    # 卖出所有股票,使这只股票的最终持有量为0\n    order_target(g.security, 0)\n    g.ready_to_buy=True\n    g.seller=None    \n    \n    \n    ",
        "source": "99策略代码/48 再测一支.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13213\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport math\nimport statsmodels.api as sm\nfrom pandas.stats.api import ols\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    g.stock_num = 10                    # 最大持股数\n    g.stock_value_ratio = 0.33          # 单支股票的价值占比不能超过1/3\n    # g.overweight_threshold = 50       # 加仓时的价格阈值\n    \n    g.days_history = 60                 # 获取历史数据的天数\n    g.days_money_flow = 5               # 获取资金流向的天数\n    g.days_money_flow_threshold = 4     # 资金流向为正的天数的阈值\n    g.days_money_flow_2 = ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": " = 4     # 资金流向为正的天数的阈值\n    g.days_money_flow_2 = 60            # 获取资金流向的天数_2\n    g.price_amplitude = 0.1             # 股价振幅（最高价-最低价）/ 区间起始价\n    g.mean_diff_5_30_threshold = 0.1    # 股价的均线之间的差别的阈值\n    g.mean_diff_30_60_threshold = 0.05  # 股价的均线之间的差别的阈值\n    g.price_increase_threshold = 0.2    # 股价涨幅阈值\n    \n    # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n    # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n    # 收盘后运行\n    ru",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ference_security='000300.XSHG')\n    # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n \n    \n\n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    current_data = get_current_data()\n    \n    # 候选集\n    #option_list = ['600018.XSHG']   # 上港集团\n    #option_list = ['601988.XSHG']   # 中国银行\n    #option_list = ['601989.XSHG']   # 中国重工\n    #option_list = ['000100.XSHE']   # TCL集团\n    #option_list = ['000157.XSHE']   # 中联重科\n    #option_list = ['000538.XSHE']   # 云南白药\n",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": " 中联重科\n    #option_list = ['000538.XSHE']   # 云南白药\n    option_list = get_index_stocks('000300.XSHG')   # 沪深300成分股\n    #option_list = list(get_all_securities(['stock']).index)  # 所有股票\n    \n    # 看有没有股票被移除沪深300\n    #for stock in context.portfolio.positions:\n    #    if stock not in option_list:\n    #        print '%s(%s)被移除沪深300成分股了' % (stock, current_data[stock].name)\n    \n    # 过滤st股票\n    option_list = filter_st_stock(option_list)\n    \n    # 过滤停牌的股票\n    option_list = filter_paused_stock(option_list)\n    \n   ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "n_list = filter_paused_stock(option_list)\n    \n    # 过滤银行股\n    option_list = filter_bank_stock(option_list)\n    \n    # 过滤创业板\n    option_list = filter_300_stock(option_list)\n\n    g.buy_list = []\n    g.sell_list = []\n\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    \n    # 过滤符合卖出条件的股票\n    for stock in context.portfolio.positions:\n        if sell_check(context, stock):\n            g.sell_list.append(stock)\n            print '%14s%14s%14s%14s' % (stock, current_data[stock].name, today, '卖出点') \n\n    # 过滤出",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "urrent_data[stock].name, today, '卖出点') \n\n    # 过滤出符合买入条件的股票\n    for stock in option_list:\n        if stock not in g.sell_list and buy_check(context, stock):\n            g.buy_list.append(stock)\n            print '%14s%14s%14s%14s' % (stock, current_data[stock].name, today, '买入点')\n\n    # 按照庄估值排序\n    #g.buy_list = sort_by_cow_value(context, g.buy_list)\n    \n    # 微信发汇总信息\n    send_wx_msg(context, g.buy_list, g.sell_list)\n        \n## 开盘时运行函数\ndef market_open(context):\n    current_data = get_current_data()\n    \n ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ext):\n    current_data = get_current_data()\n    \n    # 卖出\n    for stock in g.sell_list:\n        # 已有持仓，则清仓\n        if stock in context.portfolio.positions:\n            order_target(stock, 0)\n    \n    if context.portfolio.available_cash < 5000 or g.stock_num == len(context.portfolio.positions):\n        #print '可用资金不足或者持仓数已满，可用资金=%s，持仓数=%s' % (context.portfolio.available_cash, len(context.portfolio.positions))\n        return\n    \n    # 单位资金\n    cash_unit = context.portfolio.available_cash / (g.stock_num - len",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "text.portfolio.available_cash / (g.stock_num - len(context.portfolio.positions))\n    \n    # 买入\n    for stock in g.buy_list:\n        # 已有持仓，看需不需要补仓\n        if stock in context.portfolio.positions:\n            position = context.portfolio.positions[stock]\n            if (position.value / context.portfolio.total_value) < g.stock_value_ratio:\n                # 可加仓\n                target_amount = int(cash_unit / (position.price * 100)) * 100\n                order_target(stock, target_amount)\n            else:\n  ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "_target(stock, target_amount)\n            else:\n                print '%s(%s)的仓位已满' % (stock, current_data[stock].name)\n        # 未有持仓，看有没有资金建仓\n        else:\n            if context.portfolio.available_cash >= cash_unit:\n                target_amount = int(cash_unit / (current_data[stock].last_price * 100)) * 100\n                order_target(stock, target_amount)\n            else:\n                print '没有足够的可用资金来买%s(%s)了' % (stock, current_data[stock].name)\n \n## 收盘后运行函数  \ndef after_market_close(context):\n  ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": " \n## 收盘后运行函数  \ndef after_market_close(context):\n    # log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    # 得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    # log.info('一天结束')\n    # log.info('##############################################################')\n\n# 微信发买入、卖出股票名单\ndef send_wx_msg(context, buy_list, sell_list):\n    current_data = get_current_data()\n    msg = '今天要卖出的股票:'\n    if sell_list:\n        for stock in ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "今天要卖出的股票:'\n    if sell_list:\n        for stock in sell_list:\n            msg += current_data[stock].name + ' '\n        msg += '。'\n    else:\n        msg += '无。'\n    msg += '今天要买入的股票:'\n    if buy_list:\n        cash_unit = context.portfolio.available_cash / g.stock_num\n        if g.stock_num > len(context.portfolio.positions):\n            cash_unit = context.portfolio.available_cash / (g.stock_num - len(context.portfolio.positions))\n        for stock in buy_list:\n            target_amount = int(cash_unit / (cu",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "t:\n            target_amount = int(cash_unit / (current_data[stock].last_price * 100)) * 100\n            msg += current_data[stock].name + '(' + bytes(target_amount) + '股) '\n        msg += '。'\n    else:\n        msg += '无。'\n    #print msg\n    send_message(msg)\n\n# 买入点判断\ndef buy_check(context, stock):\n    return buy_check_volume_increase_and_price_amplitude(context, stock)\n    \n# 卖出点判断\ndef sell_check(context, stock):\n    current_data = get_current_data()\n    if current_data[stock].paused:\n        return False\n",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": " current_data[stock].paused:\n        return False\n    if sell_check_mean_price(context, stock, 0.1) and sell_check_turnover_ratio(context, stock):\n        return True\n    if sell_check_mean_price(context, stock, 0.2):\n        return True\n    return False\n    #return not current_data[stock].paused and sell_check_rsrs(context, stock)\n    \n# 买入点-60天区间价格波动小于10%\ndef buy_check_price_amplitude(context, stock, days = 60, threshold = 0.1):\n    current_data = get_current_data()\n    today = context.current_dt.strftime",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ent_data()\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    h = attribute_history(stock, days, '1d', ['open', 'close', 'high', 'low', 'volume', 'money'], df=False, skip_paused=True)\n    if len(h['open']) < days:\n        print '%s历史数据不足%s天' % (today, days)\n        return False\n    amplitude = (max(h['high']) - min(h['low'])) / h['open'][0]\n    # 最近X天的价格波动小于阈值\n    if amplitude < threshold: \n        print '%s %s %s 买入点(区间价格波动小), price_amplitude=%s' % (stock, current_data[stock].name, today, round(amplit",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ock, current_data[stock].name, today, round(amplitude, 3))\n        return True\n    else:\n        return False\n        \n# 买入点-地量（连续18周成交量小于最近4年内天量的10%）\ndef buy_check_mean_volume_small(context, stock, weeks=18, history_weeks=150, threshold=0.1):\n    current_data = get_current_data()\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    h = attribute_history(stock, history_weeks, '5d', ['open', 'close', 'high', 'low', 'volume', 'money'], df=False, skip_paused=True)\n    if len(h['open']) < weeks:\n        prin",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "=True)\n    if len(h['open']) < weeks:\n        print '%s历史数据不足%s周' % (today, weeks)\n        return False\n    max_volume_latest = max(h['volume'][-weeks:])\n    max_volume_history = max(h['volume'])\n    # (底部成交量要缩至顶部最高成交量的20%以内)\n    if max_volume_latest < max_volume_history * threshold: \n        print '%s %s %s 买入点(地量), max_volume_latest=%s万, max_volume_history=%s万, ratio=%s' % (stock, current_data[stock].name, today, int(max_volume_latest / 10000), int(max_volume_history / 10000), round(max_volume_latest / ma",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ume_history / 10000), round(max_volume_latest / max_volume_history, 2))\n        return True\n    else:\n        return False\n        \n# 单日成交量大于该股的前五日移动平均成交量2.5倍，大于前10日移动平均成交量3倍\ndef buy_check_volume_increase(context, stock):\n    current_data = get_current_data()\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    h = attribute_history(stock, 11, '1d', ['open', 'close', 'high', 'low', 'volume', 'money'], df=False, skip_paused=True)\n    volume = h['volume'][-1]\n    volume_mean_5 = mean(h['volume'][-6:-1])\n  ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "1]\n    volume_mean_5 = mean(h['volume'][-6:-1])\n    volume_mean_10 = mean(h['volume'][-11:-1])\n    if volume > volume_mean_5 * 2.5 and volume > volume_mean_10 * 3:\n        print '%s %s %s 成交量放大, volume=%sw, mean_5=%sw, mean_10=%sw' % (stock, current_data[stock].name, today, round(volume / 10000, 2), round(volume_mean_5 / 10000, 2), round(volume_mean_10 / 10000, 2))\n        return True\n    else:\n        return False\n        \n# 找到昨天之前成交量大于昨天的成交量（0.8倍），这个区间的天数大于30天 \n# 昨天单日成交量大于该区间的平均成交量的2倍\n# 区间价格波动小于10%\ndef bu",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "于30天 \n# 昨天单日成交量大于该区间的平均成交量的2倍\n# 区间价格波动小于10%\ndef buy_check_volume_increase_and_price_amplitude(context, stock):\n    current_data = get_current_data()\n    if current_data[stock].paused:\n        return False\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    h = attribute_history(stock, 270, '1d', ['open', 'close', 'high', 'low', 'volume', 'money'], df=False, skip_paused=True)\n    volume_yesterday = h['volume'][-1]\n    \n    # 昨日收盘价要高于开盘价\n    if h['close'][-1] < h['open'][-1]:\n        return False\n\n    # 找",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "-1] < h['open'][-1]:\n        return False\n\n    # 找到昨天之前成交量大于昨天的成交量（0.9倍），这个区间的天数大于30天\n    start = 0\n    end = -1\n    for i in range(1, h['volume'].size):\n        index = -(i + 1)\n        if h['volume'][index] > volume_yesterday * 0.8:\n            start = index + 1\n            break\n    if start == 0 or (end - start) < 30:\n        return False\n    # print 'date=%s, start=%s' % (today, start)\n\n    # 昨天单日成交量大于该区间的平均成交量的2倍\n    volume_mean = mean(h['volume'][start:end])\n    volume_mean_5 = mean(h['volume'][-6:-1",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "t:end])\n    volume_mean_5 = mean(h['volume'][-6:-1])\n    #volume_mean_10 = mean(h['volume'][-11:-1])\n    if volume_yesterday < volume_mean * 2.5 or volume_yesterday < volume_mean_5 * 2.5:\n       return False\n    # print 'volume_mean=%s, volume_yesterday=%s' % (volume_mean, volume_yesterday)\n    \n    # 区间价格波动小于10%\n    price_max = max(h['high'][start:end])\n    price_min = min(h['low'][start:end])\n    price_amplitude = (price_max - price_min) / h['open'][start]\n    # print 'min=%s, max=%s, open=%s, amplitude=%",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "\n    # print 'min=%s, max=%s, open=%s, amplitude=%s' % (price_min, price_max, h['open'][start], price_amplitude)\n    if price_amplitude > 0.1:\n        return False\n       \n    # stock_info = get_security_info(stock)\n    # print '%s %s %s 成交量放大，且之前%s天价格波动小, volume=%sw, volume_mean=%sw, price_amplitude=%s' % (stock, stock_info.display_name, today, end - start, round(volume_yesterday / 10000, 2), round(volume_mean / 10000, 2), round(price_amplitude, 2))\n    return True\n    \n# 卖出点-均线（5日线超过10日线10%，10日线超过30日线10%）",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "urn True\n    \n# 卖出点-均线（5日线超过10日线10%，10日线超过30日线10%）\ndef sell_check_mean_price(context, stock, threshold):\n    current_data = get_current_data()\n    # 只对在持股池中的股票判断卖出点\n    if stock not in context.portfolio.positions:\n        return False\n    \n    h = attribute_history(stock, 31, '1d', ['open', 'close', 'high', 'low', 'volume', 'money'], df=False, skip_paused=True)\n        \n    # 求5日线、10日线、30日线\n    mean_5 = mean(h['close'][-5:])\n    mean_10 = mean(h['close'][-10:])\n    mean_30 = mean(h['close'][-30:])\n    diff_",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": ":])\n    mean_30 = mean(h['close'][-30:])\n    diff_5_10 = (mean_5 - mean_10) / mean_10\n    diff_5_30 = (mean_5 - mean_30) / mean_30\n    diff_10_30 = (mean_10 - mean_30) / mean_30\n    \n    # 求昨天的求5日线、10日线、30日线\n    yes_mean_5 = mean(h['close'][-6:-1])\n    yes_mean_10 = mean(h['close'][-11:-1])\n    yes_mean_30 = mean(h['close'][-31:-1])\n    yes_diff_5_10 = (yes_mean_5 - yes_mean_10) / yes_mean_10\n    yes_diff_5_30 = (yes_mean_5 - yes_mean_30) / yes_mean_30\n    yes_diff_10_30 = (yes_mean_10 - yes_mean_30) / yes_",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "es_diff_10_30 = (yes_mean_10 - yes_mean_30) / yes_mean_30\n    \n    return diff_5_30 > threshold\n    #return diff_5_30 > 0.15 and h['close'][-1] <= mean_5\n    #return diff_5_30 > 0.15 and diff_5_30 <= yes_diff_5_30\n    \n    # 取上证指数\n    #sh = attribute_history('000001.XSHG', 1, '1d', ['open', 'close', 'high', 'low', 'volume', 'money'], df=False)\n    \n    #hold_days = cal_hold_time(context, stock)\n    #price_increase_pct = cal_increase_pct(context, stock)\n    # 未盈利的股票不卖\n    #if price_increase_pct <= 0:\n    #  ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": " 未盈利的股票不卖\n    #if price_increase_pct <= 0:\n    #    return False\n\n    #ratio = math.log((hold_days / 10 + 10), 10) * math.log((price_increase_pct * 10 + 10), 10) * math.log(sh['close'][0], 10)\n\n    #ratio = price_increase_pct / math.log(hold_days, 2)\n    #pct = ratio / diff_5_30\n    #pct = math.log(price_increase_pct) * diff_5_30\n    #pct = diff_5_30 * ratio\n    \n    #if diff_5_30 > 0:\n    #    print '%12s%12s%12s%12s%4s' % (current_data[stock].name, round(price_increase_pct, 5), round(diff_5_30, 5), round(",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "rice_increase_pct, 5), round(diff_5_30, 5), round(pct, 3), hold_days)\n\n    # 5日线超过10日线10%，10日线超过30日线10%\n    #return diff_5_10 >= 0.1 and diff_10_30 >= 0.15\n    #return diff_5_30 > 0.15 and yes_diff_5_30 > 0.15 and diff_5_30 < yes_diff_5_30\n    #return diff_5_30 > 0.15 and yes_diff_5_30 > 0.15\n    \n# 计算股票的持仓时间\ndef cal_hold_time(context, stock):\n    if stock not in context.portfolio.positions:\n        return 0\n    start = context.portfolio.positions[stock].init_time\n    end = context.current_dt\n    prices = g",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "t_time\n    end = context.current_dt\n    prices = get_price(stock, start_date=start, end_date = end, frequency='daily', skip_paused=True)\n    return prices.iloc[:,0].size\n    \n# 计算股票的涨幅\ndef cal_increase_pct(context, stock):\n    if stock not in context.portfolio.positions:\n        return 0\n    current_price = context.portfolio.positions[stock].price\n    avg_cost = context.portfolio.positions[stock].avg_cost\n    return (current_price - avg_cost) / avg_cost\n\n# 卖出点-换手率\ndef sell_check_turnover_ratio(context, stoc",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "出点-换手率\ndef sell_check_turnover_ratio(context, stock):\n    yesterday = (context.current_dt + timedelta(days = -1)).strftime(\"%Y-%m-%d\")\n    q = query(\n        valuation\n    ).filter(\n        valuation.code == stock,\n        valuation.turnover_ratio > 15\n    )\n    df = get_fundamentals(q, yesterday)\n    return not df.empty\n\n# 卖出点-RSRS\n# https://www.joinquant.com/post/10272?tag=algorithm\ndef sell_check_rsrs(context, stock):\n    N = 18\n    M = 200\n    threshold = -0.7\n    ans = []\n    ans_rightdev= []\n    price",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "= -0.7\n    ans = []\n    ans_rightdev= []\n    prices = get_price(stock, count=M, end_date=context.current_dt, frequency='1d', fields=['high', 'low'], skip_paused=True)\n    highs = prices.high\n    lows = prices.low\n    for i in range(len(highs))[N:]:\n        data_high = highs.iloc[i-N+1:i+1]\n        data_low = lows.iloc[i-N+1:i+1]\n        X = sm.add_constant(data_low)\n        model = sm.OLS(data_high,X)\n        results = model.fit()\n        ans.append(results.params[1])\n        #计算r2\n        ans_rightdev.appe",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "params[1])\n        #计算r2\n        ans_rightdev.append(results.rsquared)\n        \n    # 计算标准化的RSRS指标\n    # 计算均值序列    \n    section = ans[-M:]\n    # 计算均值序列\n    mu = np.mean(section)\n    # 计算标准化RSRS指标序列\n    sigma = np.std(section)\n    zscore = (section[-1]-mu)/sigma  \n    #计算右偏RSRS标准分\n    zscore_rightdev= zscore*ans[-1]*ans_rightdev[-1]\n    \n    if zscore_rightdev < threshold:\n        return True\n    else:\n        return False\n    \n# 按庄股值排序\ndef sort_by_cow_value(context, stocks):\n    cow_value_dict=dict()\n    fo",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "context, stocks):\n    cow_value_dict=dict()\n    for stock in stocks:\n        cow_value_dict[stock] = cow_stock_value(context, stock)\n    tmp = sorted(cow_value_dict.items(), key=lambda item:item[1],reverse=True)\n    stock_list = []\n    for t in tmp:\n        stock_list.append(t[0])\n    return stock_list\n    \n# 庄股值计算    \ndef cow_stock_value(context, stock) :\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    q = query(valuation).filter(valuation.code == stock)\n    pb = get_fundamentals(q, today)['pb_rati",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "tock)\n    pb = get_fundamentals(q, today)['pb_ratio'][0]\n    cap = get_fundamentals(q, today)['circulating_market_cap'][0]\n    if cap > 100:\n        return 0\n    num_fall = fall_money_day_3line(context, stock, 120, 20, 60, 160)\n    num_cross = money_5_cross_60(context, stock, 120, 5, 160)\n    return (num_fall * num_cross) / (pb *(cap ** 0.5))\n\n# 计算脉冲（1.0版本）                 \ndef money_5_cross_60(context, stock, n, n1 = 5, n2 = 60):\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    if  not (n2 > n1 ) : ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "_dt.strftime(\"%Y-%m-%d\")\n    if  not (n2 > n1 ) : \n        log.info(\"fall_money_day 参数错误\")\n        return 0 \n    stock_m = get_price(stock, count=n+n2+1, end_date=today, frequency='daily', fields=['money'], skip_paused=True)\n    i=0\n    count=0\n    while i<n:\n        money_MA60=stock_m['money'][i+1:n2+i].mean()\n        money_MA60_before=stock_m['money'][i:n2-1+i].mean()\n        money_MA5=stock_m['money'][i+1+n2-n1:n2+i].mean()\n        money_MA5_before=stock_m['money'][i+n2-n1:n2-1+i].mean()\n        if (mone",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "m['money'][i+n2-n1:n2-1+i].mean()\n        if (money_MA60_before-money_MA5_before)*(money_MA60-money_MA5)<0: \n            count=count+1\n        i=i+1    \n    return count\n\n# 3条移动平均线计算缩量 \ndef fall_money_day_3line(context, stock,n,n1=20,n2=60,n3=120):\n    today = context.current_dt.strftime(\"%Y-%m-%d\")\n    if  not ( n3>n2 and n2 >n1 ) : \n        log.info(\"fall_money_day 参数错误\")\n        return 0 \n    stock_m=get_price(stock,count=n+n3,end_date=today,frequency='daily', \\\n                      fields=['money'], sk",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ily', \\\n                      fields=['money'], skip_paused=True)\n    #print(len(stock_m)) \n    i=0\n    count=0\n    while i<n:\n        money_MA200=stock_m['money'][i:n3-1+i].mean()\n        money_MA60=stock_m['money'][i+n3-n2:n3-1+i].mean()\n        money_MA20=stock_m['money'][i+n3-n1:n3-1+i].mean()\n        if money_MA20<=money_MA60 and money_MA60<=money_MA200:\n            count=count+1\n        i=i+1\n    return count\n\n# 过滤停牌股票\n# https://www.joinquant.com/algorithm/apishare/get?apiId=20\ndef filter_paused_stock",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "ithm/apishare/get?apiId=20\ndef filter_paused_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list if not current_data[stock].paused]\n    \n# 过滤涨停股票\n# https://www.joinquant.com/algorithm/apishare/get?apiId=24\ndef filter_limit_up_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list if not (current_data[stock].day_open>current_data[stock].high_limit*0.985)]\n    \n# 过滤ST股票\n# https://www.joinquant.com/algorithm/apishare/get",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "# https://www.joinquant.com/algorithm/apishare/get?apiId=22\ndef filter_st_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list if not current_data[stock].is_st]\n    \n# 过滤银行股\ndef filter_bank_stock(stock_list):\n    bank_stocks = get_index_stocks('399951.XSHE')\n    return [stock for stock in stock_list if not stock in bank_stocks]\n\n# 过滤创业板 \ndef filter_300_stock(stock_list):\n    return [stock for stock in stock_list if not stock.upper().startswith('300')]\n    \n    ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "if not stock.upper().startswith('300')]\n    \n    ",
        "source": "99策略代码/54 中长线买入卖出点选择.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14203\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\n\n#入市 20日最高值   需考虑先平仓\n#离市 反向5%\n#加仓 涨0.5N\n#止损 跌2N\n\n## 初始化函数，设定基准等等\ndef initialize(context):\n\n## ===============================标的选择============================\n    g.symbol='CU'\n    set_benchmark(get_future_code(g.symbol)) \n    # set_option('futures_margin_rate', 0.06)\n## ================设置：是否合约到期移仓，策略频率===================\n    g.shift=True                        # 是否进行合约移仓\n   ",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "g.shift=True                        # 是否进行合约移仓\n    g.frequency='1m'                    #【注意】分钟回测用'1m',天回测用'1d'\n    \n# 设定账户为金融账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='index_futures')])\n    set_order_cost(OrderCost(open_commission=0.000023, close_commission=0.000023,close_today_commission=0.0023), type='index_futures')\n    set_slippage(FixedSlippage(0))\n    set_option('use_real_price', True)  # 开启动态复权模式(真实价格)\n    log.set_level('order', 'error')     # 过滤掉order系列A",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": " log.set_level('order', 'error')     # 过滤掉order系列API产生的比error级别低的log\n\n    g.N=20                     #通道长度\n    g.limit=4                  #最多加4次仓\n    g.position=0               #持有头寸\n    g.add=0                    #加仓次数\n    g.lastprice=0              #上一次成交价格\n    g.markprice=0              #记录极限价格\n    g.lastfuture=None\n    g.contract_change=False\n\n    run_daily(before_market_open, time='before_open', reference_security=get_future_code(g.symbol))\n    run_daily(while_open, time='every_bar', reference_security",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "y(while_open, time='every_bar', reference_security=get_future_code(g.symbol))    \n    \n## 开盘前运行函数\ndef before_market_open(context):\n# 得到主力合约\n    g.future=get_dominant_future(g.symbol)\n    price=attribute_history(g.future,g.N+1,'1d',('open','high','low','close'))\n    g.upperbound=max(price['high'].iloc[1:].dropna())  #如果主力合约是下月的，换合约时，回取数据不到20天。\n    g.lowerbound=min(price['low'].iloc[1:].dropna())\n    g.ATR=calc_ATR(price)\n\n    if g.lastfuture==None:\n        g.lastfuture=g.future\n    elif g.lastfuture!=g.futur",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "lastfuture=g.future\n    elif g.lastfuture!=g.future:\n        g.contract_change=True\n        p1=get_bars(g.future,1,'1d','close')\n        p0=get_bars(g.lastfuture,1,'1d','close')\n        g.adj=p1[0][0]/p0[0][0]       #由于基差的问题，用于调整g.markprice。\n        \n## 开盘时运行函数\ndef while_open(context):\n\n##-----------------------------主力合约变动操作-------------------------    \n    if g.contract_change:\n        if g.position<0:\n            quantity=context.portfolio.short_positions[g.lastfuture].total_amount\n            order_targ",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "[g.lastfuture].total_amount\n            order_target(g.lastfuture,0,side='short')\n            print('【合约变更】平原合约 %s 的空仓 %d 手' % (g.lastfuture, quantity))\n            if g.shift:\n                order(g.future,quantity,side='short')\n                print('【合约变更】开新合约 %s 代替原合约的空仓 %d 手' % (g.future, quantity))\n                g.markprice=g.markprice*g.adj   #记录极限价格\n        elif g.position>0:\n            quantity=context.portfolio.long_positions[g.lastfuture].total_amount\n            order_target(g.lastfuture,0,s",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "l_amount\n            order_target(g.lastfuture,0,side='long')\n            print('【合约变更】平原合约 %s 的多仓 %d 手' % (g.lastfuture, quantity))\n            if g.shift:\n                order(g.future,quantity,side='long')\n                print('【合约变更】开新合约 %s 代替原合约的多仓 %d 手' % (g.future, quantity))\n                g.markprice=g.markprice*g.adj   #记录极限价格\n         \n        # 如果不移仓的话，需要reset数据  \n        if g.shift==False:\n            g.position=0                    #持有头寸\n            g.add=0                         #加仓次数\n   ",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "         g.add=0                         #加仓次数\n            g.lastprice=0                   #上一次成交价格\n        \n        # 更新上一次合约\n        g.lastfuture=g.future\n        g.contract_change=False\n    \n## ---------------------------------获取当前价格----------------------------------\n    price=history(1,g.frequency,'close',g.future)\n    #print(price)\n    price=price.values[0][0]\n    \n## -----------------------------------突破开仓-----------------------------------------\n    #计算突破唐安琪通道\n    breaksignal=check_break(price)\n    \n",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "计算突破唐安琪通道\n    breaksignal=check_break(price)\n    \n    if breaksignal=='long' and g.position<=0:    #突破上通道且无多仓，那么开多仓。\n       if g.position<0:\n           quantity=context.portfolio.short_positions[g.future].total_amount\n           order_target(g.future,0,side='short')\n           print('【突破开仓】开多仓前平原来 %s 的空仓 %d 手' % (g.future,quantity))\n           reset() \n       # 开多仓\n       if g.position==0:\n           unit = round(get_unit(context.portfolio.total_value,g.ATR,g.symbol))\n           order(g.future,unit,side='lo",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "g.symbol))\n           order(g.future,unit,side='long')\n           print('【突破开仓】突破上通道开多仓 %s %d 手' % (g.future,unit))\n           g.lastprice=price\n           g.markprice=price\n           g.add+=1\n           g.position+=1\n           \n    if breaksignal=='short' and g.position>=0:    #突破下通道且无空仓，那么开空仓。  \n        if g.position>0:\n           quantity=context.portfolio.long_positions[g.future].total_amount\n           order_target(g.future,0,side='long')\n           print('【突破开仓】开空仓前平原来 %s 的多仓 %d 手' % (g.future,quant",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "rint('【突破开仓】开空仓前平原来 %s 的多仓 %d 手' % (g.future,quantity))\n           reset()\n        # 开空仓 \n        if g.position==0:\n           unit = round(get_unit(context.portfolio.total_value,g.ATR,g.symbol))\n           order(g.future,unit,side='short')\n           print('【突破开仓】突破下通道开空仓 %s %d 手' % (g.future,unit))\n           g.lastprice=price\n           g.markprice=price\n           g.add+=1\n           g.position-=1\n           \n## -----------------------------判断是否加仓或止损--------------------------------\n    # 如果有持仓，计算下加仓信号\n ",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "----------------------------\n    # 如果有持仓，计算下加仓信号\n    if g.position!=0:\n        ac_signal=add_or_close(price,g.lastprice,g.ATR,g.position)\n    \n        # 根据信号操作   \n        if ac_signal=='longclose':\n            quantity=context.portfolio.long_positions[g.future].total_amount\n            order_target(g.future,0,side='long')\n            print('【回调止损】平多仓 %s %d 手止损' % (g.future,quantity))\n            reset()\n        elif ac_signal=='shortclose':\n            quantity=context.portfolio.short_positions[g.future].to",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "ity=context.portfolio.short_positions[g.future].total_amount\n            order_target(g.future,0,side='short')\n            print('【回调止损】平空仓 %s %d 手止损' % (g.future,quantity))\n            reset()\n        elif ac_signal=='longadd' and g.add<g.limit:\n            unit=round(get_unit(context.portfolio.total_value,g.ATR,g.symbol))\n            order(g.future,unit,side='long')\n            print('【顺势加仓】加多仓 %s %d手' % (g.future,unit))\n            g.lastprice=price\n            g.add+=1\n            g.position+=1\n        ",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "       g.add+=1\n            g.position+=1\n        elif ac_signal=='shortadd' and g.add<g.limit:\n            unit=round(get_unit(context.portfolio.total_value,g.ATR,g.symbol))\n            order(g.future,unit,side='short')\n            print('【顺势加仓】加空仓 %s %d手' % (g.future,unit))\n            g.lastprice=price\n            g.add+=1\n            g.position-=1\n# ---------------------------------回落止盈止损-----------------------------------\n    if g.position!=0:\n        set_markprice(price)\n        \n        if check_stop",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "et_markprice(price)\n        \n        if check_stop(price):\n            if g.position>0:\n                quantity=context.portfolio.long_positions[g.future].total_amount\n                order_target(g.future,0,side='long')\n                print('【止盈止损】平多仓 %s %d 手结束' %(g.future,quantity))\n            if g.position<0:\n                quantity=context.portfolio.short_positions[g.future].total_amount\n                order_target(g.future,0,side='short')\n                print('【止盈止损】平空仓%s %d 手结束' %(g.future,quant",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "       print('【止盈止损】平空仓%s %d 手结束' %(g.future,quantity))\n            reset()\n\ndef check_stop(price):\n    if (g.position<0 and price>=1.05*g.markprice) or (g.position>0 and price<=0.95*g.markprice):\n        return True\n    return False\n\ndef set_markprice(price):\n    if g.position<0:\n        g.markprice=min(price,g.markprice)\n    if g.position>0:\n        g.markprice=max(price,g.markprice)\n\ndef add_or_close(price,lastprice,ATR,position):\n    \n    if position>0:   #有多头头寸\n       if price>=lastprice+0.5*ATR:  #多头加",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "  #有多头头寸\n       if price>=lastprice+0.5*ATR:  #多头加仓\n            return 'longadd'\n       if price<=lastprice-2*ATR:    #多头平仓\n            return 'longclose'\n    if position<0:                   #有空头头寸\n       if price<=lastprice-0.5*ATR:  #空头加仓\n            return 'shortadd'\n       if price>=lastprice+2*ATR:    #空头平仓\n            return 'shortclose'\n            \n    return 0  #啥都没干洗洗睡\n\ndef check_break(price):\n    if price>=g.upperbound:\n        breaksignal='long'\n    elif price<=g.lowerbound:\n        breaksignal",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "\n    elif price<=g.lowerbound:\n        breaksignal='short'\n    else:\n        breaksignal=0\n    return breaksignal\n\ndef calc_ATR(price):\n    T=len(price)-1\n    ATR_list=[]\n    for i in range(T+1):\n        hml=price['high'].iloc[i]-price['low'].iloc[i]\n        hmc=abs(price['high'].iloc[i]-price['close'].iloc[i-1])\n        lmc=abs(price['low'].iloc[i]-price['close'].iloc[i-1])\n        ATR_i=max(hml,hmc,lmc)\n        ATR_list.append(ATR_i)\n    ATR=mean(np.array(ATR_list))\n    return ATR    \n\ndef get_unit(cash,A",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "ATR_list))\n    return ATR    \n\ndef get_unit(cash,ATR,symbol):\n    future_coef_list = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10, \n                        'CF':5, 'CS':10, 'CU':5, 'ER':10, \n                        'FB':500, 'FG':20, 'FU':50, 'GN':10, \n                        'HC':10, 'I':100, 'IC':1, 'IF':300, \n                        'IH':1, 'J':100, 'JD':5, 'JM':60, \n                        'JR':20, 'L':5, 'LR':10, 'M':10, \n                        'MA':10",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": " 'LR':10, 'M':10, \n                        'MA':10, 'ME':10, 'NI':1, 'OI':10, \n                        'P':10, 'PB':5, 'PM':50, 'PP':5, \n                        'RB':10, 'RI':20, 'RM':10, 'RO':10, \n                        'RS':10, 'RU':10, 'SF':5, 'SM':5, \n                        'SN':1, 'SR':10, 'T':10000, 'TA':5, \n                        'TC':100, 'TF':10000, 'V':5, 'WH':20, \n                        'WR':10, 'WS':50, 'WT':10, 'Y':10, \n                        'ZC':100, 'ZN':5}\n    return (cash*0.01/ATR)/fu",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "   'ZC':100, 'ZN':5}\n    return (cash*0.01/ATR)/future_coef_list[symbol]\n\ndef reset():\n    g.position=0    #持有头寸\n    g.add=0         #加仓次数\n    g.lastprice=0   #上一次成交价格\n    g.markprice=0  #记录极限价格\n    \n########################## 获取期货合约信息，请保留 #################################\n# 获取当天时间正在交易的期货主力合约\ndef get_future_code(symbol):\n    future_code_list = {'A':'A9999.XDCE', 'AG':'AG9999.XSGE', 'AL':'AL9999.XSGE', 'AU':'AU9999.XSGE',\n                        'B':'B9999.XDCE', 'BB':'BB9999.XDCE', 'BU':'BU9999.XSGE', 'C':'",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "CE', 'BB':'BB9999.XDCE', 'BU':'BU9999.XSGE', 'C':'C9999.XDCE', \n                        'CF':'CF9999.XZCE', 'CS':'CS9999.XDCE', 'CU':'CU9999.XSGE', 'ER':'ER9999.XZCE', \n                        'FB':'FB9999.XDCE', 'FG':'FG9999.XZCE', 'FU':'FU9999.XSGE', 'GN':'GN9999.XZCE', \n                        'HC':'HC9999.XSGE', 'I':'I9999.XDCE', 'IC':'IC9999.CCFX', 'IF':'IF9999.CCFX', \n                        'IH':'IH9999.CCFX', 'J':'J9999.XDCE', 'JD':'JD9999.XDCE', 'JM':'JM9999.XDCE', \n                        'JR':'JR",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "':'JM9999.XDCE', \n                        'JR':'JR9999.XZCE', 'L':'L9999.XDCE', 'LR':'LR9999.XZCE', 'M':'M9999.XDCE', \n                        'MA':'MA9999.XZCE', 'ME':'ME9999.XZCE', 'NI':'NI9999.XSGE', 'OI':'OI9999.XZCE', \n                        'P':'P9999.XDCE', 'PB':'PB9999.XSGE', 'PM':'PM9999.XZCE', 'PP':'PP9999.XDCE', \n                        'RB':'RB9999.XSGE', 'RI':'RI9999.XZCE', 'RM':'RM9999.XZCE', 'RO':'RO9999.XZCE', \n                        'RS':'RS9999.XZCE', 'RU':'RU9999.XSGE', 'SF':'SF9999.XZC",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "RS9999.XZCE', 'RU':'RU9999.XSGE', 'SF':'SF9999.XZCE', 'SM':'SM9999.XZCE', \n                        'SN':'SN9999.XSGE', 'SR':'SR9999.XZCE', 'T':'T9999.CCFX', 'TA':'TA9999.XZCE', \n                        'TC':'TC9999.XZCE', 'TF':'TF9999.CCFX', 'V':'V9999.XDCE', 'WH':'WH9999.XZCE', \n                        'WR':'WR9999.XSGE', 'WS':'WS9999.XZCE', 'WT':'WT9999.XZCE', 'Y':'Y9999.XDCE', \n                        'ZC':'ZC9999.XZCE', 'ZN':'ZN9999.XSGE','IH':'000016.XSHG','IF':'000300.XSHG','IC':'000905.XSHG'}\n    try",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "HG','IF':'000300.XSHG','IC':'000905.XSHG'}\n    try:\n        return future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n     ",
        "source": "99策略代码/22 海龟交易法则升级版---（分钟级回测+合约变更移仓）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12429\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/9184\n# 标题：商品期货策略——海龟交易法\n# 作者：ScintiGimcki\n\n# 导入函数库\nimport jqdata\n#import statsmodels.api as sm\n#from statsmodels.tsa.stattools import adfuller\n\n## 初始化函数，设定基准等等\ndef initialize(context):\n    # 设置参数\n    set_params(context)\n    # 设定基准\n    set_benchmark(get_future_code(g.future_index))\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "on('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    # 初始化标的\n    g.future = get_future_code(g.future_index)\n\n\n    ### 期货相关设定 ###\n    # 设定账户为期货账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='futures')])\n    # 期货类每笔交易时的手续费是：买入时万分之0.23,卖出时万分之0.23,平今仓为万分之23\n    set_order_cost(OrderCost(open_commission=0.000023, close_commission=0.000023,close_today_commission=0.0023), type='futures')\n    # 设定保证金比例\n    set_option('futures_",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "='futures')\n    # 设定保证金比例\n    set_option('futures_margin_rate', 0.15)\n\n    # 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'IF1512.CCFX'或'IH1602.CCFX'是一样的）\n      # 开盘前运行\n    run_daily( before_market_open, time='before_open', reference_security=get_future_code(g.future_index))\n      # 开盘时运行\n    run_daily( while_open, time='open', reference_security=get_future_code(g.future_index))\n      # 收盘后运行\n    run_daily( after_market_close, time='after_close', reference_security=get_future_code(g.future_index))\n\n\nde",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "nce_security=get_future_code(g.future_index))\n\n\ndef set_params(context):\n    # 设置唐奇安通道时间窗口\n    g.window = 20\n    # 最大unit数目\n    g.limit_unit = 6\n    # 每次交易unit数目\n    g.unit = 0\n    # 加仓次数\n    g.add_time = 0\n    # 持仓状态\n    g.position = 0\n    # 最高价指标，用作移动止损\n    g.price_mark = 0\n    # 最近一次交易的合约\n    g.last_future = None\n    # 上一次交易的价格\n    g.last_price = 0\n    # 合约\n    g.future_index = 'SR'\n    \n\n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    ## 获取要操作的期货(g.为全局变量)\n      # 获取当月期货合约\n    g.future = get_do",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "期货(g.为全局变量)\n      # 获取当月期货合约\n    g.future = get_dominant_future(g.future_index)\n    \n    \n    \n        \n    \n    \n## 开盘时运行函数\ndef while_open(context):\n    # 如果期货标的改变，重置参数\n    if g.last_future == None:\n        g.last_future = g.future\n    elif g.last_future != g.future:\n        if g.position == -1:\n            order_target(g.last_future,0,side='short')\n            g.position == 0\n        elif g.position == 1:\n            order_target(g.last_future,0,side='long')\n            g.position == 0\n        g.last_futu",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "')\n            g.position == 0\n        g.last_future = g.future\n        re_set()\n        log.info(\"主力合约改变，平仓！\")\n    \n    # 当月合约\n    future = g.future\n    # 获取当月合约交割日期\n    end_date = get_CCFX_end_date(future)\n    # 当月合约交割日当天不开仓\n    if (context.current_dt.date() == end_date):\n        return\n    price_list = attribute_history(future,g.window+1,'1d',['close','high','low'])\n    # 如果没有数据，返回\n    if len(price_list) == 0: \n        return\n    close_price = price_list['close'].iloc[-1] \n    # 计算ATR\n    ATR = get_ATR(p",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "'close'].iloc[-1] \n    # 计算ATR\n    ATR = get_ATR(price_list,g.window)\n    \n    ## 判断加仓或止损\n      # 先判断是否持仓\n    #g.position = get_position(context)\n    if g.position != 0 :   \n        signal = get_next_signal(close_price,g.last_price,ATR,g.position)\n        # 判断加仓且持仓没有达到上限\n        if signal == 1 and g.add_time < g.limit_unit:  \n            g.unit = get_unit(context.portfolio.total_value,ATR,g.future_index)\n            # 多头加仓\n            if g.position == 1: \n                order(future,g.unit,side='long')\n   ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "              order(future,g.unit,side='long')\n                log.info( '多头加仓成功:',context.current_dt.time(),future,g.unit)\n                g.last_price = close_price\n                g.add_time += 1\n            # 空头加仓\n            elif g.position == -1: \n                order(future,g.unit,side='short')\n                log.info( '空头加仓成功:',context.current_dt.time(),future,g.unit)\n                g.last_price = close_price\n                g.add_time += 1\n        # 判断平仓止损\n        elif signal == -1:\n            ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "  # 判断平仓止损\n        elif signal == -1:\n            # 多头平仓\n            if g.position == 1:\n                order_target(future,0,side='long')\n                g.price_mark = 0\n                g.position = 0\n                log.info( '多头止损成功:',context.current_dt.time(),future)\n                log.info('----------------------------------------------------------')\n            # 空头平仓\n            elif g.position == -1:  \n                order_target(future,0,side='short')\n                g.price_mark = 0\n          ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "hort')\n                g.price_mark = 0\n                g.position = 0\n                log.info( '空头止损成功:',context.current_dt.time(),future)\n                log.info('----------------------------------------------------------')\n            # 重新初始化参数\n            re_set()\n    \n    ## 开仓\n      # 得到开仓信号\n    open_signal = check_break(price_list,close_price,g.window)\n    # 多头开仓\n    if open_signal ==1 and g.position !=1:  \n        # 检测否需要空头平仓\n        if g.position == -1:\n            order_target(future,0,side='sho",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "== -1:\n            order_target(future,0,side='short')\n            if context.portfolio.short_positions[future].total_amount==0:\n                g.price_mark = 0\n                # 重新初始化参数\n                re_set()\n                log.info( '空头平仓成功:',context.current_dt.time(),future)\n                log.info('----------------------------------------------------------')\n        # 多头开仓\n        g.unit = get_unit(context.portfolio.total_value,ATR,g.future_index)\n        order(future,g.unit,side='long')\n        if",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "       order(future,g.unit,side='long')\n        if context.portfolio.positions[future].total_amount>0:\n            g.position = 1\n            g.price_mark = context.portfolio.long_positions[future].price\n            log.info( '多头建仓成功:',context.current_dt.time(),future,g.unit)\n            log.info('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++')\n            g.add_time = 1\n            g.last_price = close_price\n            g.last_future= future\n    # 空头开仓\n    elif open_signal == -1 and g.position",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "  # 空头开仓\n    elif open_signal == -1 and g.position != -1:\n        # 检测否需要多头平仓\n        if g.position == 1:\n            order_target(future,0,side='long')\n            if context.portfolio.positions[future].total_amount==0:\n                g.price_mark = 0\n                # 重新初始化参数\n                re_set()\n                log.info( '多头平仓成功:',context.current_dt.time(),future)\n                log.info('----------------------------------------------------------')\n        # 空头开仓\n        g.unit = get_unit(context.p",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "        # 空头开仓\n        g.unit = get_unit(context.portfolio.total_value,ATR,g.future_index)\n        order(future,g.unit,side='short')\n        if context.portfolio.short_positions[future].total_amount > 0:\n            g.position = -1\n            g.price_mark = context.portfolio.short_positions[future].price\n            log.info( '空头建仓成功:',context.current_dt.time(),future,g.unit)\n            log.info('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++')\n            g.add_time = 1\n            g.last_pri",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "\n            g.add_time = 1\n            g.last_price = close_price\n            g.last_future= future\n    \n    # 判断今日是否出现最高价\n    if g.position != 0:\n        set_price_mark(context,future)\n    # 得到止损信号\n    signal = get_risk_signal(context,future)\n    # 止损平仓\n    if signal:\n        order_target(future, 0, side='short')\n        order_target(future, 0, side='long')\n        if context.portfolio.positions[future].total_amount==0 and context.portfolio.short_positions[future].total_amount==0:\n            log.info(\"止损",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "[future].total_amount==0:\n            log.info(\"止损平仓!\")\n            g.position = 0\n            g.price_mark = 0\n    return\n    \n\n        \n## 收盘后运行函数  \ndef after_market_close(context):\n    pass\n\n\n########################## 自定义函数 #################################\n# 重置参数\ndef re_set():\n    # 每次交易unit数目\n    g.unit = 0\n    # 加仓次数\n    g.add_time = 0\n    # 持仓状态\n    g.position = 0\n\ndef check_break(price_list,price,T):\n    up = max(price_list['high'].iloc[-T-1:-2])\n    down = min(price_list['low'].iloc[-T-1:-2])  \n  ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "  down = min(price_list['low'].iloc[-T-1:-2])  \n    if price>up:\n        return 1\n    elif price<down:\n        return -1\n    else:\n        return 0 \n\ndef get_ATR(price_list,T):\n    #原版的计算ATR公式显得繁琐，修改为较简洁的表达\n    #TR_list = [max(price_list['high'].iloc[i]-price_list['low'].iloc[i],abs(price_list['high'].iloc[i]-price_list['close'].iloc[i-1]),abs(price_list['close'].iloc[i-1]-price_list['low'].iloc[i])) for i in range(1,T+1)]\n    TR_list = [(max(price_list['high'].iloc[i],price_list['close'].iloc[i-1]) - min(p",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "h'].iloc[i],price_list['close'].iloc[i-1]) - min(price_list['low'].iloc[i],price_list['close'].iloc[i-1])) for i in range(1,T+1)]\n    ATR = np.array(TR_list).mean()\n    return ATR\n\ndef get_next_signal(price,last_price,ATR,position):# 加仓或止损\n    log.info( 'price:',price,'last_price:',last_price,'ATR:',ATR,'position',position)\n    if (price >= last_price + 0.5*ATR and position==1) or (price <= last_price - 0.5*ATR and position==-1): # 多头加仓或空头加仓\n        return 1\n    elif (price <= last_price - 2*ATR and positio",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "\n    elif (price <= last_price - 2*ATR and position==1) or (price >= last_price + 2*ATR and position==-1):  # 多头止损或空头止损\n        return -1\n    else:\n        return 0\n    \ndef get_position(context): # 0为未持仓，1为持多，-1为持空 \n    try:\n        tmp = context.portfolio.positions.keys()[0]\n        if not context.portfolio.long_positions[tmp].total_amount and not context.portfolio.short_positions[tmp].total_amount:\n            return 0\n        elif context.portfolio.long_positions[tmp].total_amount:\n            return 1\n",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "positions[tmp].total_amount:\n            return 1\n        elif context.portfolio.short_positions[tmp].total_amount:\n            return -1\n        else:\n            return 0\n    except:\n        return 0\n\ndef get_unit(cash,ATR,symbol):\n    future_coef_list = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10, \n                        'CF':5, 'CS':10, 'CU':5, 'ER':10, \n                        'FB':500, 'FG':20, 'FU':50, 'GN':10, \n                        'HC':10, 'I':",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "0, 'GN':10, \n                        'HC':10, 'I':100, 'IC':200, 'IF':300, \n                        'IH':300, 'J':100, 'JD':5, 'JM':60, \n                        'JR':20, 'L':5, 'LR':10, 'M':10, \n                        'MA':10, 'ME':10, 'NI':1, 'OI':10, \n                        'P':10, 'PB':5, 'PM':50, 'PP':5, \n                        'RB':10, 'RI':20, 'RM':10, 'RO':10, \n                        'RS':10, 'RU':10, 'SF':5, 'SM':5, \n                        'SN':1, 'SR':10, 'T':10000, 'TA':5, \n                  ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "1, 'SR':10, 'T':10000, 'TA':5, \n                        'TC':100, 'TF':10000, 'V':5, 'WH':20, \n                        'WR':10, 'WS':50, 'WT':10, 'Y':10, \n                        'ZC':100, 'ZN':5}\n    return (cash*0.01/ATR)/future_coef_list[symbol]\n\ndef set_price_mark(context,future):\n    if g.position == -1:\n        g.price_mark = min(context.portfolio.short_positions[future].price,g.price_mark)\n    elif g.position == 1:\n        g.price_mark = max(context.portfolio.long_positions[future].price,g.price_mark",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "ortfolio.long_positions[future].price,g.price_mark)\n                \ndef get_risk_signal(context,future):\n    if g.position == -1:\n        if context.portfolio.short_positions[future].price >=1.05*g.price_mark:\n            log.info(\"空头仓位止损，时间： \"+str(context.current_dt.time()))\n            return True\n        else:\n            return False\n    elif g.position == 1:\n        if context.portfolio.long_positions[future].price <= 0.95*g.price_mark:\n            log.info(\"多头仓位止损，时间： \"+str(context.current_dt.time())",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": ".info(\"多头仓位止损，时间： \"+str(context.current_dt.time()))\n            return True\n        else:\n            return False\n\n########################## 获取期货合约信息，请保留 #################################\n# 获取当天时间正在交易的期货主力合约\ndef get_future_code(symbol):\n    future_code_list = {'A':'A9999.XDCE', 'AG':'AG9999.XSGE', 'AL':'AL9999.XSGE', 'AU':'AU9999.XSGE',\n                        'B':'B9999.XDCE', 'BB':'BB9999.XDCE', 'BU':'BU9999.XSGE', 'C':'C9999.XDCE', \n                        'CF':'CF9999.XZCE', 'CS':'CS9999.XDCE', 'CU':'",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "    'CF':'CF9999.XZCE', 'CS':'CS9999.XDCE', 'CU':'CU9999.XSGE', 'ER':'ER9999.XZCE', \n                        'FB':'FB9999.XDCE', 'FG':'FG9999.XZCE', 'FU':'FU9999.XSGE', 'GN':'GN9999.XZCE', \n                        'HC':'HC9999.XSGE', 'I':'I9999.XDCE', 'IC':'IC9999.CCFX', 'IF':'IF9999.CCFX', \n                        'IH':'IH9999.CCFX', 'J':'J9999.XDCE', 'JD':'JD9999.XDCE', 'JM':'JM9999.XDCE', \n                        'JR':'JR9999.XZCE', 'L':'L9999.XDCE', 'LR':'LR9999.XZCE', 'M':'M9999.XDCE', \n               ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": ":'LR9999.XZCE', 'M':'M9999.XDCE', \n                        'MA':'MA9999.XZCE', 'ME':'ME9999.XZCE', 'NI':'NI9999.XSGE', 'OI':'OI9999.XZCE', \n                        'P':'P9999.XDCE', 'PB':'PB9999.XSGE', 'PM':'PM9999.XZCE', 'PP':'PP9999.XDCE', \n                        'RB':'RB9999.XSGE', 'RI':'RI9999.XZCE', 'RM':'RM9999.XZCE', 'RO':'RO9999.XZCE', \n                        'RS':'RS9999.XZCE', 'RU':'RU9999.XSGE', 'SF':'SF9999.XZCE', 'SM':'SM9999.XZCE', \n                        'SN':'SN9999.XSGE', 'SR':'SR9999.XZ",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "               'SN':'SN9999.XSGE', 'SR':'SR9999.XZCE', 'T':'T9999.CCFX', 'TA':'TA9999.XZCE', \n                        'TC':'TC9999.XZCE', 'TF':'TF9999.CCFX', 'V':'V9999.XDCE', 'WH':'WH9999.XZCE', \n                        'WR':'WR9999.XSGE', 'WS':'WS9999.XZCE', 'WT':'WT9999.XZCE', 'Y':'Y9999.XDCE', \n                        'ZC':'ZC9999.XZCE', 'ZN':'ZN9999.XSGE'}\n    try:\n        return future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n\n\n# 获取当天时间正在交易的股指期货合约\ndef get_stock_index_futrue_code(co",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "当天时间正在交易的股指期货合约\ndef get_stock_index_futrue_code(context,symbol,month='current_month'):\n    '''\n    获取当天时间正在交易的股指期货合约。其中:\n    symbol:\n            'IF' #沪深300指数期货\n            'IC' #中证500股指期货\n            'IH' #上证50股指期货\n    month:\n            'current_month' #当月\n            'next_month'    #隔月\n            'next_quarter'  #下季\n            'skip_quarter'  #隔季\n    '''\n    display_name_dict = {'IC':'中证500股指期货','IF':'沪深300指数期货','IH':'上证50股指期货'}\n    month_dict = {'current_month':0, 'next_month':1, 'next_quarter':2, 's",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "ent_month':0, 'next_month':1, 'next_quarter':2, 'skip_quarter':3}\n\n    display_name = display_name_dict[symbol]\n    n = month_dict[month]\n    dt = context.current_dt.date()\n    a = get_all_securities(types=['futures'], date=dt)\n    try:\n        df = a[(a.display_name == display_name) & (a.start_date <= dt) & (a.end_date >= dt)]\n        return df.index[n]\n    except:\n        return 'WARRING: 无此合约'\n\n# 获取当天时间正在交易的国债期货合约\ndef get_treasury_futrue_code(context,symbol,month='current'):\n    '''\n    获取当天时间正在交易的国债期货合约",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "ol,month='current'):\n    '''\n    获取当天时间正在交易的国债期货合约。其中:\n    symbol:\n            'T' #10年期国债期货\n            'TF' #5年期国债期货\n    month:\n            'current' #最近期\n            'next'    #次近期\n            'skip'    #最远期\n    '''\n    display_name_dict = {'T':'10年期国债期货','TF':'5年期国债期货'}\n    month_dict = {'current':0, 'next':1, 'skip':2}\n\n    display_name = display_name_dict[symbol]\n    n = month_dict[month]\n    dt = context.current_dt.date()\n    a = get_all_securities(types=['futures'], date=dt)\n    try:\n        df = a[",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "pes=['futures'], date=dt)\n    try:\n        df = a[(a.display_name == display_name) & (a.start_date <= dt) & (a.end_date >= dt)]\n        return df.index[n]\n    except:\n        return 'WARRING: 无此合约'\n\n# 获取金融期货合约到期日\ndef get_CCFX_end_date(fature_code):\n    # 获取金融期货合约到期日\n    return get_security_info(fature_code).end_date\n",
        "source": "99策略代码/49 海龟克隆优化.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/10618\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom prettytable import PrettyTable\nimport numpy as np\nimport talib\nimport pandas\nimport scipy as sp\nimport scipy.optimize\nimport datetime as dt\nfrom scipy import linalg as sla\nfrom scipy import spatial\nfrom jqdata import gta\nfrom jqdata import *\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\nimport statsmodels.api as sm\nfrom jqlib.technical_analysis import *\n\ndef in",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " sm\nfrom jqlib.technical_analysis import *\n\ndef initialize(context):\n    #用沪深 300 做回报基准\n    set_benchmark('000300.XSHG')\n    # 滑点、真实价格\n    #set_slippage(FixedSlippage(0.000))\n    set_option('use_real_price', True)\n\n    # 关闭部分log\n    log.set_level('order', 'error')\n    after_code_changed(context)\n    run_daily(fun_main, '10:50')\n    \n\ndef after_trading_end(context):\n    g.quantlib.get_portfolio_info_text(context)\n    g.quantlib.reset_param(context)\n    g.quantlib.fun_set_var(context, 'op_buy_stocks', [])\n   ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "tlib.fun_set_var(context, 'op_buy_stocks', [])\n    if  context.curve_protect_days == 0:\n        print('追加收益:{}'.format(context.portfolio.total_value))\n        context.value_list.append(context.portfolio.total_value)\n\n\n\ndef after_code_changed(context):\n\n    # 变量都挪到 after_code_changed 里\n    g.quantlib = quantlib()\n    # 策略起停标志位\n    \n    g.quantlib.fun_set_var(context, 'algo_enable', True)\n    # 定义风险敞口\n    g.quantlib.fun_set_var(context, 'riskExposure', 0.03)\n    # 正态分布概率表，标准差倍数以及置信率\n    # 1.96, 95%; 2.06, 96%",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "   # 正态分布概率表，标准差倍数以及置信率\n    # 1.96, 95%; 2.06, 96%; 2.18, 97%; 2.34, 98%; 2.58, 99%; 5, 99.9999%\n    g.quantlib.fun_set_var(context, 'confidencelevel', 1.96)\n    # 调仓参数\n    g.quantlib.fun_set_var(context, 'hold_cycle', 20)\n    g.quantlib.fun_set_var(context, 'hold_periods', 0)\n    g.quantlib.fun_set_var(context, 'stock_list', [])\n    g.quantlib.fun_set_var(context, 'position_price', {})\n    g.quantlib.fun_set_var(context, 'recal_periods', 0)\n    g.quantlib.fun_set_var(context, 'version', 1.0)\n    \n    g.qua",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "un_set_var(context, 'version', 1.0)\n    \n    g.quantlib.fun_set_var(context, 'stock_num', 10)\n    \n    g.quantlib.fun_set_var(context, 'op_buy_stocks', [])\n    g.quantlib.fun_set_var(context, 'index2', '000016.XSHG')  # 上证50指数\n    g.quantlib.fun_set_var(context, 'index8', '399333.XSHE')  # 中小板R指数\n    g.quantlib.fun_set_var(context, 'index_growth_rate', 0.01)\n    \n    g.quantlib.fun_set_var(context, 'is_day_curve_protect', False)\n    g.quantlib.fun_set_var(context, 'curve_protect_days', 0)\n    g.quantlib.fun",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ntext, 'curve_protect_days', 0)\n    g.quantlib.fun_set_var(context, 'value_list', [])\n    \n\n    if context.version < 1.0:\n        context.hold_periods = 0\n        context.riskExposure = 0.03\n        context.version = 1.0\n\n\n\ndef before_trading_start(context):\n    # 定义股票池\n    pass\n\n#def handle_data(context, data):\n#    if not context.is_day_curve_protect:\n#        if g.quantlib.equity_curve_protect(context):\n#            g.quantlib.clear_position(context)\n#            del context.value_list[:]\n    \n\ndef fun_m",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "         del context.value_list[:]\n    \n\ndef fun_main(context):\n\n    # 引用 lib\n    g.value_factor = value_factor_lib()\n    \n    #print(g.lowPEG.fun_cal_stock_PEG(context))\n    g.quantlib     = quantlib()\n    context.msg    = \"\"\n\n    # 止损\n    #print(g.quantlib.stock_clean_by_mom(context))\n    #print(context.pe_ratio_median>90)\n    #if context.curve_protect_days<>0:\n    #    if context.pe_ratio_median<70:\n    #        context.curve_protect_days +=1\n    #    return 0\n    g.quantlib.get_pe_median(context)    \n  ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "urn 0\n    g.quantlib.get_pe_median(context)    \n    if g.quantlib.stock_clean_by_mom(context) and  context.pe_ratio_median>80:\n        g.quantlib.clear_position(context)\n        return 0\n        \n    moneyfund = ['511880.XSHG','511010.XSHG','511220.XSHG']\n    # 上市不足 60 天的剔除掉\n    \n    context.moneyfund = g.quantlib.fun_delNewShare(context, moneyfund, 60)\n    \n    \n    # 检查是否需要调仓\n    rebalance_flag, context.position_price, context.hold_periods, msg = \\\n            g.quantlib.fun_needRebalance(context,'algo-ma",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "     g.quantlib.fun_needRebalance(context,'algo-maxcap', context.moneyfund, context.stock_list, context.position_price, \\\n                context.hold_periods, context.hold_cycle, 0.25)\n    \n    context.msg += msg\n    \n    statsDate = context.current_dt.date() - dt.timedelta(1)\n    \n    \n    \n    #context.algo_enable, context.recal_periods, rebalance_flag = g.quantlib.fun_check_algo(context.algo_enable, context.recal_periods, rebalance_flag, statsDate)\n    log.info(rebalance_flag)\n    trade_style = False   ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "og.info(rebalance_flag)\n    trade_style = False    # True 会交易进行类似 100股的买卖，False 则只有在仓位变动 >25% 的时候，才产生交易\n    if rebalance_flag:\n        stock_list = []\n        if context.algo_enable:\n            #获取坏股票列表，将会剔除\n            bad_stock_list = g.quantlib.fun_get_bad_stock_list(statsDate)\n            # 低估值策略\n            value_factor_stock_list = g.value_factor.fun_get_stock_list(context, context.stock_num, statsDate, bad_stock_list)\n            stock_list = value_factor_stock_list\n\n        # 分配仓位\n        equity_ra",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "actor_stock_list\n\n        # 分配仓位\n        equity_ratio, bonds_ratio = g.quantlib.fun_assetAllocationSystem(stock_list, context.moneyfund, context.confidencelevel, statsDate)\n\n        risk_ratio = 0\n        if len(equity_ratio.keys()) >= 1:\n            risk_ratio = context.riskExposure / len(equity_ratio.keys())\n\n        # 分配头寸，根据预设的风险敞口，计算交易时的比例\n        position_ratio = g.quantlib.fun_calPosition(equity_ratio, bonds_ratio, 1.0, risk_ratio, context.moneyfund, context.portfolio.portfolio_value, context.confide",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "context.portfolio.portfolio_value, context.confidencelevel, statsDate)\n        trade_style = True\n        context.stock_list = position_ratio.keys()\n\n        # 更新待购价格\n        context.position_price = g.quantlib.fun_update_positions_price(position_ratio)\n        # 卖掉已有且不在待购清单里的股票\n        for stock in context.portfolio.positions.keys():\n            if stock not in position_ratio:\n                position_ratio[stock] = 0\n        context.position_ratio = position_ratio\n\n        # 调仓，执行交易\n        g.quantlib.fun",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "on_ratio\n\n        # 调仓，执行交易\n        g.quantlib.fun_do_trade(context, context.position_ratio, context.moneyfund, trade_style)\n    log.info(context.msg)\nclass value_factor_lib():\n    \n        \n    def fun_get_stock_list(self, context, hold_number, statsDate=None, bad_stock_list=[]):\n        \n        #low_ps = self.fun_get_low_ps(context, statsDate)\n        \n        # 去行业数据\n        industry_list = g.quantlib.fun_get_industry(cycle=None)\n        max_stock = []\n        for industry in industry_list:\n            ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "       for industry in industry_list:\n            \n            stock_list = g.quantlib.fun_get_industry_stocks(industry, 2, statsDate)\n            if len(stock_list)>5:\n                df = get_fundamentals(query(valuation.code).filter(valuation.code.in_(stock_list)).order_by(valuation.market_cap.desc()).limit(1), date = statsDate)\n                max_stock = max_stock + list(df.code)\n        print max_stock\n            \n        #max_stock = list(set(max_stock) & set(low_ps))\n        \n        \n        q = q",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ck) & set(low_ps))\n        \n        \n        q = query(indicator.code).filter(indicator.code.in_(max_stock)).order_by(indicator.roe.desc())\n        \n        stock_list = list(get_fundamentals(q).code)\n       \n  \n        positions_list = context.portfolio.positions.keys()\n        stock_list = g.quantlib.unpaused(stock_list, positions_list)\n        stock_list = g.quantlib.remove_st(stock_list, statsDate)\n        stock_list = g.quantlib.fun_delNewShare(context, stock_list, 80)\n        \n        #stock_list = st",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " stock_list, 80)\n        \n        #stock_list = stock_list[:hold_number*10]\n        stock_list = g.quantlib.remove_bad_stocks(stock_list, bad_stock_list)\n        stock_list = g.quantlib.remove_limit_up(stock_list, positions_list)\n        \n        \n        #if hold_number>5:\n        #    stock_list = g.quantlib.fun_diversity_by_industry(stockpool, 2, statsDate)\n        #elif hold_number>1 and hold_number<=5:\n        #    stock_list = g.quantlib.fun_diversity_by_industry(stockpool, 1, statsDate)\n        \n    ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "by_industry(stockpool, 1, statsDate)\n        \n        \n            \n        \n        print stock_list\n        return stock_list[:hold_number]\n\n\n    \n\n\n\nclass quantlib():\n    def get_fundamentals_sum(self, table_name=indicator, search=indicator.adjusted_profit, statsDate=None):\n        # 取最近的五个季度财报的日期\n        def __get_quarter(table_name, statsDate):\n            '''\n            返回最近 n 个财报的日期\n            返回每个股票最近一个财报的日期\n            '''\n            # 取最新一季度的统计日期\n            if table_name == 'indicator':\n      ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "期\n            if table_name == 'indicator':\n                q = query(indicator.code, indicator.statDate)\n            elif table_name == 'income':\n                q = query(income.code, income.statDate)\n            elif table_name == 'cash_flow':\n                q = query(cash_flow.code, cash_flow.statDate)\n            elif table_name == 'balance':\n                q = query(balance.code, balance.statDate)\n\n            df = get_fundamentals(q, date = statsDate)\n            stock_last_statDate = {}\n          ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "e)\n            stock_last_statDate = {}\n            tmpDict = df.to_dict()\n            for i in range(len(tmpDict['statDate'].keys())):\n                # 取得每个股票的代码，以及最新的财报发布日\n                stock_last_statDate[tmpDict['code'][i]] = tmpDict['statDate'][i]\n\n            df = df.sort(columns='statDate', ascending=False)\n            # 取得最新的财报日期\n            last_statDate = df.iloc[0,1]\n\n            this_year = int(str(last_statDate)[0:4])\n            this_month = str(last_statDate)[5:7]\n\n            if this_mont",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " str(last_statDate)[5:7]\n\n            if this_month == '12':\n                last_quarter       = str(this_year)     + 'q4'\n                last_two_quarter   = str(this_year)     + 'q3'\n                last_three_quarter = str(this_year)     + 'q2'\n                last_four_quarter  = str(this_year)     + 'q1'\n                last_five_quarter  = str(this_year - 1) + 'q4'\n\n            elif this_month == '09':\n                last_quarter       = str(this_year)     + 'q3'\n                last_two_quarter   ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ar)     + 'q3'\n                last_two_quarter   = str(this_year)     + 'q2'\n                last_three_quarter = str(this_year)     + 'q1'\n                last_four_quarter  = str(this_year - 1) + 'q4'\n                last_five_quarter  = str(this_year - 1) + 'q3'\n\n            elif this_month == '06':\n                last_quarter       = str(this_year)     + 'q2'\n                last_two_quarter   = str(this_year)     + 'q1'\n                last_three_quarter = str(this_year - 1) + 'q4'\n                la",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ter = str(this_year - 1) + 'q4'\n                last_four_quarter  = str(this_year - 1) + 'q3'\n                last_five_quarter  = str(this_year - 1) + 'q2'\n\n            else:  #this_month == '03':\n                last_quarter       = str(this_year)     + 'q1'\n                last_two_quarter   = str(this_year - 1) + 'q4'\n                last_three_quarter = str(this_year - 1) + 'q3'\n                last_four_quarter  = str(this_year - 1) + 'q2'\n                last_five_quarter  = str(this_year - 1) + 'q1",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "     last_five_quarter  = str(this_year - 1) + 'q1'\n        \n            return last_quarter, last_two_quarter, last_three_quarter, last_four_quarter, last_five_quarter, stock_last_statDate\n\n        # 查财报，返回指定值\n        def __get_fundamentals_value(table_name, search, myDate):\n            '''\n            输入查询日期\n            返回指定的财务数据，格式 dict\n            '''\n            if table_name == 'indicator':\n                q = query(indicator.code, search, indicator.statDate) \n            elif table_name == 'income':\n",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "atDate) \n            elif table_name == 'income':\n                q = query(income.code, search, income.statDate)\n            elif table_name == 'cash_flow':\n                q = query(cash_flow.code, search, cash_flow.statDate)\n            elif table_name == 'balance':\n                q = query(balance.code, search, balance.statDate)\n\n            df = get_fundamentals(q, statDate = myDate).fillna(value=0)\n\n            tmpDict = df.to_dict()\n            stock_dict = {}\n            name = str(search).split('.",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "_dict = {}\n            name = str(search).split('.')[-1]\n            for i in range(len(tmpDict['statDate'].keys())):\n                tmpList = []\n                tmpList.append(tmpDict['statDate'][i])\n                tmpList.append(tmpDict[name][i])\n                stock_dict[tmpDict['code'][i]] = tmpList\n\n            return stock_dict\n\n        \n        # 得到最近 n 个季度的统计时间\n        last_quarter, last_two_quarter, last_three_quarter, last_four_quarter, last_five_quarter, stock_last_statDate = __get_quarter(tab",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "e_quarter, stock_last_statDate = __get_quarter(table_name, statsDate)\n    \n        last_quarter_dict       = __get_fundamentals_value(table_name, search, last_quarter)\n        last_two_quarter_dict   = __get_fundamentals_value(table_name, search, last_two_quarter)\n        last_three_quarter_dict = __get_fundamentals_value(table_name, search, last_three_quarter)\n        last_four_quarter_dict  = __get_fundamentals_value(table_name, search, last_four_quarter)\n        last_five_quarter_dict  = __get_fundamenta",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "        last_five_quarter_dict  = __get_fundamentals_value(table_name, search, last_five_quarter)\n\n        tmp_list = []\n        stock_list = stock_last_statDate.keys()\n        for stock in stock_list:\n            tmp_dict = {}\n            tmp_dict['code'] = stock\n            value_list = []\n            if stock in last_quarter_dict:\n                if stock_last_statDate[stock] == last_quarter_dict[stock][0]:\n                    value_list.append(last_quarter_dict[stock][1])\n\n            if stock in last_t",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "er_dict[stock][1])\n\n            if stock in last_two_quarter_dict:\n                value_list.append(last_two_quarter_dict[stock][1])\n\n            if stock in last_three_quarter_dict:\n                value_list.append(last_three_quarter_dict[stock][1])\n\n            if stock in last_four_quarter_dict:\n                value_list.append(last_four_quarter_dict[stock][1])\n\n            if stock in last_five_quarter_dict:\n                value_list.append(last_five_quarter_dict[stock][1])\n\n            for i in ran",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "_quarter_dict[stock][1])\n\n            for i in range(4 - len(value_list)):\n                value_list.append(0)\n            \n            tmp_dict['0Q'] = value_list[0]\n            tmp_dict['1Q'] = value_list[1]\n            tmp_dict['2Q'] = value_list[2]\n            tmp_dict['3Q'] = value_list[3]\n            tmp_dict['sum_value'] = value_list[0] + value_list[1] + value_list[2] + value_list[3]\n            tmp_list.append(tmp_dict)\n        df = pd.DataFrame(tmp_list)\n\n        return df\n\n    def fun_set_var(sel",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "_list)\n\n        return df\n\n    def fun_set_var(self, context, var_name, var_value):\n        if var_name not in dir(context):\n            setattr(context, var_name, var_value)\n\n    def fun_check_price(self, algo_name, stock_list, position_price, gap_trigger):\n        flag = False\n        msg = \"\"\n        if stock_list:\n            h = history(1, '1d', 'close', stock_list, df=False)\n            for stock in stock_list:\n                curPrice = h[stock][0]\n                if stock not in position_price:\n    ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "              if stock not in position_price:\n                    position_price[stock] = curPrice\n                oldPrice = position_price[stock]\n                if oldPrice != 0:\n                    deltaprice = abs(curPrice - oldPrice)\n                    if deltaprice / oldPrice > gap_trigger:\n                        msg = algo_name + \"需要调仓: \" + stock + \"，现价: \" + str(curPrice) + \" / 原价格: \" + str(oldPrice) + \"\\n\"\n                        flag = True\n                        return flag, position_price, ms",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "                   return flag, position_price, msg\n        return flag, position_price, msg\n\n    def fun_needRebalance(self,context, algo_name, moneyfund, stock_list, position_price, hold_periods, hold_cycle, gap_trigger):\n        msg = \"\"\n        rebalance_flag = False\n        \n        \n        stocks_count = 0\n        for stock in stock_list:\n            if stock not in moneyfund:\n                stocks_count += 1\n        if stocks_count == 0:\n            msg += algo_name + \"调仓，因为持股数为 0 \\n\"\n            r",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " msg += algo_name + \"调仓，因为持股数为 0 \\n\"\n            rebalance_flag = True\n        elif hold_periods == 0:\n            msg += algo_name + \"调仓，因为持股天数剩余为 0 \\n\"\n            rebalance_flag = True\n        if not rebalance_flag:\n            rebalance_flag, position_price, msg2 = self.fun_check_price(algo_name, stock_list, position_price, gap_trigger)\n            msg += msg2\n        if rebalance_flag:\n            hold_periods = hold_cycle\n        else:\n            hold_periods -= 1\n        msg += algo_name + \"离下次调仓还剩 ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "_periods -= 1\n        msg += algo_name + \"离下次调仓还剩 \" + str(hold_periods) + \" 天\\n\"\n        \n        \n\n        return rebalance_flag, position_price, hold_periods, msg\n        \n    def stock_clean_by_ma(self,context,security,short=4,long=40):\n        #检查均线是否多头\n        ma_short = attribute_history(security, short, '1d', ('close'), True).mean()['close']\n        ma_long = attribute_history(security, long, '1d', ('close'), True).mean()['close']\n        record(ma_short=ma_short,ma_long=ma_long)\n        if ma_short ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ort=ma_short,ma_long=ma_long)\n        if ma_short <= ma_long and ma_short>3300:\n            return True\n        else:\n            \n            return False\n    \n    def stock_clean_by_mom(self,context):\n        gr_index2 = self.get_growth_rate(context.index2)\n        gr_index8 = self.get_growth_rate(context.index8)\n        if (gr_index2 <= context.index_growth_rate and  gr_index8 <= context.index_growth_rate):\n            return True\n        else:\n            return False\n            \n    def equity_curve_p",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "  return False\n            \n    def equity_curve_protect(self,context):\n        if not context.is_day_curve_protect:\n            cur_value = context.portfolio.total_value\n            if len(context.value_list) >= 20:\n                last_value = context.value_list[-20]\n                avg_value = sum(context.value_list[-20:]) / 20\n                if cur_value < last_value*0.99:\n                    #if cur_value < avg_value:\n                    log.info(\"==> 启动资金曲线保护, 20日前资产: %f, 当前资产: %f\" %(last_value, cur_",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "启动资金曲线保护, 20日前资产: %f, 当前资产: %f\" %(last_value, cur_value))\n                    context.is_day_curve_protect = True\n    \n        if context.is_day_curve_protect:\n            context.curve_protect_days = -2\n\n        return context.is_day_curve_protect\n    \n    def reset_param(self,context):\n        context.is_day_curve_protect = False\n            \n    def get_pe_median(self,context):\n        scanDate = context.previous_date\n        q = query(valuation.code, valuation.pe_ratio)\n        df =get_fundamentals(q, s",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "uation.pe_ratio)\n        df =get_fundamentals(q, scanDate).dropna()\n        df['ep_ratio'] = 1/df['pe_ratio']\n        \n        print('pe_ratio median:', 1/df['ep_ratio'].quantile(0.5))\n        #print(df.head())\n        #pe中位数控制仓位\n        context.pe_ratio_median = 1/df['ep_ratio'].quantile(0.5)\n        record(pe=context.pe_ratio_median)\n        \n       \n            \n    # 更新持有股票的价格，每次调仓后跑一次\n    def fun_update_positions_price(self, ratio):\n        position_price = {}\n        if ratio:\n            h = history(",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ce = {}\n        if ratio:\n            h = history(1, '1m', 'close', ratio.keys(), df=False)\n            for stock in ratio.keys():\n                if ratio[stock] > 0:\n                    position_price[stock] = round(h[stock][0], 3)\n        return position_price\n\n    def fun_assetAllocationSystem(self, stock_list, moneyfund, confidencelevel, statsDate=None):\n        def __fun_getEquity_ratio(__stocklist, confidencelevel, type, limit_up=1.0, limit_low=0.0, statsDate=None):\n            __ratio = {}\n         ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "tatsDate=None):\n            __ratio = {}\n            if __stocklist:\n                if type == 1: #风险平价 历史模拟法\n                # 正态分布概率表，标准差倍数以及置信率\n                # 1.96, 95%; 2.06, 96%; 2.18, 97%; 2.34, 98%; 2.58, 99%; 5, 99.9999%\n                    __ratio = self.fun_calStockWeight_by_risk(confidencelevel, __stocklist, limit_up, limit_low, statsDate)\n                elif type == 2: #马科维奇\n                    __ratio = self.fun_calStockWeight(__stocklist, limit_up, limit_low)\n                elif type == ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "limit_up, limit_low)\n                elif type == 3: #最小方差\n                    __ratio = self.fun_cal_Weight_by_minvar(__stocklist, limit_up, limit_low)\n                elif type == 5: # 风险平价 方差-协方差法\n                    __ratio = self.fun_calWeight_by_RiskParity(__stocklist, statsDate)\n                else: #等权重\n                    for stock in __stocklist:\n                        __ratio[stock] = 1.0/len(__stocklist)\n\n            return __ratio\n\n        if stock_list:\n            limit_up, limit_low = roun",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "stock_list:\n            limit_up, limit_low = round(2.0/len(list(set(stock_list))), 4), round(0.5/len(list(set(stock_list))), 4)\n            equity_ratio = __fun_getEquity_ratio(stock_list, confidencelevel, 0, limit_up, limit_low, statsDate)\n        else:\n            equity_ratio = {}\n        bonds_ratio  = __fun_getEquity_ratio(moneyfund, confidencelevel, 0, 1.0, 0.0, statsDate)\n\n        return equity_ratio, bonds_ratio\n\n    def fun_calPosition(self, equity_ratio, bonds_ratio, algo_ratio, risk_ratio, money",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "_ratio, bonds_ratio, algo_ratio, risk_ratio, moneyfund, portfolio_value, confidencelevel, statsDate=None):\n        '''\n        equity_ratio 资产配仓结果\n        bonds_ratio 债券配仓结果\n        algo_ratio 策略占市值的百分比\n        risk_ratio 每个标的承受的风险系数\n        '''\n        trade_ratio = equity_ratio # 简化\n\n        return trade_ratio\n\n    # 去极值\n    def fun_winsorize(self, rs, type, num):\n        # rs为Series化的数据\n        rs = rs.dropna().copy()\n        low_line, up_line = 0, 0\n        if type == 1:   # 标准差去极值\n            mean = rs",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "    if type == 1:   # 标准差去极值\n            mean = rs.mean()\n            #取极值\n            mad = num*rs.std()\n            up_line  = mean + mad\n            low_line = mean - mad\n        elif type == 2: #中位值去极值\n            rs = rs.replace([-np.inf, np.inf], np.nan)\n            median = rs.median()\n            md = abs(rs - median).median()\n            mad = md * num * 1.4826\n            up_line = median + mad\n            low_line = median - mad\n        elif type == 3: #Boxplot 去极值\n            if len(rs) < 2:\n   ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "== 3: #Boxplot 去极值\n            if len(rs) < 2:\n                return rs\n            mc = sm.stats.stattools.medcouple(rs)\n            rs.sort()\n            q1 = rs[int(0.25*len(rs))]\n            q3 = rs[int(0.75*len(rs))]\n            iqr = q3-q1        \n            if mc >= 0:\n                    low_line = q1-1.5*np.exp(-3.5*mc)*iqr\n                    up_line = q3+1.5*np.exp(4*mc)*iqr        \n            else:\n                    low_line = q1-1.5*np.exp(-4*mc)*iqr\n                    up_line = q3+1.5*np",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "-4*mc)*iqr\n                    up_line = q3+1.5*np.exp(3.5*mc)*iqr\n\n        rs[rs < low_line] = low_line\n        rs[rs > up_line] = up_line\n        \n        return rs\n\n    #标准化\n    def fun_standardize(self, s,type):\n        '''\n        s为Series数据\n        type为标准化类型:1 MinMax,2 Standard,3 maxabs \n        '''\n        data=s.dropna().copy()\n        if int(type)==1:\n            rs = (data - data.min())/(data.max() - data.min())\n        elif type==2:\n            rs = (data - data.mean())/data.std()\n        elif t",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "s = (data - data.mean())/data.std()\n        elif type==3:\n            rs = data/10**np.ceil(np.log10(data.abs().max()))\n        return rs\n\n    #中性化\n    def fun_neutralize(self, s, df, module='pe_ratio', industry_type=None, level=2, statsDate=None):\n        '''\n        参数：\n        s为stock代码 如'000002.XSHE' 可为list,可为str\n        moduel:中性化的指标 默认为PE\n        industry_type:行业类型(可选), 如果行业不指定，全市场中性化\n        返回：\n        中性化后的Series index为股票代码 value为中性化后的值\n        '''\n        s = df[df.code.isin(list(s))]\n        s = ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "        s = df[df.code.isin(list(s))]\n        s = s.reset_index(drop = True)\n        s = pd.Series(s[module].values, index=s['code'])\n        s = self.fun_winsorize(s,1,3)\n\n        if industry_type:\n            stocks = self.fun_get_industry_stocks(industry=industry_type, level=level, statsDate=statsDate)\n        else:\n            stocks = list(get_all_securities(['stock'], date=statsDate).index)\n\n        df = df[df.code.isin(stocks)]\n        df = df.reset_index(drop = True)\n        df = pd.Series(df[module",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ndex(drop = True)\n        df = pd.Series(df[module].values, index=df['code'])\n        df = self.fun_winsorize(df,1, 3)\n        rs = (s - df.mean())/df.std()\n\n        return rs\n\n    def fun_get_factor(self, df, factor_name, industry, level, statsDate):\n        stock_list = self.fun_get_industry_stocks(industry, level, statsDate)\n        rs = self.fun_neutralize(stock_list, df, module=factor_name, industry_type=industry, level=level, statsDate=statsDate)\n        rs = self.fun_standardize(rs, 2)\n\n        retur",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "   rs = self.fun_standardize(rs, 2)\n\n        return rs\n\n    def fun_diversity_by_industry(self, stock_list, max_num, statsDate):\n        if not stock_list:\n            return stock_list\n\n        industry_list = self.fun_get_industry(cycle=None)\n        tmpList = []\n        for industry in industry_list:\n            i = 0\n            stocks = self.fun_get_industry_stocks(industry, 2, statsDate)\n            for stock in stock_list:\n                if stock in stocks: #by 行业选入 top max_num 的标的（如有）\n             ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "stocks: #by 行业选入 top max_num 的标的（如有）\n                    i += 1\n                    if i <= max_num:\n                        tmpList.append(stock) #可能一个股票横跨多个行业，会导致多次入选，但不影响后面计算\n        final_stocks = []\n        for stock in stock_list:\n            if stock in tmpList:\n                final_stocks.append(stock)\n        return final_stocks\n\n    # 根据行业取股票列表\n    def fun_get_industry_stocks(self, industry, level=2, statsDate=None):\n        if level == 2:\n            stock_list = get_industry_stocks(industry, st",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "     stock_list = get_industry_stocks(industry, statsDate)\n        elif level == 1:\n            industry_list = self.fun_get_industry_levelI(industry)\n            stock_list = []\n            for industry_code in industry_list:\n                tmpList = get_industry_stocks(industry_code, statsDate)\n                stock_list = stock_list + tmpList\n            stock_list = list(set(stock_list))\n        else:\n            stock_list = []\n\n        return stock_list\n\n    # 一级行业列表\n    def fun_get_industry_levelI(s",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "st\n\n    # 一级行业列表\n    def fun_get_industry_levelI(self, industry=None):\n        industry_dict = {\n            'A':['A01', 'A02', 'A03', 'A04', 'A05'] #农、林、牧、渔业\n            ,'B':['B06', 'B07', 'B08', 'B09', 'B11'] #采矿业\n            ,'C':['C13', 'C14', 'C15', 'C17', 'C18', 'C19', 'C20', 'C21', 'C22', 'C23', 'C24', 'C25', 'C26', 'C27', 'C28', 'C29', 'C30', 'C31', 'C32',\\\n                'C33', 'C34', 'C35', 'C36', 'C37', 'C38', 'C39', 'C40', 'C41', 'C42'] #制造业\n            ,'D':['D44', 'D45', 'D46'] #电力、热力、燃气及水生产",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "          ,'D':['D44', 'D45', 'D46'] #电力、热力、燃气及水生产和供应业\n            ,'E':['E47', 'E48', 'E50'] #建筑业\n            ,'F':['F51', 'F52'] #批发和零售业\n            ,'G':['G53', 'G54', 'G55', 'G56', 'G58', 'G59']\t#交通运输、仓储和邮政业\n            ,'H':['H61', 'H62'] #住宿和餐饮业\n            ,'I':['I63', 'I64', 'I65']\t#信息传输、软件和信息技术服务业\n            ,'J':['J66', 'J67', 'J68', 'J69']\t#金融业\n            ,'K':['K70']\t#房地产业\n            ,'L':['L71', 'L72']\t#租赁和商务服务业\n            ,'M':['M73', 'M74']\t#科学研究和技术服务业\n            ,'N':['N78']\t#水利、环境和公共设施",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "]\t#科学研究和技术服务业\n            ,'N':['N78']\t#水利、环境和公共设施管理业\n            #,'O':[] #居民服务、修理和其他服务业\n            ,'P':['P82']\t#教育\n            ,'Q':['Q83']\t#卫生和社会工作\n            ,'R':['R85', 'R86', 'R87'] #文化、体育和娱乐业\n            ,'S':['S90']\t#综合\n            }\n        if industry == None:\n            return industry_dict\n        else:\n            return industry_dict[industry]\n\n    # 行业列表\n    def fun_get_industry(self, cycle=None):\n        # cycle 的参数：None取所有行业，True取周期性行业，False取非周期性行业\n        industry_dict = {\n           ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "False取非周期性行业\n        industry_dict = {\n            'A01':False,# 农业 \t1993-09-17\n            'A02':False,# 林业 \t1996-12-06\n            'A03':False,# 畜牧业 \t1997-06-11\n            'A04':False,# 渔业 \t1993-05-07\n            'A05':False,# 农、林、牧、渔服务业 \t1997-05-30\n            'B06':True, # 煤炭开采和洗选业 \t1994-01-06\n            'B07':True, # 石油和天然气开采业 \t1996-06-28\n            'B08':True, # 黑色金属矿采选业 \t1997-07-08\n            'B09':True, # 有色金属矿采选业 \t1996-03-20\n            'B11':True, # 开采辅助活动 \t2002-02-05\n            'C13':False, ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ue, # 开采辅助活动 \t2002-02-05\n            'C13':False, #\t农副食品加工业 \t1993-12-15\n            'C14':False,# 食品制造业 \t1994-08-18\n            'C15':False,# 酒、饮料和精制茶制造业 \t1992-10-12\n            'C17':True,# 纺织业 \t1992-06-16\n            'C18':True,# 纺织服装、服饰业 \t1993-12-31\n            'C19':True,# 皮革、毛皮、羽毛及其制品和制鞋业 \t1994-04-04\n            'C20':False,# 木材加工及木、竹、藤、棕、草制品业 \t2005-05-10\n            'C21':False,# 家具制造业 \t1996-04-25\n            'C22':False,# 造纸及纸制品业 \t1993-03-12\n            'C23':False,# 印刷和记录媒介复制业 \t1994-02-24\n          ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "   'C23':False,# 印刷和记录媒介复制业 \t1994-02-24\n            'C24':False,# 文教、工美、体育和娱乐用品制造业 \t2007-01-10\n            'C25':True, # 石油加工、炼焦及核燃料加工业 \t1993-10-25\n            'C26':True, # 化学原料及化学制品制造业 \t1990-12-19\n            'C27':False,# 医药制造业 \t1993-06-29\n            'C28':True, # 化学纤维制造业 \t1993-07-28\n            'C29':True, # 橡胶和塑料制品业 \t1992-08-28\n            'C30':True, # 非金属矿物制品业 \t1992-02-28\n            'C31':True, # 黑色金属冶炼及压延加工业 \t1994-01-06\n            'C32':True, # 有色金属冶炼和压延加工业 \t1996-02-15\n            'C33':True, # 金",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "金属冶炼和压延加工业 \t1996-02-15\n            'C33':True, # 金属制品业 \t1993-11-30\n            'C34':True, # 通用设备制造业 \t1992-03-27\n            'C35':True, # 专用设备制造业 \t1992-07-01\n            'C36':True, # 汽车制造业 \t1992-07-24\n            'C37':True, # 铁路、船舶、航空航天和其它运输设备制造业 \t1992-03-31\n            'C38':True, # 电气机械及器材制造业 \t1990-12-19\n            'C39':False,# 计算机、通信和其他电子设备制造业 \t1990-12-19\n            'C40':False,# 仪器仪表制造业 \t1993-09-17\n            'C41':True, # 其他制造业 \t1992-08-14\n            'C42':False,# 废弃资源综合利用业 \t2012-10-26\n        ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "      'C42':False,# 废弃资源综合利用业 \t2012-10-26\n            'D44':True, # 电力、热力生产和供应业 \t1993-04-16\n            'D45':False,# 燃气生产和供应业 \t2000-12-11\n            'D46':False,# 水的生产和供应业 \t1994-02-24\n            'E47':True, # 房屋建筑业 \t1993-04-29\n            'E48':True, # 土木工程建筑业 \t1994-01-28\n            'E50':True, # 建筑装饰和其他建筑业 \t1997-05-22\n            'F51':False,# 批发业 \t1992-05-06\n            'F52':False,# 零售业 \t1992-09-02\n            'G53':True, # 铁路运输业 \t1998-05-11\n            'G54':True, # 道路运输业 \t1991-01-14\n            'G5",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "   'G54':True, # 道路运输业 \t1991-01-14\n            'G55':True, # 水上运输业 \t1993-11-19\n            'G56':True, # 航空运输业 \t1997-11-05\n            'G58':True, # 装卸搬运和运输代理业 \t1993-05-05\n            'G59':False,# 仓储业 \t1996-06-14\n            'H61':False,# 住宿业 \t1993-11-18\n            'H62':False,# 餐饮业 \t1997-04-30\n            'I63':False,# 电信、广播电视和卫星传输服务 \t1992-12-02\n            'I64':False,# 互联网和相关服务 \t1992-05-07\n            'I65':False,# 软件和信息技术服务业 \t1992-08-20\n            'J66':True, # 货币金融服务 \t1991-04-03\n            'J67':Tr",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "6':True, # 货币金融服务 \t1991-04-03\n            'J67':True, # 资本市场服务 \t1994-01-10\n            'J68':True, # 保险业 \t2007-01-09\n            'J69':True, # 其他金融业 \t2012-10-26\n            'K70':True, # 房地产业 \t1992-01-13\n            'L71':False,# 租赁业 \t1997-01-30\n            'L72':False,# 商务服务业 \t1996-08-29\n            'M73':False,# 研究和试验发展 \t2012-10-26\n            'M74':True, # 专业技术服务业 \t2007-02-15\n            'N77':False,# 生态保护和环境治理业 \t2012-10-26\n            'N78':False,# 公共设施管理业 \t1992-08-07\n            'P82':False,# 教育 \t2012-",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "理业 \t1992-08-07\n            'P82':False,# 教育 \t2012-10-26\n            'Q83':False,# 卫生 \t2007-02-05\n            'R85':False,# 新闻和出版业 \t1992-12-08\n            'R86':False,# 广播、电视、电影和影视录音制作业 \t1994-02-24\n            'R87':False,# 文化艺术业 \t2012-10-26\n            'S90':False,# 综合 \t1990-12-10\n            }\n\n        industry_list = []\n        if cycle == True:\n            for industry in industry_dict.keys():\n                if industry_dict[industry] == True:\n                    industry_list.append(industry)\n        e",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "          industry_list.append(industry)\n        elif cycle == False:\n            for industry in industry_dict.keys():\n                if industry_dict[industry] == False:\n                    industry_list.append(industry)\n        else:\n            industry_list = industry_dict.keys()\n\n        return industry_list\n        \n    def fun_get_Divid_by_year(self, context, stocks):\n        year = context.current_dt.year - 1\n        #将当前股票池转换为国泰安的6位股票池\n        stocks_symbol=[]\n        for s in stocks:\n           ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "cks_symbol=[]\n        for s in stocks:\n            stocks_symbol.append(s[0:6])\n\n        df = gta.run_query(query(\n                gta.STK_DIVIDEND.SYMBOL,                # 股票代码\n                gta.STK_DIVIDEND.DECLAREDATE,           # 分红消息的时间\n            ).filter(\n                gta.STK_DIVIDEND.ISDIVIDEND == 'Y',     #有分红的股票\n                gta.STK_DIVIDEND.DIVDENDYEAR == year,\n                gta.STK_DIVIDEND.TERMCODE == 'P2702',   # 年度分红\n                gta.STK_DIVIDEND.SYMBOL.in_(stocks_symbol)\n      ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " gta.STK_DIVIDEND.SYMBOL.in_(stocks_symbol)\n            )).fillna(value=0, method=None, axis=0)\n        # 转换时间格式\n        df['pubtime'] = map(lambda x: int(x.split('-')[0]+x.split('-')[1]+x.split('-')[2]),df['DECLAREDATE'])\n        # 取得当前时间\n        currenttime  = int(str(context.current_dt)[0:4]+str(context.current_dt)[5:7]+str(context.current_dt)[8:10])\n        # 选择在当前时间能看到的记录\n        df = df[(df.pubtime < currenttime)]\n        # 得到目前看起来，有上一年度年度分红的股票\n        stocks_symbol_this_year = list(df['SYMBOL'])\n    ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " stocks_symbol_this_year = list(df['SYMBOL'])\n        # 得到目前看起来，上一年度没有年度分红的股票\n        stocks_symbol_past_year = list(set(stocks_symbol) - set(stocks_symbol_this_year))\n        \n        # 查有上一年度年度分红的\n        df1 = gta.run_query(query(\n                gta.STK_DIVIDEND.SYMBOL,                # 股票代码\n                gta.STK_DIVIDEND.DIVIDENTBT,            # 股票分红\n                gta.STK_DIVIDEND.DECLAREDATE,           # 分红消息的时间\n                gta.STK_DIVIDEND.DISTRIBUTIONBASESHARES # 分红时的股本基数\n            ).filte",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "TRIBUTIONBASESHARES # 分红时的股本基数\n            ).filter(\n                gta.STK_DIVIDEND.ISDIVIDEND == 'Y',     #有分红的股票\n                gta.STK_DIVIDEND.DIVDENDYEAR == year,\n                gta.STK_DIVIDEND.SYMBOL.in_(stocks_symbol_this_year)\n            )).fillna(value=0, method=None, axis=0)\n\n        df1['pubtime'] = map(lambda x: int(x.split('-')[0]+x.split('-')[1]+x.split('-')[2]),df1['DECLAREDATE'])\n        currenttime  = int(str(context.current_dt)[0:4]+str(context.current_dt)[5:7]+str(context.current_dt",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "tr(context.current_dt)[5:7]+str(context.current_dt)[8:10])\n        df1 = df1[(df1.pubtime < currenttime)]\n\n        # 求上上年的年度分红\n        df2 = gta.run_query(query(\n                gta.STK_DIVIDEND.SYMBOL,                # 股票代码\n                gta.STK_DIVIDEND.DIVIDENTBT,            # 股票分红\n                gta.STK_DIVIDEND.DECLAREDATE,           # 分红消息的时间\n                gta.STK_DIVIDEND.DISTRIBUTIONBASESHARES # 分红时的股本基数\n            ).filter(\n                gta.STK_DIVIDEND.ISDIVIDEND == 'Y',     #有分红的股票\n     ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": ".STK_DIVIDEND.ISDIVIDEND == 'Y',     #有分红的股票\n                gta.STK_DIVIDEND.DIVDENDYEAR == (year - 1),\n                gta.STK_DIVIDEND.SYMBOL.in_(stocks_symbol_past_year)\n            )).fillna(value=0, method=None, axis=0)\n        \n        df2['pubtime'] = map(lambda x: int(x.split('-')[0]+x.split('-')[1]+x.split('-')[2]),df2['DECLAREDATE'])\n        currenttime  = int(str(context.current_dt)[0:4]+str(context.current_dt)[5:7]+str(context.current_dt)[8:10])\n        df2 = df2[(df2.pubtime < currenttime)]\n  ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "\n        df2 = df2[(df2.pubtime < currenttime)]\n        \n        df= pd.concat((df2,df1))\n\n        df['SYMBOL']=map(normalize_code,list(df['SYMBOL']))\n        df.index=list(df['SYMBOL'])\n        \n        # 获取最新股本\n        q = query(valuation.code, valuation.capitalization\n                ).filter(valuation.code.in_(list(df.index)))\n        \n        df3 = get_fundamentals(q).fillna(value=0)\n        df3['SYMBOL'] = df3['code']\n        df3 = df3.drop(['code'], axis=1)\n\n        # 合并成一个 dataframe\n        df = df.",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "xis=1)\n\n        # 合并成一个 dataframe\n        df = df.merge(df3,on='SYMBOL')\n        df.index = list(df['SYMBOL'])\n\n        # 转换成 float\n        df['DISTRIBUTIONBASESHARES'] = map(float, df['DISTRIBUTIONBASESHARES'])\n        # 计算股份比值\n        df['CAP_RATIO'] = df['DISTRIBUTIONBASESHARES'] / (df['capitalization'] * 10000)\n        \n        df['DIVIDENTBT'] = map(float, df['DIVIDENTBT'])\n        # 计算相对于目前股份而言的分红额度\n        df['DIVIDENTBT'] = df['DIVIDENTBT'] * df['CAP_RATIO']\n        df = df.drop(['SYMBOL','DECLAREDA",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "_RATIO']\n        df = df.drop(['SYMBOL','DECLAREDATE','DISTRIBUTIONBASESHARES','capitalization','CAP_RATIO'], axis=1)\n        \n        #接下来这一步是考虑多次分红的股票，因此需要累加股票的多次分红\n        df = df.groupby(df.index).sum()\n        \n        #得到当前股价\n        Price=history(1, unit='1d', field='close', security_list=list(df.index), df=True, skip_paused=False, fq='pre')\n        Price=Price.T\n        \n        df['pre_close']=Price\n    \n        #计算股息率 = 股息/股票价格，* 10 是因为取到的是每 10 股分红\n        df['divpercent']=df['DIVIDENTBT']/(df['pr",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "\n        df['divpercent']=df['DIVIDENTBT']/(df['pre_close'] * 10)\n        \n        df['code'] = np.array(df.index)\n        \n        return df\n\n    def fun_do_trade(self, context, trade_ratio, moneyfund, trade_style):\n\n        def __fun_tradeBond(context, stock, curPrice, Value):\n            curValue = float(context.portfolio.positions[stock].total_amount * curPrice)\n            deltaValue = abs(Value - curValue)\n            if deltaValue > (curPrice*200):\n                if Value > curValue:\n               ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "              if Value > curValue:\n                    cash = context.portfolio.cash\n                    if cash > (curPrice*200):\n                        self.fun_trade(context, stock, Value)\n                        \n                else:\n                    self.fun_trade(context, stock, Value)\n\n        def __fun_tradeStock(context, curPrice, stock, ratio, trade_style):\n            total_value = context.portfolio.portfolio_value\n            if stock in moneyfund:\n                __fun_tradeBond(context, s",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "eyfund:\n                __fun_tradeBond(context, stock, curPrice, total_value * ratio)\n            else:\n                curValue = context.portfolio.positions[stock].total_amount * curPrice\n                Quota = total_value * ratio\n                if Quota:\n                    if abs(Quota - curValue) / Quota >= 0.25 or trade_style:\n                        if Quota > curValue:\n                            #if curPrice > context.portfolio.positions[stock].avg_cost:\n                            self.fun_trad",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "vg_cost:\n                            self.fun_trade(context, stock, Quota)\n                            \n                        else:\n                            self.fun_trade(context, stock, Quota)\n                else:\n                    if curValue > 0:\n                        self.fun_trade(context, stock, Quota)\n    \n        trade_list = trade_ratio.keys()\n        myholdstock = context.portfolio.positions.keys()\n        stock_list = list(set(trade_list).union(set(myholdstock)))\n        total_value = ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "t).union(set(myholdstock)))\n        total_value = context.portfolio.portfolio_value\n    \n        # 已有仓位\n        holdDict = {}\n        h = history(1, '1d', 'close', stock_list, df=False)\n        for stock in myholdstock:\n            tmpW = round((context.portfolio.positions[stock].total_amount * h[stock])/total_value, 2)\n            holdDict[stock] = float(tmpW)\n    \n        # 对已有仓位做排序\n        tmpDict = {}\n        for stock in holdDict:\n            if stock in trade_ratio:\n                tmpDict[stock] = ro",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "n trade_ratio:\n                tmpDict[stock] = round((trade_ratio[stock] - holdDict[stock]), 2)\n        tradeOrder = sorted(tmpDict.items(), key=lambda d:d[1], reverse=False)\n\n        # 交易已有仓位的股票，从减仓的开始，腾空现金\n        _tmplist = []\n        for idx in tradeOrder:\n            stock = idx[0]\n            __fun_tradeStock(context, h[stock][-1], stock, trade_ratio[stock], trade_style)\n            _tmplist.append(stock)\n\n        # 交易新股票\n        for i in range(len(trade_list)):\n            stock = trade_list[i]\n    ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ade_list)):\n            stock = trade_list[i]\n            if len(_tmplist) != 0 :\n                if stock not in _tmplist:\n                    __fun_tradeStock(context, h[stock][-1], stock, trade_ratio[stock], trade_style)\n            else:\n                __fun_tradeStock(context, h[stock][-1], stock, trade_ratio[stock], trade_style)\n\n    def unpaused(self, stock_list, positions_list):\n        current_data = get_current_data()\n        tmpList = []\n        for stock in stock_list:\n            if not curren",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "for stock in stock_list:\n            if not current_data[stock].paused or stock in positions_list:\n                tmpList.append(stock)\n        return tmpList\n\n    def remove_st(self, stock_list, statsDate):\n        current_data = get_current_data()\n        return [s for s in stock_list if not current_data[s].is_st]\n\n    def remove_limit_up(self, stock_list, positions_list):\n        h = history(1, '1m', 'close', stock_list, df=False, skip_paused=False, fq='pre')\n        h2 = history(1, '1m', 'high_limit', ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "pre')\n        h2 = history(1, '1m', 'high_limit', stock_list, df=False, skip_paused=False, fq='pre')\n        tmpList = []\n        for stock in stock_list:\n            if h[stock][0] < h2[stock][0] or stock in positions_list:\n                tmpList.append(stock)\n\n        return tmpList\n\n    def fun_get_bad_stock_list(self, statsDate):\n        #0、剔除商誉占比 > 10% 的股票\n        df = get_fundamentals(\n            query(valuation.code, balance.good_will, balance.equities_parent_company_owners),\n            date = sta",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ies_parent_company_owners),\n            date = statsDate\n        )\n\n        df = df.fillna(value = 0)\n        df['good_will_ratio'] = 1.0*df['good_will'] / df['equities_parent_company_owners']\n        list_good_will = list(df[df.good_will_ratio > 0.1].code)\n\n        bad_stocks = list_good_will\n        bad_stocks = list(set(bad_stocks))\n        return bad_stocks\n\n    def remove_bad_stocks(self, stock_list, bad_stock_list):\n        tmpList = []\n        for stock in stock_list:\n            if stock not in bad_",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ck in stock_list:\n            if stock not in bad_stock_list:\n                tmpList.append(stock)\n        return tmpList\n\n    # 剔除上市时间较短的产品\n    def fun_delNewShare(self, context, equity, deltaday):\n        deltaDate = context.current_dt.date() - dt.timedelta(deltaday)\n    \n        tmpList = []\n        for stock in equity:\n            if get_security_info(stock).start_date < deltaDate:\n                tmpList.append(stock)\n    \n        return tmpList\n\n    def fun_trade(self, context, stock, value):\n       ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "ef fun_trade(self, context, stock, value):\n        self.fun_setCommission(context, stock)\n        order_target_value(stock, value)\n\n    def fun_setCommission(self, context, stock):\n        if stock in context.moneyfund:\n            set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0, close_commission=0, close_today_commission=0, min_commission=0), type='fund')\n        else:\n            set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, clos",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "n_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock')\n    def get_portfolio_info_text(self,context,op_sfs=[0]):\n        \n        sub_str = ''\n        table = PrettyTable([\"仓号\",\"股票\", \"持仓\", \"当前价\", \"盈亏率\",\"持仓比\"])  \n        for sf_id in range(len(context.subportfolios)):\n            cash = context.subportfolios[sf_id].cash\n            p_value = context.subportfolios[sf_id].positions_value\n            total_values = p_value +cash\n            if sf_id in op_sfs:\n ",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": " = p_value +cash\n            if sf_id in op_sfs:\n                sf_id_str = str(sf_id) + ' *'\n            else:\n                sf_id_str = str(sf_id)\n            for stock in context.subportfolios[sf_id].long_positions.keys():\n                position = context.subportfolios[sf_id].long_positions[stock]\n                if sf_id in op_sfs and stock in context.op_buy_stocks:\n                    stock_str = self.show_stock(stock) + ' *'\n                else:\n                    stock_str = self.show_stock(st",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "                    stock_str = self.show_stock(stock)\n                stock_raite = (position.total_amount * position.price) / total_values * 100\n                table.add_row([sf_id_str,\n                    stock_str,\n                    position.total_amount,\n                    position.price,\n                    \"%.2f%%\"%((position.price - position.avg_cost) / position.avg_cost * 100), \n                    \"%.2f%%\"%(stock_raite)]\n                    )\n            if sf_id < len(context.subportfolios) -",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "           if sf_id < len(context.subportfolios) - 1:\n                table.add_row(['----','---------------','-----','----','-----','-----'])\n            sub_str += '[仓号: %d] [总值:%d] [持股数:%d] [仓位:%.2f%%] \\n'%(sf_id,\n                total_values,\n                len(context.subportfolios[sf_id].long_positions)\n                ,p_value*100/(cash+p_value))\n        \n        print '子仓详情:\\n' + sub_str + str(table)\n    def show_stock(self,stock):\n        return \"%s %s\"%(stock[:6],get_security_info(stock).display_",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "s %s\"%(stock[:6],get_security_info(stock).display_name)\n    # 清空卖出所有持仓\n    def clear_position(self,context):\n        def close_position(position):\n            security = position.security\n            order = order_target_value(security, 0)\n            \n        if context.portfolio.positions:\n            log.info(\"==> 清仓，卖出所有股票\")\n            context.hold_periods = 0\n            for stock in context.portfolio.positions.keys():\n                position = context.portfolio.positions[stock]\n                close",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "t.portfolio.positions[stock]\n                close_position(position)\n    \n        \n    def get_growth_rate(self,security, n=20):\n        lc = self.get_close_price(security, n)\n        #c = data[security].close\n        c = self.get_close_price(security, 1, '1m')\n        \n        if not isnan(lc) and not isnan(c) and lc != 0:\n            return (c - lc) / lc\n        else:\n            log.error(\"数据非法, security: %s, %d日收盘价: %f, 当前价: %f\" %(security, n, lc, c))\n            return 0\n    \n    def get_close_price(s",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "           return 0\n    \n    def get_close_price(self,security, n, unit='1d'):\n        return attribute_history(security, n, unit, ('close'), True)['close'][0]\n",
        "source": "99策略代码/33 买入每个行业市值最大的股票.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13962\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "k_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_dail",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "ly(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"all_a_securities\"]\n    g.security_univers",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "ndex = [\"all_a_securities\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'de",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "sc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_mana",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "l = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securitie",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,inpu",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "= check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_fi",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": ")\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_t",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_fil",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "########\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 15)\n    security_list = financial_data_filter_dayu(security_list, indicator.net_profit_margin, 15)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 15)\n    security_list = financial_data_filter_",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "oe, 15)\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 50)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, secu",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\nde",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": " ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(con",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.ma",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "uy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = jud",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "          # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(se",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, '",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "scending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(con",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "t\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in securit",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "       security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "t_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "n security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n   ",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "      return security_list\n\n#自定义函数",
        "source": "99策略代码/62 选股策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15565\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import * \nimport talib \nfrom math import isnan\n\ndef initialize(context):\n    # 设置参数\n    set_parameter(context)\n    # 设定基准银华日利，在多品种的回测当中基准没有参考意义\n    set_benchmark('511880.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    ### 期货相关设定 ###\n    # 设定账户为金融账户\n    set_subportfolios([SubPortfolioConfig(",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "账户为金融账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='futures')])\n    # 期货类每笔交易时的手续费是：买入时万分之0.23,卖出时万分之0.23,平今仓为万分之23\n    set_order_cost(OrderCost(open_commission=0.00005, close_commission=0.00005,close_today_commission=0.00005), type='index_futures')\n    # 设定保证金比例\n    set_option('futures_margin_rate', 0.15)\n    # 设置滑点（单边万5，双边千1）\n    set_slippage(PriceRelatedSlippage(0.001),type='future')\n      # 开盘前运行\n    run_daily( before_market_open, time='before_open', reference_s",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "efore_market_open, time='before_open', reference_security=get_future_code('RB'))\n      # 开盘时运行\n    run_daily( market_open, time='open', reference_security=get_future_code('RB'))\n      # 收盘后运行\n    run_daily( after_market_close, time='after_close', reference_security=get_future_code('RB'))\n   \n   # 参数设置函数\ndef set_parameter(context):\n    \n    #######变量设置########\n    g.LastRealPrice = {} # 最新真实合约价格字典\n    g.HighPrice = {} # 各品种最高价字典（用于吊灯止损）\n    g.LowPrice = {} # 各品种最低价字典（用于吊灯止损）\n    g.future_list = []  # 设置期货品种列",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "各品种最低价字典（用于吊灯止损）\n    g.future_list = []  # 设置期货品种列表\n    g.TradeLots = {}  # 各品种的交易手数信息\n    g.Price_dict = {} # 各品种价格列表字典\n    g.Times = {} # 计数器（用于防止止损重入）\n    g.Reentry_long = False # 止损后重入标记\n    g.Reentry_short = False # 止损后重入标记\n    g.ATR = {} # ATR值字典\n    g.AMA = {} # AMA值字典\n    g.PriceArray = {} # 信号计算价格字典\n    g.Filter ={} # 过滤器金额（计算买卖条件）\n    g.MappingReal = {} # 真实合约映射（key为symbol，value为主力合约）\n    g.MappingIndex = {} # 指数合约映射 （key为 symbol，value为指数合约\n    \n    #######参数设置########\n    g.Cross = 0 # 均线交叉判定信号\n ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "  #######参数设置########\n    g.Cross = 0 # 均线交叉判定信号\n    g.FilterTimes = 0.3 # AMA的过滤乘数\n    g.NATRstop = 4 # ATR止损倍数\n    g.Window = 15 # AMA等窗口参数（方便起见，系数统一，绩效会有下降，但是安全））\n    \n    # 交易的期货品种信息\n    g.instruments = ['RU','TA','PP','CU','AG','L','RB','I','J','JD']\n    \n    # 价格列表初始化\n    set_future_list(context)\n\n\ndef set_future_list(context):\n    for ins in g.instruments:\n        idx = get_future_code(ins)\n        dom = get_dominant_future(ins)\n        # 填充映射字典\n        g.MappingIndex[ins] = idx\n        g.MappingReal",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "   g.MappingIndex[ins] = idx\n        g.MappingReal[ins] = dom\n        #设置主力合约已上市的品种基本参数\n        if dom == '':\n            pass\n        else:\n            if dom not in g.future_list:\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n            \n## 开盘前运行函数\ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    send_message('开始交易')\n    ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": ".current_dt.time()))\n    send_message('开始交易')\n    \n    # 过滤无主力合约的品种，传入并修改期货字典信息\n    for ins in g.instruments:\n        dom = get_dominant_future(ins)\n        if dom == '':\n            pass\n        else:\n            # 判断是否执行replace_old_futures\n            if dom == g.MappingReal[ins]:\n                pass\n            else:\n                replace_old_futures(context,ins,dom)\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n             ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "             g.LowPrice[dom] = False\n                g.Times[dom] = 0\n        \n            g.TradeLots[dom] = get_lots(context.portfolio.starting_cash/len(g.instruments),ins)\n            \n            \n## 开盘时运行函数\ndef market_open(context):\n    \n    # 以下是主循环\n    for ins in g.instruments:\n        # 过滤空主力合约品种\n        if g.MappingReal[ins] != '':\n            IndexFuture = g.MappingIndex[ins]\n            RealFuture = g.MappingReal[ins]\n            # 获取当月合约交割日期\n            end_date = get_CCFX_end_date(RealFuture)\n ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "        end_date = get_CCFX_end_date(RealFuture)\n            # 当月合约交割日当天不开仓\n            if (context.current_dt.date() == end_date):\n                return\n            else:\n                g.LastRealPrice[RealFuture] = attribute_history(RealFuture,1,'1d',['close'])['close'][-1]\n                # 获取价格list\n                g.PriceArray[IndexFuture] = attribute_history(IndexFuture,50,'1d',['close','open','high','low'])\n                g.CurrentPrice = g.PriceArray[IndexFuture]['close'][-1]\n                g.Clo",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "ay[IndexFuture]['close'][-1]\n                g.ClosePrice = g.PriceArray[IndexFuture]['close']\n                # 如果没有数据，返回\n                if len(g.PriceArray[IndexFuture]) < 50:\n                    return\n                else:\n                    close = np.array(g.PriceArray[IndexFuture]['close'])\n                    high = np.array(g.PriceArray[IndexFuture]['high'])\n                    low = np.array(g.PriceArray[IndexFuture]['low'])\n                    # 计算AMA，仅传入一个参数g.Window\n                    g.AMA[I",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": " 计算AMA，仅传入一个参数g.Window\n                    g.AMA[IndexFuture] = talib.KAMA(close,g.Window)\n                    # 计算ATR\n                    g.ATR[IndexFuture] = talib.ATR(high,low,close, g.Window)[-1]\n                    if not isnan(g.AMA[IndexFuture][-1]) :\n                        g.Filter[IndexFuture] = talib.STDDEV(g.AMA[IndexFuture][-g.Window:],g.Window)[-1]\n                \n                        #判断AMA两日差值，是否大于标准差过滤器\n                        if g.AMA[IndexFuture][-1]-g.AMA[IndexFuture][-2] > g.Filter[",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "ndexFuture][-1]-g.AMA[IndexFuture][-2] > g.Filter[IndexFuture]*g.FilterTimes:\n                            g.Cross = 1\n                        elif g.AMA[IndexFuture][-2]-g.AMA[IndexFuture][-1] > g.Filter[IndexFuture]*g.FilterTimes:\n                            g.Cross = -1\n                        else:\n                            g.Cross = 0\n        \n                        #判断交易信号：均线交叉+可二次入场条件成立\n                        if  g.Cross == 1 and g.Reentry_long == False:\n                            g.Signal = 1\n  ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "False:\n                            g.Signal = 1\n                        elif g.Cross == -1 and g.Reentry_short == False:\n                            g.Signal = -1\n                        else:\n                            g.Signal = 0\n    \n                    # 执行交易\n                    Trade(context,RealFuture,IndexFuture)\n                    # 运行防止充入模块\n                    Re_entry(context,RealFuture)\n                    # 计数器+1\n                    if RealFuture in g.Times.keys():\n                        g.T",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "ure in g.Times.keys():\n                        g.Times[RealFuture] += 1 \n                    else:\n                        g.Times[RealFuture] = 0\n            \n           \n## 收盘后运行函数\ndef after_market_close(context):\n    #log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    # 得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "################################################')\n\n## 交易模块 \ndef Trade(context,RealFuture,IndexFuture):\n    \n    # 快线高于慢线，且追踪止损失效，则可开多仓\n    if g.Signal == 1 and context.portfolio.long_positions[RealFuture].total_amount == 0:\n        if context.portfolio.long_positions[RealFuture].total_amount != 0:\n            log.info('空头有持仓：%s'%(RealFuture))\n        order_target(RealFuture,0,side='short')\n        order_target(RealFuture,g.TradeLots[RealFuture],side='long')\n        g.HighPrice[RealFuture] = g.LastRealPrice",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "\n        g.HighPrice[RealFuture] = g.LastRealPrice[RealFuture]\n        g.LowPrice[RealFuture] = False\n        log.info('正常买多合约：%s'%(RealFuture))\n        \n    \n    elif g.Signal == -1 and context.portfolio.short_positions[RealFuture].total_amount == 0:\n        if context.portfolio.short_positions[RealFuture].total_amount != 0:\n            log.info('多头有持仓：%s'%(RealFuture))\n        order_target(RealFuture,0,side ='long')\n        order_target(RealFuture,g.TradeLots[RealFuture],side='short')\n        g.LowPrice[R",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "ots[RealFuture],side='short')\n        g.LowPrice[RealFuture] = g.LastRealPrice[RealFuture]\n        g.HighPrice[RealFuture] = False\n        log.info('正常卖空合约：%s'%(RealFuture))\n    else:\n        # 追踪止损\n        Trailing_Stop(context,RealFuture,IndexFuture)\n\n        \n# 防止止损后立刻重入模块\ndef Re_entry(context,future):\n    # 防重入模块：上一次止损后20根bar内不交易，但如果出现价格突破事件则20根bar的限制失效\n    \n    #设置最高价与最低价（注意：需要错一位，不能算入当前价格）\n    g.Highest_high_2_20 = g.ClosePrice[-21:-1].max()\n    g.Lowest_low_2_20 = g.ClosePrice[-21:-1].min()\n    \n    ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "st_low_2_20 = g.ClosePrice[-21:-1].min()\n    \n    if  g.Reentry_long == True:\n        if g.Times[future] > 20 or g.CurrentPrice > g.Highest_high_2_20 :\n            g.Reentry_long = False\n    if  g.Reentry_short == True:\n        if g.Times[future] > 20 or g.CurrentPrice < g.Lowest_low_2_20 :\n            g.Reentry_short = False\n        \n# 追踪止损模块\ndef Trailing_Stop(context,RealFuture,IndexFuture):\n    \n    long_positions = context.portfolio.long_positions\n    short_positions = context.portfolio.short_positions\n",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "ort_positions = context.portfolio.short_positions\n\n    if RealFuture in long_positions.keys():\n        if long_positions[RealFuture].total_amount > 0:\n            if g.HighPrice[RealFuture]:\n                g.HighPrice[RealFuture] = max(g.HighPrice[RealFuture], g.LastRealPrice[RealFuture])\n                if g.LastRealPrice[RealFuture]  < g.HighPrice[RealFuture]  - g.NATRstop*g.ATR[IndexFuture]:\n                    log.info('多头止损:\\t' +  RealFuture)\n                    order_target(RealFuture,0,side = 'long'",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "           order_target(RealFuture,0,side = 'long')\n                    g.Reentry_long = True\n\n    if RealFuture in short_positions.keys():\n        if short_positions[RealFuture].total_amount > 0:\n            if g.LowPrice[RealFuture]:\n                g.LowPrice[RealFuture] = min(g.LowPrice[RealFuture], g.LastRealPrice[RealFuture])\n                if g.LastRealPrice[RealFuture]  > g.LowPrice[RealFuture] + g.NATRstop*g.ATR[IndexFuture]:\n                    log.info('空头止损:\\t' + RealFuture)\n                   ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "g.info('空头止损:\\t' + RealFuture)\n                    order_target(RealFuture,0,side = 'short')\n                    g.Reentry_short = True\n\n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约        \ndef replace_old_futures(context,ins,dom):\n    \n    LastFuture = g.MappingReal[ins]\n    \n    if LastFuture in context.portfolio.long_positions.keys():\n        lots_long = context.portfolio.long_positions[LastFuture].total_amount\n        order_target(LastFuture,0,side='long')\n        order_target(dom,lots_long,side='long')\n        pri",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "rder_target(dom,lots_long,side='long')\n        print('主力合约更换，平多仓换新仓')\n    \n    if LastFuture in context.portfolio.short_positions.keys():\n        lots_short = context.portfolio.short_positions[dom].total_amount\n        order_target(LastFuture,0,side='short')\n        order_target(dom,lots_short,side='short')\n        print('主力合约更换，平空仓换新仓')\n\n    g.MappingReal[ins] = dom    \n\n\n# 获取交易手数函数\ndef get_lots(cash,symbol):\n    future_coef_list = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':5",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": " 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10, \n                        'CF':5, 'CS':10, 'CU':5, 'ER':10, \n                        'FB':500, 'FG':20, 'FU':50, 'GN':10, \n                        'HC':10, 'I':100, 'IC':200, 'IF':300, \n                        'IH':300, 'J':100, 'JD':5, 'JM':60, \n                        'JR':20, 'L':5, 'LR':10, 'M':10, \n                        'MA':10, 'ME':10, 'NI':1, 'OI':10, \n                        'P':10, 'PB':5, 'PM':50, 'PP':5, \n                   ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": ":10, 'PB':5, 'PM':50, 'PP':5, \n                        'RB':10, 'RI':20, 'RM':10, 'RO':10, \n                        'RS':10, 'RU':10, 'SF':5, 'SM':5, \n                        'SN':1, 'SR':10, 'T':10000, 'TA':5, \n                        'TC':100, 'TF':10000, 'V':5, 'WH':20, \n                        'WR':10, 'WS':50, 'WT':10, 'Y':10, \n                        'ZC':100, 'ZN':5}\n    RealFuture = get_dominant_future(symbol)\n    IndexFuture = get_future_code(symbol)\n    # 获取价格list\n    Price_dict = attribute_histor",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": ")\n    # 获取价格list\n    Price_dict = attribute_history(IndexFuture,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0: \n        return\n    else:\n        open_future = Price_dict.iloc[-1]\n    # 返回手数\n    if IndexFuture in g.ATR.keys():\n    # 这里的交易手数，使用了ATR倒数头寸\n        return cash*0.1/(g.ATR[IndexFuture]*future_coef_list[symbol])\n    else:# 函数运行之初会出现没将future写入ATR字典当中的情况\n        return cash*0.0001/future_coef_list[symbol]\n\n        \n# 获取当天时间正在交易的期货主力合约函数\ndef get_future_code(symbol):\n    future_code_list ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "def get_future_code(symbol):\n    future_code_list = {'A':'A8888.XDCE', 'AG':'AG8888.XSGE', 'AL':'AL8888.XSGE', 'AU':'AU8888.XSGE',\n                        'B':'B8888.XDCE', 'BB':'BB8888.XDCE', 'BU':'BU8888.XSGE', 'C':'C8888.XDCE', \n                        'CF':'CF8888.XZCE', 'CS':'CS8888.XDCE', 'CU':'CU8888.XSGE', 'ER':'ER8888.XZCE', \n                        'FB':'FB8888.XDCE', 'FG':'FG8888.XZCE', 'FU':'FU8888.XSGE', 'GN':'GN8888.XZCE', \n                        'HC':'HC8888.XSGE', 'I':'I8888.XDCE', 'IC':'IC",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "    'HC':'HC8888.XSGE', 'I':'I8888.XDCE', 'IC':'IC8888.CCFX', 'IF':'IF8888.CCFX', \n                        'IH':'IH8888.CCFX', 'J':'J8888.XDCE', 'JD':'JD8888.XDCE', 'JM':'JM8888.XDCE', \n                        'JR':'JR8888.XZCE', 'L':'L8888.XDCE', 'LR':'LR8888.XZCE', 'M':'M8888.XDCE', \n                        'MA':'MA8888.XZCE', 'ME':'ME8888.XZCE', 'NI':'NI8888.XSGE', 'OI':'OI8888.XZCE', \n                        'P':'P8888.XDCE', 'PB':'PB8888.XSGE', 'PM':'PM8888.XZCE', 'PP':'PP8888.XDCE', \n                 ",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "8888.XZCE', 'PP':'PP8888.XDCE', \n                        'RB':'RB8888.XSGE', 'RI':'RI8888.XZCE', 'RM':'RM8888.XZCE', 'RO':'RO8888.XZCE', \n                        'RS':'RS8888.XZCE', 'RU':'RU8888.XSGE', 'SF':'SF8888.XZCE', 'SM':'SM8888.XZCE', \n                        'SN':'SN8888.XSGE', 'SR':'SR8888.XZCE', 'T':'T8888.CCFX', 'TA':'TA8888.XZCE', \n                        'TC':'TC8888.XZCE', 'TF':'TF8888.CCFX', 'V':'V8888.XDCE', 'WH':'WH8888.XZCE', \n                        'WR':'WR8888.XSGE', 'WS':'WS8888.XZCE',",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "           'WR':'WR8888.XSGE', 'WS':'WS8888.XZCE', 'WT':'WT8888.XZCE', 'Y':'Y8888.XDCE', \n                        'ZC':'ZC8888.XZCE', 'ZN':'ZN8888.XSGE'}\n    try:\n        return future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n\n    \n# 获取金融期货合约到期日\ndef get_CCFX_end_date(fature_code):\n    # 获取金融期货合约到期日\n    return get_security_info(fature_code).end_date\n",
        "source": "99策略代码/01 AdaptiveMA自适应均线 过滤器 期货多品种模型 收益稳定增长.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15556\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 期货日频多品种，MA双均线+百分比追踪止损\n# 建议给予1000000元，2012年1月1日至今回测\n# 导入函数库\nfrom jqdata import * \n\n\ndef initialize(context):\n    # 设置参数\n    set_info(context)\n    # 不设定基准，在多品种的回测当中基准没有参考意义\n    set_benchmark('511880.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    ### 期货相关设定 ###\n    # 设定账户为金融账户\n    set_subportfolios([SubPortfol",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "\n    # 设定账户为金融账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='futures')])\n    # 期货类每笔交易时的手续费是：买入时万分之2.5,卖出时万分之2.5,平今仓为万分之2.5\n    set_order_cost(OrderCost(open_commission=0.00025, close_commission=0.00025,close_today_commission=0.00025), type='index_futures')\n    # 设定保证金比例15%\n    set_option('futures_margin_rate', 0.15)\n    # 开盘前运行\n    run_daily( before_market_open, time='before_open', reference_security=get_future_code('RB'))\n    # 开盘时运行\n    run_daily( market_open, ti",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "('RB'))\n    # 开盘时运行\n    run_daily( market_open, time='open', reference_security=get_future_code('RB'))\n    # 收盘后运行\n    run_daily( after_market_close, time='after_close', reference_security=get_future_code('RB'))\n    # 设置滑点（单边万5，双边千1）\n    set_slippage(PriceRelatedSlippage(0.001),type='future')\n   \n   \n   # 参数设置函数\ndef set_info(context):\n    \n    #######变量设置########\n    g.LastRealPrice = {} # 最新真实合约价格字典(用于吊灯止损）\n    g.HighPrice = {} # 各品种最高价字典（用于吊灯止损）\n    g.LowPrice = {} # 各品种最低价字典（用于吊灯止损）\n    g.future_list = [",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "rice = {} # 各品种最低价字典（用于吊灯止损）\n    g.future_list = []  # 设置期货品种列表\n    g.TradeLots = {}  # 各品种的交易手数信息\n    g.PriceArray = {} # 信号计算价格字典\n    g.Price_dict = {} # 各品种价格列表字典\n    g.Times = {} # 计数器（用于防止止损重入）\n    g.Reentry_long = False # 止损后重入标记\n    g.Reentry_short = False # 止损后重入标记\n    g.MappingReal = {} # 真实合约映射（key为symbol，value为主力合约）\n    g.MappingIndex = {} # 指数合约映射 （key为 symbol，value为指数合约\n    #######参数设置########\n    g.FastWindow = 5 # 快线窗口长度\n    g.SlowWindow = 20 # 慢线窗口长度\n    g.Cross = 0 # 均线交叉判定信号\n    g.stop = 0",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "# 慢线窗口长度\n    g.Cross = 0 # 均线交叉判定信号\n    g.stop = 0.05 # 止损比例\n    g.margin_rate = 0.15 # 定义保证金率\n    # 交易的期货品种信息\n    g.instruments = ['TA','P','CU','ZN','C','AG','RU','AL','L','RB','CS','SF','JD','CF','J','M','V','I']\n\n    # 价格列表初始化\n    set_future_list(context)\n\n\ndef set_future_list(context):\n    for ins in g.instruments:\n        idx = get_future_code(ins)\n        dom = get_dominant_future(ins)\n        # 填充映射字典\n        g.MappingIndex[ins] = idx\n        g.MappingReal[ins] = dom\n        #设置主力合约已上市的品种基本参数\n      ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "ngReal[ins] = dom\n        #设置主力合约已上市的品种基本参数\n        if dom == '':\n            pass\n        else:\n            if dom not in g.future_list:\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n                \n\n'''\n换月模块逻辑（ins是期货品种的symbol（如‘RB’），dom或future指合约（如'RB1610.XSGE'）,idx指指数合约（如’RB8888.XSGE‘）\n    1.在第一天开始时，将所有期货品种最初的主力合约写入MappingReal与MappingIndex当中\n    2.每天开盘获取一遍ins对应的主力合约，判断是否在MappingReal中，若不在，则执行repl",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "2.每天开盘获取一遍ins对应的主力合约，判断是否在MappingReal中，若不在，则执行replace模块\n    3.replace模块中，卖出原来持有的主力合约，等量买入新合约；修改MappingReal\n'''\n## 开盘前运行函数\ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    send_message('开始交易')\n    \n    # 过滤无主力合约的品种，传入并修改期货字典信息\n    for ins in g.instruments:\n        dom = get_dominant_future(ins)\n        if dom == '':\n            pass\n        else:\n            # 判断是否执行replace_old_futures\n            if dom == g.MappingReal[ins]:\n      ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "s\n            if dom == g.MappingReal[ins]:\n                pass\n            else:\n                replace_old_futures(context,ins,dom)\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n            \n            # 每个品种使用初始资金starting_cash的10%开仓\n            g.TradeLots[dom] = get_lots(context.portfolio.starting_cash/len(g.instruments),ins)\n            \n\n## 开盘时运行函数\ndef market_open(context):\n    # 输出函数运行时间\n ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "开盘时运行函数\ndef market_open(context):\n    # 输出函数运行时间\n    #log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    # 以下是主循环\n    for ins in g.instruments:\n        # 过滤空主力合约品种\n        if g.MappingReal[ins] != '':\n            IndexFuture = g.MappingIndex[ins]\n            RealFuture = g.MappingReal[ins]\n            # 获取当月合约交割日期\n            end_date = get_CCFX_end_date(RealFuture)\n            # 当月合约交割日当天不开仓\n            if (context.current_dt.date() == end_date):\n                return\n            else:\n  ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "date):\n                return\n            else:\n                g.LastRealPrice[RealFuture] = attribute_history(RealFuture,1,'1d',['close'])['close'][-1]\n                # 获取价格list\n                g.PriceArray[IndexFuture] = attribute_history(IndexFuture,50,'1d',['close','open','high','low'])\n                g.CurrentPrice = g.PriceArray[IndexFuture]['close'][-1]\n                g.ClosePrice = g.PriceArray[IndexFuture]['close']\n                # 如果没有数据，返回\n                if len(g.PriceArray[IndexFuture]) < ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "              if len(g.PriceArray[IndexFuture]) < 50:\n                    return\n                else:\n                    \n                    #设置两条均线\n                    MaFast = g.ClosePrice[-g.FastWindow:].mean()\n                    MaSlow = g.ClosePrice[-g.SlowWindow:].mean()\n                    \n                    #判断均线交叉（金叉死叉）\n                    if MaFast>MaSlow:\n                        g.Cross = 1\n                    elif MaFast<MaSlow:\n                        g.Cross = -1\n                    else",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "             g.Cross = -1\n                    else:\n                        g.Cross = 0\n                        \n                    #判断交易信号：均线交叉+可二次入场条件成立\n                    if  g.Cross == 1 and g.Reentry_long == False:\n                        g.Signal = 1\n                    elif g.Cross == -1 and g.Reentry_short == False:\n                        g.Signal = -1\n                    else:\n                        g.Signal = 0\n                        \n                    # 执行交易\n                    Trade(conte",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "            # 执行交易\n                    Trade(context,RealFuture)\n                    # 止损后，运行防止充入模块\n                    Dont_Re_entry(context,RealFuture)\n                    # 计数器+1\n                    if RealFuture in g.Times.keys():\n                        g.Times[RealFuture] += 1 \n                    else:\n                        g.Times[RealFuture] = 0\n           \n           \n## 收盘后运行函数\ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "et_close):'+str(context.current_dt.time())))\n    # 得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n    \n\n## 交易模块 \ndef Trade(context,RealFuture):\n    \n    # 快线高于慢线，且追踪止损失效，则可开多仓\n    if g.Signal == 1 and context.portfolio.long_positions[RealFuture].total_amount == 0:\n        if context.portfolio.long_positions[RealFuture].total_amount != 0:\n         ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "positions[RealFuture].total_amount != 0:\n            log.info('空头有持仓：%s'%(RealFuture))\n        order_target(RealFuture,0,side='short')\n        order_target(RealFuture,g.TradeLots[RealFuture],side='long')\n        g.HighPrice[RealFuture] = g.LastRealPrice[RealFuture]\n        g.LowPrice[RealFuture] = False\n        log.info('正常买多合约：%s'%(RealFuture))\n        \n    \n    elif g.Signal == -1 and context.portfolio.short_positions[RealFuture].total_amount == 0:\n        if context.portfolio.short_positions[RealFuture].",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": " if context.portfolio.short_positions[RealFuture].total_amount != 0:\n            log.info('多头有持仓：%s'%(RealFuture))\n        order_target(RealFuture,0,side ='long')\n        order_target(RealFuture,g.TradeLots[RealFuture],side='short')\n        g.LowPrice[RealFuture] = g.LastRealPrice[RealFuture]\n        g.HighPrice[RealFuture] = False\n        log.info('正常卖空合约：%s'%(RealFuture))\n    else:\n         TrailingStop(context,RealFuture)\n        \n        \n# 追踪止损后,防止立刻重入模块\n# 因为追踪止损条件领先于金叉死叉，所以在止损后，要防止系统再次高位入场\ndef Dont_Re",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "块\n# 因为追踪止损条件领先于金叉死叉，所以在止损后，要防止系统再次高位入场\ndef Dont_Re_entry(context,future):\n    # 防重入模块：上一次止损后20根bar内不交易，但如果出现价格突破事件则20根bar的限制失效\n    #设置最高价与最低价（注意：需要错一位，不能算入当前价格）\n    g.Highest_high_2_20 = g.ClosePrice[-21:-1].max()\n    g.Lowest_low_2_20 = g.ClosePrice[-21:-1].min()\n    \n    if  g.Reentry_long == True:\n        if g.Times[future] > 20 or g.CurrentPrice > g.Highest_high_2_20 :\n            g.Reentry_long = False\n    if  g.Reentry_short == True:\n        if g.Times[future] > 20 or g.CurrentPrice < g.Lowest_low_2_2",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "[future] > 20 or g.CurrentPrice < g.Lowest_low_2_20 :\n            g.Reentry_short = False\n        \n\n# 追踪止损模块（百分比止损）\ndef TrailingStop(context,RealFuture):\n    \n    # 记录多空仓位\n    long_positions = context.portfolio.long_positions\n    short_positions = context.portfolio.short_positions\n    \n    # 通过for循环逐一平仓（多头）\n    if RealFuture in long_positions.keys():\n        if long_positions[RealFuture].total_amount > 0:\n            if g.HighPrice[RealFuture]:\n                g.HighPrice[RealFuture] = max(g.HighPrice[RealF",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "   g.HighPrice[RealFuture] = max(g.HighPrice[RealFuture], g.LastRealPrice[RealFuture])\n                if g.LastRealPrice[RealFuture]  < g.HighPrice[RealFuture]*(1-g.stop):\n                    log.info('多头止损:\\t' +  RealFuture)\n                    order_target(RealFuture,0,side = 'long')\n                    g.Reentry_long = True\n                    \n    # 通过for循环逐一平仓（空头）\n    if RealFuture in short_positions.keys():\n        if short_positions[RealFuture].total_amount > 0:\n            if g.LowPrice[RealFuture]",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "_amount > 0:\n            if g.LowPrice[RealFuture]:\n                g.LowPrice[RealFuture] = min(g.LowPrice[RealFuture], g.LastRealPrice[RealFuture])\n                if g.LastRealPrice[RealFuture]  > g.LowPrice[RealFuture]*(1+g.stop):\n                    log.info('空头止损:\\t' + RealFuture)\n                    order_target(RealFuture,0,side = 'short')\n                    g.Reentry_short = True\n\n\n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约        \ndef replace_old_futures(context,ins,dom):\n    \n    LastFuture = g.MappingRea",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "ntext,ins,dom):\n    \n    LastFuture = g.MappingReal[ins]\n    \n    if LastFuture in context.portfolio.long_positions.keys():\n        lots_long = context.portfolio.long_positions[LastFuture].total_amount\n        order_target(LastFuture,0,side='long')\n        order_target(dom,lots_long,side='long')\n        print('主力合约更换，平多仓换新仓')\n    \n    if LastFuture in context.portfolio.short_positions.keys():\n        lots_short = context.portfolio.short_positions[dom].total_amount\n        order_target(LastFuture,0,side='sho",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "amount\n        order_target(LastFuture,0,side='short')\n        order_target(dom,lots_short,side='short')\n        print('主力合约更换，平空仓换新仓')\n\n    g.MappingReal[ins] = dom     \n            \n        \n        \n# 获取当天时间正在交易的期货主力合约函数\ndef get_future_code(symbol):\n    future_code_list = {'A':'A8888.XDCE', 'AG':'AG8888.XSGE', 'AL':'AL8888.XSGE', 'AU':'AU8888.XSGE',\n                        'B':'B8888.XDCE', 'BB':'BB8888.XDCE', 'BU':'BU8888.XSGE', 'C':'C8888.XDCE', \n                        'CF':'CF8888.XZCE', 'CS':'CS8888",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "                  'CF':'CF8888.XZCE', 'CS':'CS8888.XDCE', 'CU':'CU8888.XSGE', 'ER':'ER8888.XZCE', \n                        'FB':'FB8888.XDCE', 'FG':'FG8888.XZCE', 'FU':'FU8888.XSGE', 'GN':'GN8888.XZCE', \n                        'HC':'HC8888.XSGE', 'I':'I8888.XDCE', 'IC':'IC8888.CCFX', 'IF':'IF8888.CCFX', \n                        'IH':'IH8888.CCFX', 'J':'J8888.XDCE', 'JD':'JD8888.XDCE', 'JM':'JM8888.XDCE', \n                        'JR':'JR8888.XZCE', 'L':'L8888.XDCE', 'LR':'LR8888.XZCE', 'M':'M8888.XDCE', \n ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "88.XDCE', 'LR':'LR8888.XZCE', 'M':'M8888.XDCE', \n                        'MA':'MA8888.XZCE', 'ME':'ME8888.XZCE', 'NI':'NI8888.XSGE', 'OI':'OI8888.XZCE', \n                        'P':'P8888.XDCE', 'PB':'PB8888.XSGE', 'PM':'PM8888.XZCE', 'PP':'PP8888.XDCE', \n                        'RB':'RB8888.XSGE', 'RI':'RI8888.XZCE', 'RM':'RM8888.XZCE', 'RO':'RO8888.XZCE', \n                        'RS':'RS8888.XZCE', 'RU':'RU8888.XSGE', 'SF':'SF8888.XZCE', 'SM':'SM8888.XZCE', \n                        'SN':'SN8888.XSGE', '",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "E', \n                        'SN':'SN8888.XSGE', 'SR':'SR8888.XZCE', 'T':'T8888.CCFX', 'TA':'TA8888.XZCE', \n                        'TC':'TC8888.XZCE', 'TF':'TF8888.CCFX', 'V':'V8888.XDCE', 'WH':'WH8888.XZCE', \n                        'WR':'WR8888.XSGE', 'WS':'WS8888.XZCE', 'WT':'WT8888.XZCE', 'Y':'Y8888.XDCE', \n                        'ZC':'ZC8888.XZCE', 'ZN':'ZN8888.XSGE'}\n    try:\n        return future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n\n\n# 获取交易手数函数\ndef get_lots(cash,symbol):\n  ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": ": 无此合约'\n\n\n# 获取交易手数函数\ndef get_lots(cash,symbol):\n    # 合约规模(Contract Size)，也称交易单位\n    future_Contract_Size = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10, \n                        'CF':5, 'CS':10, 'CU':5, 'ER':10, \n                        'FB':500, 'FG':20, 'FU':50, 'GN':10, \n                        'HC':10, 'I':100, 'IC':200, 'IF':300, \n                        'IH':300, 'J':100, 'JD':5, 'JM':60, \n                        'JR':20, 'L':5, 'LR':10, 'M':10, \n    ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "            'JR':20, 'L':5, 'LR':10, 'M':10, \n                        'MA':10, 'ME':10, 'NI':1, 'OI':10, \n                        'P':10, 'PB':5, 'PM':50, 'PP':5, \n                        'RB':10, 'RI':20, 'RM':10, 'RO':10, \n                        'RS':10, 'RU':10, 'SF':5, 'SM':5, \n                        'SN':1, 'SR':10, 'T':10000, 'TA':5, \n                        'TC':100, 'TF':10000, 'V':5, 'WH':20, \n                        'WR':10, 'WS':50, 'WT':10, 'Y':10, \n                        'ZC':100, 'ZN':5}\n  ",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": ":10, \n                        'ZC':100, 'ZN':5}\n    future = get_dominant_future(symbol)\n    # 获取价格list\n    Price_dict = attribute_history(future,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0: \n        return\n    else:\n        # 获得最新开盘价，计算能够下单多少手\n        open_price = Price_dict.iloc[-1]\n    # 返回手数（价格*合约规模=名义价值）\n    # 此处没有使用杠杆，每次以starting_cash初始资金的10%去下单\n    return cash/(open_price*g.margin_rate*future_Contract_Size[symbol])\n\n\n# 获取金融期货合约到期日\ndef get_CCFX_end_date(fature_code):\n    # 获取金融期货合约到期",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "f get_CCFX_end_date(fature_code):\n    # 获取金融期货合约到期日\n    return get_security_info(fature_code).end_date",
        "source": "99策略代码/09 商品期货 多品种日频双均线模型 作为给入门者的小礼物.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11292\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport jqdata\n# 导入talib库命名为tl\nimport talib as tl\n# 导入numpy库命名为tl\nimport numpy as np\n# 导入 technical_analysis 库\nfrom jqlib.technical_analysis import *\n'''\n================================================================================\n总体回测前\n================================================================================\n'''\n\n#### 配置参数  最多持有几只股票\nMAX_OWN_NUM = 2\n#### 配置参数  买入单只股票,最大使用可用资金的几分之1\nCASH_SP_COUN",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "M = 2\n#### 配置参数  买入单只股票,最大使用可用资金的几分之1\nCASH_SP_COUNT = 2\n#### 配置参数  每天开仓买入,最大使用多少可用资金额\nCASH_MAX_USE  = 20000\n#### 配置参数  每只股票买入最大使用多少资金额\nCASH_MAX_USE_PERSTOCK = 10000\n\n#   初始化函数，设定基准等等\ndef initialize(context):\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    log.set_level('order', 'error')\n    g.HighAfterEntry = {} #存放 持仓股票 买入后所创最高价\n    g.holdday = {}#存放 持仓股票 买入后持仓天数\n    ### 股票相关设定 ###\n    #交易费率:\n    set_order_cost(OrderCost(close_tax=0.",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "  #交易费率:\n    set_order_cost(OrderCost(close_tax=0.001#印花税\n                            , open_commission=0.0003#佣金\n                            , close_commission=0.0003\n                            , min_commission=5), type='stock')\n    ## 运行函数\n      # 盘前运行\n    run_daily(before_market_open, time='before_open') \n      # 盘中运行\n    run_daily(market_open, time='close-10m')\n      # 盘后运行\n    run_daily(after_market_close, time='after_close')\n    \n\n'''\n==================================================================",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "================================================================\n每天开盘前\n================================================================================\n'''\n#   盘前运行     \ndef before_market_open(context):\n    g.date = context.current_dt.strftime(\"%Y-%m-%d\")\n    # 输出运行时间\n    log.info('盘前运行:'+str(context.current_dt.time()))\n    #设定备选股票池（中证800）\n    g.codelist = get_index_stocks('000300.XSHG')\n    #g.codelist = ['601231.XSHG']\n    #log.info('codelist:',g.codelist)\n    g.codelist = gl_tp(g.codelist)# 过滤停牌股票\n    #l",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "\n    g.codelist = gl_tp(g.codelist)# 过滤停牌股票\n    #log.info('codelist_tp:',g.codelist)\n    g.codelist = gl_st(g.codelist)# 过滤ST股票\n    #log.info('codelist_st:',g.codelist)\n    # 开盘前更新 g.HighAfterEntry 持仓股票买入后历史最高价\n    update_HighAfterEntry(context)\n   \n    \n## 过滤停牌股票\ndef gl_tp(codelist):\n    current_data = get_current_data()\n    codelist = [code for code in codelist if not current_data[code].paused]\n    return codelist\n## 过滤ST股票\ndef gl_st(codelist):\n    current_data = get_current_data()\n    codelist = [code fo",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "_data = get_current_data()\n    codelist = [code for code in codelist if not current_data[code].is_st]\n    return codelist\n##  更新 g.HighAfterEntry 持仓股票买入后历史最高价\ndef update_HighAfterEntry(context):\n    if len(g.HighAfterEntry) > 0:\n        for code in g.HighAfterEntry.keys():\n            sj = get_bars(code, 1, unit='1d',fields=['close'],include_now=True)\n            if g.HighAfterEntry[code] < sj['close'][-1]:\n                g.HighAfterEntry[code] = sj['close'][-1]\n            else:\n                pass\n     ",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "][-1]\n            else:\n                pass\n            #log.info('最高价:', g.HighAfterEntry)\n\n'''\n================================================================================\n================================================================================\n'''\n#   盘中运行\ndef market_open(context):\n    \n    log.info('盘中运行:'+str(context.current_dt.time()))\n    sell_pd(context)##  卖出扫描判断\n    tdsell(context)##  卖出\n    \n    buy_pd(context)##  买入扫描判断\n    tdbuy(context)##  买入\n'''\n==================================",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "text)##  买入\n'''\n================================================================================\n每天交易时 买入程序\n================================================================================\n'''\ndef Check_Stocks(context):\n    security = g.codelist\n    Stocks = get_fundamentals(query(\n            valuation.code,\n            valuation.pb_ratio,\n            balance.total_assets,\n            balance.total_liability,\n            balance.total_current_assets,\n            balance.total_current_liability\n        ).fi",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "      balance.total_current_liability\n        ).filter(\n            valuation.code.in_(security),\n            valuation.pb_ratio < 2,\n            valuation.pb_ratio > 0,\n            balance.total_current_assets/balance.total_current_liability > 1.2\n        ))\n\n    Stocks['Debt_Asset'] = Stocks['total_liability']/Stocks['total_assets']\n    me = Stocks['Debt_Asset'].median()\n    Code = Stocks[Stocks['Debt_Asset'] > me].code\n    return list(Code)\n##  买入扫描判断\ndef buy_pd(context):\n    buy = []\n    own_num = len(c",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": " buy_pd(context):\n    buy = []\n    own_num = len(context.portfolio.positions)#当前持仓数\n    if own_num < MAX_OWN_NUM:#如果当前持仓数<最大持仓数，执行选股\n        codelist = Check_Stocks(context)\n        for code in codelist:\n            if code in context.portfolio.positions:#剔除持仓股票\n                continue#继续，作用不执行剩余代码，结束本次循环\n            if  btj1(code)==False or btj2(code)==False:\n                continue\n            #elif btj3(code)        == False:\n            #    continue\n            #elif btj4(context,code)== False:\n     ",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "           #elif btj4(context,code)== False:\n            #    continue\n       \n            else :\n                buy.append(code)#append添加，在buy中添加股票代码\n            #当达到最大持有数是，停止选股\n            if len(buy) + own_num == MAX_OWN_NUM:\n                break\n\n    #set()创建一个无序不重复元素集,可以计算交集'&'、差集'-'、并集'|'运算\n    g.tdbuy = list(set(buy) - set(g.tdsell))#剔除今日卖出的股票\n    #log.info(' tdbuy ',g.tdbuy)#在日志中输出\n    return\n##  买入\ndef tdbuy(context):\n    buylist = g.tdbuy\n    if len(buylist)>0:#len=长度，如果 买入列表长度>0\n        #每份资金=m",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "len(buylist)>0:#len=长度，如果 买入列表长度>0\n        #每份资金=min(设定.最大可用现金,账户现金)/max(今日买入只数,买入单只股票,最大使用可用资金的几分之1）\n        per_cash = min(CASH_MAX_USE,context.portfolio.available_cash)/max(len(buylist),CASH_SP_COUNT)\n    else:#否则\n        per_cash = 0\n    for code in buylist:\n        # 用所有 cash 买入股票\n        order_value(code, per_cash)\n        # 记录这次买入\n        #log.info(\"开仓，买入 %s\" % (code))    \n    return\n####买入条件1：\ndef btj1(code):\n    a = bei_li(code)\n    b = RS(code)\n    tj = False\n    if  a == -1:\n        tj = True\n   ",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": " tj = False\n    if  a == -1:\n        tj = True\n    return tj\ndef btj2(code):\n    a = bei_li(code)\n    b = RS(code)\n    tj = False\n    if  b == -1:\n        tj = True\n    return tj\n####买入条件2：\n'''\n================================================================================\n每天交易时 卖出程序\n================================================================================\n'''\n##  卖出扫描判断\ndef sell_pd(context):\n    g.tdsell = []\n    if len(context.portfolio.positions)>0:\n        for code in context.portfolio.positions",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "0:\n        for code in context.portfolio.positions:#如果股票在持仓中\n            if  stj1(code) == True :\n                g.tdsell.append(code)\n    #log.info('tdsell ',g.tdsell)\n##  卖出\ndef tdsell(context):\n    sell_list = g.tdsell\n    \n    for code in sell_list:\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(code, 0)\n        # 记录这次卖出\n        #log.info(\"平仓，卖出 %s\" % (code))\n    return\n####卖出条件1\ndef stj1(code):\n    a = bei_li(code)\n    b = RS(code)\n    tj = False\n    if  b == 1 or a==1:\n        tj = True\n    retu",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "    if  b == 1 or a==1:\n        tj = True\n    return tj\n\n\n'''\n================================================================================\n盘后运行\n================================================================================\n'''\n#   收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('盘后运行:'+str(context.current_dt.time())))\n    ji_lu(context)\n    \n    #画线\n    record (a=GetCurrentPositionCount(context))\n    #record ()\n    #record ()\n    log.info('一天结束\\n════════════════════════════════════════════",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "一天结束\\n══════════════════════════════════════════════════════════════════════════════════════════════════════════════════')\n\ndef ji_lu(context):\n    trades = get_orders()    #得到当天所有成交记录\n    for t in trades.values():\n        #if t.is_buy and t.filled>0:\n        if t.action == 'open' and t.filled>0:\n            x = str(t.security)\n            g.HighAfterEntry[x] = t.price\n        #elif not t.is_buy and t.filled>0:\n        elif t.action == 'close' and t.filled>0:\n            xx = str(t.security)\n            try",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": ":\n            xx = str(t.security)\n            try:\n                del g.HighAfterEntry[xx]\n            except:\n                g.HighAfterEntry[xx] = 0\n        log.info(\"成交记录 \\n\\\n                              代码：%s\\n\\\n                              方向：%s\\n\\\n                              价格：%s\\n\\\n                              数量：%s\\n\"\n                              ,t.security,t.action,t.price,t.filled)\n\n##  获取当前持有几只股票\ndef GetCurrentPositionCount(context):\n    c=0#初始为0只，空仓\n              # context.portfolio.p",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "  c=0#初始为0只，空仓\n              # context.portfolio.positions = 当前持仓\n    for code in context.portfolio.positions:\n        if context.portfolio.positions[code].total_amount>0:#如果仓位>0\n            c+=1   #c+1     \n    return c\n\n'''\n================================================================================\n附属程序\n================================================================================\n'''\n\n\ndef bei_li(code):\n    security=code\n    check_date=g.date\n    TRIX1,MATRIX1 = TRIX(security,check_date, N = 12, M",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "RIX1,MATRIX1 = TRIX(security,check_date, N = 12, M = 20)\n    TRIX11=TRIX1[security]\n    MATRIX11=MATRIX1[security]\n    dev_type = None\n    if TRIX1[security]>MATRIX1[security]:\n        \n       \n        dev_type = -1\n    \n    elif TRIX1[security] < MATRIX1[security]: \n        \n        \n        dev_type = 1\n    else:  \n       \n        dev_type = 0\n    \n    return dev_type\n\ndef RS(code):\n    security=code\n    check_date=g.date\n    RSI1 = RSI(security,check_date,  N1=6)\n    RSI11=RSI1[security]\n    dev_type = N",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": ",  N1=6)\n    RSI11=RSI1[security]\n    dev_type = None\n    if 80>RSI11>55 or RSI11<15:\n        \n       \n        dev_type = -1\n    \n    elif 50>RSI11>20 or RSI11>85: \n       \n        \n        dev_type = 1\n    else:  \n     \n        dev_type = 0\n    \n    return dev_type\n\n\n",
        "source": "99策略代码/42 低估值+TRIX+RSI 低回撤策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14986\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\nfrom datetime import datetime, timedelta\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": " \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    g.security = []\n    g.counter_open = 0\n    run_monthly(market_open, 8, time='open', reference_security='000300.XSHG')\n\n\n# # 每半年开盘去选择这些股票\ndef market_open(context):\n    g.counter_open += 1\n    if g.counter_open == 1:  \n        log.info(\"又是半年，该做事了。counter: \" + str(g.counter_open))\n        sell_all()",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "unter: \" + str(g.counter_open))\n        sell_all()\n        date = str(context.current_dt.date())\n        yesterday = (datetime.strptime(date, \"%Y-%m-%d\").date() - timedelta(1)).strftime(\"%Y-%m-%d\")\n        # 获取当天的 PE, PB 符合要求的股票\n        stock_list = get_stock_list(yesterday)\n        # 按照股票代码排序股票表格\n        stock_list = stock_list.sort([\"code\"], ascending=[True])\n        # 获取对应的股息率\n        # log.info(\"股票名单：\\n\" + str(stock_list))\n        if stock_list.shape[0] > 0:\n            stock_list[\"dividend_ratio\"] = st",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "> 0:\n            stock_list[\"dividend_ratio\"] = stock_list.apply(lambda x: DividendRatio([x[0]], yesterday), axis=1)\n            stock_list = stock_list.dropna()\n            stock_list = stock_list[stock_list[\"dividend_ratio\"] > 0.03]\n            # 获取 stock_list 中股票的行业代码并且合并\n            industry_df = finance.run_query(\n                    query(\n                        finance.STK_COMPANY_INFO.code,\n                        finance.STK_COMPANY_INFO.industry_id\n                    ).filter(\n                  ",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "d\n                    ).filter(\n                        finance.STK_COMPANY_INFO.code.in_(stock_list[\"code\"].tolist())\n                    )\n                )\n            stock_list[\"industry_id\"] = industry_df[\"industry_id\"].tolist()\n            # PE 为重\n            stock_list = stock_list.sort([\"pe_ratio\", \"pb_ratio\", \"dividend_ratio\"], ascending=[True, True, False])\n            # 股息率为重\n            # stock_list = stock_list.sort([\"dividend_ratio\", \"pe_ratio\", \"pb_ratio\"], ascending=[False, True, True])\n   ",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "\", \"pb_ratio\"], ascending=[False, True, True])\n            # 获取股票和对应信息\n            stock_list_info, stock_list = get_stocks(stock_list, 10)\n            for stock in stock_list:\n                log.info('函数运行时间(before_market_open)：' + str(context.current_dt.time()) + '选择股票：' + stock)\n            if len(stock_list) > 6:\n                g.security = stock_list\n            else:\n                g.security = []\n            cash = context.portfolio.available_cash\n            log.info(\"时间：\" + str(context.current_d",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "            log.info(\"时间：\" + str(context.current_dt.date()) + \" 买买买！\" + \"cash: \" + str(cash))\n            buy_stock(g.security, cash)\n        else:\n            log.info(\"未找到 PE, PB 符合要求的股票，直接返回\")\n            return\n    else:\n        log.info(\"非半年周期，counter: \" + str(g.counter_open))\n        if g.counter_open == 6:\n            g.counter_open = 0\n \n\n\n# 获取 0 < PE < 10, 0 < PB < 1.5 的股票\ndef get_stock_list(date):\n    log.info('当前日期：' + date + '，获取 PE，PB 符合要求的股票')\n    q = query(\n        valuation.code,\n        val",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "    q = query(\n        valuation.code,\n        valuation.pe_ratio,\n        valuation.pb_ratio\n    )\n    stock_list = get_fundamentals(q, date)\n    # 过滤掉不符合要求的股票\n    stock_list = stock_list[stock_list[\"pe_ratio\"] > 0]\n    stock_list = stock_list[stock_list[\"pe_ratio\"] < 10]\n    stock_list = stock_list[stock_list[\"pb_ratio\"] > 0]\n    stock_list = stock_list[stock_list[\"pb_ratio\"] < 1.5]\n    \n    return stock_list\n    \n# 获取对应股票代码 list 下的股息率\ndef DividendRatio(security_list,end_date,count=1):\n    '''查询股息率(日更新)\n ",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "curity_list,end_date,count=1):\n    '''查询股息率(日更新)\n    输入:股票池,截止日期,获取数量\n    输出:panel结构,单位:1'''\n    trade_days = get_trade_days(end_date=end_date,count = count)\n    security_list.sort()\n    secu_list = [x[:6] for x in security_list]\n    code_df = jy.run_query(query(\n         jy.SecuMain.InnerCode,jy.SecuMain.SecuCode,\n    #     jy.SecuMain.ChiName,jy.SecuMain.CompanyCode\n        ).filter(\n        jy.SecuMain.SecuCode.in_(secu_list),jy.SecuMain.SecuCategory==1).order_by(jy.SecuMain.SecuCode))\n    code_df['code'",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "order_by(jy.SecuMain.SecuCode))\n    code_df['code'] = security_list\n    df = jy.run_query(query(\n#         jy.LC_DIndicesForValuation    #得到整表\n        jy.LC_DIndicesForValuation.InnerCode,\n                jy.LC_DIndicesForValuation.TradingDay,\n                 jy.LC_DIndicesForValuation.DividendRatio,\n                ).filter(jy.LC_DIndicesForValuation.InnerCode.in_(code_df.InnerCode),\n                        jy.LC_DIndicesForValuation.TradingDay.in_(trade_days)\n                        ))\n    f_df = df.merg",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "ays)\n                        ))\n    f_df = df.merge(code_df,on='InnerCode').set_index(['TradingDay','code']).drop(['InnerCode','SecuCode'],axis=1)\n    panel = f_df.to_panel()\n    return panel.major_xs(panel.major_axis[0])[\"DividendRatio\"].tolist()[0] if len(panel.major_axis) > 0 else None\n\n# 获取股票的行业代码\ndef get_industry_id(code):\n    df = finance.run_query(\n        query(\n            finance.STK_COMPANY_INFO.industry_id\n        ).filter(\n            finance.STK_COMPANY_INFO.code == code\n        )\n    )\n    \n ",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "K_COMPANY_INFO.code == code\n        )\n    )\n    \n    return df[\"industry_id\"][0]\n\n# 在备选股票中选出 10 只股票，注意同行业的占比不能超过 10%\ndef get_stocks(sorted_stock_list, max_stock):\n    stock_list_info = []\n    stock_list = []\n    occur_dict = {}\n    for loc in range(sorted_stock_list.shape[0]):\n        field = get_industry_id(sorted_stock_list.iloc[loc][\"code\"])\n        if field in occur_dict:\n            if occur_dict[field] >= max_stock * 0.3:\n                continue\n            else:\n                occur_dict[field] += ",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "       else:\n                occur_dict[field] += 1\n                stock_list_info.append(sorted_stock_list.iloc[loc])\n                stock_list.append(sorted_stock_list.iloc[loc][\"code\"])\n        else:\n            stock_list_info.append(sorted_stock_list.iloc[loc])\n            stock_list.append(sorted_stock_list.iloc[loc][\"code\"])\n            occur_dict[field] = 1\n        if len(stock_list) >= max_stock:\n            break\n    return stock_list_info, stock_list\n\ndef sell_all():\n    log.info(\"股票数量：\" + str(",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "_list\n\ndef sell_all():\n    log.info(\"股票数量：\" + str(len(g.security)))\n    for stock in g.security:\n        # 卖出这些股票\n        log.info(\"卖出：\" + stock)\n\n        order_target(stock, 0)\n\ndef buy_stock(stock_list, sum_price):\n    if stock_list is None or len(stock_list) == 0:\n        log.info(\"未选到合适股票，本期空仓\")\n        return \n    # 获取 stock_list 中股票的当日价格\n    price_dict = history(1, unit='1d', field='avg', security_list=stock_list, df=False, skip_paused=False, fq='pre')\n    for stock in price_dict.keys():\n        price",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "\n    for stock in price_dict.keys():\n        price_dict[stock] = price_dict[stock][0]\n    # 将 sum_price 平均分配到这些股票上\n    sum_price_dict = {}\n    per_price = sum_price / len(price_dict)\n    for stock in price_dict.keys():\n        num = math.floor(per_price / price_dict[stock] / 100)\n        log.info(\"买入：\" + stock + \", 数量：\" + str(num * 100) + \"股\")\n        order(stock, num * 100)\n    #     sum_price_dict[stock] = math.floor(per_price / price_dict[stock] / 100)\n    # sum_value = 0\n    # for stock in sum_price_dic",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "  # sum_value = 0\n    # for stock in sum_price_dict.keys():\n    #     sum_value += sum_price_dict[stock] * price_dict[stock]*100\n    # res_value = sum_price - sum_value\n    # return price_dict, sum_price_dict, res_value\n    \n\n",
        "source": "99策略代码/85 【第一次玩】我就是要买便宜股系列.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13706\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nfrom jqlib.technical_analysis import *\nimport datetime\nimport pandas as pd\nimport numpy as np\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n        #",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "的log\n    log.set_level('order', 'error')\n        #send_message('推送测试')\n    init_cash = 80000  # 初始资金\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock')])\n\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n    # 要操作的股票池：（g:global为全局变量）\n    g.security = ['002241.XSHE', '000333.XSHE','002230.XSHE','002747.XSHE','002415.XSHE']\n    g.holding_high_price = 0  # 持有期间最高价\n    g.init_price = 0  # 股票初始价格,用于计算股票收益\n    #for stk in g.securi",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "ce = 0  # 股票初始价格,用于计算股票收益\n    #for stk in g.security:\n    # 获取股票的收盘价\n    #  close_data = attribute_history(stk, 5, '1d', ['close'])\n    # 取得上一时间点价格\n    #  g.init_price = close_data['close'][-1]\n    #history(5, security_list=['000001.XSHE', '000002.XSHE'])\n    close_data = history(5,unit='1d',field='close', security_list=g.security)\n    #print(close_data)\n    g.init_price = close_data.iloc[-1]\n    #取得初始交易日前一日所有股票收盘价格\n    #print(g.init_price)\n    g.maxnum = 5  # 最大持仓数\n    g.lower = -2  # 下限\n    g.upper = 1  #",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": " # 最大持仓数\n    g.lower = -2  # 下限\n    g.upper = 1  # 上限\n    g.zscore_window = 60  # zscore窗口\n    g.ma_window = 20  # 均线窗口\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5),\n                   type='stock')\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', r",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "un_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n\n#买入卖出信号函数\ndef get_buy_sell(context):\n    buy, sell = [], []\n    # 取得当前可用的资金\n    cash = context.portfolio.available_cash\n    # 设定均线窗口长度\n    n1 = 5 \n    #5日均线\n    n2 = 10\n    #10日均线\n    close_data = history(5,unit='1d',field='close', secur",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "se_data = history(5,unit='1d',field='close', security_list=g.security)\n    #日交易数据\n    for stk in g.security:\n        # 取得上一时间点价格\n        previous_price = close_data.iloc[-1][stk]\n        # 画出上一时间点价格\n        record(stock_price=previous_price)\n        # 计算股票收益率\n        stock_returns = (previous_price - g.init_price[stk]) / g.init_price[stk]\n        # 画出上一时间点持股收益，方便查看，放大100倍\n        record(stock_returns=stock_returns * 100)\n        # 获取股票的收盘价\n        close_data1 = attribute_history(stk, n2 + 2, '1d', ['close']",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "1 = attribute_history(stk, n2 + 2, '1d', ['close'], df=False)\n        ma_n1 = close_data1['close'][-n1:].mean()\n        # 取得过去 ma_n2 天的平均价格\n        ma_n2 = close_data1['close'][-n2:].mean()\n        hold = context.subportfolios[0].long_positions <> {}\n        #print('是否持仓：')\n        #print(hold)\n        selladj = analysis_sell(context, stk) or ma_n1 < ma_n2\n        #print('是否卖出flag：%s :' %(stk))\n        #print(selladj)\n        \n        #判断该股是否有卖出标志位\n        if hold and selladj:\n            #如果有标志位则卖出\n       ",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "f hold and selladj:\n            #如果有标志位则卖出\n            sell.append(stk)\n            print(\"最终判断 %s:卖出%%\" % (stk))\n            send_message(\"最终判断 %s:卖出%%\" % (stk))\n    #判断买入信号        \n    for stk in g.security:\n        \n        ma_n1 = close_data1['close'][-n1:].mean()\n        # 取得过去 ma_n2 天的平均价格\n        ma_n2 = close_data1['close'][-n2:].mean()\n        buyadj = analysis_buy(context, stk) and ma_n1 > ma_n2*0.95\n        #print(analysis_buy(context, stk))\n        #print(ma_n1 >= ma_n2)\n        #print('是否买入flag",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "   #print(ma_n1 >= ma_n2)\n        #print('是否买入flag：%s :' %(stk))\n        #print(buyadj)\n        if buyadj:\n            buy.append(stk)\n            print(\"最终判断 %s:买入%%\" % (stk))\n            send_message(\"最终判断 %s:买入%%\" % (stk))    \n    return buy, sell\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    print('美好的一天~')\n    \n    g.buy, g.sell = get_buy_sell(cont",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "好的一天~')\n    \n    g.buy, g.sell = get_buy_sell(context)\n    # 要操作的股票：平安银行（g.为全局变量）\n    #g.security = '000001.XSHE'\n    \n## 开盘时运行函数\ndef market_open(context):\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    #security = g.security\n    # 获取股票的收盘价\n    #close_data = attribute_history(security, 5, '1d', ['close'])\n    # 取得过去五天的平均价格\n    #MA5 = close_data['close'].mean()\n    # 取得上一时间点价格\n    #current_price = close_data['close'][-1]\n    # 取得当前的现金\n    #cash = context.portfolio.available_cash\n    ",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "\n    #cash = context.portfolio.available_cash\n    # 先卖\n    for code in g.sell:\n        order_target(code, 0)\n    # 再买\n    \n    if len(g.buy)>0 and len(context.portfolio.positions)>0:\n        for stock in context.portfolio.positions:\n            holdsell = context.portfolio.positions[stock].closeable_amount\n            print('多股金叉卖出半仓分散持仓%s' %holdsell)\n            if holdsell>100:\n               order_target(stock, holdsell/2)\n        \n    cash_per_stock = context.portfolio.available_cash    \n    if len(g.bu",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "ntext.portfolio.available_cash    \n    if len(g.buy)>0:    \n        cash_per_stock = context.portfolio.available_cash/len(g.buy) # 个股资金\n    for code in g.buy:\n        hold = len(context.portfolio.positions)\n        # 未达到最大持仓数\n        if hold < g.maxnum and cash_per_stock>8000 :\n            order_target_value(code, cash_per_stock)\n    print('buy: %d  sell: %d  hold: %d' % (len(g.buy), len(g.sell), len(context.portfolio.positions)))\n\n    # 如果上一时间点价格高出五天平均价1%, 则全仓买入\n    #if current_price > 1.01*MA5:\n        # ",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "则全仓买入\n    #if current_price > 1.01*MA5:\n        # 记录这次买入\n    #    log.info(\"价格高于均价 1%%, 买入 %s\" % (security))\n        # 用所有 cash 买入股票\n    #    order_value(security, cash)\n    # 如果上一时间点价格低于五天平均价, 则空仓卖出\n    #elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:\n        # 记录这次卖出\n    #    log.info(\"价格低于均价, 卖出 %s\" % (security))\n        # 卖出所有股票,使这只股票的最终持有量为0\n    #    order_target(security, 0)\n \n## 收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_c",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n\n\n\n\n\n\n\n#分析卖出函数\ndef analysis_sell(context, security):\n    # 分析某支股票是否卖出时机\n    # MACD 死叉\n    # 亏损超过15%\n    # 持有期间最高价下跌超过15%\n    sellflag=False\n    #返回值0 默认为不卖出 返回值为1则卖出该股票\n    # MACD 死叉\n    if isMACDDead(conte",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": " 返回值为1则卖出该股票\n    # MACD 死叉\n    if isMACDDead(context, security):\n        # 卖出所有股票,使这只股票的最终持有量为0\n        sellflag=True \n        # 记录这次卖出\n        msg_to_send = \"Selling %s:macd_dead\" % (security)\n        log.info(msg_to_send)\n        #send_message(msg_to_send, channel='weixin')\n\n    # 亏损超过15%\n    price = context.subportfolios[0].long_positions[security].price\n    avg_cost = context.subportfolios[0].long_positions[security].avg_cost\n\n    if price <> 0 and price < avg_cost * 0.93:\n        # 卖出所有股票,使这只股票的最终持有量为0",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": " < avg_cost * 0.93:\n        # 卖出所有股票,使这只股票的最终持有量为0\n        #order_target(security, 0)\n        sellflag=True\n        # 记录这次卖出\n        msg_to_send = \"Selling %s:亏损超过15%%\" % (security)\n        log.info(msg_to_send)\n        #send_message(msg_to_send, channel='weixin')\n    #均值回归Zscore卖出\n    \n    yesterday = context.current_dt - datetime.timedelta(1)  # 昨天\n    count = g.zscore_window + g.ma_window - 1  # 2个窗口数和\n    code = security\n    price_df = get_price(g.security, end_date=yesterday, fields='close', count=coun",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "ty, end_date=yesterday, fields='close', count=count).close\n    #if d.has_key:\n    #print(price_df)\n    try:\n        #print('zscore断点0')\n        single_df = price_df[code].to_frame('close')\n        #print('zscore断点1')\n        single_df['ma'] = pd.rolling_mean(single_df.close, window=g.ma_window)  # 均线\n        #print('zscore断点2')\n        single_df.dropna(inplace=True)\n        single_df['sub'] = single_df.close - single_df.ma  # 对差值进行回归\n        zscore_mean = single_df['sub'].mean(); zscore_std = single_df['sub",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "ngle_df['sub'].mean(); zscore_std = single_df['sub'].std()  # 均值和标准差\n        zscore_value = (single_df['sub'][-1] - zscore_mean) / zscore_std\n        #print('zscore断点3')\n        if zscore_value >= g.upper and price <> 0:  # 卖出\n            #order_target(security, 0)# zscore值\n            msg_to_send = \"zscore值 %s:卖出%%\" % (security)\n            print('zscore值卖出')\n            log.info(msg_to_send)\n            sellflag=True\n    except:\n        pass\n    # 持有期间最高价下跌超过15%\n    # 先计算持有期间最高价holding_high_price\n    if p",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "跌超过15%\n    # 先计算持有期间最高价holding_high_price\n    if price == 0:\n        g.holding_high_price = 0  # 无持仓\n    elif price > g.holding_high_price:\n        g.holding_high_price = price  # 设置股价为更高值\n\n        if price < g.holding_high_price * 0.93:\n            # 卖出所有股票,使这只股票的最终持有量为0\n            #order_target(security, 0)\n            # 记录这次卖出\n            msg_to_send = \"Selling %s:持有期间最高价下跌超过15%%\" % (security)\n            log.info(msg_to_send)\n            sellflag=True\n            #send_message(msg_to_send, channel='wei",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "           #send_message(msg_to_send, channel='weixin')\n    return sellflag\n    # 应该卖出，但订单未成交，需要继续出售\n    pass\n\n\ndef analysis_buy(context, security):\n    # 分析某支股票是否买入时机，如是则买入\n    # MACD 金叉\n    buyflag=False\n    #返回值0 默认为不买入 返回值为1则买入该股票\n    # 取得当前可用的资金\n    #cash = context.portfolio.available_cash\n\n    # MACD 金叉\n    if isMACDGold(context, security):\n        buyflag=True\n    # 用所有 cash 买入股票\n    #    if cash > 60000:\n    #        dividecash=cash/5*4\n    #    else: dividecash=cash\n    #    dividecash=cash    \n   ",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": ": dividecash=cash\n    #    dividecash=cash    \n    #    order_value(security, dividecash)\n    # 记录这次买入\n        msg_to_send = \"Buying %s:macd_gold\" % (security)\n        log.info(msg_to_send)\n        #send_message(msg_to_send, channel='weixin')\n    return buyflag\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef isMACDGold(context, security):\n    '''\n    判断是否 MACD 金叉\n    return True or False\n    '''\n    # 当天和前一个交易日的日期\n    check_date = context.current_dt.strftime('%Y-%m-%d')\n    previous_date = context.previous_date\n\n    # 计算并输出 security 的",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "te = context.previous_date\n\n    # 计算并输出 security 的 MACD 值\n    macd_dif, macd_dea, macd_macd = MACD(security, check_date=check_date, SHORT=12, LONG=26, MID=9)\n    previous_date_macd_dif, previous_date_macd_dea, previous_date_macd_macd = MACD(security, check_date=previous_date,\n                                                                                   SHORT=12, LONG=26, MID=9)\n\n    if previous_date_macd_macd[security] < 0 and macd_macd[security] > 0:\n        return True\n    else:\n        return False\n",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "       return True\n    else:\n        return False\n\n\ndef isMACDDead(context, security):\n    '''\n    判断是否 MACD 死叉\n    return True or False\n    '''\n    # 当天和前一个交易日的日期\n    check_date = context.current_dt.strftime('%Y-%m-%d')\n    previous_date = context.previous_date\n\n    # 计算并输出 security 的 MACD 值\n    macd_dif, macd_dea, macd_macd = MACD(security, check_date=check_date, SHORT=12, LONG=26, MID=9)\n    previous_date_macd_dif, previous_date_macd_dea, previous_date_macd_macd = MACD(security, check_date=previous_date,",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "cd_macd = MACD(security, check_date=previous_date,\n                                                                                   SHORT=12, LONG=26, MID=9)\n\n    if previous_date_macd_macd[security] > 0 and macd_macd[security] < 0:\n        return True\n    else:\n        return False\n",
        "source": "99策略代码/18 均值回归策略分享.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11115\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/10246\n# 标题：【量化课堂】RSRS(阻力支撑相对强度)择时策略（上）\n# 作者：JoinQuant量化课堂\n\n# 导入函数库\nimport jqdata\nfrom jqdata import *\nimport pandas as pd\nfrom pandas import Series, DataFrame\nimport numpy as np\nimport matplotlib\nfrom pandas.stats.api import ols\nimport datetime\nimport time\n\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定上证指数作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XS",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "ence_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n\n    # 设置RSRS指标中N, M的值\n    g.N = 18\n    g.M = 480\n    \n    # 要操作的股票：平安银行（g.为全局变量）\n    g.security = '000300.XSHG'\n    \n    # 买入阈值\n    g.buy = 0.7\n ",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": " = '000300.XSHG'\n    \n    # 买入阈值\n    g.buy = 0.7\n    g.sell = -0.7\n    \n    \n    # 计算出所有需要的RSRS斜率指标\n    # 计算交易日期区间长度(包括开始前一天)\n    g.trade_date_range = len(get_trade_days(start_date = context.run_params.start_date, end_date = context.run_params.end_date)) + 1\n    # 取出交易日期时间序列(包括开始前一天)\n    g.trade_date_series = get_trade_days(end_date = context.run_params.end_date, count = g.trade_date_range)\n    # 计算RSRS斜率的时间区间长度\n    g.date_range = len(get_trade_days(start_date = context.run_params.start_date, end_date = con",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "te = context.run_params.start_date, end_date = context.run_params.end_date)) + g.M\n    # 取出计算RSRS斜率的时间序列\n    g.date_series = get_trade_days(end_date = context.run_params.end_date, count = g.date_range)\n    # 建立RSRS斜率空表\n    g.RSRS_ratio_list = Series(np.zeros(len(g.date_series)), index = g.date_series)\n    # 填入各个日期的RSRS斜率值\n    for i in g.date_series:\n        g.RSRS_ratio_list[i] = RSRS_ratio(g.N, i)\n        \n        \n    \n    # 计算标准化的RSRS指标\n    # 计算均值序列\n    g.trade_mean_series =  pd.rolling_mean(g.RSRS_ratio",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": ".trade_mean_series =  pd.rolling_mean(g.RSRS_ratio_list, g.M)[-g.trade_date_range:]\n    # 计算标准差序列\n    g.trade_std_series = pd.rolling_std(g.RSRS_ratio_list, g.M)[-g.trade_date_range:]\n    # 计算标准化RSRS指标序列\n    g.RSRS_stdratio_list = Series(np.zeros(len(g.trade_date_series)), index = g.trade_date_series)\n    g.RSRS_stdratio_list = (g.RSRS_ratio_list[-g.trade_date_range:] - g.trade_mean_series) /  g.trade_std_series\n    #print g.RSRS_stdratio_list\n        \n    \n  \n# 附: RSRS斜率指标定义\ndef RSRS_ratio(N, date):\n    se",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "  \n# 附: RSRS斜率指标定义\ndef RSRS_ratio(N, date):\n    security = g.security\n    stock_price_high = get_price(security, end_date = date, count = N)['high']\n    stock_price_low = get_price(security, end_date = date, count = N)['low']\n    ols_reg = ols(y = stock_price_high, x = stock_price_low)\n    return ols_reg.beta.x\n    \n    \n    \n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_me",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "ime()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message('美好的一天~')\n\n\n    \n\n    \n## 开盘时运行函数\ndef market_open(context):\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    security = g.security\n    # 取得当前的现金\n    cash = context.portfolio.available_cash\n\n    # 如果上一时间点的RSRS斜率大于买入阈值, 则全仓买入\n    if g.RSRS_stdratio_list[context.previous_date] > g.buy:\n        # 记录这次买入\n        log.info(\"标准化RSRS斜率大于买入阈值, 买入 %s\" % (security))\n        # 用所有 cash 买入股票\n        order_value(security, cash)\n    # 如果上一时间点的RS",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "      order_value(security, cash)\n    # 如果上一时间点的RSRS斜率小于卖出阈值, 则空仓卖出\n    elif g.RSRS_stdratio_list[context.previous_date] < g.sell and context.portfolio.positions[security].closeable_amount > 0:\n        # 记录这次卖出\n        log.info(\"标准化RSRS斜率小于卖出阈值, 卖出 %s\" % (security))\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(security, 0)\n \n## 收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _t",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "  #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n",
        "source": "99策略代码/93 RSRS——大盘择时.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14750\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\nimport pandas as pd\nimport numpy as np\nfrom sklearn import linear_model\nfrom numpy import mean, std\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    context.stock_id='510300.XSHG'\n    context.beat_list=[]\n    context.count=0\n    context.z_beta_r2_list=[]\n    context.n_value=18\n    context.m_value=400\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSH",
        "source": "99策略代码/69 阻力支撑相对强度（RSRS）指标择时策略.txt"
    },
    {
        "text": "00\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\ndef before_trading_start(context):\n    advance_high_array=attribute_history(context.stock_id,400,'60m','high')\n    advance_low_array=attribute_history(context.stock_id,400,'60m','low')\n    \n    for i in range(context.n_value,context.m_value):\n        \n        sliding_windows_high_array=advance_high_array[i-18:i]\n        sliding_windows_low_array=advance_low_array[i-18:i]\n\n        reg = linear_m",
        "source": "99策略代码/69 阻力支撑相对强度（RSRS）指标择时策略.txt"
    },
    {
        "text": "=advance_low_array[i-18:i]\n\n        reg = linear_model.LinearRegression()\n        reg.fit (sliding_windows_low_array,sliding_windows_high_array)\n        beat=reg.coef_\n        context.beat_list.append(beat)\n        \n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context,data):\n\n    context.count=context.count+1\n    if context.count % 60==0:\n        high_array=attribute_history(context.stock_id,18,'60m','high')\n        low_array=attribute_history(context.stock_id,18,'60m','low')\n        reg = li",
        "source": "99策略代码/69 阻力支撑相对强度（RSRS）指标择时策略.txt"
    },
    {
        "text": "(context.stock_id,18,'60m','low')\n        reg = linear_model.LinearRegression()\n        reg.fit(low_array,high_array)\n        beat=reg.coef_\n        R_sq=reg.score(low_array,high_array)\n    \n        beat_z=R_sq*(beat-mean(context.beat_list))/std(context.beat_list)\n    \n        context.z_beta_r2_list.append(beat_z)\n        log.info(\"context.z_beta_r2_list\",context.z_beta_r2_list)\n        cash = context.portfolio.available_cash\n        print(cash)\n        print(\"beat\",beat)\n        print(\"R_sq\",R_sq)\n        ",
        "source": "99策略代码/69 阻力支撑相对强度（RSRS）指标择时策略.txt"
    },
    {
        "text": "t(\"beat\",beat)\n        print(\"R_sq\",R_sq)\n        print(\"beat_z\",beat_z)\n        record(name=beat_z)\n        if len(context.z_beta_r2_list)>2:\n            if context.z_beta_r2_list[-2]<0.7 and context.z_beta_r2_list[-1]>0.7:\n                log.info(\" 买入 %s\" % (context.stock_id))\n                order_value(context.stock_id,cash)\n            if context.z_beta_r2_list[-2]>-0.7 and context.z_beta_r2_list[-1]<-0.7:\n                log.info(\" 卖出 %s\" % (context.stock_id))\n                order_target_value(conte",
        "source": "99策略代码/69 阻力支撑相对强度（RSRS）指标择时策略.txt"
    },
    {
        "text": "tock_id))\n                order_target_value(context.stock_id, 0)\n    # record(context.z_beta_r2_list)\n",
        "source": "99策略代码/69 阻力支撑相对强度（RSRS）指标择时策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11713\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport pandas as pd\nimport datetime\nimport numpy as np\nimport math\nimport time\nimport jqdata\nfrom pandas import Series, DataFrame\nimport statsmodels.api as sm\nimport scipy.stats as scs\nimport matplotlib.pyplot as plt\n#from pandas import Series, DataFrame\n\n#总体回测前要做的事情\ndef initialize(context):\n    set_params()        #1设置策参数\n    set_variables() #2设置中间变量\n    set_backtest()   #3设置回测条件\n\n#1\n#设置策参数\ndef set_par",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "  set_backtest()   #3设置回测条件\n\n#1\n#设置策参数\ndef set_params():\n    g.tc=15  # 调仓频率\n    g.yb=63  # 样本长度\n    g.N=20   # 持仓数目\n    \n    #ARL=total_liability/total_assetsARL=total_liability/total_assets\n    #g.factors=[\"market_cap\",\"roe\",\"pe_ratio\",\"eps\"] # 选出来的可用因子\n    #g.factors=[\"market_cap\",\"roe\",\"pe_ratio\",\"ps_ratio\"] # 用户选出来的因子\n    #g.factors=[\"circulating_market_cap\",\"eps\",\"net_profit_to_total_revenue\",\"roe\",\"pcf_ratio\",\"ps_ratio\",\"pe_ratio\",\"turnover_ratio\"] # 用户选出来的因子\n    g.factors=[\"circulating_market_cap\",\"",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "用户选出来的因子\n    g.factors=[\"circulating_market_cap\",\"ps_ratio\",\"eps\",\"net_profit_to_total_revenue\",\"roe\",\"pcf_ratio\",\"pe_ratio\",\"turnover_ratio\"] # 用户选出来的因子\n    # 因子等权重里1表示因子值越小越好，-1表示因子值越大越好\n    g.weights=[[-1],[1],[-1],[-1],[-1],[-1],[1],[1]]\n#2\n#设置中间变量\ndef set_variables():\n    g.t=0              #记录回测运行的天数\n    g.if_trade=False   #当天是否交易\n\n#3\n#设置回测条件\ndef set_backtest():\n    set_option('use_real_price', True)#用真实价格交易\n    log.set_level('order', 'error')\n\n'''\n=====================================================",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "=============================================================================\n每天开盘前\n================================================================================\n'''\n\n#每天开盘前要做的事情\ndef before_trading_start(context):\n    if g.t%g.tc==0:\n        #每g.tc天，交易一次性\n        g.if_trade=True \n        # 设置手续费与手续费\n        set_slip_fee(context) \n        # 设置可行股票池：获得当前开盘的沪深300股票池并剔除当前或者计算样本期间停牌的股票\n        g.all_stocks = set_feasible_stocks(get_index_stocks('000300.XSHG'),g.yb,context)\n        # 查询所有财务因子\n        #运行时会报err",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "g.yb,context)\n        # 查询所有财务因子\n        #运行时会报error，说g.q不能序列化，于是把它后置了\n        #g.q = query(valuation,balance,cash_flow,income,indicator).filter(valuation.code.in_(g.all_stocks))\n    g.t+=1\n\n#4\n# 设置可行股票池\n# 过滤掉当日停牌的股票,且筛选出前days天未停牌股票\n# 输入：stock_list为list类型,样本天数days为int类型，context（见API）\n# 输出：list\ndef set_feasible_stocks(stock_list,days,context):\n    # 得到是否停牌信息的dataframe，停牌的1，未停牌得0\n    suspened_info_df = get_price(list(stock_list), start_date=context.current_dt, end_date=context.current_dt, frequency='daily', f",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": " end_date=context.current_dt, frequency='daily', fields='paused')['paused'].T\n    # 过滤停牌股票 返回dataframe\n    unsuspened_index = suspened_info_df.iloc[:,0]<1\n    # 得到当日未停牌股票的代码list:\n    unsuspened_stocks = suspened_info_df[unsuspened_index].index\n    # 进一步，筛选出前days天未曾停牌的股票list:\n    feasible_stocks=[]\n    current_data=get_current_data()\n    #获取指定天数内是否有停牌，和为0则没有停牌\n    for stock in unsuspened_stocks:\n        if sum(attribute_history(stock, days, unit='1d',fields=('paused'),skip_paused=False))[0]==0:\n            f",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "'paused'),skip_paused=False))[0]==0:\n            feasible_stocks.append(stock)\n    return feasible_stocks\n    \n#5\n# 根据不同的时间段设置滑点与手续费\ndef set_slip_fee(context):\n    # 将滑点设置为0\n    set_slippage(FixedSlippage(0)) \n    # 根据不同的时间段设置手续费\n    dt=context.current_dt\n    log.info(type(context.current_dt))\n    \n    if dt>datetime.datetime(2013,1, 1):\n        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)) \n        \n    elif dt>datetime.datetime(2011,1, 1):\n        set_commission(PerTrade(buy_cost",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "11,1, 1):\n        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))\n            \n    elif dt>datetime.datetime(2009,1, 1):\n        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))\n                \n    else:\n        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))\n\n'''\n================================================================================\n每天交易时\n================================================================================\n'''\ndef handl",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "====================================\n'''\ndef handle_data(context, data):\n    if g.if_trade==True:\n    # 计算现在的总资产，以分配资金，这里是等额权重分配\n        g.everyStock=context.portfolio.portfolio_value/g.N\n        # 获得因子排序，返回一个dataframe,有股票代码、有得分、有因子值\n        df_caiwu=getRankedFactors(g.factors,g.all_stocks)\n        toBuy=df_caiwu.index[0:g.N]\n        # 对于不需要持仓的股票，全仓卖出\n        order_stock_sell(context,toBuy)\n        # 对于不需要持仓的股票，按分配到的份额买入\n        order_stock_buy(context,toBuy)\n    g.if_trade=False    \n\n#6\n#获得卖出信号，并执行卖出操作\n#输入",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": ")\n    g.if_trade=False    \n\n#6\n#获得卖出信号，并执行卖出操作\n#输入：context,toBuy-list\n#输出：none\ndef order_stock_sell(context,toBuy):\n    # 对于不需要持仓的股票，全仓卖出\n        for i in context.portfolio.positions:\n            if i not in toBuy:\n                order_target_value(i, 0)\n\n#7\n#获得买入信号，并执行买入操作\n#输入：context,toBuy-list\n#输出：none\ndef order_stock_buy(context,toBuy):\n    # 对于不需要持仓的股票，按分配到的份额买入\n    for i in toBuy:\n        if i not in context.portfolio.positions:\n            order_target_value(i,g.everyStock)\n\n#9\n#取因子数据\n#输入：f-全局通用的查询,",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "et_value(i,g.everyStock)\n\n#9\n#取因子数据\n#输入：f-全局通用的查询,股票列表\n#输出：因子数据，打分完毕的股票的代码-dataframe\ndef getRankedFactors(f,all_stocks):\n    # 获得股票的基本面数据\n    q = query(valuation,balance,cash_flow,income,indicator).filter(valuation.code.in_(all_stocks))\n    df = get_fundamentals(q)\n    #获取我们指定因子的df\n    df1= df[f]\n    #将股票名字当作列表\n    df1.index = df.code\n    #把因子值变成排序的值\n    df1=df1.rank(axis=0, method='average', ascending=True)\n    #进行打分\n    points=np.dot(df1.values,g.weights)\n    #打分加入df\n    df1['points']=pd.Series(list(point",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "    #打分加入df\n    df1['points']=pd.Series(list(points),index=df1.index)\n    #排序\n    df1=df1.sort('points',ascending=True)\n    #返回一个打完分的df\n    return df1\n\n'''\n================================================================================\n每天收盘后\n================================================================================\n'''\n# 每日收盘后要做的事情（本策略中不需要）\ndef after_trading_end(context):\n    return\n",
        "source": "99策略代码/92 多因子选股策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/10545\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "uy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "io.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.secur",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_fil",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_li",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_l",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in buy_lists if money_flow_dayu(context, security, 'net_pct_main', 10, which_day='previous')]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    el",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "     # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.sell",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "lled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\nde",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "   # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    security_list = [security for security in security_list if MACD_judge_jincha(security, 12, 26, 26)]\n    security_list = [security for security in security_list if BBands_lowerband_judge_dayu(security, 6, 5, 2, 2)]\n    security_list = [security for security in security_list if MA_judge_duotou(security, 5, 10)]\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    security_list = [security for security in security_list if money_flow_dayu(context, security, 'net_pct_main', 15, which_day='previous')]\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\nd",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        valuation.circulating_market_cap:('asc',0),\n        valuation.pe_ratio:('asc',0),\n        indicator.roe:('desc',0),\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "ys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if n_day_chg_dayu(security, 5, 0.05)]\n    sell_lists = [security for security in sell_lists if MACD_judge_sicha(security, 12, 26, 26)]\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_list",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": " len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_fi",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "  return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = re",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": ":\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sor",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "#######################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 sco",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "      a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n     ",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n   ",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in se",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "a()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in securi",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "        security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "ity_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n ",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        s",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": ":\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/95 资金流策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11619\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport numpy as np\nimport pandas as pd\nimport scipy as sp\nfrom datetime import *\nimport jqdata\nfrom jqdata import gta\nimport statsmodels.api as sm\nfrom jqlib.technical_analysis import *\nfrom cvxopt import solvers, matrix\nimport time\n\n\ndef initialize(context):\n    set_benchmark('000001.XSHG')\n    set_slippage(FixedSlippage(0.02))\n    set_option('use_real_price', True)\n    g.days=0\n    g.seven=seven()\n   ",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "price', True)\n    g.days=0\n    g.seven=seven()\n    g.get_sign=get_sign()\n    g.filter_process=filter_process_()\n    g.seven.set_commission_style(type=2) #VM\n    \n\ndef handle_data(context, data):\n    bollsign=g.get_sign.calboll(context)\n    runsign=g.get_sign.calrun(context)\n    \n    #list0=g.filter_process.fp_initial_list(index='000050.XSHG')\n    list0=get_index_stocks('000001.XSHG')\n    #print(len(list0))\n    list1=g.filter_process.fp_indu_filter(list0)\n    #print(len(list1))\n    list2=g.filter_process.fp_",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": " #print(len(list1))\n    list2=g.filter_process.fp_peg_filter(dynamic=True,yb_length=4,qr_length=3,list1=list1,context=context)\n    #print(len(list2))\n    #list3=g.filter_process.fp_rs_filter(list2,benchmark='000001.XSHG',context=context)\n    #print(len(list3))\n    \n    list3=g.filter_process.fp_pb_filter(context,list2)\n    list4=g.seven.set_tradeable_stock(context, list3, paused_style=True, new_style=True, new_count=60, limit_style=True)\n    #print(len(list4))\n    weights=g.seven.AllocationSystem(context, l",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "))\n    weights=g.seven.AllocationSystem(context, list4=list4, alloc_type=0)\n    #print(weights)\n    \n    g.seven.TradingSystem(context, bearsign=bollsign, tradesign=runsign, list4=list4, weight_data=weights)\n\nclass get_sign():\n    \n    #布林通道预警信号\n    def calboll(self,context):\n        index='000001.XSHG' \n        stdate=context.previous_date\n        ub,mb,lb=Bollinger_Bands(index, check_date=stdate, timeperiod=20, nbdevup=2.33, nbdevdn=1.97) #VM\n        maxprice=attribute_history(index,count=1,fields=['high'",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "ice=attribute_history(index,count=1,fields=['high'])\n        minprice=attribute_history(index,count=1,fields=['low'])\n        sign=[]\n        if maxprice['high'][0]>0.97*ub[index]: #VM\n            sign.append('bullish')\n        elif minprice['low'][0]<1.02*lb[index]: #VM\n            sign.append('bearish')\n        else:\n            sign.append('hold')\n            \n        bearsign=sign\n        return bearsign\n        \n    def calrun(self,context):\n        days=g.days\n        tradesign=[]\n        if days % 1 ",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "s=g.days\n        tradesign=[]\n        if days % 1 ==0: #VM\n            tradesign.append('trade')\n        else:\n            tradesign.append('hold')\n        days+=1\n        g.days=days\n        return tradesign\n\nclass filter_process_():\n        \n    def fp_initial_list(self,index):\n        list0=get_index_stocks(index)\n        return list0\n    \n    def fp_indu_filter(self,list0):\n        cycle_indu=[#'A01', #\t农业 \t1993-09-17\n                          #'A02', # 林业 \t1996-12-06\n                          #'A03', #",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "林业 \t1996-12-06\n                          #'A03', #\t畜牧业 \t1997-06-11\n                          #'A04', #\t渔业 \t1993-05-07\n                          #'A05', #\t农、林、牧、渔服务业 \t1997-05-30\n                          'B06', # 煤炭开采和洗选业 \t1994-01-06\n                          'B07', # 石油和天然气开采业 \t1996-06-28\n                          'B08', # 黑色金属矿采选业 \t1997-07-08\n                          'B09', # 有色金属矿采选业 \t1996-03-20\n                          'B11', # 开采辅助活动 \t2002-02-05\n                          #'C13', #\t农副食品加工业 \t1993-12-15\n",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "                    #'C13', #\t农副食品加工业 \t1993-12-15\n                          #C14 \t食品制造业 \t1994-08-18\n                          #C15 \t酒、饮料和精制茶制造业 \t1992-10-12\n                          #C17 \t纺织业 \t1992-06-16\n                          #C18 \t纺织服装、服饰业 \t1993-12-31\n                          #C19 \t皮革、毛皮、羽毛及其制品和制鞋业 \t1994-04-04\n                          #C20 \t木材加工及木、竹、藤、棕、草制品业 \t2005-05-10\n                          #C21 \t家具制造业 \t1996-04-25\n                          #C22 \t造纸及纸制品业 \t1993-03-12\n                          #C23",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "造纸及纸制品业 \t1993-03-12\n                          #C23 \t印刷和记录媒介复制业 \t1994-02-24\n                          #C24 \t文教、工美、体育和娱乐用品制造业 \t2007-01-10\n                          'C25', # 石油加工、炼焦及核燃料加工业 \t1993-10-25\n                          'C26', # 化学原料及化学制品制造业 \t1990-12-19\n                          #C27 \t医药制造业 \t1993-06-29\n                          'C28', # 化学纤维制造业 \t1993-07-28\n                          'C29', # 橡胶和塑料制品业 \t1992-08-28\n                          'C30', # 非金属矿物制品业 \t1992-02-28\n                          'C31', # 黑色",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": " \t1992-02-28\n                          'C31', # 黑色金属冶炼及压延加工业 \t1994-01-06\n                          'C32', # 有色金属冶炼和压延加工业 \t1996-02-15\n                          'C33', # 金属制品业 \t1993-11-30\n                          'C34', # 通用设备制造业 \t1992-03-27\n                          'C35', # 专用设备制造业 \t1992-07-01\n                          'C36', # 汽车制造业 \t1992-07-24\n                          'C37', # 铁路、船舶、航空航天和其它运输设备制造业 \t1992-03-31\n                          'C38', # 电气机械及器材制造业 \t1990-12-19\n                          #C39 \t计算机、通",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": " \t1990-12-19\n                          #C39 \t计算机、通信和其他电子设备制造业 \t1990-12-19\n                          #C40 \t仪器仪表制造业 \t1993-09-17\n                          'C41', # 其他制造业 \t1992-08-14\n                          #C42 \t废弃资源综合利用业 \t2012-10-26\n                          'D44', # 电力、热力生产和供应业 \t1993-04-16\n                          #D45 \t燃气生产和供应业 \t2000-12-11\n                          #D46 \t水的生产和供应业 \t1994-02-24\n                          'E47', # 房屋建筑业 \t1993-04-29\n                          'E48', # 土木工程建筑业 \t1994-01-28\n      ",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "               'E48', # 土木工程建筑业 \t1994-01-28\n                          'E50', # 建筑装饰和其他建筑业 \t1997-05-22\n                          #F51 \t批发业 \t1992-05-06\n                          #F52 \t零售业 \t1992-09-02\n                          'G53', # 铁路运输业 \t1998-05-11\n                          'G54', # 道路运输业 \t1991-01-14\n                          'G55', # 水上运输业 \t1993-11-19\n                          'G56', # 航空运输业 \t1997-11-05\n                          'G58', # 装卸搬运和运输代理业 \t1993-05-05\n                          #G59 \t仓储业 \t1996-06",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "05-05\n                          #G59 \t仓储业 \t1996-06-14\n                          #H61 \t住宿业 \t1993-11-18\n                          #H62 \t餐饮业 \t1997-04-30\n                          #I63 \t电信、广播电视和卫星传输服务 \t1992-12-02\n                          #I64 \t互联网和相关服务 \t1992-05-07\n                          #I65 \t软件和信息技术服务业 \t1992-08-20\n                          'J66', # 货币金融服务 \t1991-04-03\n                          'J67', # 资本市场服务 \t1994-01-10\n                          'J68', # 保险业 \t2007-01-09\n                          'J69', # 其",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "业 \t2007-01-09\n                          'J69', # 其他金融业 \t2012-10-26\n                          'K70', # 房地产业 \t1992-01-13\n                          #L71 \t租赁业 \t1997-01-30\n                          #L72 \t商务服务业 \t1996-08-29\n                          #M73 \t研究和试验发展 \t2012-10-26\n                          'M74', # 专业技术服务业 \t2007-02-15\n                          #N77 \t生态保护和环境治理业 \t2012-10-26\n                          #N78 \t公共设施管理业 \t1992-08-07\n                          #P82 \t教育 \t2012-10-26\n                          #Q83 \t卫生",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "\t教育 \t2012-10-26\n                          #Q83 \t卫生 \t2007-02-05\n                          #R85 \t新闻和出版业 \t1992-12-08\n                          #R86 \t广播、电视、电影和影视录音制作业 \t1994-02-24\n                          #R87 \t文化艺术业 \t2012-10-26\n                          #S90 \t综合 \t1990-12-10\n            ]\n\n        cycle_indu_stocks=[]\n        a=0\n        for i in cycle_indu:\n            cycle_indu_stocks_=get_industry_stocks(i)\n            a+=len(cycle_indu_stocks_)\n            cycle_indu_stocks=list(set(cycle_indu_stocks_).uni",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "cycle_indu_stocks=list(set(cycle_indu_stocks_).union(set(cycle_indu_stocks)))\n        list1=list(set(list0).difference(set(cycle_indu_stocks)))\n        return list1 #返回非周期股票池list\n    \n    def fp_pb_filter(self,context,list_):\n        df=get_fundamentals(query(valuation.code,valuation.circulating_market_cap,valuation.pe_ratio,valuation.pb_ratio,valuation.ps_ratio,indicator.roa,indicator.gross_profit_margin).filter(valuation.code.in_(list_)))\n        PB=df.sort(['pb_ratio'],ascending=True)\n        PB=PB.reset",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "t(['pb_ratio'],ascending=True)\n        PB=PB.reset_index(drop=True)\n        PB=PB[PB.pb_ratio > 0]\n        PB=PB.reset_index(drop=True)\n        PB=PB[0:int(len(PB)*0.2)]\n        ListOfPB=list(PB['code'])\n        return ListOfPB\n    \n    def fp_peg_filter(self,dynamic,yb_length,qr_length,list1,context\n                     ):\n        present_date=context.current_dt\n        startdate=int(present_date.year)-5\n        #startdate=2013\n        df_eps=get_fundamentals(query(indicator.code,indicator.eps).filter(indi",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "ls(query(indicator.code,indicator.eps).filter(indicator.code.in_(list1)),statDate=str(startdate-1))\n        df_eps=df_eps.rename(columns={'eps':str('eps_')+str(startdate-1),'code':str('code')+str(startdate-1)})\n        if dynamic==False:\n            df_pe=get_fundamentals(query(valuation.code,valuation.pe_ratio).filter(valuation.code.in_(list1)),statDate=str(startdate-1))\n            df_pe=df_pe.rename(columns={'pe_ratio':str('pe_ratio_')+str(startdate-1),'code':str('code_')+str(startdate-1)})\n            f",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "ode':str('code_')+str(startdate-1)})\n            floc1=[]\n            floc2=[]\n            for i in range(startdate,startdate+qr_length+1):\n                year_date=i\n                df_new_pe=get_fundamentals(query(valuation.code,valuation.pe_ratio).filter(valuation.code.in_(list1)),statDate=year_date)\n                df_new_pe=df_new_pe.rename(columns={'pe_ratio':str('pe_ratio_')+str(year_date),'code':str('code_')+str(year_date)})\n\n                df_new_eps=get_fundamentals(query(indicator.code,indicato",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "eps=get_fundamentals(query(indicator.code,indicator.eps).filter(indicator.code.in_(list1)),statDate=str(year_date))\n                df_new_eps=df_new_eps.rename(columns={'eps':str('eps_')+str(year_date),'code':str('code_')+str(year_date)})\n\n                floc1.append(str('pe_ratio_')+str(year_date))\n                floc2.append(str('eps_')+str(year_date))\n                df_pe=pd.concat([df_pe,df_new_pe],axis=1)\n                df_eps=pd.concat([df_eps,df_new_eps],axis=1)\n\n            floc1.append(str('co",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "new_eps],axis=1)\n\n            floc1.append(str('code_')+str(year_date))\n            floc2.append(str('code_')+str(year_date))\n\n            #print(df_eps[floc2])\n\n            delta_eps=df_eps[[str('code_')+str(year_date),str('eps_')+str(year_date-1),str('eps_')+str(year_date)]]\n            delta_eps['delta_eps_'+str(year_date)]=(delta_eps[str('eps_')+str(year_date)]-delta_eps[str('eps_')+str(year_date-1)])/delta_eps[str('eps_')+str(year_date-1)]\n            delta_eps=delta_eps[[str('code_')+str(year_date),'d",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "elta_eps=delta_eps[[str('code_')+str(year_date),'delta_eps_'+str(year_date)]]\n\n            static_pe=df_pe[[str('code_')+str(year_date),'pe_ratio_'+str(year_date)]]\n            list_1=static_pe[str('code_')+str(year_date)]\n            list_2=delta_eps[str('code_')+str(year_date)]\n            if len(set(list_1).union(set(list_2))) != len(set(list_1).intersection(list_2)):\n                raise (ValueError,'cannot match list')\n\n            static_peg=delta_eps\n            static_peg['pe_ratio_'+str(year_date)",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "\n            static_peg['pe_ratio_'+str(year_date)]=static_pe['pe_ratio_'+str(year_date)]\n            peg=static_peg['pe_ratio_'+str(year_date)]/(static_peg['delta_eps_'+str(year_date)]*100)\n            static_peg['peg_'+str(year_date)]=peg\n            static_peg=static_peg[[str('code_')+str(year_date),'peg_'+str(year_date)]]\n            fdf1=static_peg\n            fdf=fdf1.rename(columns={str('code_')+str(year_date):'code','peg_'+str(year_date):'peg'})\n            \n            \n        elif dynamic==True:\n",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "        \n            \n        elif dynamic==True:\n\n            floc2=[]\n            for i in range(startdate,startdate+qr_length+1):\n                year_date=i\n\n                df_new_eps=get_fundamentals(query(indicator.code,indicator.eps).filter(indicator.code.in_(list1)),statDate=str(year_date))\n                df_new_eps=df_new_eps.rename(columns={'eps':str('eps_')+str(year_date),'code':str('code_')+str(year_date)})\n\n                floc2.append(str('eps_')+str(year_date))\n                df_eps=pd.con",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "s_')+str(year_date))\n                df_eps=pd.concat([df_eps,df_new_eps],axis=1)\n\n            floc2.append(str('code_')+str(year_date))\n\n\n            delta_eps=df_eps[[str('code_')+str(year_date),str('eps_')+str(year_date-1),str('eps_')+str(year_date)]]\n            delta_eps['delta_eps_'+str(year_date)]=(delta_eps[str('eps_')+str(year_date)]-delta_eps[str('eps_')+str(year_date-1)])/delta_eps[str('eps_')+str(year_date-1)]\n            delta_eps=delta_eps[[str('code_')+str(year_date),'delta_eps_'+str(year_dat",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "('code_')+str(year_date),'delta_eps_'+str(year_date)]]\n            \n            namelist=list(delta_eps[str('code_')+str(year_date)])\n            dynamic_pe=get_fundamentals(query(valuation.code,valuation.pe_ratio).filter(valuation.code.in_(namelist)))\n\n            list_1=dynamic_pe['code']\n            list_2=delta_eps[str('code_')+str(year_date)]\n            if len(set(list_1).union(set(list_2))) != len(set(list_1).intersection(list_2)):\n                raise (ValueError,'cannot match list')\n\n            d",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "se (ValueError,'cannot match list')\n\n            dynamic_peg=delta_eps\n            dynamic_peg['pe_ratio_now']=dynamic_pe['pe_ratio']\n            dyna_peg=dynamic_peg['pe_ratio_now']/(dynamic_peg['delta_eps_'+str(year_date)]*100)\n            dynamic_peg['dynamic_peg_'+str(year_date)]=dyna_peg\n            dynamic_peg=dynamic_peg[[str('code_')+str(year_date),'dynamic_peg_'+str(year_date)]]\n            fdf2=dynamic_peg\n            fdf=fdf2.rename(columns={str('code_')+str(year_date):'code','dynamic_peg_'+str(y",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "code_')+str(year_date):'code','dynamic_peg_'+str(year_date):'peg'})\n            \n        fdf=fdf.sort(['peg'],ascending=True)\n        fdf=fdf[0<fdf.peg]\n        fdf=fdf[5>fdf.peg]\n        fdf=fdf.reset_index(drop=True)\n        list2=list(fdf['code'])\n        return list2 #返回peg\n    \n    def fp_rs_filter(self,list2,benchmark,context#换成context\n                    ):\n        previous_date=context.previous_date\n        #previous_date=datetime.date(2018,2,25)\n        month_date=previous_date+datetime.timedelta(d",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "     month_date=previous_date+datetime.timedelta(days=-30)\n        year_date=previous_date+datetime.timedelta(days=-365)\n\n        price_p=get_price(list2,end_date=previous_date,count=1,fields='close')['close']\n        market_p=get_price(benchmark,end_date=previous_date,count=1,fields='close')['close']\n\n        price_m=get_price(list2,end_date=month_date,count=1,fields='close')['close']\n        market_m=get_price(benchmark,end_date=month_date,count=1,fields='close')['close']\n\n        price_y=get_price(list2,",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "close')['close']\n\n        price_y=get_price(list2,end_date=year_date,count=1,fields='close')['close']\n        market_y=get_price(benchmark,end_date=year_date,count=1,fields='close')['close']\n\n        month_S_m=(market_p.mean()-market_m.mean())/market_m.mean()\n        year_S_m=(market_p.mean()-market_y.mean())/market_y.mean()\n\n        month_S_s=(price_p.mean()-price_m.mean())/price_m.mean()\n        year_S_s=(price_p.mean()-price_y.mean())/price_y.mean()\n\n        RS_month=(month_S_s-month_S_m)/(1+month_S_m)\n ",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "    RS_month=(month_S_s-month_S_m)/(1+month_S_m)\n        RS_year=(year_S_s-year_S_m)/(1+year_S_m)\n\n        tobuylist={'code':[],'RS_month':[],'RS_year':[]}\n        for i in range(len(list2)):\n            if RS_month[list2[i]]>0 and RS_year[list2[i]]>0 and RS_year[list2[i]]>RS_month[list2[i]]:\n                tobuylist['code'].append(list2[i])\n                tobuylist['RS_month'].append(RS_month[list2[i]])\n                tobuylist['RS_year'].append(RS_year[list2[i]])\n\n        tobuylist=pd.DataFrame(tobuyli",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "list2[i]])\n\n        tobuylist=pd.DataFrame(tobuylist)\n        tobuylist=tobuylist.sort(['RS_year'],ascending=False)\n        tobuylist=tobuylist.reset_index(drop=True)\n\n        list3=list(tobuylist['code'])\n        return list3\n\ndef get_markowitz(context,list_):\n    dayavereturn=[]\n    returndict={}\n    riskaverse=0.3  #VM\n    for security in list_:\n        a=attribute_history(security, count=30, fields=['close'])\n        returnlist=[]\n        for i in range(len(a)-1):\n            returnrate=(a['close'][i+1]",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "len(a)-1):\n            returnrate=(a['close'][i+1]-a['close'][i])/a['close'][i]\n            returnlist.append(returnrate)\n        dayavereturn.append(average(returnlist))\n        returndict[security]=returnlist\n    returndict=pd.DataFrame(returndict)\n    cov=returndict.corr()\n        \n    P=matrix(riskaverse*cov.as_matrix())\n\n    q=-1*matrix(dayavereturn)\n    A=[]\n    \n    h=[]\n    for i in range(len(list_)):\n        A.append([1.0])\n        h.append([0.0])\n    A=matrix(A)\n    \n    h=matrix(h).T\n    \n    G=m",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "   A=matrix(A)\n    \n    h=matrix(h).T\n    \n    G=matrix(-1.0*np.eye(len(list_)))\n    \n    b=matrix([[1.0]])\n        \n    sol=solvers.qp(P=P,q=q,A=A,b=b)\n        \n    __weight=list(sol['x'].T)\n        \n    _weight={}\n    for i in range(len(list_)):\n        weight=__weight[i]\n        st=list_[i]\n        _weight[st]=float(weight)\n        \n    return _weight\n    \n    \ndef get_risk_parity(context,list_):\n    raise TypeError\n\n\n#------\nclass seven():\n    \n    #为context全局变量新增内置对象\n    def set_var(self,context,var_na",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "text全局变量新增内置对象\n    def set_var(self,context,var_name,var_value):\n        if var_name not in dir(context):\n            setattr(context,var_name,var_value)\n    \n    def set_commission_style(self,type):\n        if type==1:\n            set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock')\n        if type==2:\n            set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0, close_commission=",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": " close_tax=0, open_commission=0, close_commission=0, close_today_commission=0, min_commission=0), type='stock')\n        else:\n            set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock')\n    \n    def set_tradeable_stock(self, context, list3, paused_style=True, new_style=True, new_count=60, limit_style=True):\n        def del_new_stock(context, list3, new_style, new_count):\n            if new_style",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "3, new_style, new_count):\n            if new_style==False:\n                return list3\n            else:\n                period=context.current_dt.date()-datetime.timedelta(new_count)\n                newlist=[]\n                for stock in list3:\n                    if get_security_info(stock).start_date < period:\n                        newlist.append(stock)\n                return newlist\n                \n    \n        def del_paused_stock(context, list3, paused_style):\n            if paused_style==False:\n",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "aused_style):\n            if paused_style==False:\n                return list3\n            else:\n                current_data = get_current_data()\n                newlist=[]\n                for stock in list3:\n                    if not current_data[stock].paused:\n                        newlist.append(stock)\n                return newlist\n            \n        def del_limit_stock(context, list3, limit_style):   \n            h1=history(1, '1m', 'close', list3, df=False, skip_paused=False, fq='pre')\n         ",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": ", df=False, skip_paused=False, fq='pre')\n            h2=history(1, '1m', 'high_limit', list3, df=False, skip_paused=False, fq='pre')\n            newlist=[]\n            for stock in list3:\n                if h1[stock][0] < h2[stock][0]:\n                    newlist.append(stock)\n            return newlist\n            \n        listofnew=del_new_stock(context, list3, new_style, new_count)\n        listofpaused=del_paused_stock(context, list3, paused_style)\n        listoflimit=del_limit_stock(context, list3, limi",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "  listoflimit=del_limit_stock(context, list3, limit_style)\n        list4=list(set(listofnew) & set(listofpaused))\n        return list4\n        \n    def AllocationSystem(self, context, list4, alloc_type):\n        def equal_weight_system(context, list4):\n            __weight={}\n            length=len(list4)\n            for stock in list4:\n                __weight[stock]=1.0/length\n            return __weight\n        \n        def markowitz_weight_system(context, list4):\n            __weight=get_markowitz(conte",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": ", list4):\n            __weight=get_markowitz(context=context, list_=list4)\n            return __weight\n                \n        def risk_parity_system(context, list4):\n            __weight=get_risk_parity(context=context,list_=list4)\n            return __weight\n        \n        if alloc_type == 1:\n            try:\n                weight_data=risk_parity_system(context, list4)\n            except (TypeError):\n                print('The data is missing, then using the equal weight system... \\nOr no stock fitte",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "ing the equal weight system... \\nOr no stock fitted the criteria...')\n                weight_data=equal_weight_system(context, list4)\n                \n        if alloc_type == 2:\n            try:\n                weight_data=markowitz_weight_system(context, list4)\n            except (TypeError, ValueError):\n                #print(list4)\n                print('The data is missing, then using the equal weight system... \\nOr, no stock fitted the criteria...')\n                weight_data=equal_weight_system(cont",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "              weight_data=equal_weight_system(context, list4)###\n                #print(list4)\n                \n        if alloc_type == 3:\n            weight_data=target_risk_system(context, list4)\n            \n        if alloc_type == 0:\n            weight_data=equal_weight_system(context, list4)\n            \n        return weight_data\n    \n    def TradingSystem(self, context, bearsign, tradesign, list4, weight_data):\n        holdings=context.portfolio.positions.keys()\n        if tradesign[0] == 'trade':\n",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "itions.keys()\n        if tradesign[0] == 'trade':\n            if bearsign[0] == 'bearish':\n                for eachhold in holdings:\n                    order_target_value(eachhold,0)\n            else:\n                for eachhold in holdings:\n                    if eachhold not in list4:\n                        order_target_value(eachhold,0)\n                cash=context.portfolio.cash\n                total_v=float(context.portfolio.total_value)\n                for eachsec in list4:\n                    weig",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "    for eachsec in list4:\n                    weight=weight_data[eachsec]\n                    buyamount=float(cash*weight)\n                    if eachsec in holdings:\n                        order_value(eachsec,min(buyamount,context.portfolio.positions[eachsec]))\n                    else:\n                        order_value(eachsec,max(buyamount,0.0))\n        else:\n            if bearsign[0] == 'bearish':\n                for eachhold in holdings:\n                    order_target_value(eachhold,0)\n          ",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "         order_target_value(eachhold,0)\n                \n",
        "source": "99策略代码/23 Principle by Jim Slater 祖鲁法则在A股的实现与改进.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13958\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "anagement_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securitie",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "r_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    security_stoploss(context,0.2,g.open_sell_securities)\n    portfolio_stoploss(context,0.2,g.open_sell_securities)\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        ret",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "= other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "    # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n       ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "   # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "ty_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 18)\n    security_list = financial_data_filter_dayu(security_list, valuation.pe_ratio, 15)\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 1",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "filter_dayu(security_list, valuation.market_cap, 100)\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 4)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pa",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": " 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ###########",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "###############################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n   ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "ell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(c",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "rn\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[s",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "            # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(cont",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "#################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        ret",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": " False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n         ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "d_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "      security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_lis",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "  security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    f",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "iverse_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n       ",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": " len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securit",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "    return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/88 一位小白编辑的多因子选股策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12307\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport pandas as pd\nfrom pandas import DataFrame,Series\nimport numpy as np\nimport statsmodels.formula as smFormula\nimport statsmodels.api as smApi\nfrom operator import methodcaller\nfrom six import StringIO\nimport datetime\ndef initialize(context):\n    log.set_level('order', 'error')\n    g.indexList = ['801011','801012','801013','801014','801015','801016','801017','801018',\n                    '801021','8",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "'801017','801018',\n                    '801021','801022','801023','801024','801032','801033','801034',\n                    '801035','801036','801037','801041','801051','801053','801054','801055',\n                    '801072','801073','801074','801075','801076',\n                    '801081','801082','801083','801084','801085','801092','801093','801094',\n                    '801101','801102','801111','801112','801121','801123','801131','801132',\n                    '801141','801142','801143','801151','801152'",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "      '801141','801142','801143','801151','801152','801153','801154',\n                    '801155','801156','801161','801162','801163','801164','801171','801172',\n                    '801173','801174','801175','801176','801177','801178','801181','801182',\n                    '801191','801192','801193','801194','801202','801203','801204','801205',\n                    '801211','801212','801213','801214','801215','801222','801223','801231',\n                    '801711','801712','801713','801721','801722','8017",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "'801711','801712','801713','801721','801722','801723','801724','801725',\n                    '801731','801732','801733','801734','801741','801742','801743','801744',\n                    '801751','801752','801761','801881']\n\n    g.pastDay = 20 \n    df_week = read_file('df_week.csv')\n    dfa = read_file('dfa.csv')\n    dfb = read_file('dfb.csv')\n    dfc = read_file('dfc.csv')\n    open_week = read_file('open_week.csv')\n    df_low = read_file('df_low.csv')\n    g.df = pd.read_csv(StringIO(df_week),index_col = 0)[",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "df = pd.read_csv(StringIO(df_week),index_col = 0)[53:]\n    g.df1 = pd.read_csv(StringIO(dfa),index_col = 0)\n    g.df2 = pd.read_csv(StringIO(dfb),index_col = 0)\n    g.df3 = pd.read_csv(StringIO(open_week),index_col = 0)[53:]\n    g.df4 = pd.read_csv(StringIO(df_low),index_col = 0)\n    g.df5 = pd.read_csv(StringIO(dfc),index_col = 0)\n    g.df.columns = g.df1.columns = g.df2.columns = g.df3.columns = g.df4.columns = g.df5.columns = g.indexList\n    run_weekly(mainHerd, weekday = 1, time = 'open')\ndef index_sele",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "inHerd, weekday = 1, time = 'open')\ndef index_select(context):\n    g.current = context.current_dt.date()\n    cur_year = datetime.datetime.strftime(g.current,'%Y-%m-%d').split('-')[0]\n    cur_month = datetime.datetime.strftime(g.current,'%Y-%m-%d').split('-')[1]\n    cur_day = datetime.datetime.strftime(g.current,'%Y-%m-%d').split('-')[2]\n    cur = str(cur_year) + '-' + str(cur_month) + '-' + str(cur_day)\n    ks = []\n    for i in g.df.index.values:\n        df_year = i.split('/')[0]\n        df_month = i.split(",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "year = i.split('/')[0]\n        df_month = i.split('/')[1]\n        df_day = i.split('/')[2]\n        k = str(df_year) + '-' + str(df_month) + '-' + str(df_day)\n        k = datetime.datetime.strptime(k,'%Y-%m-%d')-datetime.datetime.strptime(cur,'%Y-%m-%d')\n        ks.append(k)\n    g.N = 0\n    for i in range(len(ks)-1):\n        if ks[i] < datetime.timedelta(0) and ks[i+1] > datetime.timedelta(0):\n            g.N = i\n    index_new = []\n    for i in g.indexList:\n        M = 0\n        if g.df1[i].iloc[g.N] > g.df2",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "       M = 0\n        if g.df1[i].iloc[g.N] > g.df2[i].iloc[g.N] and g.df1[i].iloc[g.N-1] < g.df2[i].iloc[g.N-1]:\n            M += 1 \n        rs = g.df[i].iloc[g.N]-g.df3[i].iloc[g.N] \n        if rs < 0:\n            M += 1 \n        if g.df[i].iloc[g.N] >= g.df4[i].iloc[g.N-1] and g.df[i].iloc[g.N] >= g.df4[i].iloc[g.N-2]:\n            M += 1\n        if M ==3:\n            index_new.append(i)\n    index_new_2 = []\n    for j in g.indexList:\n        G = 0\n        if g.df1[j].iloc[g.N] > g.df2[j].iloc[g.N] >g.df5[j",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "f g.df1[j].iloc[g.N] > g.df2[j].iloc[g.N] >g.df5[j].iloc[g.N] and g.df1[j].iloc[g.N-1] > g.df2[j].iloc[g.N-1] >g.df5[j].iloc[g.N-1]:\n            G += 1\n        if g.df1[j].iloc[g.N]/g.df2[j].iloc[g.N] > g.df1[j].iloc[g.N-1]/g.df2[j].iloc[g.N-1]:\n            G += 1\n        rs = g.df[j].iloc[g.N]/g.df3[j].iloc[g.N] -1\n        rs_1 = g.df[j].iloc[g.N-1]/g.df3[j].iloc[g.N-1]-1\n        if rs < 0 < rs_1 :\n            G += 1 \n        if G == 3:\n            index_new_2.append(j)\n    index_last= set(index_new)|set(i",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "w_2.append(j)\n    index_last= set(index_new)|set(index_new_2)\n    return index_last\ndef filtVol(stocks):\n    returnStocks = []\n    varss = {}\n    for s in stocks:\n        varss[s] = variance(s)\n    var = pd.DataFrame(varss,index = stocks,columns = ['T'])\n    var.sort('T',ascending = True,inplace = True)\n    returnStocks = list(var.index.values)[:2]\n    return returnStocks\ndef variance(stock):\n    close = attribute_history(stock, 20, '1d', 'close',df=False)['close']\n    narray=np.array(close)\n    sum1=narray",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "close']\n    narray=np.array(close)\n    sum1=narray.sum()\n    narray2=narray*narray\n    sum2=narray2.sum()\n    mean=sum1/len(close)\n    var=sum2/len(close)-mean**2\n    return var\ndef filtMarketCap(context,stocks,index):\n    returnStocks = []\n    oriStocks = get_industry_stocks(index)\n    indexMarketCap = get_fundamentals(\n        query(valuation.code,\n            valuation.circulating_market_cap\n        ).filter(valuation.code.in_(oriStocks)\n        ).order_by(valuation.circulating_market_cap.desc()), date =",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "y(valuation.circulating_market_cap.desc()), date = context.current_dt)\n    indexMarketCap.index = indexMarketCap['code']\n    del indexMarketCap['code']\n    returnStocks = list(indexMarketCap.index.values)[:2]\n    return returnStocks\ndef findLeadStock(context,index,method = 1):\n    oriStocks = get_industry_stocks(index)        \n    if method == 0:\n        filtStocks = filtVol(oriStocks)\n        return filtStocks\n    elif method == 1:\n        filtStocks = filtMarketCap(context,oriStocks,index)\n        return ",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "MarketCap(context,oriStocks,index)\n        return filtStocks\n    elif method == 2:\n        filtStocks = filtVol(oriStocks)\n        if len(filtStocks) != 0:\n            filtStocks = filtMarketCap(context,filtStocks,index)\n        else:\n            pass\n        return filtStocks\n    else:\n        return 'Error method order'\ndef myFiltMavg(stocks):\n    returnArr = []\n    for s in stocks:\n        stocksPrice = attribute_history(s,1,'1d','close')['close'][-1]\n        ma5 = attribute_history(s,5,'1d','close')['cl",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "     ma5 = attribute_history(s,5,'1d','close')['close'].mean()\n        ma20 = attribute_history(s,20,'1d','close')['close'].mean()\n        if stocksPrice > ma5 and ma5 > ma20:\n            returnArr.append(s)\n        else:\n            continue\n    return returnArr\ndef mainHandle(context,stocks,cash):\n    numStocks = len(stocks)\n    if numStocks > 0:\n        for security in context.portfolio.positions.keys():\n            if security in stocks:\n                continue\n            else:\n                order_t",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "continue\n            else:\n                order_target(security,0)\n                print(\"Selling %s\" %(security))\n        if cash != 0:\n            for security in stocks:\n                currentData = get_current_data()\n                pauseSign = currentData[security].paused\n                STInfo = get_extras('is_st',security,start_date = context.current_dt, end_date=context.current_dt)\n                STSign = STInfo.iloc[-1]\n                if not pauseSign and not STSign.bool():\n                    ",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "seSign and not STSign.bool():\n                    order_value(security, cash/numStocks)\n                    print(\"Buying %s\" % (security))\n                else:\n                    continue\n        else:\n            pass\n    else:\n        for security in context.portfolio.positions.keys():\n            order_target(security,0)\n\ndef mainHerd(context):\n    herdStocks = []\n    rationalStocks = []\n\n    indexList = index_select(context)\n    for i,eachIndex in enumerate(indexList):\n        herdStocks += findLeadS",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "merate(indexList):\n        herdStocks += findLeadStock(context,eachIndex,method = 1)\n    herdStocks = myFiltMavg(herdStocks)\n    cash = context.portfolio.cash\n    mainHandle(context,herdStocks,cash)\n###########################################################################\n                           #止损\n###########################################################################\n\n\n    \n    \n    \n    ",
        "source": "99策略代码/68 板块轮动不动？.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14756\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\nimport pandas as pd\nimport numpy as np\nfrom sklearn import linear_model\nfrom numpy import mean, std\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    context.stock_id='510300.XSHG'\n    context.beat_list=[]\n    context.count=0\n    context.z_beta_r2_list=[]\n    context.n_value=18\n    context.m_value=400\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSH",
        "source": "99策略代码/27 RSRS指标择时（30分钟线）.txt"
    },
    {
        "text": "00\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\ndef before_trading_start(context):\n    advance_high_array=attribute_history(context.stock_id,400,'30m','high')\n    advance_low_array=attribute_history(context.stock_id,400,'30m','low')\n    \n    for i in range(context.n_value,context.m_value):\n        \n        sliding_windows_high_array=advance_high_array[i-18:i]\n        sliding_windows_low_array=advance_low_array[i-18:i]\n\n        reg = linear_m",
        "source": "99策略代码/27 RSRS指标择时（30分钟线）.txt"
    },
    {
        "text": "=advance_low_array[i-18:i]\n\n        reg = linear_model.LinearRegression()\n        reg.fit (sliding_windows_low_array,sliding_windows_high_array)\n        beat=reg.coef_\n        context.beat_list.append(beat)\n        \n# 每个单位时间(每分钟调用一次)\ndef handle_data(context,data):\n\n    context.count=context.count+1\n    if context.count % 30==0:\n        high_array=attribute_history(context.stock_id,18,'30m','high')\n        low_array=attribute_history(context.stock_id,18,'30m','low')\n        reg = linear_model.LinearRegressio",
        "source": "99策略代码/27 RSRS指标择时（30分钟线）.txt"
    },
    {
        "text": ",'low')\n        reg = linear_model.LinearRegression()\n        reg.fit(low_array,high_array)\n        beat=reg.coef_\n        R_sq=reg.score(low_array,high_array)\n    \n        beat_z=R_sq*(beat-mean(context.beat_list))/std(context.beat_list)\n    \n        context.z_beta_r2_list.append(beat_z)\n        \n        cash = context.portfolio.available_cash\n        record(price1=0.7)\n        record(name=beat_z)\n        record(Price2=-0.7)\n        if len(context.z_beta_r2_list)>2:\n            if context.z_beta_r2_list[-2",
        "source": "99策略代码/27 RSRS指标择时（30分钟线）.txt"
    },
    {
        "text": "_list)>2:\n            if context.z_beta_r2_list[-2]<0.7 and context.z_beta_r2_list[-1]>0.7:\n                log.info(\" 买入 %s\" % (context.stock_id))\n                order_value(context.stock_id,cash)\n            if context.z_beta_r2_list[-2]>-0.7 and context.z_beta_r2_list[-1]<-0.7:\n                log.info(\" 卖出 %s\" % (context.stock_id))\n                order_target_value(context.stock_id, 0)",
        "source": "99策略代码/27 RSRS指标择时（30分钟线）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13967\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "anagement_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securitie",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "r_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "xt, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "tements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "heck_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_list",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "text, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "ade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "#######################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_qujian(security_list, valuation.pb_ratio, (3,10))\n    security_list = financial_data_filter_qujian(security_list, valuation.pe_ratio_lyr, (10,20))\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n#",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "l_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n  ",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": " - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.or",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n     ",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b =",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": ".DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(contex",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n#",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "ck].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_l",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "    security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_li",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "ata[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_ind",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "ecurity_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n      ",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "st if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "   return security_list\n\n#自定义函数",
        "source": "99策略代码/94 PE和PB策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11624\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/10778\n# 标题：【量化课堂】机器学习多因子策略\n# 作者：JoinQuant量化课堂\n\nimport pandas as pd\nimport numpy as np\nimport math\nfrom sklearn.svm import SVR  \nfrom sklearn.model_selection import GridSearchCV  \nfrom sklearn.model_selection import learning_curve\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nimport jqdata\n#from jqlib.alpha191",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "ForestRegressor\nimport jqdata\n#from jqlib.alpha191 import *\nfrom jqlib.technical_analysis import *\nfrom pandas import DataFrame,Series\n\ndef initialize(context):\n    set_params()\n    set_backtest()\n    run_daily(trade, '14:50')\n    \ndef set_params():\n    g.days = 0\n    g.refresh_rate = 10\n    g.stocknum = 10\n    g.index = '000985.XSHG'\n    \ndef set_backtest():\n    set_benchmark(g.index)\n    set_option('use_real_price', True)\n    log.set_level('order', 'error')\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税,",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": ")\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    #set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))\n    \ndef trade(context):\n    if g.days % g.refresh_rate == 0:\n        cur_day = context.current_dt\n        pre_day = context.previous_date\n        sample = get_index_stocks(g.index, date = None)\n        q = query(valuation.code, valuation.market_cap, balance.total_assets - balance.total_liability,\n                  balance.total_assets / balance.total_liability, income",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "nce.total_assets / balance.total_liability, income.net_profit, income.net_profit + 1, \n                  indicator.inc_revenue_year_on_year, balance.development_expenditure).filter(valuation.code.in_(sample))\n        df = get_fundamentals(q, date = None)\n        df.columns = ['code', 'log_mcap', 'log_NC', 'LEV', 'NI_p', 'NI_n', 'g', 'log_RD']\n        \n        df['log_mcap'] = np.log(df['log_mcap'])\n        df['log_NC'] = np.log(df['log_NC'])\n        df['NI_p'] = np.log(np.abs(df['NI_p']))\n        df['NI_n']",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "'] = np.log(np.abs(df['NI_p']))\n        df['NI_n'] = np.log(np.abs(df['NI_n'][df['NI_n']<0]))\n        df['log_RD'] = np.log(df['log_RD'])\n        df.index = df.code.values\n        \n        CYEL,CYES = CYE(df.code.tolist(),check_date=pre_day)\n        df['CYEL'] = Series(CYEL)\n        df['CYES'] = Series(CYES)\n        #log.info(df['CYEL'])\n        #log.info(df['CYES'])\n        \n        del df['code']\n        df = df.fillna(0)\n        df[df>10000] = 10000\n        df[df<-10000] = -10000\n        industry_set = [",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "   df[df<-10000] = -10000\n        industry_set = ['801010', '801020', '801030', '801040', '801050', '801080', '801110', '801120', '801130', \n                  '801140', '801150', '801160', '801170', '801180', '801200', '801210', '801230', '801710',\n                  '801720', '801730', '801740', '801750', '801760', '801770', '801780', '801790', '801880','801890']\n        \n        for i in range(len(industry_set)):\n            industry = get_industry_stocks(industry_set[i], date = None)\n            s = pd.Se",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "ndustry_set[i], date = None)\n            s = pd.Series([0]*len(df), index=df.index)\n            s[set(industry) & set(df.index)]=1\n            df[industry_set[i]] = s\n            \n        X = df[['log_NC', 'LEV', 'NI_p', 'NI_n', 'g', 'log_RD','CYEL','CYES','801010', '801020', '801030', '801040', '801050', \n                '801080', '801110', '801120', '801130', '801140', '801150', '801160', '801170', '801180', '801200', \n                '801210', '801230', '801710', '801720', '801730', '801740', '801750', '",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "801710', '801720', '801730', '801740', '801750', '801760', '801770', '801780', \n                '801790', '801880', '801890']]\n        Y = df[['log_mcap']]\n        X = X.fillna(0)\n        Y = Y.fillna(0)\n        \n        svr = SVR(kernel='rbf', gamma=0.1) \n        model = svr.fit(X, Y)\n        factor = Y - pd.DataFrame(svr.predict(X), index = Y.index, columns = ['log_mcap'])\n        factor = factor.sort_index(by = 'log_mcap')\n        stockset = list(factor.index[:10])\n        sell_list = list(context.portfo",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "ndex[:10])\n        sell_list = list(context.portfolio.positions.keys())\n        for stock in sell_list:\n            if stock not in stockset[:g.stocknum]:\n                stock_sell = stock\n                order_target_value(stock_sell, 0)\n            \n        if len(context.portfolio.positions) < g.stocknum:\n            num = g.stocknum - len(context.portfolio.positions)\n            cash = context.portfolio.cash/num\n        else:\n            cash = 0\n            num = 0\n        for stock in stockset[:g.sto",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "      num = 0\n        for stock in stockset[:g.stocknum]:\n            if stock in sell_list:\n                pass\n            else:\n                stock_buy = stock\n                order_target_value(stock_buy, cash)\n                num = num - 1\n                if num == 0:\n                    break\n        g.days += 1\n    else:\n        g.days = g.days + 1    \n         ",
        "source": "99策略代码/06 为什么股票市值是当前的样子？.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11988\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in c",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "urities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_fil",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_ou",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "s = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n  ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_l",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "k_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.opera",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "al_data_filter_dayu(security_list, indicator.operation_profit_to_total_revenue, 10)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    security_list = [security for security in security_list if ipo_days_dayu(context, security, 100)]\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n   ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n#",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": " = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        re",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n  ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "ext.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ###############",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "###########################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n      ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            retu",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "elled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(sel",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "listed:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n        ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "        current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "iverse(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "ilter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n  ",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": ", concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/24 自选策略1.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13107\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n'''\n策略思路：\n选股：统计申万一级行业指数，每月固定时间选取涨幅最大的指数，\n选取指数成分股中流通市值最大的5只股票作为操作标的\n择时：每月第一个交易日进行买卖操作，默认开盘卖出不在股票池中股票，买入选出的股票\n仓位：平均分配仓位\n'''\nimport pandas as pd\nimport numpy as np\nfrom jqdata import jy\nimport jqdata\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    #策略参数设置\n    #行业统计天数\n    g.days = 10\n    #运行天数\n    g.trade_days = 0\n    #行业内最大持仓股数\n    g.max_hold_stocknum = 5\n    #操作的股票列表\n    g.buy_list = []\n    #标记是否交易\n    g.trade = False\n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "ommission=0.0003, min_commission=5), type='stock')\n    \n    # 每月第一个交易日进行操作\n    # 开盘前运行\n    run_daily(before_market_open,time='before_open', reference_security='000300.XSHG') \n    # 开盘时运行\n    run_daily(market_open,time='open', reference_security='000300.XSHG')\n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    if g.trade_days%g.days == 0:\n        g.trade = True\n        #获取行业指数指定g.days日收益最高的行业\n        date = context.previous_date\n        s_date = ShiftTradingDay(date,-g.days)\n        hy_df = get_hy_pct",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "radingDay(date,-g.days)\n        hy_df = get_hy_pct(s_date,date)\n        #获取行业指数的成分股\n        temp_list = get_industry_stocks(hy_df.index[0],date=date)\n        #剔除停牌股\n        all_data = get_current_data()\n        temp_list = [stock for stock in temp_list if not all_data[stock].paused]\n        #按市值进行排序\n        g.buy_list = get_check_stocks_sort(context,temp_list)\n        \n    g.trade_days += 1\n        \n## 开盘时运行函数\ndef market_open(context):\n    if g.trade:\n        #卖出不在买入列表中的股票\n        sell(context,g.buy_list)\n ",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "  #卖出不在买入列表中的股票\n        sell(context,g.buy_list)\n        #买入不在持仓中的股票，按要操作的股票平均资金\n        buy(context,g.buy_list)\n        g.trade = False\n#交易函数 - 买入\ndef buy(context, buy_lists):\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions.keys())\n    buy_lists = buy_lists[:Num]\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        cash = context.portfolio.total_value/(g.max_hold_stocknum*1.0)\n        # 进行买入操作\n        for s in buy_lists:\n            order_value(s,cash)\n       ",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "buy_lists:\n            order_value(s,cash)\n       \n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    hold_stock = context.portfolio.positions.keys()\n    for s in hold_stock:\n        #卖出不在买入列表中的股票\n        if s not in buy_lists:\n            order_target_value(s,0)   \n\n#按市值进行排序    \ndef get_check_stocks_sort(context,check_out_lists):\n    df = get_fundamentals(query(valuation.circulating_cap,valuation.code).filter(valuation.code.in_(check_out_lists)),date=context.previous_date)\n    #asc值为0，从大到",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "ists)),date=context.previous_date)\n    #asc值为0，从大到小\n    df = df.sort('circulating_cap',ascending=0)\n    out_lists = list(df['code'].values)[:g.max_hold_stocknum]\n    return out_lists\n    \n#统计各指数当天涨跌\n#输入日期\n#返回df\ndef get_hy_pct(date_s,date):\n    #指数涨跌幅统计\n    #总数据\n    sw_hy = jqdata.get_industries(name='sw_l1')\n    sw_hy_dict  = {}\n    for i in sw_hy.index:\n        value = get_SW_index(i,start_date=date_s,end_date=date)\n        sw_hy_dict[i] = value\n    pl_hy = pd.Panel(sw_hy_dict)\n    pl = pl_hy.transpose(2,1",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": " pd.Panel(sw_hy_dict)\n    pl = pl_hy.transpose(2,1,0)\n    pl = pl.loc[['PrevClosePrice','OpenPrice','HighPrice','LowPrice','ClosePrice','TurnoverVolume','TurnoverValue'],:,:]\n    #涨跌幅数据\n    pl_pct = (pl.iloc[:,-1,:]/pl.iloc[:,-2,:]-1)*100\n    pl_pct_5 = (pl.iloc[:,-1,:]/pl.iloc[:,-1-g.days,:]-1)*100\n    \n    df_fin = pd.concat([pl_pct['ClosePrice'],pl_pct_5['ClosePrice']],axis=1)\n    df_fin.columns = ['涨跌幅%','n日涨跌幅%']\n    return df_fin.sort('n日涨跌幅%',ascending=0)\n\n#获取N天前的交易日日期\ndef ShiftTradingDay(date,shift=",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "g=0)\n\n#获取N天前的交易日日期\ndef ShiftTradingDay(date,shift=5):\n    # 获取所有的交易日，返回一个包含所有交易日的 list,元素值为 datetime.date 类型.\n    tradingday = jqdata.get_all_trade_days()\n    # 得到date之后shift天那一天在列表中的行标号 返回一个数\n    shiftday_index = list(tradingday).index(date)+shift\n    # 根据行号返回该日日期 为datetime.date类型\n    return tradingday[shiftday_index]  \n\n#行业涨跌幅\n#直接用申万的行业指数数据进行说明了\ndef get_SW_index(SW_index = 801010,start_date = '2017-01-31',end_date = '2018-01-31'):\n    index_list = ['PrevClosePrice','OpenPrice','HighPrice','LowPrice','Clos",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "osePrice','OpenPrice','HighPrice','LowPrice','ClosePrice','TurnoverVolume','TurnoverValue','TurnoverDeals','ChangePCT','UpdateTime']\n    jydf = jy.run_query(query(jy.SecuMain).filter(jy.SecuMain.SecuCode==str(SW_index)))\n    link=jydf[jydf.SecuCode==str(SW_index)]\n    rows=jydf[jydf.SecuCode==str(SW_index)].index.tolist()\n    result=link['InnerCode'][rows]\n\n    df = jy.run_query(query(jy.QT_SYWGIndexQuote).filter(jy.QT_SYWGIndexQuote.InnerCode==str(result[0]),\\\n                                              ",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "),\\\n                                                   jy.QT_SYWGIndexQuote.TradingDay>=start_date,\\\n                                                         jy.QT_SYWGIndexQuote.TradingDay<=end_date\n                                                        ))\n    df.index = df['TradingDay']\n    df = df[index_list]\n    return df\n",
        "source": "99策略代码/81 申万行业轮动策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14603\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\ndef initialize(context):\n    run_daily(period,time='every_bar')\n    g.stocksnum=20\ndef period(context):\n      scu=get_index_stocks('000001.XSHG')+get_index_stocks('399106.XSHE')\n      q=query(valuation.code).filter(valuation.code.in_(scu)).order_by(valuation.market_cap.asc()).limit(g.stocksnum)\n      df=get_fundamentals(q)\n      stocklist=list(df['code'])\n      m=get_current_data()\n      buylist=stockli",
        "source": "99策略代码/14 抗击熊市的中短期低市值策略.txt"
    },
    {
        "text": ")\n      m=get_current_data()\n      buylist=stocklist\n      for stock in context.portfolio.positions:\n          if stock not in buylist: #如果stock不在buylist\n              order_target(stock, 0)\n      for stk in buylist:\n          order_value(stk,50000)\n      for stk in context.portfolio.positions:\n          cost=context.portfolio.positions[stk].price\n          close_data = attribute_history(stk,10, '1d', ['close'])\n          close_data2 = attribute_history(stk,15, '1d', ['close'])\n          close_data3 = attri",
        "source": "99策略代码/14 抗击熊市的中短期低市值策略.txt"
    },
    {
        "text": "15, '1d', ['close'])\n          close_data3 = attribute_history(stk,20, '1d', ['close'])\n          MA10 = close_data['close'].mean()\n          MA15 = close_data2['close'].mean()\n          MA20 = close_data3['close'].mean()\n          price = close_data['close'][-1]\n          ret=price/cost-1\n          cash=context.portfolio.cash/20\n          if price<MA20:\n              order_value(stk,cash*0.5)\n          elif price<MA15:\n              order_value(stk,cash*0.3)\n          elif price<MA10:\n              order_v",
        "source": "99策略代码/14 抗击熊市的中短期低市值策略.txt"
    },
    {
        "text": ")\n          elif price<MA10:\n              order_value(stk,cash*0.2)\n          elif ret>0.05:\n              order_value(stk,-cash*0.5)\n          elif ret>0.1:\n              order_value(stk,-cash*0.3)\n          elif ret>0.15:\n              order_value(stk,-cash*0.2)\n              \n          \n\n\n          \n          \n              \n          \n     \n              \n    ",
        "source": "99策略代码/14 抗击熊市的中短期低市值策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13378\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 365\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_tr",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "heck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n ",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": " g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_list",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": ":\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    ",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securit",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "der_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_univer",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "text, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    #",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "tatements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.che",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": ".check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_li",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "ontext, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financi",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "#########################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_qujian(security_list, valuation.pe_ratio, (5.5,11.5))\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 5)\n    security_list = financial_data_filter_dayu(security_list, indicator.roa, 0.5)\n    security_list = financial_data_filter_qujian(security_list, valuation.pb_ratio, (0.7,5.4))\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n ",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": " (0.7,5.4))\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "##\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.p",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n   ",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "nt, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_l",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "cknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "y_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "t) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "nding = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock ",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "t g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n       ",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "t, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['s",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "         temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": " industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "t_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/80 向导式 价值分析(一),成功避开股灾,大盘震荡跌时小涨.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12114\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in c",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "urities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_fil",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_ou",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "s = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n  ",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_l",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "k_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 10)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef ",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "   # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_f",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = contex",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "rities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    ",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": ")\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "ecurity_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 k",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "     return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],asce",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": " 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "t = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n    ",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "ed:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, sec",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "curity_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_d",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": ", security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).inde",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "urities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securiti",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "ties = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [st",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "ies += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/56 爱神的箭放声大哭.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12280\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.00025, close_commission=0.00025, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 65\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 30\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": ".check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n   ",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "   g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_h",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "def buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_circulating_market_cap_percent'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "= list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    security_stoploss(context,0.2,g.open_sell_securities)\n    ### _风控函数",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "(context,0.2,g.open_sell_securities)\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(con",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": " # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n ",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "al_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n  ",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "rade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 #",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "       ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_li",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pb_ratio, 2)\n    securit",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "(security_list, valuation.pb_ratio, 2)\n    security_list = financial_data_filter_dayu(security_list, indicator.roa, 1)\n    security_list = financial_data_filter_dayu(security_list, indicator.net_profit_margin, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.gross_profit_margin, 10)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    security_list = [security for security in security_list if ATR_judge_xiaoyu(security, 0.5, 14)]\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, secu",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "t\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        indicator.gross_profit_margin:('desc',1),\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": " 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_li",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "ontext.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "ion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_lis",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n           ",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in ",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "lded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "ist):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\n",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    cu",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": " high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], conte",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stoc",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "t:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n ",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "cks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/74 基于沪深300的增强.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12886\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 10\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 1\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_tra",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "eck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n  ",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "   run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"399101.XSHE\",\"399102",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "g.security_universe_index = [\"399101.XSHE\",\"399102.XSHE\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n   ",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities ",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    index_stoploss_diefu(context,2,1,g.open_sell_securities, '000300.XSHG')\n    ##",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": ",2,1,g.open_sell_securities, '000300.XSHG')\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_fil",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "st)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_l",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists =",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "sts)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_secu",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": " g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.circulating_marke",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "_xiaoyu(security_list, valuation.circulating_market_cap, 100)\n    security_list = financial_data_filter_dayu(security_list, indicator.operation_profit_to_total_revenue, 20)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    security_list = [security for security in security_list if ipo_days_qujian(context, security, (20,300))]\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_i",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": " return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "eturn security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        indicator.inc_net_profit_year_on_year:('desc',50),\n        indicator.roe:('desc',50),\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n   ",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "io.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "  selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "y_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stoc",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "             amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "alse)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    retu",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "xt.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if no",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "ity_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_c",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "t):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": " security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "  else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for st",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "p_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n    ",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "tock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/47 次新小盘策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12056\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\n#5日均线大于10日均线买入\nimport jqdata\n\n# 初始化函数，设定基准等等\ndef initialize(context):#初始化\n    g.security = '601111.XSHG'# 股票名:中国国航\n     # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # True为开启动态复权模式，使用真实价格交易\n    #set_option('use_real_price', True) \n    \ndef handle_data(context, data):#每日循环\n    last_price = data[g.security].close# 取得最近日收盘价\n    # 取得过去二十天的平均价格\n    average_price = data[g.security].mavg(20, 'clo",
        "source": "99策略代码/86 5日线穿十日线策略（供初学）.txt"
    },
    {
        "text": "    average_price = data[g.security].mavg(20, 'close')\n    #取得五天和十天的均价\n    average_price5 = data[g.security].mavg(5, 'close')\n    average_price10= data[g.security].mavg(10, 'close')\n    \n    \n    cash = context.portfolio.cash# 取得当前的现金\n    # 如果五日大于10日且昨日收盘价大于5日均线, 则买入，否则卖出。\n    if average_price5 > average_price10:\n       if last_price>average_price5:\n         if cash > 100 * last_price:\n           order_value(g.security, cash)# 用当前所有资金买入股票\n    #昨日收盘价小于五日均价卖出       \n    if last_price < average_price5:\n       ",
        "source": "99策略代码/86 5日线穿十日线策略（供初学）.txt"
    },
    {
        "text": "      \n    if last_price < average_price5:\n         if context.portfolio.positions[g.security].amount > 0:\n           order_target(g.security, 0)# 将股票仓位调整到0，即全卖出\n",
        "source": "99策略代码/86 5日线穿十日线策略（供初学）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14323\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n#双均线策略\n# 2015-01-01 到 2016-03-08, ￥2000000, 每天\n# https://www.joinquant.com/post/ae7b7f898c798186ff05523d385f8561?f=stydy&m=algorithm\n\n'''\n================================================================================\n总体回测前\n================================================================================\n'''\n#总体回测前要做的事情\ndef initialize(context):\n    set_params()    #1设置策参数\n    set_variables() #2设置中间变量\n  ",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "arams()    #1设置策参数\n    set_variables() #2设置中间变量\n    set_backtest()  #3设置回测条件\n    \n    g.long_day = 60 # 长均线天数\n    g.short_day = 120 # 短均线天数\n    \n#1\n#设置策略参数\ndef set_params():\n    g.tc=15  # 调仓频率\n    g.N=4 # 持仓数目\n    g.security = [\"000001.XSHE\",\"000002.XSHE\",\"000006.XSHE\",\"000007.XSHE\",\"000009.XSHE\"]#设置股票池\n\n#2\n#设置中间变量\ndef set_variables():\n    return\n\n#3\n#设置回测条件\ndef set_backtest():\n    set_option('use_real_price', True) #用真实价格交易\n    log.set_level('order', 'error')\n\n'''\n=========================================",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "r')\n\n'''\n================================================================================\n每天开盘前\n================================================================================\n'''\n#每天开盘前要做的事情\ndef before_trading_start(context):\n    set_slip_fee(context) \n\n#4 \n# 根据不同的时间段设置滑点与手续费\ndef set_slip_fee(context):\n    # 将滑点设置为0\n    # set_slippage(FixedSlippage(0)) \n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n\n'''\n================================================================================\n每天交易时\n================================================================================\n'''\ndef handle_data(context, data):\n    # 将总资金等分为g.N份，为每只股票配资\n    capital_unit = context.portfolio.portfolio_value/g.N\n    toSell = signal_stock_sell(context,data)\n    toBuy = signal_stock_buy(context,data)\n    # 执行卖出操作以腾出资金\n    ",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "nal_stock_buy(context,data)\n    # 执行卖出操作以腾出资金\n    for i in range(len(g.security)):\n        if toSell[i]==1:\n            order_target_value(g.security[i],0)\n    # 执行买入操作\n    for i in range(len(g.security)):\n        if toBuy[i]==1:\n            order_target_value(g.security[i],capital_unit)  \n    if not (1 in toBuy) or (1 in toSell):\n        # log.info(\"今日无操作\")\n        send_message(\"今日无操作\")\n\n\n#5\n#获得卖出信号\n#输入：context, data\n#输出：sell - list\ndef signal_stock_sell(context,data):\n    sell = [0]*len(g.security)\n    fo",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "ntext,data):\n    sell = [0]*len(g.security)\n    for i in range(len(g.security)):\n    # 算出今天和昨天的两个指数移动均线的值，我们这里假设长线是60天，短线是1天(前一天的收盘价)\n        (ema_long_pre,ema_long_now) = get_EMA(g.security[i],g.long_day,data)\n        (ema_short_pre,ema_short_now) = get_EMA(g.security[i],g.short_day,data)\n        # 如果短均线从上往下穿越长均线，则为死叉信号，标记卖出\n        if ema_short_now < ema_long_now and ema_short_pre > ema_long_pre and context.portfolio.positions[g.security[i]].sellable_amount > 0:\n            sell[i]=1\n    return sell\n     ",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "t > 0:\n            sell[i]=1\n    return sell\n        \n\n#6\n#获得买入信号\n#输入：context, data\n#输出：buy - list\ndef signal_stock_buy(context,data):\n    buy = [0]*len(g.security)\n    for i in range(len(g.security)):\n    # 算出今天和昨天的两个指数移动均线的值，我们这里假设长线是60天，短线是1天(前一天的收盘价)\n        (ema_long_pre,ema_long_now) = get_EMA(g.security[i],g.long_day,data)\n        (ema_short_pre,ema_short_now) = get_EMA(g.security[i],g.short_day,data)\n        # 如果短均线从下往上穿越长均线，则为金叉信号，标记买入\n        if ema_short_now > ema_long_now and ema_short_pre < ema",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "a_short_now > ema_long_now and ema_short_pre < ema_long_pre and context.portfolio.positions[g.security[i]].sellable_amount == 0 :\n            buy[i]=1\n    return buy\n\n#7\n# 计算移动平均线数据\n# 输入：股票代码-字符串，移动平均线天数-整数\n# 输出：算术平均值-浮点数\ndef get_MA(security_code,days):\n    # 获得前days天的数据，详见API\n    a=attribute_history(security_code, days, '1d', ('close'))\n    # 定义一个局部变量sum，用于求和\n    sum=0\n    # 对前days天的收盘价进行求和\n    for i in range(1,days+1):\n        sum+=a['close'][-i]\n    # 求和之后除以天数就可以的得到算术平均值啦\n    return sum/days\n\n#8\n# 计算指数移动",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "后除以天数就可以的得到算术平均值啦\n    return sum/days\n\n#8\n# 计算指数移动平均线数据\n# 输入：股票代码-字符串，移动指数平均线天数-整数，data\n# 输出：今天和昨天的移动指数平均数-浮点数\ndef get_EMA(security_code,days,data):\n    # 如果只有一天的话,前一天的收盘价就是移动平均\n    if days==1:\n    # 获得前两天的收盘价数据，一个作为上一期的移动平均值，后一个作为当期的移动平均值\n        t = attribute_history(security_code, 2, '1d', ('close'))\n        return t['close'][-2],t['close'][-1]\n    else:\n    # 如果全局变量g.EMAs不存在的话，创建一个字典类型的变量，用来记录已经计算出来的EMA值\n        if 'EMAs' not in dir(g):\n            g.EMAs={}\n        # 字典的关键字用股票编码和天数连接起来唯一确定，以免不同股票或者不同天数",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "s={}\n        # 字典的关键字用股票编码和天数连接起来唯一确定，以免不同股票或者不同天数的指数移动平均弄在一起了\n        key=\"%s%d\" %(security_code,days)\n        # 如果关键字存在，说明之前已经计算过EMA了，直接迭代即可\n        if key in g.EMAs:\n            #计算alpha值\n            alpha=(days-1.0)/(days+1.0)\n            # 获得前一天的EMA（这个是保存下来的了）\n            EMA_pre=g.EMAs[key]\n            # EMA迭代计算\n            EMA_now=EMA_pre*alpha+data[security_code].close*(1.0-alpha)\n            # 写入新的EMA值\n            g.EMAs[key]=EMA_now\n            # 给用户返回昨天和今天的两个EMA值\n            return (EMA_pre,EMA_n",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "用户返回昨天和今天的两个EMA值\n            return (EMA_pre,EMA_now)\n        # 如果关键字不存在，说明之前没有计算过这个EMA，因此要初始化\n        else:\n            # 获得days天的移动平均\n            ma=get_MA(security_code,days) \n            # 如果滑动平均存在（不返回NaN）的话，那么我们已经有足够数据可以对这个EMA初始化了\n            if not(isnan(ma)):\n                g.EMAs[key]=ma\n                # 因为刚刚初始化，所以前一期的EMA还不存在\n                return (float(\"nan\"),ma)\n            else:\n                # 移动平均数据不足days天，只好返回NaN值\n                return (float(\"nan\"),float(\"nan\"))\n\n'''\n==================",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "float(\"nan\"),float(\"nan\"))\n\n'''\n================================================================================\n每天收盘后\n================================================================================\n'''\n# 每日收盘后要做的事情（本策略中不需要）\ndef after_trading_end(context):\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('##############################################################')",
        "source": "99策略代码/46 Get API 新技能，研究中写策略并回测.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12143\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/570\n# 标题：【简单的多均线择时策略】那个天台排队的孩子，我给你讲个故事\n# 作者：陈小米。\n\ndef initialize(context):\n    g.stock = ['600196.XSHG']\n    set_benchmark('600196.XSHG')\n    g.month = context.current_dt.month\n    g.stock_grade = [0]\n    g.mavg5 = [0]\n    g.mavg10 = [0]\n    g.mavg20 = [0]\n    g.mavg30 = [0]\n    g.mavg60 = [0]\n    g.mavg180 = [0]\n    g.cash = 20000\n\n# 计算股票过去n个单位时间（一天）均值\ndef cacul",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "    g.cash = 20000\n\n# 计算股票过去n个单位时间（一天）均值\ndef caculate_mavg(stock,n):\n    return history(n, '1d', 'close', [stock],df = False)[stock].mean()\n\n# 得到需要的多条均线\ndef evaluate_by_mavg(stock):\n   mavg5 = caculate_mavg(stock,5)\n   g.mavg5.append(mavg5)\n   mavg10 = caculate_mavg(stock,10)\n   g.mavg10.append(mavg10)\n   mavg20 = caculate_mavg(stock,20)\n   g.mavg20.append(mavg20)\n   mavg30 = caculate_mavg(stock,30)\n   g.mavg30.append(mavg30)\n   return None\n\n# 判断多头排列\ndef is_highest_point(data,stock,n):\n    if len(g.mavg10)>",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "highest_point(data,stock,n):\n    if len(g.mavg10)>2:\n        price = data[stock].price\n        if g.mavg5[n] > g.mavg10[n]\\\n        and g.mavg10[n] > g.mavg20[n]\\\n        and g.mavg20[n] > g.mavg30[n]:\n            return True\n    return False\n\n# 判断空头排列——空仓\ndef is_lowest_point(data,stock,n):\n    if len(g.mavg10)>2:\n        price = data[stock].price\n        if g.mavg5[n] < g.mavg10[n]\\\n        and g.mavg10[n] < g.mavg20[n]:\n            return True\n    return False\n    \n# 判断多头排列后的死叉——卖出\ndef is_crossDOWN(data,s",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "alse\n    \n# 判断多头排列后的死叉——卖出\ndef is_crossDOWN(data,stock,mavg1,mavg2):\n    if len(mavg2)>2 and is_highest_point(data,stock,-2)\\\n    and is_highest_point(data,stock,-3):\n        if mavg1[-2] > mavg2[-2]\\\n        and mavg1[-1] < mavg2[-1]:\n            return True\n    return False\n\n# 判断空头排列后的金叉——买入\ndef is_crossUP(data,stock,mavg1,mavg2):\n    if len(mavg2)>2 and is_lowest_point(data,stock,-2)\\\n    and is_lowest_point(data,stock,-3):\n        if mavg1[-2] < mavg2[-2]\\\n        and mavg1[-1] > mavg2[-1]:\n            ",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "]\\\n        and mavg1[-1] > mavg2[-1]:\n            return True\n    return False\n\n# 判断均线纠缠\ndef is_struggle(mavg1,mavg2,mavg3):\n    if abs((mavg1[-1]-mavg2[-1])/mavg2[-1])< 0.003\\\n    or abs((mavg2[-1]-mavg3[-1])/mavg3[-1])< 0.002:\n        return True\n    return False\n\ndef handle_data(context, data):\n    for stock in g.stock:\n        evaluate_by_mavg(stock)\n        price = data[stock].price\n        # 多头排列——满仓买入\n        if is_highest_point(data,stock,-1) and context.portfolio.positions_value ==0:\n            # ",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "text.portfolio.positions_value ==0:\n            # 均线纠缠时，不进行买入操作\n            if is_struggle(g.mavg10,g.mavg20,g.mavg30):\n                continue\n            else:\n                order_target_value(stock,g.cash)\n        # 空头排列——清仓卖出\n        elif is_lowest_point(data,stock,-1):\n            order_target_value(stock,0)\n        # 多头排列后死叉——清仓卖出\n        if is_crossDOWN(data,stock,g.mavg5,g.mavg10):\n            order_target_value(stock,0)\n        # 空头排列后金叉——满仓买入\n        elif is_crossUP(data,stock,g.mavg10,g.mavg20",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "      elif is_crossUP(data,stock,g.mavg10,g.mavg20) and context.portfolio.positions_value ==0:\n            order_target_value(stock,g.cash)\n    record(mavg5 = g.mavg5[-1])\n    record(mavg10 = g.mavg10[-1])\n    record(mavg20 = g.mavg20[-1])\n    record(mavg30 = g.mavg30[-1])",
        "source": "99策略代码/89 test1：简单的多均线择时.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11700\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 标题：低回撤，PE分仓\n# 作者：桑梓\n#自定义数据是股指ETF占的仓位\nfrom __future__ import division \nimport numpy as np\nimport pandas as pd\nimport bisect\n\ndef initialize(context):\n    g.flag = False\n    run_monthly(monthly, 1, time='open')\n    set_benchmark('000300.XSHG')    \n    #g.CN10y_bond=0.03\n    log.set_level('order', 'error')\n\n    g.HoldLevel=0\n    g.LastHoldLevel=0\n    \n    g.HoldLevel1=0\n    g.HoldLevel2=0.2\n    g.HoldLev",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": " g.HoldLevel1=0\n    g.HoldLevel2=0.2\n    g.HoldLevel3=0.4\n    g.HoldLevel4=0.6\n    g.HoldLevel5=0.75\n    g.HoldLevel6=0.9\n    \n    #创建8个独立的仓位\n    init_cash = context.portfolio.starting_cash  #获取初始资金\n    init_cash = context.portfolio.starting_cash/8  #将初始资金等分为10份\n    set_subportfolios([SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubP",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock'),\\\n                       SubPortfolioConfig(cash=init_cash, type='stock')]) \n                       \n    g.stocks = {\n                'hs300':['000300.XSHG','510300.XSHG',context.subportfolios[0]",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "00300.XSHG','510300.XSHG',context.subportfolios[0],0,14.10,44.42],\n                'zzhb':['000827.XSHG','512580.XSHG',context.subportfolios[1],1,26.78,72.29], #中证保\n                'zz500':['000905.XSHG','510510.XSHG',context.subportfolios[2],2,21.99,69.81], #中证500\n                'hlzz':['000015.XSHG','510880.XSHG',context.subportfolios[3],3,8.40,46.23], #红利指数\n                'cyb':['399006.XSHE','159915.XSHE',context.subportfolios[4],4,27.61,121.85], #创业板\n                'zztmt':['000998.XSHG','150203.XSH",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "                'zztmt':['000998.XSHG','150203.XSHE',context.subportfolios[5],5,28.15,108.92], #tmt\n                'yy':['000933.XSHG','512010.XSHG',context.subportfolios[6],6,22.22,66.82], #医药\n                'zz100':['000903.XSHG','150012.XSHE',context.subportfolios[7],7,9.81,36.59] #中证100\n                }\n                \ndef monthly(context):\n    g.flag = True\n    \ndef Relation(n,MaxRatio,MinRatio):\n    if n>=MaxRatio*0.9+MinRatio:\n        HoldLevel=g.HoldLevel1\n    elif n>MaxRatio*0.8+MinRatio:\n     ",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "HoldLevel1\n    elif n>MaxRatio*0.8+MinRatio:\n        HoldLevel=g.HoldLevel2\n    elif n>MaxRatio*0.7+MinRatio:\n        HoldLevel=g.HoldLevel3\n    elif n>MaxRatio*0.6+MinRatio:\n        HoldLevel=g.HoldLevel4\n    elif n>MaxRatio*0.5+MinRatio:   \n        HoldLevel=g.HoldLevel5\n    elif n>MaxRatio*0.3+MinRatio:  #16.92  0.4=19.36\n        HoldLevel=g.HoldLevel6\n    else:\n        HoldLevel=1\n    return HoldLevel\n    #else:\n    #    k=(g.MinHoldLevel-g.MaxHoldLevel)/(g.MaxRatio-g.MinRatio)\n    #    b=g.MinHoldLevel",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "/(g.MaxRatio-g.MinRatio)\n    #    b=g.MinHoldLevel-g.MinRatio*k\n    #    g.HoldLevel=k*n+b\n    #Debug:\n    #print 'k=(' +str(g.MaxHoldLevel)+'-'+str(g.MinHoldLevel) + ')/' +\\\n    #'('+str(g.MaxRatio)+'-'+str(g.MinRatio)+')'+' = '+str(k)\n    #print 'HoldLevel=' +str(k) + '*N' + '+' +str(b)\n\ndef PeRatio(code,context): # 计算当前指数PE\n    date = context.current_dt\n    stocks = get_index_stocks(code, date)\n    q = query(valuation).filter(valuation.code.in_(stocks))\n    df = get_fundamentals(q, date)\n    if len(df)>0",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "   df = get_fundamentals(q, date)\n    if len(df)>0:\n        pe2 = len(df)/sum([1/p if p>0 else 0 for p in df.pe_ratio])\n        return pe2\n    else:\n        return float('NaN')\n        \n#def ChangeHoldLevel(stock,NewHoldLevel,context):\n#    order_target_value(g.stocks[stock][1],NewHoldLevel*g.stocks[stock][2],pindex=g.stocks[stock][3])\n    #order_target_value(g.Test_bond,(1-NewHoldLevel)*AllMoney,None)\n\ndef handle_data(context, data):\n    #if context.current_dt.isoweekday()!=1:      #ne Marcher que Lundi. \n",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "_dt.isoweekday()!=1:      #ne Marcher que Lundi. \n    #    return\n    #N= (1/PeRatio(get_current_data()))/g.CN10y_bond\n    if g.flag == True:\n        for stock in g.stocks:\n            index_pe = PeRatio(g.stocks[stock][0],context)\n        \n            MaxRatio1 = g.stocks[stock][5]\n            MinRatio = g.stocks[stock][4]\n            MaxRatio = MaxRatio1-MinRatio\n        \n            HoldLevel = Relation(index_pe,MaxRatio,MinRatio)\n        \n            trade_code = g.stocks[stock][1]\n            cash = g.",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "de_code = g.stocks[stock][1]\n            cash = g.stocks[stock][2].total_value * HoldLevel\n            inde = g.stocks[stock][3]\n\n        \n            order_target_value(trade_code,cash,pindex=inde)\n        g.flag = False\n        \n        \n        \n'''        \n    N = PeRatio(code,context)\n    HoldLevel = Relation(N)\n    ChangeHoldLevel(HoldLevel,context.portfolio.total_value)\n    print 'PE:%.2f'%N\n    print \"Holdlevel is %.2f\" % HoldLevel\n    \n    record(name=g.HoldLevel)\n'''",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "me=g.HoldLevel)\n'''",
        "source": "99策略代码/65 8只基金按PE调仓.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13972\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = True\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.da",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "agement_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities ",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_u",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": ", g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "ments_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_o",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "ck_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists ",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "xt, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in buy_lists if money_flow_xiaoyu(context, security, 'net_pct_main', 20, which_day='previous')]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "+= 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "k in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio_lyr, 20)\n    security_list = financial_data_filter_qujian(security_list, indicator.roe, (3,40))\n    security_list = financial_data_filter_qujian(security_list, valuation.pb_",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "al_data_filter_qujian(security_list, valuation.pb_ratio, (3,14))\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "ilter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n   ",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "####\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if money_flow_dayu(context, security, 'net_pct_main', 30, which_day='previous')]\n    ### _出场函数筛选-结束 ###\n    \n    # 卖",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "y='previous')]\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_manageme",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": " # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hol",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "   if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 #",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "turn\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 ",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "       a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n  ",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "ys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "t if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_c",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_d",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "ilter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_in",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "et_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, indust",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "def industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": " security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/16 投资学作业.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11877\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holde",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in c",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "urities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    security_stoploss(context,0.1,g.open_sell_securities)\n    security_stopprofit(context,0.5,g.o",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ecurities)\n    security_stopprofit(context,0.5,g.open_sell_securities)\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.ch",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ck_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_fi",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n ",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "imit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ts)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, in",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ist = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 15)\n    security_list = financial_data_filter_dayu(security_list, indicator.gross_profit_margin, 20)\n    security_list = financial_data_filter_dayu(security_list, indicator.operation_profit_to_total_revenue, 10)\n    security_list = financial_data_filter_dayu(security_list, valuation.market_cap, 200)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    #",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "r_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_l",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "text.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,in",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ity_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        res",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "   if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return li",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "scending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in securit",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "       security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in s",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "t_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ndex)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "ities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in secu",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "[stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/28 收益策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13974\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "anagement_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securitie",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "r_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "xt, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "tements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "heck_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_list",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "text, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "ade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "#######################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.roe, 8)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 7)\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio_lyr, 30)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list)",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "ef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "s = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(con",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "d_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n    ",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": " 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_v",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "# 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "    # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        re",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "ore'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": " stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in ",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "ata()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        c",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "ntext, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for sto",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index ",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "te()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_l",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "  securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock ",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/57 黄泽森策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/16022\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nfrom jqdata import *\nimport datetime\nimport time\nimport talib\n\n'''\nArrayManager:\n用于拼接K线的类，该策略基于不均匀的K线完成，在固定时间输出bar（日内，如早盘收盘时）\n而当前平台未推出该功能，因而自定义ArrayManager类来实现          \n'''\nclass ArrayManager(object):\n    \n    # 初始化函数，设定基准等等\n    def __init__(self, size=100):\n        # 设定Array的缓存大小\n        self.size = size  \n        \n        # 基本指标与基本指标的Array字典初始化（用于K线按收盘时间分割）\n        # 在这里VarArrays指的是全新K线的数据，以字",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "化（用于K线按收盘时间分割）\n        # 在这里VarArrays指的是全新K线的数据，以字典的形式存放，Vars是更新K线前的缓存\n        self.Vars = {'close':False,\n                    'open':False,\n                    'high':False,\n                    'low':False}\n                    \n        self.VarsArrays = {'close':np.zeros(size),\n                          'open':np.zeros(size),\n                          'high':np.zeros(size),\n                          'low':np.zeros(size)}\n    \n    # 更新Array，形成新的bar数据，后续指标等都是基于该Array进行计算    \n    def updateBarArray(self):\n   ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "基于该Array进行计算    \n    def updateBarArray(self):\n        for var in self.VarsArrays.keys():\n            self.VarsArrays[var][0:self.size-1] = self.VarsArrays[var][1:self.size]\n            self.VarsArrays[var][-1] = self.Vars[var]\n    \n    # 更新缓存（即为更新Array做准备）        \n    def updateBar(self,close,high,low,open):\n        # 如果缓存Vars没有数据，或者被clear，则初次写入\n        if self.Vars['close'] == False:\n            self.Vars['close'] = close\n            self.Vars['high'] = high\n            self.Vars['low'] = low\n            ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "gh\n            self.Vars['low'] = low\n            self.Vars['open'] = open\n        else:\n            # 如果有数据，则实时更新\n            self.Vars['close'] = close\n            self.Vars['high'] = max(self.Vars['high'],high)\n            self.Vars['low'] = min(self.Vars['low'],low)\n            \n   \n    # 清除Bar数据       \n    def clear(self):\n        self.Vars['open']= False\n        self.Vars['close']= False\n        self.Vars['high'] = False\n        self.Vars['low']= False\n    \n    # 输出当前Array\n    def exportArray(self,fie",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "\n    \n    # 输出当前Array\n    def exportArray(self,field):\n        return self.VarsArrays[field]\n    # 输出当前缓存变量  \n    def exportVar(self,field):\n        return self.Vars[field]\n    \n    # 输出10天内的最高价    \n    def Highest_10(self,future):\n        return self.VarsArrays['close'][-10*g.TodayBar[future]-1:-1].max()\n    \n    # 输出10天内的最低价    \n    def Lowest_10(self,future):\n        return self.VarsArrays['close'][-10*g.TodayBar[future]-1:-1].min()\n\n\ndef initialize(context):\n    # 设置参数\n    set_parameter(context)\n    # 设",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "xt):\n    # 设置参数\n    set_parameter(context)\n    # 设定基准银华日利，在多品种的回测当中基准没有参考意义\n    set_benchmark('511880.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    ### 期货相关设定 ###\n    # 设定账户为金融账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='futures')])\n    # 期货类每笔交易时的手续费是：买入时万分之1,卖出时万分之1,平今仓为万分之1\n    set_order_cost(OrderCost(open_commission=0.0001, close_commission=0.0001,close_today_comm",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "n=0.0001, close_commission=0.0001,close_today_commission=0.0001), type='index_futures')\n    # 设定保证金比例\n    set_option('futures_margin_rate', 0.15)\n    # 设置滑点（单边万5，双边千1）\n    set_slippage(PriceRelatedSlippage(0.001),type='future')\n    # 开盘前运行\n    run_daily( before_market_open, time='before_open', reference_security='AG8888.XSGE')\n    # 开盘时运行\n    run_daily( DataPrepare, time='every_bar', reference_security='AG8888.XSGE')\n    # 收盘后运行\n    run_daily( after_market_close, time='after_close', reference_security='AG88",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "lose, time='after_close', reference_security='AG8888.XSGE')\n    #切割函数\n    \ndef set_parameter(context):\n    #######变量设置########\n    # 字典信息代表各品种分别对应变量\n    g.AM = {}  # ArrayManger\n    g.Data = {}  # 数据字典\n    g.LastPrice = {}  # 最新价格字典（用于吊灯止损）\n    g.HighPrice = {} # 各品种最高价字典（用于吊灯止损）\n    g.LowPrice = {} # 各品种最低价字典（用于吊灯止损）\n    g.TradeLots = {}  # 各品种的交易手数信息\n    g.Price_dict = {} # 各品种价格列表字典\n    g.Times = {} # 计数器（用于防止止损重入）\n    g.TodayBar = {} # 每个future当日的bar数量\n    g.MidLine = {} # 布林带中线\n    g.ATR = {} # ATR数组\n ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "   g.MidLine = {} # 布林带中线\n    g.ATR = {} # ATR数组\n    g.Reentry_long = False # 止损后重入标记\n    g.Reentry_short = False # 止损后重入标记\n    #######参数设置########\n    g.Signal = 0 # 交易判定信号\n    g.offset = 2 # 通道倍数\n    g.NATRstop = 4\n    g.Window = 15\n    g.MarginRate = 1\n    g.MappingReal = {} # 真实合约映射（key为symbol，value为主力合约）\n    g.MappingIndex = {} # 指数合约映射 （key为 symbol，value为指数合约\n    # 交易的期货品种信息\n    g.instruments = ['JD','RU','RB','I','J','TA']\n    #g.instruments = ['RB']\n    # 切割K线时间，每次收盘时切割（由于夜盘收盘时间不定，因而将其设置为早盘第一个15分钟时切",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "    # 切割K线时间，每次收盘时切割（由于夜盘收盘时间不定，因而将其设置为早盘第一个15分钟时切）\n    g.CloseMarket = ['0915','1130','1500']\n    # 运行Bar计算函数的时间（每分钟运行计算会导致速度奇慢，因而取最小颗粒度15分钟）\n    g.DatePrepareTime = ['00','15','30','45']\n    #将初始数据传入future_list\n    set_future_list(context)\n\n\n    # 数据初始化\ndef set_future_list(context):\n    for ins in g.instruments:\n        idx = get_future_code(ins)\n        dom = get_dominant_future(ins)\n        # 填充映射字典\n        g.MappingIndex[ins] = idx\n        g.MappingReal[ins] = dom\n        g.Times[idx] = 0\n          \n  ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "[ins] = dom\n        g.Times[idx] = 0\n          \n                \n## 开盘前运行函数\ndef before_market_open(context):\n    \n    # 过滤无主力合约的品种，传入并修改期货字典信息\n    for ins in g.instruments:\n        RealFuture = get_dominant_future(ins)\n        IndexFuture = get_future_code(ins)\n        \n        # 以下逻辑判断该品种是否有夜盘，并计算TodayBar\n        g.Data[IndexFuture] = attribute_history(IndexFuture,120, unit='60m',fields = ['close'])\n        HourList = [x.strftime('%H') for x in g.Data[IndexFuture].index[:]]\n        if '21' in HourList: \n  ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "Future].index[:]]\n        if '21' in HourList: \n            g.TodayBar[IndexFuture] = 3\n        else:\n            g.TodayBar[IndexFuture] = 2\n        \n        \n        if RealFuture == '':\n            pass\n        else:\n            # 判断是否执行replace_old_futures\n            if RealFuture == g.MappingReal[ins]:\n                pass\n            else:\n                replace_old_futures(context,ins,RealFuture)\n                g.HighPrice[IndexFuture] = False\n                g.LowPrice[IndexFuture] = False\n       ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "           g.LowPrice[IndexFuture] = False\n                g.Times[IndexFuture] = 0\n                g.MappingReal[ins] = RealFuture\n                \n            # 计算交易手数\n            lots = context.portfolio.starting_cash/len(g.instruments)\n            g.TradeLots[IndexFuture] = get_lots(lots,ins)\n\n  \ndef DataPrepare(context):\n    # 每15分钟跑一次数据接合模块\n    if str(context.current_dt.time().strftime('%M')) in g.DatePrepareTime:\n        for ins in g.instruments:\n            IndexFuture = get_future_code(ins)\n       ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "        IndexFuture = get_future_code(ins)\n            RealFuture = get_dominant_future(ins)\n            # 获取历史数据\n            g.LastPrice[IndexFuture] = attribute_history(IndexFuture,50, unit='15m',fields = ['close','open','high','low'])\n            # 如果当前时间在该品种实际交易时间内（基于15分钟bar），则执行拼接\n            if str(context.current_dt.time()) in [x.strftime('%H:%M:%S') for x in g.LastPrice[IndexFuture].index[:]]:\n                # 初始化\n                if IndexFuture not in g.AM.keys():\n                    g.AM[IndexFutu",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "in g.AM.keys():\n                    g.AM[IndexFuture] = ArrayManager()\n                    g.AM[IndexFuture].updateBar(g.LastPrice[IndexFuture]['close'][-1],\n                                            g.LastPrice[IndexFuture]['high'][-1],\n                                            g.LastPrice[IndexFuture]['low'][-1],\n                                            g.LastPrice[IndexFuture]['open'][-1])\n                else:\n                    # 收盘时间时输出新Bar\n                    if g.LastPrice[IndexFuture].index",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "                 if g.LastPrice[IndexFuture].index[-1].strftime('%H%M') in g.CloseMarket :\n                        # 没有夜盘的品种在9点15分不输出新Bar\n                        if g.TodayBar[IndexFuture] == 2 and g.LastPrice[IndexFuture].index[-1].strftime('%H%M') == '0915':\n                            pass\n                        else:\n                            # updateBarArray首先把新数据填充到Array中，老数据向前移动1位\n                            # clear同时删除缓存\n                            g.AM[IndexFuture].updateBarArray()\n             ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "  g.AM[IndexFuture].updateBarArray()\n                            g.AM[IndexFuture].clear()\n                            # 【每次在输出新的Bar的时候执行指标计算与交易逻辑】\n                            market_open(context)\n                    # 非收盘时间更新缓存（4个价格）\n                    else:\n                        g.AM[IndexFuture].updateBar(g.LastPrice[IndexFuture]['close'][-1],\n                                            g.LastPrice[IndexFuture]['high'][-1],\n                                            g.LastPrice[IndexFuture]['low'][-1",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "                g.LastPrice[IndexFuture]['low'][-1],\n                                            g.LastPrice[IndexFuture]['open'][-1])\n\n\n## 开盘时运行函数\ndef market_open(context):\n    # 输出函数运行时间\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    # 主循环函数（遍历各期货品种）\n    \n    for ins in g.MappingReal.keys():\n        # 计算今日的Bar数（用以确定ATR的参数）\n        IndexFuture = get_future_code(ins)\n        RealFuture = get_dominant_future(ins)\n\n        # ATR计算  \n        g.low = g.AM[IndexFuture].exportArray('low')",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "      g.low = g.AM[IndexFuture].exportArray('low')[-g.TodayBar[IndexFuture]*g.Window-1:]\n        g.high = g.AM[IndexFuture].exportArray('high')[-g.TodayBar[IndexFuture]*g.Window-1:]\n        g.close = g.AM[IndexFuture].exportArray('close')[-g.TodayBar[IndexFuture]*g.Window-1:]\n        # 为了防止ATR误算，如果出现大面积的空数据，则不计算ATR\n        if 0 in g.close:\n            pass\n        else:\n            g.ATR[IndexFuture] = talib.ATR(g.high,g.low,g.close, timeperiod = g.TodayBar[IndexFuture]*g.Window)[-1]\n            print(g.ATR",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "IndexFuture]*g.Window)[-1]\n            print(g.ATR[IndexFuture])\n            # 布林带计算\n            g.MidLine = g.close[-g.Window*g.TodayBar[IndexFuture]:].mean()\n            g.BollUp = g.MidLine + g.offset*g.ATR[IndexFuture]\n            g.BollDown = g.MidLine - g.offset*g.ATR[IndexFuture]\n            \n        \n            # 交易信号计算\n            if g.close[-1] > g.BollUp:\n                g.Cross = 1\n            elif g.close[-1] < g.BollDown:\n                g.Cross = -1\n            else:\n                g.Cross ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "ss = -1\n            else:\n                g.Cross = 0\n            \n            #判断交易信号：布林带突破+可二次入场条件成立\n            if  g.Cross == 1 and g.Reentry_long == False:\n                g.Signal = 1\n            elif g.Cross == -1 and g.Reentry_short == False:\n                g.Signal = -1\n            else:\n                g.Signal = 0\n            # 执行交易\n            Trade(context,RealFuture,IndexFuture)\n            # 运行防止充入模块\n            Dont_Re_entry(context,IndexFuture,ins)\n            # 计数器+1\n            g.Times[I",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "ure,ins)\n            # 计数器+1\n            g.Times[IndexFuture] += 1\n\n\n## 收盘后运行函数\ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    # 得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n\n\n## 交易模块 \ndef Trade(context,RealFuture,IndexFuture):\n    \n    # 快线高于慢线，且追踪止损失效，则可开多仓\n    if g.Signal =",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "\n    \n    # 快线高于慢线，且追踪止损失效，则可开多仓\n    if g.Signal == 1 and context.portfolio.long_positions[RealFuture].total_amount == 0:\n        if context.portfolio.short_positions[RealFuture].total_amount != 0:\n            log.info('空头有持仓：%s'%(RealFuture))\n        order_target(RealFuture,0,side='short')\n        order_target(RealFuture,g.TradeLots[IndexFuture],side='long')\n        g.HighPrice[IndexFuture] = g.close[-1]\n        g.LowPrice[IndexFuture] = False\n        log.info('正常买多合约：%s'%(RealFuture))\n    \n    elif g.Sign",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "nfo('正常买多合约：%s'%(RealFuture))\n    \n    elif g.Signal == -1 and context.portfolio.short_positions[RealFuture].total_amount == 0:\n        if context.portfolio.long_positions[RealFuture].total_amount != 0:\n            log.info('多头有持仓：%s'%(RealFuture))\n        order_target(RealFuture,0,side ='long')\n        order_target(RealFuture,g.TradeLots[IndexFuture],side='short')\n        g.LowPrice[IndexFuture] = g.close[-1]\n        g.HighPrice[IndexFuture] = False\n        log.info('正常卖空合约：%s'%(RealFuture))\n    else:\n    ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": " log.info('正常卖空合约：%s'%(RealFuture))\n    else:\n        TrailingStop(context,RealFuture,IndexFuture)\n        \n        \n# 防止止损后立刻重入模块\ndef Dont_Re_entry(context,IndexFuture,ins):\n    # 防重入模块：上一次止损后10天内不交易，但如果出现价格突破事件，则10天内的限制失效\n    g.Highest_high_10 = g.AM[IndexFuture].Highest_10(IndexFuture)\n    g.Lowest_low_10 = g.AM[IndexFuture].Lowest_10(IndexFuture)\n    \n    if  g.Reentry_long == True:\n        if g.Times[IndexFuture] > 10*g.TodayBar[IndexFuture] or g.close[-1] > g.Highest_high_10 :\n            g.Reentry_lo",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "-1] > g.Highest_high_10 :\n            g.Reentry_long = False\n    if  g.Reentry_short == True:\n        if g.Times[IndexFuture] > 10*g.TodayBar[IndexFuture] or g.close[-1] < g.Lowest_low_10 :\n            g.Reentry_short = False\n        \n        \n# 吊灯止损模块\ndef TrailingStop(context,RealFuture,IndexFuture):\n    \n    # 仓位状态\n    long_positions = context.portfolio.long_positions\n    short_positions = context.portfolio.short_positions\n    # 多头进场后最高价 空头jinchanghou\n    g.HighPrice[IndexFuture] = max(g.HighPrice[IndexFu",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "g.HighPrice[IndexFuture] = max(g.HighPrice[IndexFuture],g.close[-1])\n    g.LowPrice[IndexFuture] = min(g.LowPrice[IndexFuture],g.close[-1])\n    \n    if RealFuture in long_positions.keys():\n        if long_positions[RealFuture].total_amount > 0:\n            if g.HighPrice[IndexFuture]:\n                if g.close[-1]  < g.HighPrice[IndexFuture]  - g.NATRstop*g.ATR[IndexFuture]:\n                    log.info('多头止损:\\t' +  RealFuture)\n                    order_target(RealFuture,0,side = 'long')\n                  ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "get(RealFuture,0,side = 'long')\n                    g.Reentry_long = True\n\n    if RealFuture in short_positions.keys():\n        if short_positions[RealFuture].total_amount > 0:\n            if g.LowPrice[IndexFuture]:\n                if g.close[-1]  > g.LowPrice[IndexFuture] + g.NATRstop*g.ATR[IndexFuture]:\n                    log.info('空头止损:\\t' + RealFuture)\n                    order_target(RealFuture,0,side = 'short')\n                    g.Reentry_short = True\n        \n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约     ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "rue\n        \n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约        \ndef replace_old_futures(context,ins,RealFuture):\n    \n    LastFuture = g.MappingReal[ins]\n    \n    if LastFuture in context.portfolio.long_positions.keys():\n        lots_long = context.portfolio.long_positions[LastFuture].total_amount\n        order_target(LastFuture,0,side='long')\n        order_target(RealFuture,lots_long,side='long')\n        print('主力合约更换，平多仓换新仓')\n    \n    if LastFuture in context.portfolio.short_positions.keys():\n        lots_short = c",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "lio.short_positions.keys():\n        lots_short = context.portfolio.short_positions[LastFuture].total_amount\n        order_target(LastFuture,0,side='short')\n        order_target(RealFuture,lots_short,side='short')\n        print('主力合约更换，平空仓换新仓')\n\n        \n\n        \n# 获取当天时间正在交易的期货主力合约函数\ndef get_future_code(symbol):\n    future_code_list = {'A':'A8888.XDCE', 'AG':'AG8888.XSGE', 'AL':'AL8888.XSGE', 'AU':'AU8888.XSGE',\n                        'B':'B8888.XDCE', 'BB':'BB8888.XDCE', 'BU':'BU8888.XSGE', 'C':'C8888.XD",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "':'BB8888.XDCE', 'BU':'BU8888.XSGE', 'C':'C8888.XDCE', \n                        'CF':'CF8888.XZCE', 'CS':'CS8888.XDCE', 'CU':'CU8888.XSGE', 'ER':'ER8888.XZCE', \n                        'FB':'FB8888.XDCE', 'FG':'FG8888.XZCE', 'FU':'FU8888.XSGE', 'GN':'GN8888.XZCE', \n                        'HC':'HC8888.XSGE', 'I':'I8888.XDCE', 'IC':'IC8888.CCFX', 'IF':'IF8888.CCFX', \n                        'IH':'IH8888.CCFX', 'J':'J8888.XDCE', 'JD':'JD8888.XDCE', 'JM':'JM8888.XDCE', \n                        'JR':'JR8888.XZC",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "8.XDCE', \n                        'JR':'JR8888.XZCE', 'L':'L8888.XDCE', 'LR':'LR8888.XZCE', 'M':'M8888.XDCE', \n                        'MA':'MA8888.XZCE', 'ME':'ME8888.XZCE', 'NI':'NI8888.XSGE', 'OI':'OI8888.XZCE', \n                        'P':'P8888.XDCE', 'PB':'PB8888.XSGE', 'PM':'PM8888.XZCE', 'PP':'PP8888.XDCE', \n                        'RB':'RB8888.XSGE', 'RI':'RI8888.XZCE', 'RM':'RM8888.XZCE', 'RO':'RO8888.XZCE', \n                        'RS':'RS8888.XZCE', 'RU':'RU8888.XSGE', 'SF':'SF8888.XZCE', 'SM'",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "ZCE', 'RU':'RU8888.XSGE', 'SF':'SF8888.XZCE', 'SM':'SM8888.XZCE', \n                        'SN':'SN8888.XSGE', 'SR':'SR8888.XZCE', 'T':'T8888.CCFX', 'TA':'TA8888.XZCE', \n                        'TC':'TC8888.XZCE', 'TF':'TF8888.CCFX', 'V':'V8888.XDCE', 'WH':'WH8888.XZCE', \n                        'WR':'WR8888.XSGE', 'WS':'WS8888.XZCE', 'WT':'WT8888.XZCE', 'Y':'Y8888.XDCE', \n                        'ZC':'ZC8888.XZCE', 'ZN':'ZN8888.XSGE'}\n    try:\n        return future_code_list[symbol]\n    except:\n        ret",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "n future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n\n\n# 获取交易手数函数（ATR倒数头寸）\ndef get_lots(cash,symbol):\n    future_coef_list = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10,\n                        'CF':5, 'CS':10, 'CU':5, 'ER':10,\n                        'FB':500, 'FG':20, 'FU':50, 'GN':10,\n                        'HC':10, 'I':100, 'IC':200, 'IF':300,\n                        'IH':300, 'J':100, 'JD':5, 'JM':60,\n                        'JR':20, ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "'JD':5, 'JM':60,\n                        'JR':20, 'L':5, 'LR':10, 'M':10,\n                        'MA':10, 'ME':10, 'NI':1, 'OI':10,\n                        'P':10, 'PB':5, 'PM':50, 'PP':5,\n                        'RB':10, 'RI':20, 'RM':10, 'RO':10,\n                        'RS':10, 'RU':10, 'SF':5, 'SM':5,\n                        'SN':1, 'SR':10, 'T':10000, 'TA':5,\n                        'TC':100, 'TF':10000, 'V':5, 'WH':20,\n                        'WR':10, 'WS':50, 'WT':10, 'Y':10,\n                       ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": " 'WS':50, 'WT':10, 'Y':10,\n                        'ZC':100, 'ZN':5,'AP':10}\n    RealFuture = get_dominant_future(symbol)\n    IndexFuture = get_future_code(symbol)\n    # 获取价格list\n    Price_dict = attribute_history(IndexFuture,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0:\n        return\n    else:\n        open_future = Price_dict.iloc[-1]\n    # 返回手数\n    if IndexFuture in g.ATR.keys():\n        # 每次使用5%资金开仓交易\n        # 合约价值的表达式是：g.ATR[IndexFuture]*future_coef_list[symbol]\n        return cash*0.",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "e]*future_coef_list[symbol]\n        return cash*0.05/(g.ATR[IndexFuture]*future_coef_list[symbol])\n    else:# 函数运行之初会出现没将future写入ATR字典当中的情况\n        return 0\n\n\n'''\n# 获取交易手数函数(无ATR版本）\ndef get_lots(cash,symbol):\n    # 获取合约规模(Contract Size)，也称交易单位\n    future_Contract_Size = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10,\n                        'CF':5, 'CS':10, 'CU':5, 'ER':10,\n                        'FB':500, 'FG':20, 'FU':50, 'GN':10,\n                        'H",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "':20, 'FU':50, 'GN':10,\n                        'HC':10, 'I':100, 'IC':200, 'IF':300,\n                        'IH':300, 'J':100, 'JD':5, 'JM':60,\n                        'JR':20, 'L':5, 'LR':10, 'M':10,\n                        'MA':10, 'ME':10, 'NI':1, 'OI':10,\n                        'P':10, 'PB':5, 'PM':50, 'PP':5,\n                        'RB':10, 'RI':20, 'RM':10, 'RO':10,\n                        'RS':10, 'RU':10, 'SF':5, 'SM':5,\n                        'SN':1, 'SR':10, 'T':10000, 'TA':5,\n               ",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "SN':1, 'SR':10, 'T':10000, 'TA':5,\n                        'TC':100, 'TF':10000, 'V':5, 'WH':20,\n                        'WR':10, 'WS':50, 'WT':10, 'Y':10,\n                        'ZC':100, 'ZN':5,'AP':10}\n    future = get_dominant_future(symbol)\n    # 获取价格list\n    Price_dict = attribute_history(future,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0:\n        return\n    else:\n        # 获得最新开盘价，计算能够下单多少手\n        open_price = Price_dict.iloc[-1]\n    # 返回手数（价格*合约规模=名义价值）\n    # 保证金使用，控制在33%\n    # 合",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "   # 返回手数（价格*合约规模=名义价值）\n    # 保证金使用，控制在33%\n    # 合约保证金的表达式是：open_price*future_Contract_Size[symbol]*g.MarginRate\n    return cash*0.33/(open_price*future_Contract_Size[symbol]*g.MarginRate)\n'''\n",
        "source": "99策略代码/20 分钟K线数据重构 ATR自适应通道 请高手来迭代.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13400\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入TA-Lib\nimport talib as tb\ndef initialize(context):\n    set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))\n    set_option('use_real_price', True)\n    g.buy_stock_count = 3\n    g.kama_days = 13\n    g.new_public_days = 150\n    g.return_radio = 0.999\n    \n    g.days_counter = 0\n    g.buy_period =2\n    \n    # 运行函数\n    run_daily(market_end, time='after_close')\n    \ndef handle_data(con",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "_end, time='after_close')\n    \ndef handle_data(context, data):\n    hour = context.current_dt.hour\n    minute = context.current_dt.minute\n    \n    if hour == 9 and minute == 59:\n        if(g.days_counter%g.buy_period == 0):\n            buy_stocks = select_stocks(context,data)\n            adjust_position(context,data, buy_stocks)\n           \n    \n    #每N分钟检查是否要卖\n    if minute%5 == 0 :\n        for stock in context.portfolio.positions.keys():\n            if(context.portfolio.positions[stock].closeable_amount > ",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "ext.portfolio.positions[stock].closeable_amount > 0):\n                single = get_kama_single(context,stock)\n                if(single == -1):\n                    order_target_value(stock, 0)\n\ndef market_end(context):\n    g.days_counter = g.days_counter +1;\n\n\n#过滤停牌 st        \ndef filter_paused_and_st_stock(stock_list):\n    current_data = get_current_data()\n    return [stock for stock in stock_list if not current_data[stock].paused \n    and not current_data[stock].is_st and 'ST' not in current_data[stock].\n",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "stock].is_st and 'ST' not in current_data[stock].\n    name and '*' not in current_data[stock].name and '退' not in current_data[stock].name]\n\ndef filter_gem_stock(context, stock_list):\n    return [stock for stock in stock_list  if stock[0:3] != '300']\n\n#筛选股票, 次新最小市值排序获取前N个    \ndef select_stocks(context,data):\n    q = query(valuation.code, \n            valuation.circulating_market_cap\n        ).order_by(\n            valuation.circulating_market_cap.asc()\n        ).filter(\n            valuation.circulating_mar",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "   ).filter(\n            valuation.circulating_market_cap <= 99\n        ).limit(100)\n        \n    df = get_fundamentals(q)\n    stock_list = list(df['code'])\n    stock_list = filter_paused_and_st_stock(stock_list)\n    stock_list = filter_gem_stock(context, stock_list)\n    blacklist = [] \n    #新股筛选\n    tmpList = []\n    for stock in stock_list :\n        #按交易日期算更合理？\n        days_public=(context.current_dt.date() - get_security_info(stock).start_date).days\n        if days_public < g.new_public_days and days_publ",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "  if days_public < g.new_public_days and days_public > 50:\n                tmpList.append(stock)\n    stock_list = tmpList\n    #均线筛选\n    tmp_TimeSelect_List = []\n    for stock in stock_list :\n        sigle = get_kama_single(context, stock)\n        if(sigle >= 0):\n            tmp_TimeSelect_List.append(stock)\n    stock_list = tmp_TimeSelect_List\n    \n    \n    filter_stocks = []\n    last_prices = history(1, '1m', 'close', security_list=stock_list)\n    curr_data = get_current_data()\n    for stock in stock_list:",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": " = get_current_data()\n    for stock in stock_list:\n        if last_prices[stock][-1] < curr_data[stock].high_limit:\n            if last_prices[stock][-1] > curr_data[stock].low_limit:\n                if stock not in blacklist:\n                    filter_stocks.append(stock)\n    stock_list = filter_stocks \n    stock_list = stock_list[:g.buy_stock_count]  \n    return stock_list;\n    \ndef adjust_position(context,data, buy_stocks):\n    #卖\n    for stock in context.portfolio.positions.keys():\n        last_prices ",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "t.portfolio.positions.keys():\n        last_prices = history(1, '1m', 'close', security_list=context.portfolio.positions.keys())\n        if stock not in buy_stocks:\n            curr_data = get_current_data()\n            if last_prices[stock][-1] < curr_data[stock].high_limit:\n                position = context.portfolio.positions[stock]\n                order_target_value(stock, 0)\n    #买            \n    for stock in buy_stocks:\n        position_count = len(context.portfolio.positions)\n        if g.buy_stock_",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "ntext.portfolio.positions)\n        if g.buy_stock_count > position_count:\n            value = context.portfolio.cash / (g.buy_stock_count - position_count)\n            if context.portfolio.positions[stock].total_amount == 0:\n                order_target_value(stock, value)\n\n\n\ndef get_kama_single(context,security):\n    period= g.kama_days*4*6\n    close_long = get_price(security, end_date=context.current_dt, frequency='10m', fields=['close'], count= period +2*4*6 )['close'].values;\n    #close_short = get_pric",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "4*6 )['close'].values;\n    #close_short = get_price(g.security, end_date=context.previous_date, frequency='1d', fields=['close'], count= short_days+10 )['close'].values;\n    kama_long =  tb.KAMA(close_long,timeperiod= period); \n    #kama_short =  tb.KAMA(close_short,timeperiod= short_days); \n    # if( (kama_short[-1] > kama_long[-1]) & (kama_short[-2] <= kama_long[-2]) & (kama_short[-1] > kama_short[-2])):\n    #     return 1\n    # if(( kama_short[-1] < kama_long[-1]) & (kama_short[-2] >= kama_long[-2]) & (k",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "long[-1]) & (kama_short[-2] >= kama_long[-2]) & (kama_short[-1] < kama_short[-2])):\n    #     return 0\n    #std = np.std(kama_long[long_days:]);\n    \n    #sell\n    if ((kama_long[-1] / kama_long[-2])< g.return_radio ): #or ((close_short[-1]/close_short[-2])<=0.93):\n        return -1;\n    # if ((close_long[-1] / close_long[-2])<= 0.97 ): #or ((close_short[-1]/close_short[-2])<=0.93):\n    #      return -1;    \n    #attribute_history    \n    if(kama_long[-1]/kama_long[-2] >1.01):\n        return 1;\n    # if kam",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "ma_long[-2] >1.01):\n        return 1;\n    # if kama_short[-1] < kama_long[-1] and kama_short[-2] > kama_long[-2]:\n    #     #sell\n    #     return 0;\n    # if kama_short[-1] > kama_long[-1] and kama_short[-2] < kama_long[-2]:\n    #     #buy\n    #     return 1\n    return 0;    \n\n",
        "source": "99策略代码/82 次新+小市值+KAMA择时 轮动.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11101\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport talib\nimport math\nimport numpy as np\nimport pandas as pd\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    g.security = '399300.XSHE'\n    set_benchmark('399300.XSHE')\n    \n    #设置参数\n    context.OBSERVATION = 100  \n    context.ADXPERIOD = 18\n    \n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    security = g.security  \n    # 获取股票的价格信息\n    price = attribute_history(",
        "source": "99策略代码/79 DMI——大盘择时.txt"
    },
    {
        "text": "y  \n    # 获取股票的价格信息\n    price = attribute_history(security, context.OBSERVATION, '1d', ('high','low','close'))\n\n    ADX = talib.ADX(price['high'].values,price['low'].values,price['close'].values, context.ADXPERIOD)\n    PDI = talib.PLUS_DI(price['high'].values,price['low'].values,price['close'].values, context.ADXPERIOD)\n    NDI = talib.MINUS_DI(price['high'].values,price['low'].values,price['close'].values, context.ADXPERIOD)\n    \n    current_price = data[security].close\n    current_position = context.portf",
        "source": "99策略代码/79 DMI——大盘择时.txt"
    },
    {
        "text": "curity].close\n    current_position = context.portfolio.positions[security].closeable_amount\n    cash = context.portfolio.cash\n    \n    print(security) \n    if current_price !=0:\n        shares = cash/current_price\n    \n    record(ADX=ADX[-1])\n    record(Plus_DI=PDI[-1])\n    record(Minus_DI=NDI[-1])\n    \n    #ADX上行，+DI>-DI，当前空仓，则全仓买入标的\n    if ADX[-1]>ADX[-2] and PDI[-1]>NDI[-1] and current_position <= 0:\n        order_value(security,cash)\n        log.info(\"Buying %s\" % (security))#记录交易信息\n    #ADX下行，+DI<-DI，则",
        "source": "99策略代码/79 DMI——大盘择时.txt"
    },
    {
        "text": "ying %s\" % (security))#记录交易信息\n    #ADX下行，+DI<-DI，则进行清仓\n    if ADX[-1]<ADX[-2] and PDI[-1]<NDI[-1] and current_position > 0:\n        order_target(security, 0)\n        log.info(\"Selling %s\" % (security))\n    #百度上解释说ADX大于50会发生反转，但实际效果不佳。\n    # if ADX[-1]>50:\n    #     order_target(security, 0)\n    #     log.info(\"Selling %s\" % (security))\n    \n\n",
        "source": "99策略代码/79 DMI——大盘择时.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15757\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 期货日频多品种，MA双均线+百分比追踪止损\n# 建议给予1000000元，2012年1月1日至今回测\n# 导入函数库\nfrom jqdata import * \nimport talib\n\ndef initialize(context):\n    # 设置参数\n    set_parameter(context)\n    # 设定基准银华日利，在多品种的回测当中基准没有参考意义\n    set_benchmark('511880.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    ### 期货相关设定 ###\n    # 设定账户为金融账户\n    set_subpo",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": ")\n    ### 期货相关设定 ###\n    # 设定账户为金融账户\n    set_subportfolios([SubPortfolioConfig(cash=context.portfolio.starting_cash, type='futures')])\n    # 期货类每笔交易时的手续费是：买入时万分之0.5,卖出时万分之0.5,平今仓为万分之5\n    set_order_cost(OrderCost(open_commission=0.00005, close_commission=0.00005,close_today_commission=0.00005), type='index_futures')\n    # 设定保证金比例\n    set_option('futures_margin_rate', 0.15)\n    # 设置滑点（单边万5，双边千1）\n    set_slippage(PriceRelatedSlippage(0.001),type='future')\n    # 开盘前运行\n    run_daily( before_market_open, time='b",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "# 开盘前运行\n    run_daily( before_market_open, time='before_open', reference_security=get_future_code('RB'))\n    # 开盘时运行\n    run_weekly( market_open, 1,time='open', reference_security=get_future_code('RB'))\n    # 交易运行 \n    run_weekly(Trade, 1, time='open', reference_security=get_future_code('RB'))\n    # 收盘后运行\n    run_daily( after_market_close, time='after_close', reference_security=get_future_code('RB'))\n    \n    \n    \n\n   # 参数设置函数\ndef set_parameter(context):\n    \n    #######变量设置########\n    g.LastRealPrice = {",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "  \n    #######变量设置########\n    g.LastRealPrice = {} # 最新真实合约价格字典(用于吊灯止损）\n    g.HighPrice = {} # 各品种最高价字典（用于吊灯止损）\n    g.LowPrice = {} # 各品种最低价字典（用于吊灯止损）\n    g.future_list = []  # 设置期货品种列表\n    g.TradeLots = {}  # 各品种的交易手数信息\n    g.PriceArray = {} # 信号计算价格字典\n    g.Price_dict = {} # 各品种价格列表字典\n    g.Times = {} # 计数器（用于防止止损重入）\n    g.Reentry_long = False # 止损后重入标记\n    g.Reentry_short = False # 止损后重入标记\n    g.MappingReal = {} # 真实合约映射（key为symbol，value为主力合约）\n    g.MappingIndex = {} # 指数合约映射 （key为 symbol，value为指数合约\n   ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "ingIndex = {} # 指数合约映射 （key为 symbol，value为指数合约\n    g.StatusTimer = {} # 当前状态计数器\n    g.ATR = {}\n    g.CurrentPrice = {}\n    g.Price_DaysAgo = {}\n    g.Momentum = {}\n    g.Signal = {}\n    g.ClosePrice = {}\n\n    #######参数设置########\n    g.HoldingWeek = 1 # 持有窗口长度\n    g.Timer = 0\n    g.BackWindow = 10 # 回溯窗口长度\n    g.Cross = 0 # 均线交叉判定信号\n    g.MarginRate = 0.15 \n    # 交易的期货品种信息\n    g.instruments = ['AL','NI','CU','AG','RU','MA','PP','TA','L','V','M','A','P','Y','OI','C','CS','JD','SR','HC','J','I','SF','RB','ZC',",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "I','C','CS','JD','SR','HC','J','I','SF','RB','ZC','FG']\n    # 价格列表初始化\n    set_future_list(context)\n\n\ndef set_future_list(context):\n    for ins in g.instruments:\n        idx = get_future_code(ins)\n        dom = get_dominant_future(ins)\n        # 填充映射字典\n        g.MappingIndex[ins] = idx\n        g.MappingReal[ins] = dom\n        g.StatusTimer[ins] = 0\n        #设置主力合约已上市的品种基本参数\n        if dom == '':\n            pass\n        else:\n            if dom not in g.future_list:\n                g.future_list.append(dom)\n",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "e_list:\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n                \n\n'''\n换月模块逻辑（ins是期货品种的symbol（如‘RB’），dom或future指合约（如'RB1610.XSGE'）,idx指指数合约（如’RB8888.XSGE‘）\n    1.在第一天开始时，将所有期货品种最初的主力合约写入MappingReal与MappingIndex当中\n    2.每天开盘获取一遍ins对应的主力合约，判断是否在MappingReal中，若不在，则执行replace模块\n    3.replace模块中，卖出原来持有的主力合约，等量买入新合约；修改MappingReal\n'''\n## 开盘前运行函数\ndef before_market_open(context):\n    # 输出运行时间\n    log.info",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "re_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n    send_message('开始交易')\n    \n    # 过滤无主力合约的品种，传入并修改期货字典信息\n    for ins in g.instruments:\n        dom = get_dominant_future(ins)\n        if dom == '':\n            pass\n        else:\n            # 判断是否执行replace_old_futures\n            if dom == g.MappingReal[ins]:\n                pass\n            else:\n                replace_old_futures(context,ins,dom)\n                g.future_list.append(dom)\n  ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": ",dom)\n                g.future_list.append(dom)\n                g.HighPrice[dom] = False\n                g.LowPrice[dom] = False\n                g.Times[dom] = 0\n        \n            g.TradeLots[dom] = get_lots(context.portfolio.starting_cash/len(g.instruments),ins)\n            \n\n## 开盘时运行函数\ndef market_open(context):\n    # 输出函数运行时间\n    #log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    # 以下是主循环\n    for ins in g.instruments:\n        # 过滤空主力合约品种\n        if g.MappingReal[ins] != '':\n          ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "品种\n        if g.MappingReal[ins] != '':\n            IndexFuture = g.MappingIndex[ins]\n            RealFuture = g.MappingReal[ins]\n            # 获取当月合约交割日期\n            end_date = get_CCFX_end_date(RealFuture)\n            # 当月合约交割日当天不开仓\n            if (context.current_dt.date() == end_date):\n                return\n            else:\n                g.LastRealPrice[RealFuture] = attribute_history(RealFuture,1,'1d',['close'])['close'][-1]\n                # 获取价格list\n                #if g.StatusTimer[ins] == 0:\n  ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "st\n                #if g.StatusTimer[ins] == 0:\n                g.PriceArray[IndexFuture] = attribute_history(IndexFuture,g.BackWindow+5,'1d',['close','open','high','low'])\n                \n                # 如果没有数据，返回\n                if len(g.PriceArray[IndexFuture]) < 1:\n                    return\n                else: \n                    g.ClosePrice[ins] = g.PriceArray[IndexFuture]['close']\n                    g.CurrentPrice[ins] = g.ClosePrice[ins][-1]\n                    g.Price_DaysAgo[ins] = g.Close",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "                    g.Price_DaysAgo[ins] = g.ClosePrice[ins][-g.BackWindow]\n                    \n                    close = np.array(g.PriceArray[IndexFuture]['close'])\n                    high = np.array(g.PriceArray[IndexFuture]['high'])\n                    low = np.array(g.PriceArray[IndexFuture]['low'])\n                    g.ATR[IndexFuture] = talib.ATR(high,low,close, g.BackWindow)[-1]\n                    \n                \n                    # 计算动量标记\n                    if g.CurrentPrice[ins] > g.Pri",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "                    if g.CurrentPrice[ins] > g.Price_DaysAgo[ins] :\n                        g.Momentum[ins] = 1\n                    elif g.CurrentPrice[ins] < g.Price_DaysAgo[ins] :\n                        g.Momentum[ins] = -1\n                    else:\n                        g.Momentum[ins] = 0\n                        \n                    #判断交易信号：动量g.Momentum[ins] == 1多头，-1为空头\n                    if  g.Momentum[ins] == 1 :\n                        g.Signal[ins] = 1\n                    elif g.Momentum[ins] =",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "ns] = 1\n                    elif g.Momentum[ins] == -1 :\n                        g.Signal[ins] = -1\n                    else:\n                        g.Signal[ins] = 0\n                    \n                    \n           \n## 收盘后运行函数\ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    # 得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('###############",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "    log.info('一天结束')\n    log.info('##############################################################')\n    \n    \n## 交易模块 \ndef Trade(context):\n    \n    for ins in g.instruments:\n        RealFuture = g.MappingReal[ins]\n        if ins in g.Signal.keys() and RealFuture in g.LastRealPrice.keys():\n        \n            if g.Signal[ins] == 1 and context.portfolio.long_positions[RealFuture].total_amount == 0:\n                if context.portfolio.long_positions[RealFuture].total_amount != 0:\n                    log.info",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "e].total_amount != 0:\n                    log.info('空头有持仓：%s'%(RealFuture))\n                order_target(RealFuture,0,side='short')\n                order_target(RealFuture,g.TradeLots[RealFuture],side='long')\n                g.HighPrice[RealFuture] = g.LastRealPrice[RealFuture]\n                g.LowPrice[RealFuture] = False\n                log.info('正常买多合约：%s'%(RealFuture))\n        \n    \n            elif g.Signal[ins] == -1 and context.portfolio.short_positions[RealFuture].total_amount == 0:\n               ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "ons[RealFuture].total_amount == 0:\n                if context.portfolio.short_positions[RealFuture].total_amount != 0:\n                    log.info('多头有持仓：%s'%(RealFuture))\n                order_target(RealFuture,0,side ='long')\n                order_target(RealFuture,g.TradeLots[RealFuture],side='short')\n                g.LowPrice[RealFuture] = g.LastRealPrice[RealFuture]\n                g.HighPrice[RealFuture] = False\n                log.info('正常卖空合约：%s'%(RealFuture))\n\n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约    ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "RealFuture))\n\n\n# 移仓模块：当主力合约更换时，平当前持仓，更换为最新主力合约        \ndef replace_old_futures(context,ins,dom):\n    \n    LastFuture = g.MappingReal[ins]\n    \n    if LastFuture in context.portfolio.long_positions.keys():\n        lots_long = context.portfolio.long_positions[LastFuture].total_amount\n        order_target(LastFuture,0,side='long')\n        order_target(dom,lots_long,side='long')\n        print('主力合约更换，平多仓换新仓')\n    \n    if LastFuture in context.portfolio.short_positions.keys():\n        lots_short = context.portfo",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "itions.keys():\n        lots_short = context.portfolio.short_positions[dom].total_amount\n        order_target(LastFuture,0,side='short')\n        order_target(dom,lots_short,side='short')\n        print('主力合约更换，平空仓换新仓')\n\n    g.MappingReal[ins] = dom     \n            \n'''增加删除过去合约'''\n        \n        \n# 获取当天时间正在交易的期货主力合约函数\ndef get_future_code(symbol):\n    future_code_list = {'A':'A8888.XDCE', 'AG':'AG8888.XSGE', 'AL':'AL8888.XSGE', 'AU':'AU8888.XSGE',\n                        'B':'B8888.XDCE', 'BB':'BB8888.XDCE',",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "             'B':'B8888.XDCE', 'BB':'BB8888.XDCE', 'BU':'BU8888.XSGE', 'C':'C8888.XDCE', \n                        'CF':'CF8888.XZCE', 'CS':'CS8888.XDCE', 'CU':'CU8888.XSGE', 'ER':'ER8888.XZCE', \n                        'FB':'FB8888.XDCE', 'FG':'FG8888.XZCE', 'FU':'FU8888.XSGE', 'GN':'GN8888.XZCE', \n                        'HC':'HC8888.XSGE', 'I':'I8888.XDCE', 'IC':'IC8888.CCFX', 'IF':'IF8888.CCFX', \n                        'IH':'IH8888.CCFX', 'J':'J8888.XDCE', 'JD':'JD8888.XDCE', 'JM':'JM8888.XDCE', \n      ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "', 'JD':'JD8888.XDCE', 'JM':'JM8888.XDCE', \n                        'JR':'JR8888.XZCE', 'L':'L8888.XDCE', 'LR':'LR8888.XZCE', 'M':'M8888.XDCE', \n                        'MA':'MA8888.XZCE', 'ME':'ME8888.XZCE', 'NI':'NI8888.XSGE', 'OI':'OI8888.XZCE', \n                        'P':'P8888.XDCE', 'PB':'PB8888.XSGE', 'PM':'PM8888.XZCE', 'PP':'PP8888.XDCE', \n                        'RB':'RB8888.XSGE', 'RI':'RI8888.XZCE', 'RM':'RM8888.XZCE', 'RO':'RO8888.XZCE', \n                        'RS':'RS8888.XZCE', 'RU':'RU88",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "                    'RS':'RS8888.XZCE', 'RU':'RU8888.XSGE', 'SF':'SF8888.XZCE', 'SM':'SM8888.XZCE', \n                        'SN':'SN8888.XSGE', 'SR':'SR8888.XZCE', 'T':'T8888.CCFX', 'TA':'TA8888.XZCE', \n                        'TC':'TC8888.XZCE', 'TF':'TF8888.CCFX', 'V':'V8888.XDCE', 'WH':'WH8888.XZCE', \n                        'WR':'WR8888.XSGE', 'WS':'WS8888.XZCE', 'WT':'WT8888.XZCE', 'Y':'Y8888.XDCE', \n                        'ZC':'ZC8888.XZCE', 'ZN':'ZN8888.XSGE','AP':'AP8888.XZCE'}\n    try:\n        re",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "8888.XSGE','AP':'AP8888.XZCE'}\n    try:\n        return future_code_list[symbol]\n    except:\n        return 'WARNING: 无此合约'\n\n\n# 获取交易手数函数（ATR倒数头寸）\ndef get_lots(cash,symbol):\n    future_coef_list = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10, \n                        'CF':5, 'CS':10, 'CU':5, 'ER':10, \n                        'FB':500, 'FG':20, 'FU':50, 'GN':10, \n                        'HC':10, 'I':100, 'IC':200, 'IF':300, \n                        'IH':300, 'J",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "0, 'IF':300, \n                        'IH':300, 'J':100, 'JD':5, 'JM':60, \n                        'JR':20, 'L':5, 'LR':10, 'M':10, \n                        'MA':10, 'ME':10, 'NI':1, 'OI':10, \n                        'P':10, 'PB':5, 'PM':50, 'PP':5, \n                        'RB':10, 'RI':20, 'RM':10, 'RO':10, \n                        'RS':10, 'RU':10, 'SF':5, 'SM':5, \n                        'SN':1, 'SR':10, 'T':10000, 'TA':5, \n                        'TC':100, 'TF':10000, 'V':5, 'WH':20, \n                 ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "00, 'TF':10000, 'V':5, 'WH':20, \n                        'WR':10, 'WS':50, 'WT':10, 'Y':10, \n                        'ZC':100, 'ZN':5,'AP':10}\n    RealFuture = get_dominant_future(symbol)\n    IndexFuture = get_future_code(symbol)\n    # 获取价格list\n    Price_dict = attribute_history(IndexFuture,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0: \n        return\n    else:\n        open_future = Price_dict.iloc[-1]\n    # 返回手数\n    if IndexFuture in g.ATR.keys():\n        return cash*0.10/(g.ATR[IndexFutur",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "keys():\n        return cash*0.10/(g.ATR[IndexFuture]*future_coef_list[symbol])\n    else:# 函数运行之初会出现没将future写入ATR字典当中的情况\n        return cash*0.0001/future_coef_list[symbol]\n\n\n'''\n# 获取交易手数函数(无ATR版本）\ndef get_lots(cash,symbol):\n    # 获取合约规模(Contract Size)，也称交易单位\n    future_Contract_Size = {'A':10, 'AG':15, 'AL':5, 'AU':1000,\n                        'B':10, 'BB':500, 'BU':10, 'C':10, \n                        'CF':5, 'CS':10, 'CU':5, 'ER':10, \n                        'FB':500, 'FG':20, 'FU':50, 'GN':10, \n        ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "    'FB':500, 'FG':20, 'FU':50, 'GN':10, \n                        'HC':10, 'I':100, 'IC':200, 'IF':300, \n                        'IH':300, 'J':100, 'JD':5, 'JM':60, \n                        'JR':20, 'L':5, 'LR':10, 'M':10, \n                        'MA':10, 'ME':10, 'NI':1, 'OI':10, \n                        'P':10, 'PB':5, 'PM':50, 'PP':5, \n                        'RB':10, 'RI':20, 'RM':10, 'RO':10, \n                        'RS':10, 'RU':10, 'SF':5, 'SM':5, \n                        'SN':1, 'SR':10, 'T':10000",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "                        'SN':1, 'SR':10, 'T':10000, 'TA':5, \n                        'TC':100, 'TF':10000, 'V':5, 'WH':20, \n                        'WR':10, 'WS':50, 'WT':10, 'Y':10, \n                        'ZC':100, 'ZN':5,'AP':10}\n    future = get_dominant_future(symbol)\n    # 获取价格list\n    Price_dict = attribute_history(future,10,'1d',['open'])\n    # 如果没有数据，返回\n    if len(Price_dict) == 0: \n        return\n    else:\n        # 获得最新开盘价，计算能够下单多少手\n        open_price = Price_dict.iloc[-1]\n    # 返回手数（价格*合约规模=名义价",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "price = Price_dict.iloc[-1]\n    # 返回手数（价格*合约规模=名义价值）\n    # 此处没有使用杠杆，每次以starting_cash初始资金的10%去下单\n    return cash/(open_price*future_Contract_Size[symbol]*g.MarginRate)\n'''\n\n# 获取金融期货合约到期日\ndef get_CCFX_end_date(fature_code):\n    # 获取金融期货合约到期日\n    return get_security_info(fature_code).end_date\n    ",
        "source": "99策略代码/04 趋势交易能赚钱吗？商品期货动量效应挖掘初探.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11764\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/11736\n# 标题：招行_海天配对策略（学习招行伊利配对）\n# 作者：维络\n\n# 克隆自聚宽文章：https://www.joinquant.com/post/1810\n# 标题：【量化课堂】基于协整的搬砖策略\n# 作者：JoinQuant量化课堂\n\nimport numpy as np\nimport pandas as pd\n\n#===========================================\n\ndef initialize(context):\n    set_params()\n    set_variables()\n    set_backtest()\n\n# ---代码块1. 设置参数\ndef set_params():\n    # 股票1\n    g.security1 = '510220.",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": "set_params():\n    # 股票1\n    g.security1 = '510220.XSHG' \n    # 股票2\n    g.security2 = '510500.XSHG'\n    # 基准\n    g.benchmark = '510500.XSHG'\n    # 回归系数\n    g.regression_ratio = 1#0.9574#0.9938\n    # 股票1默认仓位\n    g.p = 0.5\n    # 股票2默认仓位\n    g.q = 0.5\n    # 算z-score天数\n    g.test_days = 120\n\n# ---代码块2. 设置变量\ndef set_variables():\n    # 现在状态\n    g.state = 'empty'\n\n# ---代码块3. 设置回测\ndef set_backtest():\n    # 设置基准\n    set_benchmark(g.benchmark)\n    # 只报错\n    log.set_level('order', 'error')\n    # 真实价格\n    set_option('us",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": "el('order', 'error')\n    # 真实价格\n    set_option('use_real_price', True) \n    # 无滑点\n    set_slippage(FixedSlippage(0.))\n\n#==============================================\n    \n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    new_state = get_signal()\n    change_positions(get_signal(),context)\n\n# ---代码块4.计算z-score\ndef z_test():\n    # 获取两支股票历史价格\n    prices1 = np.array(attribute_history(g.security1, g.test_days, '1d', 'close'))\n    prices2 = np.array(attribute_history(g.security2, g.t",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": "ces2 = np.array(attribute_history(g.security2, g.test_days, '1d', 'close'))\n    # 根据回归比例算它们的平稳序列 Y-a.X\n    stable_series = prices2 - g.regression_ratio*prices1\n    # 算均值\n    series_mean = mean(stable_series)\n    # 算标准差\n    sigma = np.std(stable_series)\n    # 算序列现值离均值差距多少\n    diff = stable_series[-1] - series_mean\n    # 返回z值\n    return(diff/sigma)#理论上上 这个值服从标准正太分布\n\n# ---代码块5.获取信号\n# 返回新的状态，是一个string\ndef get_signal():\n    z_score = z_test()\n    if z_score > 2.1:#海天/招行0.82\n        # 状态为全仓第一支\n        return('buy",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": ":#海天/招行0.82\n        # 状态为全仓第一支\n        return('buy1')\n    # 如果小于负标准差\n    if z_score < -2.1:\n        # 状态为全仓第二支\n        return('buy2')\n    # 如果在正负标准差之间\n    if -1.95<= z_score <= 1.95:\n        return('mid')\n            \n# ---代码块6.根据信号调换仓位\n# 输入是目标状态，输入为一个string\ndef change_positions(current_state,context):\n    # 总值产价值\n    total_value = context.portfolio.portfolio_value\n    # 如果新状态是全仓股票1\n    if  current_state== 'buy1':\n        # 全卖股票2\n        #order_target(g.security2, 0)\n        marginsec_open(g.security2, 1000",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": "rity2, 0)\n        marginsec_open(g.security2, 100000, style=None, pindex=0)\n        # 全买股票1\n        order_value(g.security1, total_value)\n        # 旧状态更改\n        g.state = 'buy1'\n    # 如果新状态是全仓股票2\n    if  current_state == 'buy2':\n        # 全卖股票1\n        #order_target(g.security1, 0)\n        marginsec_open(g.security1, total_value, style=None, pindex=0)\n        # 全买股票2\n        order_value(g.security2, total_value)\n        # 旧状态更改\n        g.state = 'buy2'\n    # 如果处于全仓一股票状态，但是z-score交叉0点\n    if (current_state=",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": "# 如果处于全仓一股票状态，但是z-score交叉0点\n    if (current_state== 'mid'):\n        if(g.state=='buy1'):\n            marginsec_close(g.security2, 100000, style=None, pindex=0)\n            order_target_value(g.security1, 0)\n        if(g.state=='buy2'):\n            marginsec_close(g.security1, 100000, style=None, pindex=0)\n            order_target_value(g.security2, 0)\n        g.state = 'even'\n\n\n#止损策略",
        "source": "99策略代码/55 中小板-中证500配对交易.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14460\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\n\n# 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 定义一个全局变量, 保存要操作的股票\n    # 000001(股票:平安银行)\n    g.security = '000333.XSHE'\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n\n# 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次\ndef handle_data(context, data):\n    security = g.security\n    # 获取股票的收盘价\n    close_data1 = attribute_h",
        "source": "99策略代码/66 高于MA10买入低于MA20卖出回测半年收益率20.4%.txt"
    },
    {
        "text": "urity\n    # 获取股票的收盘价\n    close_data1 = attribute_history(security, 20, '1d', ['close'])\n    close_data2 = attribute_history(security, 10, '1d', ['close'])\n    # 取得过去五天的平均价格\n    MA10 = close_data2['close'].mean()\n    MA5 = close_data1['close'].mean()\n    # 取得上一时间点价格\n    current_price = close_data1['close'][-1]\n    # 取得当前的现金\n    cash = context.portfolio.cash\n\n    # 如果上一时间点价格高出五天平均价1%, 则全仓买入\n    if current_price > 1.01*MA10:\n        # 用所有 cash 买入股票\n        order_value(security, cash)\n        # 记录这次买入\n        l",
        "source": "99策略代码/66 高于MA10买入低于MA20卖出回测半年收益率20.4%.txt"
    },
    {
        "text": "r_value(security, cash)\n        # 记录这次买入\n        log.info(\"Buying %s\" % (security))\n    # 如果上一时间点价格低于五天平均价, 则空仓卖出\n    elif current_price < MA5 and context.portfolio.positions[security].closeable_amount > 0:\n        # 卖出所有股票,使这只股票的最终持有量为0\n        order_target(security, 0)\n        # 记录这次卖出\n        log.info(\"Selling %s\" % (security))\n    # 画出上一时间点价格\n    record(stock_price=current_price)\n",
        "source": "99策略代码/66 高于MA10买入低于MA20卖出回测半年收益率20.4%.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15100\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\ndef initialize(context):\n    \"\"\"初始化函数\"\"\"\n    \n    # 持有最小市值股票数\n    g.stocksnum = 10\n    # 轮动频率\n    g.period = 10\n    # 记录策略进行到第几天\n    g.days = 0 \n    # 周期循环daily\n    run_daily(daily,time='every_bar')\n    \n\ndef daily(context):\n    \"\"\"交易函数\"\"\"\n    \n    # 每运行一天加一\n    g.days += 1\n    # 判断策略进行天数是否能被轮动频率整除余1\n    if g.days % g.period != 1:\n        return\n\n    # 获取当前时间\n    date=context.current_dt.strftime(\"%Y-%m-",
        "source": "99策略代码/25 简单市值轮动策略-学习.txt"
    },
    {
        "text": "取当前时间\n    date=context.current_dt.strftime(\"%Y-%m-%d\")\n    # 获取上证指数和深证综指的成分股代码并连接，即为全A股市场所有股票\n    # 这里股票池不放在全局中是因为总有新发型股票出现，所以要动态获取股票池\n    scu = get_index_stocks('000001.XSHG') + get_index_stocks('399106.XSHE')\n\n    # 选出在scu内的股票的股票代码，并按照当前时间市值从小到大排序\n    df = get_fundamentals(query(\n            valuation.code,\n            valuation.market_cap\n        ).filter(\n            valuation.code.in_(scu)\n        ).order_by(\n            valuation.market_cap.asc()\n        ), date=date\n        )\n\n    # 取出前g.stocksnum名的股",
        "source": "99策略代码/25 简单市值轮动策略-学习.txt"
    },
    {
        "text": "   ), date=date\n        )\n\n    # 取出前g.stocksnum名的股票代码，并转成list类型，buylist为选中的股票\n    buylist =list(df['code'][:g.stocksnum])\n\n    # 对于每个当下持有的股票进行判断：现在是否已经不在buylist里，如果是则卖出\n    for stock in context.portfolio.positions:\n        if stock not in buylist: #如果stock不在buylist\n            order_target(stock, 0) #调整stock的持仓为0，即卖出\n\n    # 已经持仓的不会再被买入\n    buy_list = list(set(buylist) - set(context.portfolio.positions.keys()))\n    # 当日停牌的股票不交易\n    current_data = get_current_data()\n    buy_list = [stock for stock in buylist ",
        "source": "99策略代码/25 简单市值轮动策略-学习.txt"
    },
    {
        "text": "data()\n    buy_list = [stock for stock in buylist if not current_data[stock].paused]\n    # 如果没有需要买进的股票，就返回\n    if len(buy_list) <= 0:\n        return\n    # 将资金分成g.stocksnum份\n    position_per_stk = context.portfolio.cash/len(buy_list)\n    # 用position_per_stk大小的g.stocksnum份资金去买buylist中的股票\n    for stock in buy_list:\n        order_value(stock, position_per_stk)\n    ",
        "source": "99策略代码/25 简单市值轮动策略-学习.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11102\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n#发布自聚宽\n\nimport talib\nimport pandas as pd\nimport numpy as np\nimport math\nfrom sklearn.model_selection import learning_curve\n\nimport talib\n#import numpy as np\n#import pandas as pd\n\ndef initialize(context):\n    # # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    # set_order_cost(OrderCost(close_tax=0.000, open_commission=0.0000, close_commission=0.0000, min_commission=0), type='stock')\n    # # ",
        "source": "99策略代码/76 MACD——大盘择时.txt"
    },
    {
        "text": "=0.0000, min_commission=0), type='stock')\n    # # 设定滑点为固定值\n    # set_slippage(FixedSlippage(0.00))\n    # 定义一个全局变量, 保存要操作的证券                                                                                           \n    context.stocks = ['399300.XSHE']\n    # 设置我们要操作的股票池\n    set_universe(context.stocks)\n\n# 初始化此策略\ndef handle_data(context, data):\n    # 取得当前的现金\n    cash = context.portfolio.cash\n    # 循环股票列表\n    for stock in context.stocks:\n        # 获取股票的数据\n        h = attribute_history(stock, 60, '1d', ('high',",
        "source": "99策略代码/76 MACD——大盘择时.txt"
    },
    {
        "text": "   h = attribute_history(stock, 60, '1d', ('high','low','close'))\n        # 创建STOCH买卖信号，包括最高价，最低价，收盘价和快速线（一般取为9），慢速线\n        # 注意：STOCH函数使用的price必须是narray\n        macd, macdsignal, macdhist = talib.MACD(h['close'].values, fastperiod=9, slowperiod=24, signalperiod=9)\n        # 获得最近的kd值\n        print(macdsignal)\n        # 获取当前股票的数据\n        current_position = context.portfolio.positions[stock].amount\n        # 获取当前股票价格\n        current_price = data[stock].price\n        # 当slowk > 90 or slowd > 90，且拥有的股票数量>=0时，卖",
        "source": "99策略代码/76 MACD——大盘择时.txt"
    },
    {
        "text": "        # 当slowk > 90 or slowd > 90，且拥有的股票数量>=0时，卖出所有股票\n        if macd[-1] < 0 and current_position >= 0:\n            order_target(stock, 0)\n        # 当slowk < 10 or slowd < 10, 且拥有的股票数量<=0时，则全仓买入\n        elif macd[-1] > 0 and current_position <= 0:\n            # 买入股票\n            order_value(stock, cash)\n            # 记录这次买入\n            log.info(\"Buying %s\" % (stock))",
        "source": "99策略代码/76 MACD——大盘择时.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13975\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.s",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": ".security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801030\",\"801040\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "nding = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "y_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "[s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = i",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "r_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n  ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "    g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "tements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 5)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 8)\n    security_list = financial_data_filter_dayu(security_list, indicator.net_profit_margin, 4)\n    security_list = financial_data_filter_dayu(security_list, valuation.circulating_market_cap, 2)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return s",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    security_list = [security for security in security_list if situation_filter_dayu(security, 'high', 12)]\n    security_list = [security for security in security_list if ipo_days_dayu(context, security, 1)]\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ##",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "t, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n   ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "\n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "))\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n    ",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[securit",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "y_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "urity_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_dat",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "st):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "   if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_un",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_lis",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/84 投资策略说明.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14646\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 300\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 3\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "eck_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_da",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "aily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_u",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_market_cap_percent'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_ri",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "t_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s f",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_se",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "curity_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lis",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = deli",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "y_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_stateme",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "###############\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_qujian(security_list, valuation.pe_ratio, (4,5.5))\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "curity_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        valuation.pe_ratio:",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "():\n    input_dict = {\n        valuation.pe_ratio:('asc',0.1),\n        indicator.roe:('desc',0.1),\n        valuation.market_cap:('asc',0.1),\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [securit",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": " 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "x_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n               ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "x_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "       if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_lis",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "ed_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return s",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_sec",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "ecurity_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n   ",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "ecurity_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_se",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/64 12年年化34%，Sharpe1.2，银行股轮动.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13760\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000905.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 20\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 100\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_t",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000905.XSHG\"]\n    ",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "  g.security_universe_index = [\"000905.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lis",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "):\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_market_cap_percent'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_s",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "         order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.secu",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "niverse(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_l",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(co",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "ict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n   ",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "ed_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n   ",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "  if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\n",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    security_list = [security for security in security_list if MACD_judge_jincha(se",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": " security in security_list if MACD_judge_jincha(security, 12, 26, 26)]\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "rity not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "ment_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(cont",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "   for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n########",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": ", amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "curity_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.s",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "ecurity in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in ",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_de",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n    ",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "ock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_un",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "eturn security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_f",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "rted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/08 MACD单因子多头策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/11251\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport numpy as np\nimport pandas as pd\nimport bisect\n# 初始化函数，设定基准等等\ndef initialize(context):\n    #基准指数\n    g.benchmark_index = '000300.XSHG'\n    # 要操作的股票：（g.为全局变量）\n    g.buy_index = '160706.XSHE'\n    set_benchmark(g.benchmark_index)\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 过滤掉order系列API产生的比error级别低的log\n    log.set_level('order', 'error')\n    set_commission(",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "og.set_level('order', 'error')\n    set_commission(PerTrade(buy_cost=0.0015, sell_cost=0.005))\n\n    # 按月运行\n    run_monthly(fnud_main, 1, time='open')\n    run_monthly(fnud_close, 1, time='after_close')\n    run_daily(fund_sell, time='every_bar')\n    g.Totalmonth = 0\n    g.TotalCash = 0\n    g.MaxCash = 0\n    g.LastCash = 1000   #每月定投额度\n    g.pe_now=0\n    # 输出内容到日志 log.info()\n    log.info(\"定投指数：%s，定投基金：%s,每月定投额度：%s\" %(get_security_info(g.benchmark_index).display_name , get_security_info(g.buy_index).display_name",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "name , get_security_info(g.buy_index).display_name,g.LastCash))\n    log.info(\"------------------------------------------------------\")\n    send_message(\"定投指数：%s，定投基金：%s,每月定投额度：%s\" %(get_security_info(g.benchmark_index).display_name , get_security_info(g.buy_index).display_name,g.LastCash))\n    \ndef fnud_main(context):\n    g.Totalmonth += 1\n    df = get_index_pes(context)\n    g.pe_now = float(df.ix[0,2]) / 100 #当前PE百分比 log.info(df)\n    if g.pe_now <0.4:\n        g.pe_ratio = 1.5;\n    elif g.pe_now < 0.6:\n    ",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "   g.pe_ratio = 1.5;\n    elif g.pe_now < 0.6:\n        g.pe_ratio = 1.0;\n    elif g.pe_now < 0.8:\n        g.pe_ratio = 0.5;\n    else:\n        g.pe_ratio = -999;\n    cash = g.pe_ratio * g.LastCash\n    g.LastCash = g.LastCash * 1.01\n    order_value(g.buy_index, cash)    #定投5000\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message(\"Month %d ，沪深300当前PE百分比: %.2f ，(%s)买卖金额：%.2f\" %(g.Totalmonth,g.pe_now,g.buy_index, cash))\n    log.info(\"Month %d   当前PE百分比: %.2f  \" %(g.Totalmonth,g.pe_now))\n    \ndef fund_sell(context):\n  ",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "almonth,g.pe_now))\n    \ndef fund_sell(context):\n    if (g.pe_now > 0.75 ) & (context.portfolio.positions_value >0):\n        df = get_index_pes(context)\n        g.pe_now = float(df.ix[0,2]) / 100 #当前PE百分比 log.info(df)\n        if g.pe_now >= 0.8:\n            order_target_value(g.buy_index, 0)  #全部卖出\n            log.info(\"全部清仓\")\n            send_message(\"全部清仓\")\n    \ndef fnud_close(context):\n    #得到当天所有订单\n    orders = get_orders()\n    cash = 0.0\n    for _order in orders.values():\n        cash = float(_order.pri",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "n orders.values():\n        cash = float(_order.price) * float(_order.filled)\n        if _order.is_buy == False:\n            cash = cash * -1.0;\n        g.TotalCash += cash\n        if g.MaxCash < g.TotalCash:\n            g.MaxCash = g.TotalCash\n        if g.TotalCash <= 0:\n            g.TotalCash = 0\n    # 获取账户的持仓价值\n    positions_value = context.portfolio.positions_value\n    available_cash = context.portfolio.available_cash\n    returns = context.portfolio.returns * 100\n    log.info(\"总投入: %d，最大投入: %d，今日买卖: %s",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "urns * 100\n    log.info(\"总投入: %d，最大投入: %d，今日买卖: %s\" %(g.TotalCash , g.MaxCash,cash))\n    log.info(\"当前持仓: %.2f，账户余额：%.2f，总权益的累计收益率：%.2f\" %(positions_value , available_cash , returns))\n    log.info(\"------------------------------------------------------\")\n\ndef on_strategy_end(context):\n    log.info(\"回测结束：总投入: %d，最大投入: %d\" %(g.TotalCash , g.MaxCash))\n    # 获取账户的持仓价值\n    positions_value = context.portfolio.positions_value\n    available_cash = context.portfolio.available_cash\n    returns = context.portfolio.retu",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "vailable_cash\n    returns = context.portfolio.returns * 100\n    log.info(\"当前持仓: %.2f，账户余额：%.2f，总权益的累计收益率：%.2f\" %(positions_value , available_cash , returns))\n\n################################### 自定义函数 ###############################\n#指定日期的指数PE（等权重）\ndef get_index_pe_date(index_code,date):\n    stocks = get_index_stocks(index_code, date)\n    q = query(valuation).filter(valuation.code.in_(stocks))\n    df = get_fundamentals(q, date)\n    if len(df)>0:\n        pe = len(df)/sum([1/p if p>0 else 0 for p in df.pe_rat",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": " len(df)/sum([1/p if p>0 else 0 for p in df.pe_ratio])\n        return pe\n    else:\n        return float('NaN')\n    \n#指数历史PE\ndef get_index_pe(index_code,today):\n    start= get_security_info(index_code).start_date \n    #end = pd.datetime.today();\n    end = today;\n    dates=[]\n    pes=[]\n    for d in pd.date_range(start,end,freq='M'): #频率为月\n    #for d in jqdata.get_trade_days(start_date=start, end_date=end): #频率为天，交易日\n        dates.append(d)\n        pes.append(get_index_pe_date(index_code,d))\n    return pd.Ser",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "get_index_pe_date(index_code,d))\n    return pd.Series(pes, index=dates)\n#获取指数PE\ndef get_index_pes(context):\n    today = context.current_dt\n    all_index = get_all_securities(['index'])\n    index_choose =[g.benchmark_index]\n    df_pe = pd.DataFrame()\n    for code in index_choose:\n        #print(u'正在处理: ',code) \n        df_pe[code]=get_index_pe(code,today)\n\n    #today= pd.datetime.today()\n    results=[]\n    for code in index_choose:\n        pe = get_index_pe_date(code,today)\n        q_pes = [df_pe.quantile(i/",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "ate(code,today)\n        q_pes = [df_pe.quantile(i/10.0)[code]  for i in range(11)]\n        idx = bisect.bisect(q_pes,pe)\n        quantile = idx-(q_pes[idx]-pe)/(q_pes[idx]-q_pes[idx-1])\n        index_name = all_index.ix[code].display_name\n        results.append([index_name,'%.2f'% pe,'%.2f'% (quantile*10)]+['%.2f'%q  for q in q_pes]+[df_pe[code].count()])\n    columns=[u'名称',u'当前PE',u'分位点%',u'最小PE']+['%d%%'% (i*10) for i in range(1,10)]+[u'最大PE' , u\"数据个数\"]\n    return pd.DataFrame(data=results,index=index_cho",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "  return pd.DataFrame(data=results,index=index_choose,columns=columns)\n\n\n\n",
        "source": "99策略代码/72 基金定投-沪深300-5年回测.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13156\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport talib \n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 输出内容到日志 log.info()\n    log.info('初始函数开始运行且全局只运行一次')\n    # 过滤掉order系列API产生的比error级别低的log\n    # log.set_level('order', 'error')\n    \n    ### 股票相关设定 ###\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n",
        "source": "99策略代码/45 布林带策略.txt"
    },
    {
        "text": "易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    \n    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）\n      # 开盘前运行\n    run_daily(before_market_open, time='before_open', reference_security='000300.XSHG') \n      # 开盘时运行\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n      # 收盘后运行\n    run_daily(after_market_close, ",
        "source": "99策略代码/45 布林带策略.txt"
    },
    {
        "text": ")\n      # 收盘后运行\n    run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')\n    \n## 开盘前运行函数     \ndef before_market_open(context):\n    # 输出运行时间\n    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))\n\n    # 给微信发送消息（添加模拟交易，并绑定微信生效）\n    send_message('美好的一天~')\n\n    # 要操作的股票：平安银行（g.为全局变量）\n    g.security = '600519.XSHG'\n    \n## 开盘时运行函数\ndef market_open(context):\n    log.info('函数运行时间(market_open):'+str(context.current_dt.time()))\n    security = g.security\n    # 获取股票的收盘",
        "source": "99策略代码/45 布林带策略.txt"
    },
    {
        "text": "t.time()))\n    security = g.security\n    # 获取股票的收盘价\n    h= attribute_history(security, 25, '1d', ['high','low','close'])\n    \n    #获取可以资金\n    cash=context.portfolio.available_cash\n    \n    #计算布林带上轨，中轨，下轨\n    upper,middle,lower=talib.BBANDS(\n        h['close'].values,\n        timeperiod=20,\n        nbdevup=2,\n        nbdevdn=2,\n        matype=0)\n    #获取当前仓位信息   \n    current_position=context.portfolio.positions[security].amount\n    \n    #获取当前股价\n    current_price=h['close'][-1]\n    \n    if current_price>upper[",
        "source": "99策略代码/45 布林带策略.txt"
    },
    {
        "text": "ce=h['close'][-1]\n    \n    if current_price>upper[-1] and current_position>=0:\n        order_target_value(security,cash)\n        \n    elif current_price<lower[-1] and current_position <=0:\n        order_value(security,0)\n        \n    record(upper=upper[-1],\n    lower=lower[-1],\n    mean=middle[-1],\n    price=current_price,\n    position_size=current_position)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n## 收盘后运行函数  \ndef after_market_close(context):\n    log.info(str('函数运行时间(after_market_close):",
        "source": "99策略代码/45 布林带策略.txt"
    },
    {
        "text": "xt):\n    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))\n    #得到当天所有成交记录\n    trades = get_trades()\n    for _trade in trades.values():\n        log.info('成交记录：'+str(_trade))\n    log.info('一天结束')\n    log.info('##############################################################')\n",
        "source": "99策略代码/45 布林带策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/14694\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.00015, close_commission=0.00015, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "eck_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_da",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "aily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_u",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "_index = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801010\",\"801020\",\"801030\",\"801040\",\"801050\",\"801080\",\"801110\",\"801120\",\"801130\",\"801140\",\"801150\",\"801160\",\"801170\",\"801180\",\"801200\",\"801210\",\"801230\",\"801710\",\"801720\",\"801730\",\"801740\",\"801750\",\"801760\",\"801770\",\"801780\",\"801790\",\"801880\",\"801890\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = True\n\n    # 委托类型\n    g.order_style_str = 'by_market_cap_percent'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "alue(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    security_stoploss(context,0.1,g.open_sell_securities)\n    security_stopprofit(context,0.3,g.open_sell_securities)\n    portfolio_max_stoploss(context,0.2,g.open_sell_securities)\n    index_stoploss_sicha(context,60,g.open_sell_securities, '000300.XSHG')\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(co",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "ntext, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_rec",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "   # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in buy_lists if situation_filt",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "curity for security in buy_lists if situation_filter_xiaoyu_ma(security, 'close', 99)]\n        buy_lists = [security for security in buy_lists if situation_filter_xiaoyu_ma(security, 'volume', 60)]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "uy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef fina",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "############################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_revenue_year_on_year, 15)\n    security_list = financial_data_filter_qujian(security_list, valuation.pb_ratio, (0,2))\n    security_list = financial_data_filter_xiaoyu(security_list, valuation.pe_ratio, 40)\n    security_list = financial_data_filter_dayu(security_list, indicator.inc_net_profit_year_on_year, 10)\n  ",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "ist, indicator.inc_net_profit_year_on_year, 10)\n    security_list = financial_data_filter_dayu(security_list, indicator.roa, 4)\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 #################",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "#########################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if n_day_chg_dayu(security, 20, 0.1)]\n    sell_lists = [s",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "y_chg_dayu(security, 20, 0.1)]\n    sell_lists = [security for security in sell_lists if situation_filter_dayu_ma(security, 'volume', 20)]\n    sell_lists = [security for security in sell_lists if MA_VOLUME_judge_sicha(security, 5, 10)]\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_secur",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "     # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "             a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "urity_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "ortfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        s",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "       current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            secur",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "urrent_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "ntext, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(in",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "text, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        ret",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/44 新手初来，写了一个价值投资策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/10730\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nimport pandas as pd\nfrom jqdata import gta\n\ndef initialize(context):\n    set_params(context) \n    set_variables()  \n    set_backtest() \n\ndef set_params(context):\n    g.tc = 3 \n    g.buy = 5\n    g.hold = 10 \n    # 因子等权重里1表示因子值越小越好，-1表示因子值越大越好\n    g.factors_weights = [-1]\n    g.factors_rank = ['dividend_rate']\n    g.industries = ['801010','801020','801030','801040','801050','801080',\n                    '",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": ",'801040','801050','801080',\n                    '801110','801120','801130','801140','801150','801160',\n                    '801170','801180','801200','801210','801230','801710',\n                    '801720','801730','801740','801750','801760','801770',\n                    '801780','801790','801880','801890']\n    # g.industries = ['A01','A02','A03','A04','A05','B06','B07','B08','B09','B11','C13','C14','C15','C17','C18',\\\n                    #  'C19','C20','C21','C22','C23','C24','C25','C26','C27','C28','C29",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "21','C22','C23','C24','C25','C26','C27','C28','C29','C30','C31','C32','C33','C34','C35',\\\n                    #  'C36','C37','C38','C39','C40','C41','C42','D44','D45','D46','E47','E48','E50','F51','F52','G53','G54','G55',\\\n                    # 'G56','G58','G59','H61','H62','I63','I64','I65','J66','J67','J68','J69','K70','L71','L72','M73','M74','N77',\\\n                    # 'N78','P82','Q83','R85','R86','R87','S90']\n    g.factors_PTC = [[valuation.market_cap, 'market_cap', 0.8, False]]\n    g.factors_industr",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": ", 'market_cap', 0.8, False]]\n    g.factors_industries_PTC = [[cash_flow.cash_equivalent_increase/valuation.market_cap, 'NCFP', 0.4, False], [valuation.pe_ratio, 'pe', 0.10, True]]\n    g.args_div = [context.current_dt.date()-datetime.timedelta(1), context.current_dt.year-1]\n    \n\ndef set_variables():\n    g.t = 0  \n    g.if_trade = False  \n    g.buy_count = 0\n\ndef set_backtest():\n    set_option('use_real_price', True) \n    log.set_level('order', 'error')\n\ndef before_trading_start(context):\n    if g.t % g.tc =",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "before_trading_start(context):\n    if g.t % g.tc == 0:\n        g.if_trade = True\n        set_slip_fee(context)\n        g.all_stocks = feasible_stocks(context, list(get_all_securities().index))\n    g.t += 1\n\n# 过滤涨跌停板、停牌、次新股、ＳＴ等情况\ndef feasible_stocks(context, stock_list):\n    current_data = get_current_data()\n    stock_list = [stock for stock in stock_list if\n                    stock in context.portfolio.positions.keys()\n                    or (not current_data[stock].paused\n                    and sum(attri",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "ta[stock].paused\n                    and sum(attribute_history('000300.XSHG', 14, unit='1d',\n                    fields=('paused'),skip_paused=False))[0]==0)]\n                    \n    stock_list = [stock for stock in stock_list\n                  if not current_data[stock].is_st\n                  and 'ST' not in current_data[stock].name\n                  and '*' not in current_data[stock].name\n                  and '退' not in current_data[stock].name]\n   \n    stock_list = [stock for stock in stock_list if\n  ",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": " stock_list = [stock for stock in stock_list if\n                  stock in context.portfolio.positions.keys()\n                  or current_data[stock].low_limit<current_data[stock].day_open \n                     < current_data[stock].high_limit]\n                     \n    stock_list = [stock for stock in stock_list if \n                  (context.current_dt.date() - get_security_info(stock).start_date) \n                  >= datetime.timedelta(360)]\n                  \n    # stock_list = [stock for stock in sto",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "       \n    # stock_list = [stock for stock in stock_list if stock[0:3] != '300']\n\n    return stock_list\n\ndef set_slip_fee(context):\n    set_slippage(FixedSlippage(0))\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \n                    open_commission=0.001, close_commission=0.002, \n                    close_today_commission=0, min_commission=5), type='stock')\n\ndef handle_data(context, data):\n    if g.if_trade == True :\n        log.info('交易前时间：',context.current_dt)\n        buylist, holdlist = mul",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "ontext.current_dt)\n        buylist, holdlist = multifactor_stocks_select(context)\n        stock_sell_and_buy(context, buylist, holdlist)\n        trade_summery(context)\n    g.if_trade = False\n\n# 买入和卖出\ndef stock_sell_and_buy(context, buylist, holdlist):\n    for stock in context.portfolio.positions:\n        if stock not in holdlist:\n            order_target_value(stock, 0)\n\n    stocks_num = len(buylist) - len(context.portfolio.positions)\n\n    if stocks_num <= 0:\n        return\n    else:\n        position_per_st",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": ":\n        return\n    else:\n        position_per_stk = context.portfolio.cash / stocks_num\n        for stock in buylist:\n            if stock not in context.portfolio.positions:\n                order_target_value(stock, position_per_stk)\n                g.buy_count += 1\n\n# 多因子选股的流程，最后输出可买入的股票池和可继续持仓的股票池\ndef multifactor_stocks_select(context):\n    df = factors_selected(context)\n    df = factors_percent(g.factors_PTC, df)\n    df = factors_industries_percent(g.factors_industries_PTC, df)\n    df = concat_data(co",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "actors_industries_PTC, df)\n    df = concat_data(context, df, dividend_rate, g.args_div)\n    factors_rank, stocks_code = factors_ranked(df, g.factors_rank)\n    points = np.dot(factors_rank, g.factors_weights)\n    stocks_sort = points_sorted(points, stocks_code)\n    buylist = stocks_sort[0:g.buy]\n    holdlist = stocks_sort[0:g.hold]\n    return buylist, holdlist\n\n# 因子选择、阀值过滤\ndef factors_selected(context):\n    factors = query(valuation.code, valuation.pe_ratio)\n    factors = factors.filter(valuation.code.in_(g.",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "    factors = factors.filter(valuation.code.in_(g.all_stocks),  \n            indicator.inc_net_profit_annual>0, \n            indicator.inc_net_profit_year_on_year>5, cash_flow.cash_equivalent_increase>0)\n    df = get_fundamentals(factors, context.current_dt.date())\n    df.index = df.code.values\n    del df['code']\n    df = df.dropna(axis=0)\n    return df\n\n# 因子按全市场的百分比过滤\ndef factors_percent(factors, df=None):\n    def s_percent(factor, factor_name, percentage, ascending):\n        q = query(valuation.code, fact",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "ascending):\n        q = query(valuation.code, factor).order_by(factor.asc() if ascending==True else factor.desc())\n        df_s = get_fundamentals(q)\n        df_s = df_s[0:int(len(df_s)*percentage)]\n        df_s.index = df_s.code.values\n        del df_s['code']\n        df_s.columns = [factor_name]\n        return df_s\n    \n    df_m = None\n    for i in factors:\n        df_s = s_percent(i[0], i[1], i[2], i[3])\n        df_m = pd.concat([df_m, df_s], axis=1)\n    df_m = df_m.dropna(axis=0)\n    if df is not None:\n",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "df_m = df_m.dropna(axis=0)\n    if df is not None:\n        index_intersect = set(df.index.values)&set(df_m.index.values)\n        df_m = df.loc[index_intersect,:]\n    df_m = df_m.dropna(axis=0)\n    return df_m\n\n# 因子按行业的百分比过滤\ndef factors_industries_percent(factors, df=None):\n    def s_neutral(factor, factor_name, percentage, ascending):\n        df_all = None\n        for aa in g.industries:\n            industries_stock_list = list(get_industry_stocks(aa))\n            q = query(valuation.code, factor).filter(val",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "      q = query(valuation.code, factor).filter(valuation.code.in_(industries_stock_list),factor>0).order_by(factor.asc() if ascending==True else factor.desc())\n            df = get_fundamentals(q)\n            df = df[0:int(len(df)*percentage)]\n            df.index = df.code.values\n            del df['code']\n            df.columns = [factor_name]\n            df_all = pd.concat([df_all, df])\n        return df_all\n    \n    df_m = None\n    for i in factors:\n        df_s = s_neutral(i[0], i[1], i[2], i[3])\n     ",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "    df_s = s_neutral(i[0], i[1], i[2], i[3])\n        df_m = pd.concat([df_m, df_s], axis=1)\n    df_m = df_m.dropna(axis=0)\n    if df is not None:\n        index_intersect = set(df.index.values)&set(df_m.index.values)\n        df_m = df.loc[index_intersect,:]\n    df_m = df_m.dropna(axis=0)\n    return df_m\n\n# 不同表的数据整合到一个DataFrame里，func是从另外一张表获取数据的函数，args是func需要的参数，考虑参数的多变性，设置了几种情况\ndef concat_data(context, df, func, args):\n    stock_codes = df.index\n    df_div_all = None\n    for code in stock_codes:\n        if l",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "l = None\n    for code in stock_codes:\n        if len(args) == 0:\n            df_div = func(code)\n        elif len(args) == 1:\n            df_div = func(code, args[0])\n        elif len(args) == 2:\n            df_div = func(code, args[0], args[1])\n        elif len(args) == 3:\n            df_div = func(code, args[0], args[1], args[2])    \n        elif len(args) == 4:\n            df_div = func(code, args[0], args[1], args[2], args[3])     \n        df_div_all = pd.concat([df_div_all, df_div], axis=0)\n    df_new ",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "d.concat([df_div_all, df_div], axis=0)\n    df_new = pd.concat([df_div_all, df], axis=1)\n    df_new = df_new.dropna(axis=0)\n    return df_new\n\n# 获取股息率的函数     \ndef dividend_rate(stock, end_date=None, paymentdate=2015, start_date=None, count=1, date=None,  no_data_return=NaN, skip_paused=False):\n    def get_div(df, paymentdate):\n        df.PAYMENTDATE = pd.to_datetime(df.PAYMENTDATE)\n        try:\n            if len(df)>0:\n                div = df[[x.year == (int(paymentdate)+1) for x in df.PAYMENTDATE]]['DIVID",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "t(paymentdate)+1) for x in df.PAYMENTDATE]]['DIVIDENTBT'].iloc[-1]\n                return float(div)\n            else:\n                return no_data_return\n        except:\n            return no_data_return\n    \n    symbol = stock[:6]\n    df = gta.run_query(query(\n            gta.STK_MKT_DIVIDENT.SYMBOL,\n\n            gta.STK_MKT_DIVIDENT.PAYMENTDATE,\n            gta.STK_MKT_DIVIDENT.DIVIDENTBT,\n            ).filter(gta.STK_MKT_DIVIDENT.SYMBOL.in_([symbol])\n            ).order_by(gta.STK_MKT_DIVIDENT.PAYMENT",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "           ).order_by(gta.STK_MKT_DIVIDENT.PAYMENTDATE))\n    div = get_div(df, paymentdate)\n    from math import isnan\n    if isnan(div) == True:\n        div = get_div(df, paymentdate-1)\n    df = get_price(stock, start_date=start_date, count=count, end_date=end_date, fields=['close'], frequency='daily', fq=None)\n    df['dividend_rate'] = float(div)/df['close']*100\n    df['dividend_rate'] = df['dividend_rate'].round(4)\n    del df['close']\n    df.index = [stock]\n    return df\n\n# 多因子数据过滤好后，按指定的因子进行排序\ndef facto",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "k]\n    return df\n\n# 多因子数据过滤好后，按指定的因子进行排序\ndef factors_ranked(df, factors_rank):\n    df_factors = df.loc[:,factors_rank]\n    df_rank = df_factors.rank(ascending=False)\n    return df_rank, df.index\n\n# 按因子总得分进行排序\ndef points_sorted(points, stocks):\n    pd_points = pd.DataFrame(points, index=stocks, columns=['points'])\n    stocks = list(pd_points.sort(columns='points', ascending=False).index)\n    return stocks  \n    \n# 按个人偏好设置一些交易统计 \ndef trade_summery(context):\n    log.info('买入次数=',g.buy_count)\n    date = (contex",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "  log.info('买入次数=',g.buy_count)\n    date = (context.previous_date-context.run_params.start_date).days\n    buy_count_peryear = g.buy_count/(float(date)/365) if (float(date)/365) >0 else 0\n    log.info('一年平均买入次数=',buy_count_peryear/g.buy)\n",
        "source": "99策略代码/67 多因子回测完整模板（筛选和买卖条件强于‘策略生成器’）.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12648\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom operator import itemgetter, attrgetter\nimport pandas as pd\nimport numpy as np\nimport talib as tl\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000016.XSHG')\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderC",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "分之三加千之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, \\\n                             open_commission=0.0003, close_commission=0.0003,\\\n                             close_today_commission=0, min_commission=5), type='stock')\n    g.buylist=[]\n    # 持仓数量\n    g.stocknum =10\n    # 持仓天数\n    g.holdDays=[]\n    for days in range(0,7):\n        g.holdDays.append([])\n\n    # 股票买入金额 \n    g.cash_per_stock = context.portfolio.portfolio_value / g.stocknum\n    # 运行函数\n    # run_daily(trade,time=\"op",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "stocknum\n    # 运行函数\n    # run_daily(trade,time=\"open\")\n    # 止盈百分比\n    g.cut_gain_percentage = 0.2\n    # 止损百分比\n    g.cut_loss_percentage = 0.5\n \n## 形态和成交额选股\ndef check_stocks(context):\n# 设定查询条件\n    q = query(\n            valuation.code,\n            valuation.circulating_market_cap,\n            valuation.circulating_cap\n        ).filter(\n            valuation.circulating_market_cap.between(8,50)\n        ).order_by(\n            valuation.circulating_market_cap.asc()\n        )\n    # 选股\n    df = get_fundamentals",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "asc()\n        )\n    # 选股\n    df = get_fundamentals(q)\n    resultdict=dict()\n    buylist=[]\n    for index,row in df.iterrows():\n        hData = attribute_history(row['code'], 10, unit='1d'\n            , fields=['open', 'close', 'high', 'low', 'volume', 'money','high_limit']\n            , skip_paused=False\n            , df=False)\n        closes = hData['close']\n        amount = hData['money']\n        vl=hData['volume']\n        hlm=hData['high_limit']\n        lows=hData['low']\n        highs=hData['high']\n     ",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "ows=hData['low']\n        highs=hData['high']\n        opens=hData['open']\n        if np.isnan(closes[0]):\n            continue\n        \n        if amount[-1]>2200000000:\n            continue\n        \n        if vl[-1]!=max(vl[-3:]):\n            continue\n        \n        if amount[-3]/amount[-4]<2:\n            continue\n        \n        if closes[-1]!=hlm[-1] or closes[-2]!=hlm[-2] or closes[-3]!=hlm[-3] or closes[-4]==hlm[-4]:\n            continue\n        \n        resultdict[row['code']]=closes[-1]\n        lo",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "     resultdict[row['code']]=closes[-1]\n        log.info(row['code'],get_security_info(row['code']).display_name,amount[-1],context.current_dt)\n    \n    sorteddict=sorted(resultdict.iteritems(), key=itemgetter(1),reverse=False)\n    for v in sorteddict:\n        buylist.append(v[0])\n    g.buylist = filter_paused_stock(buylist)\n    \n    \ndef before_trading_start(context):\n    check_stocks(context)\n    \n## 交易函数\ndef handle_data(context, data):\n    if context.current_dt.hour != 9 or  context.current_dt.minute != ",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "ent_dt.hour != 9 or  context.current_dt.minute != 30:\n        return\n    todaylist=[]\n    # 如果有持仓，则卖出\n    if len(list(context.portfolio.positions.keys())) > 0 :\n        to_sell = sell_signal(context)\n        for security in to_sell[1]:\n            order_target(security, 0)\n        for security in to_sell[0]:\n            order_target(security,0)\n    if len(g.holdDays[-1])>0:\n        for security in g.holdDays[-1]:\n            order_target(security, 0)\n    g.holdDays.insert(0,[])\n    g.holdDays=g.holdDays[:-1",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "oldDays.insert(0,[])\n    g.holdDays=g.holdDays[:-1]\n    ## 选股\n    if len(g.buylist)==0:\n        return\n    buynum =  g.stocknum - len(context.portfolio.positions.keys())\n    if buynum<=0:\n        return\n    stock_list = g.buylist[:buynum]   \n    cash = context.portfolio.portfolio_value /(len(stock_list)+1)\n    for stock in stock_list:\n        if stock in list(context.portfolio.positions.keys()):\n            continue\n        if len(context.portfolio.positions.keys()) < g.stocknum:\n            close = attribu",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": ".keys()) < g.stocknum:\n            close = attribute_history(stock, 1, '1d', ['close'])['close'][0]\n            curOpen = get_current_data()[stock].day_open\n            if curOpen>=close*0.94:\n                order_value(stock, cash)\n                todaylist.append(stock)\n\n    g.holdDays[0].extend(todaylist)\n     \n \n \n \n# 过滤停牌股票\ndef filter_paused_stock(stock_list):\n    cur_data = get_current_data()\n    # 非停牌、非ST\n    stock_list = [stock for stock in stock_list if \n                  (not cur_data[stock].paus",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "st if \n                  (not cur_data[stock].paused) and \n                  (not cur_data[stock].is_st) and \n                  ('ST' not in cur_data[stock].name) and \n                  ('*' not in cur_data[stock].name) and \n                  ('退' not in cur_data[stock].name)]\n    \n    return stock_list\n \ndef sell_signal(context):\n    # 建立需要卖出的股票list \n    to_sell_gain = []\n    to_sell_lost = []\n    # 对于仓内所有股票\n    for security in context.portfolio.positions:\n        # 取现价\n        current_price = attribute_hi",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "        # 取现价\n        current_price = attribute_history(security, 1, '1d', ['close'])['close'][0]\n        # 获取买入平均价格\n        avg_cost = context.portfolio.positions[security].avg_cost\n        # 计算止盈线\n        high = avg_cost * (1+ g.cut_gain_percentage)\n        # 计算止损线\n        low = avg_cost*(1-g.cut_loss_percentage)\n        # 如果价格突破了止损或止盈线\n        if current_price >= high:\n            to_sell_gain.append(security)\n        if current_price <= low:\n            to_sell_lost.append(security)\n    return(to_sell_g",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "to_sell_lost.append(security)\n    return(to_sell_gain,to_sell_lost)\n",
        "source": "99策略代码/10 追三板策略.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/15387\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True)\n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "'order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "k_stocks_days = 0\n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0\n    # 获取未卖出的股票\n    g.open_sell_securities = []\n    # 卖出股票的dict\n    g.selled_security_list={}\n\n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'info')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_dail",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "ly(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易\n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数\n\n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市\n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000300.XSHG\"]\n    g.security_universe_use",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "ndex = [\"000300.XSHG\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = [\"801780\"]\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'asc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = True\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n   ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_cap_mean'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfol",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    security_stoploss(context,0.2,g.open_sell_securities)\n    security_stopprofit(context,0.2,g.open_sell_secur",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": " security_stopprofit(context,0.2,g.open_sell_securities)\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "_out_lists = technical_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n  ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "eturn\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n    ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "ntext, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        buy_lists = [security for security in buy_lists if MACD_judge_jincha(security, 12, 26, 9)]\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "al_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    security_list = financial_data_filter_qujian(security_list, valuation.pe_ratio, (0,30))\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return secu",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "  ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n########################",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n\n    ### _出场函数筛选-开始 ###\n    sell_lists = [security for security in sell_lists if MACD_judge_sicha(se",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": " for security in sell_lists if MACD_judge_sicha(security, 12, 26, 9)]\n    ### _出场函数筛选-结束 ###\n\n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n\n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n\n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n\n    # 判断当日是否触发",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "_management_signal:\n        return\n\n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n\n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(conte",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "  for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n#########",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": " amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.c",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "urity_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = True)\n            else:\n                a = a.sort_values(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            if hasattr(a, 'sort'):\n                a = a.sort(['score'],ascending = False)\n            else:\n         ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "e'],ascending = False)\n            else:\n                a = a.sort_values(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "t g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n       ",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "t, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['s",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "         temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": " industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "t_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/58 MACD金叉买入，死叉卖出.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/12946\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\nfrom kuanke.wizard import *\nfrom jqdata import *\nimport numpy as np\nimport pandas as pd\nimport talib\nimport datetime\n\n## 初始化函数，设定要操作的股票、基准等等\ndef initialize(context):\n    # 设定基准\n    set_benchmark('000300.XSHG')\n    # 设定滑点\n    set_slippage(FixedSlippage(0.02))\n    # True为开启动态复权模式，使用真实价格交易\n    set_option('use_real_price', True) \n    # 设定成交量比例\n    set_option('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "('order_volume_ratio', 1)\n    # 股票类交易手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')\n    # 个股最大持仓比重\n    g.security_max_proportion = 1\n    # 选股频率\n    g.check_stocks_refresh_rate = 1\n    # 买入频率\n    g.buy_refresh_rate = 1\n    # 卖出频率\n    g.sell_refresh_rate = 1\n    # 最大建仓数量\n    g.max_hold_stocknum = 5\n\n    # 选股频率计数器\n    g.check_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trad",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "ck_stocks_days = 0 \n    # 买卖交易频率计数器\n    g.buy_trade_days=0\n    g.sell_trade_days=0 \n    # 获取未卖出的股票\n    g.open_sell_securities = [] \n    # 卖出股票的dict\n    g.selled_security_list={}\n    \n    # 股票筛选初始化函数\n    check_stocks_initialize()\n    # 股票筛选排序初始化函数\n    check_stocks_sort_initialize()\n    # 出场初始化函数\n    sell_initialize()\n    # 入场初始化函数\n    buy_initialize()\n    # 风控初始化函数\n    risk_management_initialize()\n\n    # 关闭提示\n    log.set_level('order', 'error')\n\n    # 运行函数\n    run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n   ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "  run_daily(sell_every_day,'open') #卖出未卖出成功的股票\n    run_daily(risk_management, 'every_bar') #风险控制\n    run_daily(check_stocks, 'open') #选股\n    run_daily(trade, 'open') #交易  \n    run_daily(selled_security_list_count, 'after_close') #卖出股票日期计数 \n      \n\n## 股票筛选初始化函数\ndef check_stocks_initialize():\n    # 是否过滤停盘\n    g.filter_paused = True\n    # 是否过滤退市  \n    g.filter_delisted = True\n    # 是否只有ST\n    g.only_st = False\n    # 是否过滤ST\n    g.filter_st = True\n    # 股票池\n    g.security_universe_index = [\"000002.XSHG\",\"399106.",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": ".security_universe_index = [\"000002.XSHG\",\"399106.XSHE\"]\n    g.security_universe_user_securities = []\n    # 行业列表\n    g.industry_list = []\n    # 概念列表\n    g.concept_list = []\n\n## 股票筛选排序初始化函数\ndef check_stocks_sort_initialize():\n    # 总排序准则： desc-降序、asc-升序\n    g.check_out_lists_ascending = 'desc'\n\n## 出场初始化函数\ndef sell_initialize():\n    # 设定是否卖出buy_lists中的股票\n    g.sell_will_buy = False\n\n    # 固定出仓的数量或者百分比\n    g.sell_by_amount = None\n    g.sell_by_percent = None\n\n## 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "# 入场初始化函数\ndef buy_initialize():\n    # 是否可重复买入\n    g.filter_holded = False\n\n    # 委托类型\n    g.order_style_str = 'by_market_cap_percent'\n    g.order_style_value = 100\n\n## 风控初始化函数\ndef risk_management_initialize():\n    # 策略风控信号\n    g.risk_management_signal = True\n\n    # 策略当日触发风控清仓信号\n    g.daily_risk_management = True\n\n    # 单只最大买入股数或金额\n    g.max_buy_value = None\n    g.max_buy_amount = None\n\n\n## 卖出未卖出成功的股票\ndef sell_every_day(context):\n    g.open_sell_securities = list(set(g.open_sell_securities))\n    open_sell_se",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "list(set(g.open_sell_securities))\n    open_sell_securities = [s for s in context.portfolio.positions.keys() if s in g.open_sell_securities]\n    if len(open_sell_securities)>0:\n        for stock in open_sell_securities:\n            order_target_value(stock, 0)\n    g.open_sell_securities = [s for s in g.open_sell_securities if s in context.portfolio.positions.keys()]\n    return\n\n## 风控\ndef risk_management(context):\n    ### _风控函数筛选-开始 ###\n    security_stopprofit(context,0.2,g.open_sell_securities)\n    ### _风控函数",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "(context,0.2,g.open_sell_securities)\n    ### _风控函数筛选-结束 ###\n    return\n\n## 股票筛选\ndef check_stocks(context):\n    if g.check_stocks_days%g.check_stocks_refresh_rate != 0:\n        # 计数器加一\n        g.check_stocks_days += 1\n        return\n    # 股票池赋值\n    g.check_out_lists = get_security_universe(context, g.security_universe_index, g.security_universe_user_securities)\n    # 行业过滤\n    g.check_out_lists = industry_filter(context, g.check_out_lists, g.industry_list)\n    # 概念过滤\n    g.check_out_lists = concept_filter(con",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": " # 概念过滤\n    g.check_out_lists = concept_filter(context, g.check_out_lists, g.concept_list)\n    # 过滤ST股票\n    g.check_out_lists = st_filter(context, g.check_out_lists)\n    # 过滤退市股票\n    g.check_out_lists = delisted_filter(context, g.check_out_lists)\n    # 财务筛选\n    g.check_out_lists = financial_statements_filter(context, g.check_out_lists)\n    # 行情筛选\n    g.check_out_lists = situation_filter(context, g.check_out_lists)\n    # 技术指标筛选\n    g.check_out_lists = technical_indicators_filter(context, g.check_out_lists)\n ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "al_indicators_filter(context, g.check_out_lists)\n    # 形态指标筛选函数\n    g.check_out_lists = pattern_recognition_filter(context, g.check_out_lists)\n    # 其他筛选函数\n    g.check_out_lists = other_func_filter(context, g.check_out_lists)\n\n    # 排序\n    input_dict = get_check_stocks_sort_input_dict()\n    g.check_out_lists = check_stocks_sort(context,g.check_out_lists,input_dict,g.check_out_lists_ascending)\n\n    # 计数器归一\n    g.check_stocks_days = 1\n    return\n\n## 交易函数\ndef trade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n  ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "rade(context):\n   # 初始化买入列表\n    buy_lists = []\n\n    # 买入股票筛选\n    if g.buy_trade_days%g.buy_refresh_rate == 0:\n        # 获取 buy_lists 列表\n        buy_lists = g.check_out_lists\n        # 过滤ST股票\n        buy_lists = st_filter(context, buy_lists)\n        # 过滤停牌股票\n        buy_lists = paused_filter(context, buy_lists)\n        # 过滤退市股票\n        buy_lists = delisted_filter(context, buy_lists)\n        # 过滤涨停股票\n        buy_lists = high_limit_filter(context, buy_lists)\n\n        ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 #",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "       ### _入场函数筛选-开始 ###\n        ### _入场函数筛选-结束 ###\n\n    # 卖出操作\n    if g.sell_trade_days%g.sell_refresh_rate != 0:\n        # 计数器加一\n        g.sell_trade_days += 1\n    else:\n        # 卖出股票\n        sell(context, buy_lists)\n        # 计数器归一\n        g.sell_trade_days = 1\n\n\n    # 买入操作\n    if g.buy_trade_days%g.buy_refresh_rate != 0:\n        # 计数器加一\n        g.buy_trade_days += 1\n    else:\n        # 卖出股票\n        buy(context, buy_lists)\n        # 计数器归一\n        g.buy_trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_li",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "trade_days = 1\n\n## 卖出股票日期计数\ndef selled_security_list_count(context):\n    g.daily_risk_management = True\n    if len(g.selled_security_list)>0:\n        for stock in g.selled_security_list.keys():\n            g.selled_security_list[stock] += 1\n\n##################################  选股函数群 ##################################\n\n## 财务指标筛选函数\ndef financial_statements_filter(context, security_list):\n    ### _财务指标筛选函数-开始 ###\n    ### _财务指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 行情筛选函数\ndef situation_filter(cont",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "security_list\n\n## 行情筛选函数\ndef situation_filter(context, security_list):\n    ### _行情筛选函数-开始 ###\n    ### _行情筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 技术指标筛选函数\ndef technical_indicators_filter(context, security_list):\n    ### _技术指标筛选函数-开始 ###\n    ### _技术指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 形态指标筛选函数\ndef pattern_recognition_filter(context, security_list):\n    ### _形态指标筛选函数-开始 ###\n    ### _形态指标筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n## 其他方式筛选函数\ndef other_func_filter(context, s",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "list\n\n## 其他方式筛选函数\ndef other_func_filter(context, security_list):\n    ### _其他方式筛选函数-开始 ###\n    ### _其他方式筛选函数-结束 ###\n\n    # 返回列表\n    return security_list\n\n# 获取选股排序的 input_dict\ndef get_check_stocks_sort_input_dict():\n    input_dict = {\n        }\n    # 返回结果\n    return input_dict\n\n##################################  交易函数群 ##################################\n# 交易函数 - 出场\ndef sell(context, buy_lists):\n    # 获取 sell_lists 列表\n    init_sl = context.portfolio.positions.keys()\n    sell_lists = context.portfolio.positions",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "eys()\n    sell_lists = context.portfolio.positions.keys()\n\n    # 判断是否卖出buy_lists中的股票\n    if not g.sell_will_buy:\n        sell_lists = [security for security in sell_lists if security not in buy_lists]\n    \n    ### _出场函数筛选-开始 ###\n    ### _出场函数筛选-结束 ###\n    \n    # 卖出股票\n    if len(sell_lists)>0:\n        for stock in sell_lists:\n            sell_by_amount_or_percent_or_none(context,stock, g.sell_by_amount, g.sell_by_percent, g.open_sell_securities)\n    \n    # 获取卖出的股票, 并加入到 g.selled_security_list中\n    selled_sec",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "卖出的股票, 并加入到 g.selled_security_list中\n    selled_security_list_dict(context,init_sl)\n    \n    return\n\n# 交易函数 - 入场\ndef buy(context, buy_lists):\n    # 风控信号判断\n    if not g.risk_management_signal:\n        return\n    \n    # 判断当日是否触发风控清仓止损\n    if not g.daily_risk_management:\n        return\n    # 判断是否可重复买入\n    buy_lists = holded_filter(context,buy_lists)\n    \n    # 获取最终的 buy_lists 列表\n    Num = g.max_hold_stocknum - len(context.portfolio.positions)\n    buy_lists = buy_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "_lists[:Num]\n\n    # 买入股票\n    if len(buy_lists)>0:\n        # 分配资金\n        result = order_style(context,buy_lists,g.max_hold_stocknum, g.order_style_str, g.order_style_value)\n        for stock in buy_lists:\n            if len(context.portfolio.positions) < g.max_hold_stocknum:\n                # 获取资金\n                Cash = result[stock]\n                # 判断个股最大持仓比重\n                value = judge_security_max_proportion(context,stock,Cash,g.security_max_proportion)\n                # 判断单只最大买入股数或金额\n               ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "n)\n                # 判断单只最大买入股数或金额\n                amount = max_buy_value_or_amount(stock,value,g.max_buy_value,g.max_buy_amount)\n                # 下单\n                order(stock, amount, MarketOrderStyle())\n    return\n\n###################################  公用函数群 ##################################\n## 排序\ndef check_stocks_sort(context,security_list,input_dict,ascending='desc'):\n    if (len(security_list) == 0) or (len(input_dict) == 0):\n        return security_list\n    else:\n        # 生成 key 的 list\n        idk",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "list\n    else:\n        # 生成 key 的 list\n        idk = list(input_dict.keys())\n        # 生成矩阵\n        a = pd.DataFrame()\n        for i in idk:\n            b = get_sort_dataframe(security_list, i, input_dict[i])\n            a = pd.concat([a,b],axis = 1)\n        # 生成 score 列\n        a['score'] = a.sum(1,False)\n        # 根据 score 排序\n        if ascending == 'asc':# 升序\n            a = a.sort(['score'],ascending = True)\n        elif ascending == 'desc':# 降序\n            a = a.sort(['score'],ascending = False)\n      ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "    a = a.sort(['score'],ascending = False)\n        # 返回结果\n        return list(a.index)\n\n## 过滤同一标的继上次卖出N天不再买入\ndef filter_n_tradeday_not_buy(security, n=0):\n    try:\n        if (security in g.selled_security_list.keys()) and (g.selled_security_list[security]<n):\n            return False\n        return True\n    except:\n        return True\n\n## 是否可重复买入\ndef holded_filter(context,security_list):\n    if not g.filter_holded:\n        security_list = [stock for stock in security_list if stock not in context.portfolio",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "in security_list if stock not in context.portfolio.positions.keys()]\n    # 返回结果\n    return security_list\n\n## 卖出股票加入dict\ndef selled_security_list_dict(context,security_list):\n    selled_sl = [s for s in security_list if s not in context.portfolio.positions.keys()]\n    if len(selled_sl)>0:\n        for stock in selled_sl:\n            g.selled_security_list[stock] = 0\n\n## 过滤停牌股票\ndef paused_filter(context, security_list):\n    if g.filter_paused:\n        current_data = get_current_data()\n        security_list = [",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "ata = get_current_data()\n        security_list = [stock for stock in security_list if not current_data[stock].paused]\n    # 返回结果\n    return security_list\n\n## 过滤退市股票\ndef delisted_filter(context, security_list):\n    if g.filter_delisted:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if not (('退' in current_data[stock].name) or ('*' in current_data[stock].name))]\n    # 返回结果\n    return security_list\n\n\n## 过滤ST股票\ndef st_filter(context, security_list):\n    if g",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "股票\ndef st_filter(context, security_list):\n    if g.only_st:\n        current_data = get_current_data()\n        security_list = [stock for stock in security_list if current_data[stock].is_st]\n    else:\n        if g.filter_st:\n            current_data = get_current_data()\n            security_list = [stock for stock in security_list if not current_data[stock].is_st]\n    # 返回结果\n    return security_list\n\n# 过滤涨停股票\ndef high_limit_filter(context, security_list):\n    current_data = get_current_data()\n    security_li",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": " current_data = get_current_data()\n    security_list = [stock for stock in security_list if not (current_data[stock].day_open >= current_data[stock].high_limit)]\n    # 返回结果\n    return security_list\n\n# 获取股票股票池\ndef get_security_universe(context, security_universe_index, security_universe_user_securities):\n    temp_index = []\n    for s in security_universe_index:\n        if s == 'all_a_securities':\n            temp_index += list(get_all_securities(['stock'], context.current_dt.date()).index)\n        else:\n    ",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "ntext.current_dt.date()).index)\n        else:\n            temp_index += get_index_stocks(s)\n    for x in security_universe_user_securities:\n        temp_index += x\n    return  sorted(list(set(temp_index)))\n\n# 行业过滤\ndef industry_filter(context, security_list, industry_list):\n    if len(industry_list) == 0:\n        # 返回股票列表\n        return security_list\n    else:\n        securities = []\n        for s in industry_list:\n            temp_securities = get_industry_stocks(s)\n            securities += temp_securities",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "tocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n# 概念过滤\ndef concept_filter(context, security_list, concept_list):\n    if len(concept_list) == 0:\n        return security_list\n    else:\n        securities = []\n        for s in concept_list:\n            temp_securities = get_concept_stocks(s)\n            securities += temp_securities\n        security_list = [stock for stock in secu",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "s\n        security_list = [stock for stock in security_list if stock in securities]\n        # 返回股票列表\n        return security_list\n\n#自定义函数",
        "source": "99策略代码/37 个股止损.txt"
    },
    {
        "text": "该策略由聚宽用户分享，仅供学习交流使用。\n原文网址：https://www.joinquant.com/post/13673\n\n原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。\n\n\n原文策略源码如下：\n\n# 导入函数库\nimport jqdata\nimport datetime\nimport pandas as pd\nimport numpy as np\n\n# 初始化函数，设定基准等等\ndef initialize(context):\n    # 设定沪深300作为基准\n    set_benchmark('000300.XSHG')\n    # 开启动态复权模式(真实价格)\n    set_option('use_real_price', True)\n    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱\n    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), t",
        "source": "99策略代码/12 【均值回归】基于zscore的均值回归策略（胜率100%）.txt"
    },
    {
        "text": "003, close_commission=0.0003, min_commission=5), type='stock')\n    # 运行时间\n    run_daily(before_open, time='08:00', reference_security='000300.XSHG')\n    run_daily(market_open, time='open', reference_security='000300.XSHG')\n    set_params(context)\n\n# 全局变量设置\ndef set_params(context):\n    g.stock_list = ['601238.XSHG']  # 股票池\n    g.maxnum = 1  # 最大持仓数\n    g.lower = -2  # 下限\n    g.upper = 1  # 上限\n    \n    g.zscore_window = 60  # zscore窗口\n    g.ma_window = 20  # 均线窗口\n    log.set_level('order', 'error')\n\n# 获取当天买卖股",
        "source": "99策略代码/12 【均值回归】基于zscore的均值回归策略（胜率100%）.txt"
    },
    {
        "text": "线窗口\n    log.set_level('order', 'error')\n\n# 获取当天买卖股票\ndef get_buy_sell(context):\n    #stock_list = get_index_stocks('000016.XSHG')[:10]\n    yesterday = context.current_dt - datetime.timedelta(1)  # 昨天\n    count = g.zscore_window + g.ma_window - 1  # 2个窗口数和\n    price_df = get_price(g.stock_list, end_date=yesterday, fields='close', count=count).close\n    data = get_current_data()  # 当前时间数据\n    buy, sell = [], []\n    for code in g.stock_list:\n        if data[code].paused:  # 跳过停牌股\n            continue\n        si",
        "source": "99策略代码/12 【均值回归】基于zscore的均值回归策略（胜率100%）.txt"
    },
    {
        "text": "].paused:  # 跳过停牌股\n            continue\n        single_df = price_df[code].to_frame('close')\n        single_df['ma'] = pd.rolling_mean(single_df.close, window=g.ma_window)  # 均线\n        single_df.dropna(inplace=True)\n        single_df['sub'] = single_df.close - single_df.ma  # 对差值进行回归\n        zscore_mean = single_df['sub'].mean(); zscore_std = single_df['sub'].std()  # 均值和标准差\n        zscore_value = (single_df['sub'][-1] - zscore_mean) / zscore_std  # zscore值\n        record(zscore=zscore_value)\n        recor",
        "source": "99策略代码/12 【均值回归】基于zscore的均值回归策略（胜率100%）.txt"
    },
    {
        "text": "\n        record(zscore=zscore_value)\n        record(lower=g.lower)\n        record(upper=g.upper)\n        hold = context.portfolio.positions.keys()\n        if zscore_value <= g.lower and code not in hold:  # 买入\n            buy.append(code)\n        if zscore_value >= g.upper and code in hold:  # 卖出\n            sell.append(code)\n    return buy, sell\n\n## 开盘前运行函数\ndef before_open(context):\n    g.buy, g.sell = get_buy_sell(context)\n    \n## 开盘时运行函数\ndef market_open(context):\n    # 先卖\n    for code in g.sell:\n        ",
        "source": "99策略代码/12 【均值回归】基于zscore的均值回归策略（胜率100%）.txt"
    },
    {
        "text": "ontext):\n    # 先卖\n    for code in g.sell:\n        order_target(code, 0)\n    # 再买\n    for code in g.buy:\n        hold = len(context.portfolio.positions)\n        # 未达到最大持仓数\n        if hold < g.maxnum:\n            cash_per_stock = context.portfolio.available_cash / (g.maxnum - hold)  # 个股资金\n            order_target_value(code, cash_per_stock)\n    print('buy: %d  sell: %d  hold: %d' % (len(g.buy), len(g.sell), len(context.portfolio.positions)))\n",
        "source": "99策略代码/12 【均值回归】基于zscore的均值回归策略（胜率100%）.txt"
    }
]